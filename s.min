	TTL	l i c e n s e -- software license for this program
;
;     copyright 1983-2012 robert b. k. dewar
;     copyright 2012-2015 david shields
;
;     this file is part of macro spitbol.
;
;     macro spitbol is free software: you can redistribute it and/or modify
;     it under the terms of the gnu general public license as published by
;     the free software foundation, either version 2 of the license, or
;     (at your option) any later version.
;
;     macro spitbol is distributed in the hope that it will be useful,
;     but without any warranty; without even the implied warranty of
;     merchantability or fitness for a particular purpose.  see the
;     gnu general public license for more details.
;
;     you should have received a copy of the gnu general public license
;     along with macro spitbol.	 if not, see <http://www.gnu.org/licenses/>.
;
	TTL	s p i t b o l -- notes to implementors
;
;      m a c r o   s p i t b o l     v e r s i o n   13.01
;      ---------------------------------------------------
;
;      date of release	-  january 2013
;
;      macro spitbol is maintained by
;	    dr. david shields
;	    260 garth rd apt 3h4
;	    scarsdale, ny 10583
;      e-mail - thedaveshields at gmail dot com
;
;      version 3.7 was maintained by
;	    mark emmer
;	    catspaw, inc.
;	    p.o. box 1123
;	    salida, colorado 81021
;	    u.s.a
;      e-mail - marke at snobol4 dot com
;
;      versions 2.6 through 3.4 were maintained by
;	    dr. a. p. mccann (deceased)
;	    department of computer studies
;	    university of leeds
;	    leeds ls2 9jt
;	    england.
;
;      from 1979 through early 1983 a number of fixes and
;      enhancements were made by steve duff and robert goldberg.
;
;
	TTL	s p i t b o l - revision history
	EJC
;      r e v i s i o n	 h i s t o r y
;      -------------------------------
;
;      version 13.01 (january 2013, david shields)
;
;      this version has the same functionality as the previous release, but with
;      many internal code changes.
;      support for x86-64 has been added, but is not currently working.
;      the description of the minimal language formerly found here as comments
;      is now to be found in the file minimal-reference-manual.html
;
;      version 3.8 (june 2012, david shields)
;      --------------------------------------
;
;      this version is very close to v3.7, with the
;	       same functionality.
;
;	       the source is now maintained using git, so going forward
;	       the detailed revision history will be recorded in the git
;	       commit logs, not in this file.
;
	TTL	s p i t b o l  -- basic information
	EJC
;
;      general structure
;      -----------------
;
;      this program is a translator for a version of the snobol4
;      programming language. language details are contained in
;      the manual macro spitbol by dewar and mccann, technical
;      report 90, university of leeds 1976.
;      the implementation is discussed in dewar and mccann,
;      macro spitbol - a snobol4 compiler, software practice and
;      experience, 7, 95-113, 1977.
;      the language is as implemented by the btl translator
;      (griswold, poage and polonsky, prentice hall, 1971)
;      with the following principal exceptions.
;
;      1)   redefinition of standard system functions and
;	    operators is not permitted.
;
;      2)   the value function is not provided.
;
;      3)   access tracing is provided in addition to the
;	    other standard trace modes.
;
;      4)   the keyword stfcount is not provided.
;
;      5)   the keyword fullscan is not provided and all pattern
;	    matching takes place in fullscan mode (i.e. with no
;	    heuristics applied).
;
;      6)   a series of expressions separated by commas may
;	    be grouped within parentheses to provide a selection
;	    capability. the semantics are that the selection
;	    assumes the value of the first expression within it
;	    which succeeds as they are evaluated from the left.
;	    if no expression succeeds the entire statement fails
;
;      7)   an explicit pattern matching operator is provided.
;	    this is the binary query (see gimpel sigplan oct 74)
;
;      8)   the assignment operator is introduced as in the
;	    gimpel reference.
;
;      9)   the exit function is provided for generating load
;	    modules - cf. gimpels sitbol.
;
;
;      the method used in this program is to translate the
;      source code into an internal pseudo-code (see following
;      section). an interpretor is then used to execute this
;      generated pseudo-code. the nature of the snobol4 language
;      is such that the latter task is much more complex than
;      the actual translation phase. accordingly, nearly all the
;      code in the program section is concerned with the actual
;      execution of the snobol4 program.
	EJC
;
;      interpretive code format
;      ------------------------
;
;      the interpretive pseudo-code consists of a series of
;      address pointers. the exact format of the code is
;      described in connection with the cdblk format. the
;      purpose of this section is to give general insight into
;      the interpretive approach involved.
;
;      the basic form of the code is related to reverse polish.
;      in other words, the operands precede the operators which
;      are zero address operators. there are some exceptions to
;      these rules, notably the unary not operator and the
;      selection construction which clearly require advance
;      knowledge of the operator involved.
;
;      the operands are moved to the top of the main stack and
;      the operators are applied to the top stack entries. like
;      other versions of spitbol, this processor depends on
;      knowing whether operands are required by name or by value
;      and moves the appropriate object to the stack. thus no
;      name/value checks are included in the operator circuits.
;
;      the actual pointers in the code point to a block whose
;      first word is the address of the interpretor routine
;      to be executed for the code word.
;
;      in the case of operators, the pointer is to a word which
;      contains the address of the operator to be executed. in
;      the case of operands such as constants, the pointer is to
;      the operand itself. accordingly, all operands contain
;      a field which points to the routine to load the value of
;      the operand onto the stack. in the case of a vaRIAble,
;      there are three such pointers. one to load the value,
;      one to store the value and a third to jump to the label.
;
;      the handling of failure returns deserves special comment.
;      the location flptr contains the pointer to the location
;      on the main stack which contains the failure return
;      which is in the form of a byte offset in the current
;      code block (cdblk or exblk). when a failure occurs, the
;      stack is popped as indicated by the setting of flptr and
;      control is passed to the appropriate location in the
;      current code block with the stack pointer pointing to the
;      failure offset on the stack and flptr unchanged.
	EJC
;
;      internal data representations
;      -----------------------------
;
;      representation of values
;
;      a value is represented by a pointer to a block which
;      describes the type and particulars of the data value.
;      in general, a vaRIAble is a location containing such a
;      pointer (although in the case of trace associations this
;      is modified, see description of trblk).
;
;      the following is a list of possible datatypes showing the
;      type of block used to hold the value. the details of
;      each block format are given later.
;
;      datatype		     block type
;      --------		     ----------
;
;      array		     arblk or vcblk
;
;      code		     cdblk
;
;      expression	     exblk or seblk
;
;      integer		     icblk
;
;      name		     nmblk
;
;      pattern		     p0blk or p1blk or p2blk
;
;      real		     rcblk
;
;      string		     scblk
;
;      table		     tbblk
;
;      program datatype	     pdblk
	EJC
;
;      representation of vaRIAbles
;      ---------------------------
;
;      during the course of evaluating expressions, it is
;      necessary to generate names of vaRIAbles (for example
;      on the left side of a binary equals operator). these are
;      not to be confused with objects of datatype name which
;      are in fact values.
;
;      from a logical point of view, such names could be simply
;      represented by a pointer to the appropriate value cell.
;      however in the case of arrays and program defined
;      datatypes, this would violate the rule that there must be
;      no pointers into the middle of a block in dynamic store.
;      accordingly, a name is always represented by a base and
;      offset. the base points to the start of the block
;      containing the vaRIAble value and the offset is the
;      offset within this block in bytes. thus the address
;      of the actual vaRIAble is determined by adding the base
;      and offset values.
;
;      the following are the instances of vaRIAbles represented
;      in this manner.
;
;      1)   natural vaRIAble base is ptr to vrblk
;			     offset is *vrval
;
;      2)   table element    base is ptr to teblk
;			     offset is *teval
;
;      3)   array element    base is ptr to arblk
;			     offset is offset to element
;
;      4)   vector element   base is ptr to vcblk
;			     offset is offset to element
;
;      5)   prog def dtp     base is ptr to pdblk
;			     offset is offset to field value
;
;      in addition there are two cases of objects which are
;      like vaRIAbles but cannot be handled in this manner.
;      these are called pseudo-vaRIAbles and are represented
;      with a special base pointer as follows=
;
;      expression vaRIAble   ptr to evblk (see evblk)
;
;      keyword vaRIAble	     ptr to kvblk (see kvblk)
;
;      pseudo-vaRIAbles are handled as special cases by the
;      access procedure (acess) and the assignment procedure
;      (asign). see these two procedures for details.
	EJC
;
;      organization of data area
;      -------------------------
;
;      the data area is divided into two regions.
;
;      static area
;
;      the static area builds up from the bottom and contains
;      data areas which are allocated dynamically but are never
;      deleted or moved around. the macro-program itself
;      uses the static area for the following.
;
;      1)   all vaRIAble blocks (vrblk).
;
;      2)   the hash table for vaRIAble blocks.
;
;      3)   miscellaneous buffers and work areas (see program
;	    initialization section).
;
;      in addition, the system procedures may use this area for
;      input/output buffers, eXTernal functions etc. space in
;      the static region is allocated by calling procedure alost
;
;      the following global vaRIAbles define the current
;      location and size of the static area.
;
;      statb		     address of start of static area
;      state		     address+1 of last word in area.
;
;      the minimum size of static is given approximately by
;	    12 + *e_hnb + *e_sts + space for alphabet string
;	    and standard print buffer.
	EJC
;      dynamic area
;
;      the dynamic area is built upwards in memory after the
;      static region. data in this area must all be in standard
;      block formats so that it can be processed by the garbage
;      collector (procedure gbcol). gbcol compacts blocks down
;      in this region as required by space exhaustion and can
;      also move all blocks up to allow for expansion of the
;      static region.
;      with the exception of tables and arrays, no spitbol
;      object once built in dynamic memory is ever subsequently
;      modified. observing this rule necessitates a copying
;      action during string and pattern concatenation.
;
;      garbage collection is fundamental to the allocation of
;      space for values. spitbol uses a very efficient garbage
;      collector which insists that pointers into dynamic store
;      should be identifiable without use of bit tables,
;      marker bits etc. to satisfy this requirement, dynamic
;      memory must not start at too low an address and lengths
;      of arrays, tables, strings, code and expression blocks
;      may not exceed the numerical value of the lowest dynamic
;      address.
;
;      to avoid either penalizing users with modest
;      requirements or restricting those with greater needs on
;      host systems where dynamic memory is allocated in low
;      addresses, the minimum dynamic address may be specified
;      sufficiently high to permit arbitrarily large spitbol
;      objects to be created (with the possibility in eXTreme
;      cases of wasting large amounts of memory below the
;      start address). this minimum value is made available
;      in vaRIAble mxlen by a system routine, sysmx.
;      alternatively sysmx may indicate that a
;      default may be used in which dynamic is placed
;      at the lowest possible address following static.
;
;      the following global work cells define the location and
;      length of the dynamic area.
;
;      dnamb		     start of dynamic area
;      dnamp		     next available location
;      dname		     last available location + 1
;
;      dnamb is always higher than state since the alost
;      procedure maintains some expansion space above state.
;      *** dnamb must never be permitted to have a value less
;      than that in mxlen ***
;
;      space in the dynamic region is allocated by the alloc
;      procedure. the dynamic region may be used by system
;      procedures provided that all the rules are obeyed.
;      some of the rules are subtle so it is preferable for
;      osint to manage its own memory needs. spitbol procs
;      obey rules to ensure that no action can cause a garbage
;      collection except at such times as contents of XL, XR
;      and the stack are +clean+ (see comment before utility
;      procedures and in gbcol for more detail). note
;      that calls of alost may cause garbage collection (shift
;      of memory to free space). spitbol procs which call
;      system routines assume that they cannot precipitate
;      collection and this must be respected.
	EJC
;
;      register usage
;      --------------
;
;      (CP)		     code pointer register. used to
;			     hold a pointer to the current
;			     location in the interpretive pseudo
;			     code (i.e. ptr into a cdblk).
;
;      (XL,XR)		     general index registers. usually
;			     used to hold pointers to blocks in
;			     dynamic storage. an important
;			     restriction is that the value in
;			     XL must be collectable for
;			     a garbage collect call. a value
;			     is collectable if it either points
;			     outside the dynamic area, or if it
;			     points to the start of a block in
;			     the dynamic area.
;
;      (XS)		     stack pointer. used to point to
;			     the stack front. the stack may
;			     build up or down and is used
;			     to stack subroutine return points
;			     and other recursively saved data.
;
;      (XT)		     an alternative name for XL during
;			     its use in accessing stacked items.
;
;      (WA,WB,WC)	     general work registers. cannot be
;			     used for indexing, but may hold
;			     various types of data.
;
;      (IA)		     used for all signed integer
;			     arithmetic, both that used by the
;			     translator and that arising from
;			     use of snobol4 arithmetic operators
;
;      (RA)		     real accumulator. used for all
;			     floating point arithmetic.
	EJC
;
;      spitbol conditional assembly symbols
;      ------------------------------------
;
;      in the spitbol translator, the following conditional
;      assembly symbols are referred to. to incorporate the
;      features referred to, the minimal source should be
;      prefaced by suitable conditional assembly symbol
;      definitions.
;      in all cases it is permissible to default the definitions
;      in which case the additional features will be omitted
;      from the target code.
;
;      .caex		     define to allow up arrow for expon.
;      .caht		     define to include horizontal tab
;      .casl		     define to include 26 shifted lettrs
;      .cavt		     define to include vertical tab
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
;      .cgbc		     define to include sysgc function
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
;      .ciod		     define to not use default delimiter
;			       in processing 3rd arg of input()
;			       and output()
;      .cmth		     define to include math functions
;      .cnbf		     define to omit buffer eXTension
;      .cnbt		     define to omit batch initialisation
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
;      .cnld		     define to omit load() code.
;      .cnlf		     define to add file type for load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define to no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
;			     omit to take default of 50000
;      .csax		     define if sysax is to be called
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
;      .csn8		     define to pad stmt nos to 8 chars
;      .csou		     define if output, terminal to sysou
;      .ctet		     define to table entry trace wanted
;      .ctmd		     define if systm unit is decisecond
;      .cucf		     define to include cfp_u
;      .cuej		     define to suppress needless ejects
;      .culk		     define to include &l/ucase keywords
;      .culc		     define to include &case (lc names)
;			     if cucl defined, must support
;			     minimal op flc wreg that folds
;			     argument to lower case
;      .cust		     define to include set() code
;
;			     conditional options
;			     since .undef not allowed if symbol
;			     not defined, a full comment line
;			     indicates symbol initially not
;			     defined.
;
.DEF   .caex		     define to allow up arrow for expon.
.DEF   .caht		     define to include horizontal tab
.DEF   .casl		     define to include 26 shifted lettrs
.DEF   .cavt		     define to include vertical tab
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
.DEF   .cgbc		     define to include sysgc function
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
.DEF   .ciod		     define to not use default delimiter
;			     in processing 3rd arg of input()
;			     and output()
;      .cmth		     define to include math functions
.DEF   .cnbf		     define to omit buffer eXTension
.DEF   .cnbt		     define to omit batch initialisation
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
.DEF   .cnld		     define to omit load() code.
;      .cnlf		     define to add file type to load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define if no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
.DEF   .csax		     define if sysax is to be called
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
.DEF   .csn8		     define to pad stmt nos to 8 chars
;      .csou		     define if output, terminal to sysou
.DEF   .ctet		     define to table entry trace wanted
;      .ctmd		     define if systm unit is decisecond
.DEF   .cucf		     define to include cfp_u
.DEF   .cuej		     define to suppress needless ejects
.DEF   .culk		     define to include &l/ucase keywords
.DEF   .culc		     define to include &case (lc names)
.DEF   .cust		     define to include set() code
;
;      force definition of .ccmk if .ccmc is defined
;
.IF    .ccmc
.DEF   .ccmk
.FI
	TTL	s p i t b o l -- procedures section
;
;      this section starts with descriptions of the operating
;      system dependent procedures which are used by the spitbol
;      translator. all such procedures have five letter names
;      beginning with sys. they are listed in alphabetical
;      order.
;      all procedures have a  specification consisting of a
;      model call, preceded by a possibly empty list of register
;      contents giving parameters available to the procedure and
;      followed by a possibly empty list of register contents
;      required on return from the call or which may have had
;      their contents destroyed. only those registers explicitly
;      mentioned in the list after the call may have their
;      values changed.
;      the segment of code providing the eXTernal procedures is
;      conveniently referred to as osint (operating system
;      interface). the sysxx procedures it contains provide
;      facilities not usually available as primitives in
;      assembly languages. for particular target machines,
;      implementors may choose for some minimal opcodes which
;      do not have reasonably direct translations, to use calls
;      of additional procedures which they provide in osint.
;      e.g. mWB or trc might be translated as jsr sysmb,
;      jsr systc in some implementations.
;
;      in the descriptions, reference is made to --blk
;      formats (-- = a pair of letters). see the spitbol
;      definitions section for detailed descriptions of all
;      such block formats except fcblk for which sysfc should
;      be consulted.
;
;      section 0 contains inp,inr specifications of internal
;      procedures,routines. this gives a single pass translator
;      information making it easy to generate alternative calls
;      in the translation of jsr-s for procedures of different
;      types if this proves necessary.
;
	SEC				; start of procedures section
.IF    .csax
	EJC
;
;      sysax -- after execution
;
sysax	EXP	0			; define eXTernal entry point
;
;      if the conditional assembly symbol .csax is defined,
;      this routine is called immediately after execution and
;      before printing of execution statistics or dump output.
;      purpose of call is for implementor to determine and
;      if the call is not required it will be omitted if .csax
;      is undefined. in this case sysax need not be coded.
;
;      jsr  sysax	     call after execution
.ELSE
.FI
	EJC
.IF    .cbsp
;
;      sysbs -- backspace file
;
sysbs	EXP	3			; define eXTernal entry point
;
;      sysbs is used to implement the snobol4 function backspace
;      if the conditional assembly symbol .cbsp is defined.
;      the meaning is system dependent.	 in general, backspace
;      repositions the file one record closer to the beginning
;      of file, such that a subsequent read or write will
;      operate on the previous record.
;
;      (WA)		     ptr to fcblk or zero
;      (XR)		     backspace argument (scblk ptr)
;      jsr  sysbs	     call to backspace
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if backspace not allowed
;      ppm  loc		     return here if i/o error
;      (WA,WB)		     destroyed
;
;      the second error return is used for files for which
;      backspace is not permitted. for example, it may be expected
;      files on character devices are in this category.
	EJC
.FI
;
;      sysbx -- before execution
;
sysbx	EXP	0			; define eXTernal entry point
;
;      called after initial spitbol compilation and before
;      commencing execution in case osint needs
;      to assign files or perform other necessary services.
;      osint may also choose to send a message to online
;      terminal (if any) indicating that execution is starting.
;
;      jsr  sysbx	     call before execution starts
	EJC
.IF    .cnci
;
;      sysci -- convert integer
;
sysci	EXP
;
;      sysci is an optional osint routine that causes spitbol to
;      call sysci to convert integer values to strings, rather
;      than using the internal spitbol conversion code.	 this
;      code may be less efficient on machines with hardware
;      conversion instructions and in such cases, it may be an
;      advantage to include sysci.  the symbol .cnci must be
;      defined if this routine is to be used.
;
;      the rules for converting integers to strings are that
;      positive values are represented without any sign, and
;      there are never any leading blanks or zeros, except in
;      the case of zero itself which is represented as a single
;      zero digit.  negative numbers are represented with a
;      preceeding minus sign.  there are never any trailing
;      blanks, and conversion cannot fail.
;
;      (ia)		     value to be converted
;      jsr  sysci	     call to convert integer value
;      (XL)		     pointer to pseudo-scblk with string
	EJC
.FI
.IF    .ccmc
;
;      syscm -- general string comparison function
;
syscm	EXP	1			; define eXTernal entry point
;
;      provides string comparison determined by interface.
;      used for international string comparison.
;
;
;      (XR)		     character pointer for first string
;      (XL)		     character pointer for second string
;      (WB)		     character count of first string
;      (WA)		     character count of second string
;      jsr  syscm	     call to syscm function
;      ppm  loc		     string too long for syscm
;      ppm  loc		     first string lexically gt second
;      ppm  loc		     first string lexically lt second
;      ---		     strings equal
;      (XL)		     zero
;      (XR)		     destroyed
;
	EJC
.FI
.IF    .cnra
.ELSE
.IF    .cncr
;
;      syscr -- convert real
;
syscr	EXP
;
;      syscr is an optional osint routine that causes spitbol to
;      call syscr to convert real values to strings, rather
;      than using the internal spitbol conversion code.	 this
;      code may be desired on machines where the integer size
;      is too small to allow production of a sufficient number
;      of significant digits.  the symbol .cncr must be defined
;      if this routine is to be used.
;
;      the rules for converting reals to strings are that
;      positive values are represented without any sign, and
;      there are never any leading blanks or zeros, except in
;      the case of zero itself which is represented as a single
;      zero digit.  negative numbers are represented with a
;      preceeding minus sign.  there are never any trailing
;      blanks, or trailing zeros in the fractional part.
;      conversion cannot fail.
;
;      (RA)		     value to be converted
;      (WA)		     no. of significant digits desired
;      (WB)		     conversion type:
;			      negative for e-type conversion
;			      zero for g-type conversion
;			      positive for f-type conversion
;      (WC)		     character positions in result scblk
;      (XR)		     scblk for result
;      jsr  syscr	     call to convert real value
;      (XR)		     result scblk
;      (WA)		     number of result characters
	EJC
.FI
.FI
;
;      sysdc -- date check
;
sysdc	EXP	0			; define eXTernal entry point
;
;      sysdc is called to check that the expiry date for a trial
;      version of spitbol is unexpired.
;
;      jsr  sysdc	     call to check date
;      return only if date is ok
	EJC
;
;      sysdm  -- dump core
;
sysdm	EXP	0			; define eXTernal entry point
;
;      sysdm is called by a spitbol program call of dump(n) with
;      n ge 4.	its purpose is to provide a core dump.
;      n could hold an encoding of the start adrs for dump and
;      amount to be dumped e.g.	 n = 256*a + s , s = start adrs
;      in kilowords,  a = kilowords to dump
;
;      (XR)		     parameter n of call dump(n)
;      jsr  sysdm	     call to enter routine
	EJC
;
;      sysdt -- get current date
;
sysdt	EXP	0			; define eXTernal entry point
;
;      sysdt is used to obtain the current date. the date is
;      returned as a character string in any format appropriate
;      to the operating system in use. it may also contain the
;      current time of day. sysdt is used to implement the
;      snobol4 function date().
;
;      (XR)		     parameter n of call date(n)
;      jsr  sysdt	     call to get date
;      (XL)		     pointer to block containing date
;
;      the format of the block is like an scblk except that
;      the first word need not be set. the result is copied
;      into spitbol dynamic memory on return.
.IF    .cera
	EJC
;
;      sysea -- inform osint of compilation and runtime errors
;
sysea	EXP	1			; define eXTernal entry point
;
;      provides means for interface to take special actions on
;      errors
;
;      (WA)		     error code
;      (WB)		     line number
;      (WC)		     column number
;      (XR)		     system stage
.IF    .csfn
;      (XL)		     file name (scblk)
.FI
;      jsr  sysea	     call to sysea function
;      ppm  loc		     suppress printing of error message
;      (XR)		     message to print (scblk) or 0
;
;      sysea may not return if interface chooses to retain
;      control.	 closing files via the fcb chain will be the
;      responsibility of the interface.
;
;      all registers preserved
.FI
	EJC
;
;      sysef -- eject file
;
sysef	EXP	3			; define eXTernal entry point
;
;      sysef is used to write a page eject to a named file. it
;      may only be used for files where this concept makes
;      sense. note that sysef is not normally used for the
;      standard output file (see sysep).
;
;      (WA)		     ptr to fcblk or zero
;      (XR)		     eject argument (scblk ptr)
;      jsr  sysef	     call to eject file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if inappropriate file
;      ppm  loc		     return here if i/o error
	EJC
;
;      sysej -- end of job
;
sysej	EXP	0			; define eXTernal entry point
;
;      sysej is called once at the end of execution to
;      terminate the run. the significance of the abend and
;      code values is system dependent. in general, the code
;      value should be made available for testing, and the
;      abend value should cause some post-mortem action such as
;      a dump. note that sysej does not return to its caller.
;      see sysxi for details of fcblk chain
;
;      (WA)		     value of abend keyword
;      (WB)		     value of code keyword
;      (XL)		     o or ptr to head of fcblk chain
;      jsr  sysej	     call to end job
;
;      the following special values are used as codes in (WB)
;      999  execution suppressed
;      998  standard output file full or unavailable in a sysxi
;	    load module. in these cases (WA) contains the number
;	    of the statement causing premature termination.
	EJC
;
;      sysem -- get error message teXT
;
sysem	EXP	0			; define eXTernal entry point
;
;      sysem is used to obtain the teXT of err, erb calls in the
;      source program given the error code number. it is allowed
;      to return a null string if this facility is unavailable.
;
;      (WA)		     error code number
;      jsr  sysem	     call to get teXT
;      (XR)		     teXT of message
;
;      the returned value is a pointer to a block in scblk
;      format except that the first word need not be set. the
;      string is copied into dynamic memory on return.
;      if the null string is returned either because sysem does
;      not provide error message teXTs or because WA is out of
;      range, spitbol will print the string stored in errteXT
;      keyword.
	EJC
;
;      sysen -- endfile
;
sysen	EXP	3			; define eXTernal entry point
;
;      sysen is used to implement the snobol4 function endfile.
;      the meaning is system dependent. in general, endfile
;      implies that no further i/o operations will be performed,
;      but does not guarantee this to be the case. the file
;      should be closed after the call, a subsequent read
;      or write may reopen the file at the start or it may be
;      necessary to reopen the file via sysio.
;
;      (WA)		     ptr to fcblk or zero
;      (XR)		     endfile argument (scblk ptr)
;      jsr  sysen	     call to endfile
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if endfile not allowed
;      ppm  loc		     return here if i/o error
;      (WA,WB)		     destroyed
;
;      the second error return is used for files for which
;      endfile is not permitted. for example, it may be expected
;      that the standard input and output files are in this
;      category.
	EJC
;
;      sysep -- eject printer page
;
sysep	EXP	0			; define eXTernal entry point
;
;      sysep is called to perform a page eject on the standard
;      printer output file (corresponding to syspr output).
;
;      jsr  sysep	     call to eject printer output
	EJC
;
;      sysex -- call eXTernal function
;
sysex	EXP	3			; define eXTernal entry point
;
;      sysex is called to pass control to an eXTernal function
;      previously loaded with a call to sysld.
;
;      (XS)		     pointer to arguments on stack
;      (XL)		     pointer to control block (efblk)
;      (WA)		     number of arguments on stack
;      jsr  sysex	     call to pass control to function
;      ppm  loc		     return here if function call fails
;      ppm  loc		     return here if insufficient memory
;      ppm  loc		     return here if bad argument type
.IF    .cexp
.ELSE
;      (XS)		     popped past arguments
.FI
;      (XR)		     result returned
;
;      the arguments are stored on the stack with
;      the last argument at 0(XS). on return, XS
;      is popped past the arguments.
;
;      the form of the arguments as passed is that used in the
;      spitbol translator (see definitions and data structures
;      section). the control block format is also described
;      (under efblk) in this section.
;
;      there are two ways of returning a result.
;
;      1)   return a pointer to a block in dynamic storage. this
;	    block must be in exactly correct format, including
;	    the first word. only functions written with intimate
;	    knowledge of the system will return in this way.
;
;      2)   string, integer and real results may be returned by
;	    pointing to a pseudo-block outside dynamic memory.
;	    this block is in icblk, rcblk or scblk format except
;	    that the first word will be overwritten
;	    by a type word on return and so need not
;	    be correctly set. such a result is
;	    copied into main storage before proceeding.
;	    unconverted results may similarly be returned in a
;	    pseudo-block which is in correct format including
;	    type word recognisable by garbage collector since
;	    block is copied into dynamic memory.
	EJC
;
;      sysfc -- file control block routine
;
sysfc	EXP	2			; define eXTernal entry point
;
;      see also sysio
;      input and output have 3 arguments referred to as shown
;	    input(vaRIAble name,file arg1,file arg2)
;	    output(vaRIAble name,file arg1,file arg2)
;      file arg1 may be an integer or string used to identify
;      an i/o channel. it is converted to a string for checking.
;      the exact significance of file arg2
;      is not rigorously prescribed but to improve portability,
;      the scheme described in the spitbol user manual
;      should be adopted when possible. the preferred form is
;      a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
;      _f_ is an optional file name which is placed first.
;	remaining items may be omitted or included in any order.
;      _r_ is maximum record length
;      _c_ is a carriage control character or character string
;      _i_ is some form of channel identification used in the
;	  absence of _f_ to associate the vaRIAble
;	  with a file allocated dynamically by jcl commands at
;	  spitbol load time.
;      ,...,z_z_ are additional fields.
;      if , (comma) cannot be used as a delimiter, .ciod
;      should be defined to introduce by conditional assembly
;      another delimiter (see
;	 iodel	equ  *
;      early in definitions section).
;      sysfc is called when a vaRIAble is input or output
;      associated to check file arg1 and file arg2 and
;      to  report whether an fcblk (file control
;      block) is necessary and if so what size it should be.
;      this makes it possible for spitbol rather than osint to
;      allocate such a block in dynamic memory if required
;      or alternatively in static memory.
;      the significance of an fcblk , if one is requested, is
;      entirely up to the system interface. the only restriction
;      is that if the fcblk should appear to lie in dynamic
;      memory, pointers to it should be proper pointers to
;      the start of a recognisable and garbage collectable
;      block (this condition will be met if sysfc requests
;      spitbol to provide an fcblk).
;      an option is provided for osint to return a pointer in
;      XL to an fcblk which it privately allocated. this ptr
;      will be made available when i/o occurs later.
;      private fcblks may have arbitrary contents and spitbol
;      stores nothing in them.
	EJC
;      the requested size for an fcblk in dynamic memory
;      should allow a 2 word overhead for block type and
;      length fields. information subsequently stored in the
;      remaining words may be arbitrary if an xnblk (eXTernal
;      non-relocatable block) is requested. if the request is
;      for an XRblk (eXTernal relocatable block) the
;      contents of words should be collectable (i.e. any
;      apparent pointers into dynamic should be genuine block
;      pointers). these restrictions do not apply if an fcblk
;      is allocated outside dynamic or is not allocated at all.
;      if an fcblk is requested, its fields will be initialised
;      to zero before entry to sysio with the exception of
;      words 0 and 1 in which the block type and length
;      fields are placed for fcblks in dynamic memory only.
;      for the possible use of sysej and sysxi, if fcblks
;      are used, a chain is built so that they may all be
;      found - see sysxi for details.
;      if both file arg1 and file arg2 are null, calls of sysfc
;      and sysio are omitted.
;      if file arg1 is null (standard input/output file), sysfc
;      is called to check non-null file arg2 but any request
;      for an fcblk will be ignored, since spitbol handles the
;      standard files specially and cannot readily keep fcblk
;      pointers for them.
;      filearg1 is type checked by spitbol so further checking
;      may be unneccessary in many implementations.
;      file arg2 is passed so that sysfc may analyse and
;      check it. however to assist in this, spitbol also passes
;      on the stack the components of this argument with
;      file name, _f_ (otherwise null) eXTracted and stacked
;      first.
;      the other fields, if any, are eXTracted as substrings,
;      pointers to them are stacked and a count of all items
;      stacked is placed in WC. if an fcblk was earlier
;      allocated and pointed to via file arg1, sysfc is also
;      passed a pointer to this fcblk.
;
;      (XL)		     file arg1 scblk ptr (2nd arg)
;      (XR)		     filearg2 (3rd arg) or null
;      -(XS)...-(XS)	     scblks for _f_,_r_,_c_,...
;      (WC)		     no. of stacked scblks above
;      (WA)		     existing file arg1 fcblk ptr or 0
;      (WB)		     0/3 for input/output assocn
;      jsr  sysfc	     call to check need for fcblk
;      ppm  loc		     invalid file argument
;      ppm  loc		     fcblk already in use
;      (XS)		     popped (WC) times
;      (WA non zero)	     byte size of requested fcblk
;      (WA=0,XL non zero)    private fcblk ptr in XL
;      (WA=XL=0)	     no fcblk wanted, no private fcblk
;      (WC)		     0/1/2 request alloc of XRblk/xnblk
;			     /static block for use as fcblk
;      (WB)		     destroyed
.IF    .cgbc
	EJC
;
;      sysgc -- inform interface of garbage collections
;
sysgc	EXP	0			; define eXTernal entry point
;
;      provides means for interface to take special actions
;      prior to and after a garbage collection.
;
;      possible usages-
;      1. provide visible screen icon of garbage collection
;	  in progress
;      2. inform virtual memory manager to ignore page access
;	  patterns during garbage collection.  such accesses
;	  typically destroy the page working set accumulated
;	  by the program.
;      3. inform virtual memory manager that contents of memory
;	  freed by garbage collection can be discarded.
;
;      (XR)		     non-zero if beginning gc
;			     =0 if completing gc
;      (WA)		     dnamb=start of dynamic area
;      (WB)		     dnamp=next available location
;      (WC)		     dname=last available location + 1
;      jsr  sysgc	     call to sysgc function
;      all registers preserved
.FI

	EJC
;
;      syshs -- give access to host computer features
;
syshs	EXP	8			; define eXTernal entry point
;
;      provides means for implementing special features
;      on different host computers. the only defined entry is
;      that where all arguments are null in which case syshs
;      returns an scblk containing name of computer,
;      name of operating system and name of site separated by
;      colons. the scblk need not have a correct first field
;      as this is supplied on copying string to dynamic memory.
;      spitbol does no argument checking but does provide a
;      single error return for arguments checked as erroneous
;      by osint. it also provides a single execution error
;      return. if these are inadequate, use may be made of the
;      minimal error section direct as described in minimal
;      documentation, section 10.
;      several non-error returns are provided. the first
;      corresponds to the defined entry or, for implementation
;      defined entries, any string may be returned. the others
;      permit respectively,  return a null result, return with a
;      result to be stacked which is pointed at by XR, and a
;      return causing spitbol statement failure. if a returned
;      result is in dynamic memory it must obey garbage
;      collector rules. the only results copied on return
;      are strings returned via ppm loc3 return.
;
;      (WA)		     argument 1
;      (XL)		     argument 2
;      (XR)		     argument 3
;      (WB)		     argument 4
;      (WC)		     argument 5
;      jsr  syshs	     call to get host information
;      ppm  loc1	     erroneous arg
;      ppm  loc2	     execution error
;      ppm  loc3	     scblk ptr in XL or 0 if unavailable
;      ppm  loc4	     return a null result
;      ppm  loc5	     return result in XR
;      ppm  loc6	     cause statement failure
;      ppm  loc7	     return string at XL, length WA
;      ppm  loc8	     return copy of result in XR
	EJC
;
;      sysid -- return system identification
;
sysid	EXP	0			; define eXTernal entry point
;
;      this routine should return strings to head the standard
;      printer output. the first string will be appended to
;      a heading line of the form
;	    macro spitbol version v.v
;      supplied by spitbol itself. v.v are digits giving the
;      major version number and generally at least a minor
;      version number relating to osint should be supplied to
;      give say
;	    macro spitbol version v.v(m.m)
;      the second string should identify at least the machine
;      and operating system.  preferably it should include
;      the date and time of the run.
;      optionally the strings may include site name of the
;      the implementor and/or machine on which run takes place,
;      unique site or copy number and other information as
;      appropriate without making it so long as to be a
;      nuisance to users.
;      the first words of the scblks pointed at need not be
;      correctly set.
;
;      jsr  sysid	     call for system identification
;      (XR)		     scblk ptr for addition to header
;      (XL)		     scblk ptr for second header
	EJC
.IF    .cinc
;
;      sysif -- switch to new include file
;
sysif	EXP	1			; define eXTernal entry point
;
;      sysif is used for include file processing, both to inform
;      the interface when a new include file is desired, and
;      when the end of file of an include file has been reached
;      and it is desired to return to reading from the previous
;      nested file.
;
;      it is the responsibility of sysif to remember the file
;      access path to the present input file before switching to
;      the new include file.
;
;      (XL)		     ptr to scblk or zero
;      (XR)		     ptr to vacant scblk of length cswin
;			     (XR not used if XL is zero)
;      jsr  sysif	     call to change files
;      ppm  loc		     unable to open file
;      (XR)		     scblk with full path name of file
;			     (XR not used if input XL is zero)
;
;      register XL points to an scblk containing the name of the
;      include file to which the interface should switch.  data
;      is fetched from the file upon the next call to sysrd.
;
;      sysif may have the ability to search multiple libraries
;      for the include file named in (XL).  it is therefore
;      required that the full path name of the file where the
;      file was finally located be returned in (XR).  it is this
;      name that is recorded along with the source statements,
;      and will accompany subsequent error messages.
;
;      register XL is zero to mark conclusion of use of an
;      include file.
	EJC
.FI
;
;      sysil -- get input record length
;
sysil	EXP	0			; define eXTernal entry point
;
;      sysil is used to get the length of the next input record
;      from a file previously input associated with a sysio
;      call. the length returned is used to establish a buffer
;      for a subsequent sysin call.  sysil also indicates to the
;      caller if this is a binary or teXT file.
;
;      (WA)		     ptr to fcblk or zero
;      jsr  sysil	     call to get record length
;      (WA)		     length or zero if file closed
;      (WC)		     zero if binary, non-zero if teXT
;
;      no harm is done if the value returned is too long since
;      unused space will be reclaimed after the sysin call.
;
;      note that it is the sysil call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record input from the file.
	EJC
;
;      sysin -- read input record
;
sysin	EXP	3			; define eXTernal entry point
;
;      sysin is used to read a record from the file which was
;      referenced in a prior call to sysil (i.e. these calls
;      always occur in pairs). the buffer provided is an
;      scblk for a string of length set from the sysil call.
;      if the actual length read is less than this, the length
;      field of the scblk must be modified before returning
;      unless buffer is right padded with zeroes.
;      it is also permissible to take any of the alternative
;      returns after scblk length has been modified.
;
;      (WA)		     ptr to fcblk or zero
;      (XR)		     pointer to buffer (scblk ptr)
;      jsr  sysin	     call to read record
;      ppm  loc		     endfile or no i/p file after sysxi
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if record format error
;      (WA,WB,WC)	     destroyed
	EJC
;
;      sysio -- input/output file association
;
sysio	EXP	2			; define eXTernal entry point
;
;      see also sysfc.
;      sysio is called in response to a snobol4 input or output
;      function call except when file arg1 and file arg2
;      are both null.
;      its call always follows immediately after a call
;      of sysfc. if sysfc requested allocation
;      of an fcblk, its address will be in WA.
;      for input files, non-zero values of _r_ should be
;      copied to WC for use in allocating input buffers. if _r_
;      is defaulted or not implemented, WC should be zeroised.
;      once a file has been opened, subsequent input(),output()
;      calls in which the second argument is identical with that
;      in a previous call, merely associate the additional
;      vaRIAble name (first argument) to the file and do not
;      result in re-opening the file.
;      in subsequent associated accesses to the file a pointer
;      to any fcblk allocated will be made available.
;
;      (XL)		     file arg1 scblk ptr (2nd arg)
;      (XR)		     file arg2 scblk ptr (3rd arg)
;      (WA)		     fcblk ptr (0 if none)
;      (WB)		     0 for input, 3 for output
;      jsr  sysio	     call to associate file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return if input/output not allowed
;      (XL)		     fcblk pointer (0 if none)
;      (WC)		     0 (for default) or max record lngth
;      (WA,WB)		     destroyed
;
;      the second error return is used if the file named exists
;      but input/output from the file is not allowed. for
;      example, the standard output file may be in this category
;      as regards input association.
	EJC
;
;      sysld -- load eXTernal function
;
sysld	EXP	3			; define eXTernal entry point
;
;      sysld is called in response to the use of the snobol4
;      load function. the named function is loaded (whatever
;      this means), and a pointer is returned. the pointer will
;      be used on subsequent calls to the function (see sysex).
;
;      (XR)		     pointer to function name (scblk)
;      (XL)		     pointer to library name (scblk)
;      jsr  sysld	     call to load function
;      ppm  loc		     return here if func does not exist
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if insufficient memory
;      (XR)		     pointer to loaded code
;
;      the significance of the pointer returned is up to the
;      system interface routine. the only restriction is that
;      if the pointer is within dynamic storage, it must be
;      a proper block pointer.
	EJC
;
;      sysmm -- get more memory
;
sysmm	EXP	0			; define eXTernal entry point
;
;      sysmm is called in an attempt to allocate more dynamic
;      memory. this memory must be allocated contiguously with
;      the current dynamic data area.
;
;      the amount allocated is up to the system to decide. any
;      value is acceptable including zero if allocation is
;      impossible.
;
;      jsr  sysmm	     call to get more memory
;      (XR)		     number of additional words obtained
	EJC
;
;      sysmx -- supply mxlen
;
sysmx	EXP	0			; define eXTernal entry point
;
;      because of the method of garbage collection, no spitbol
;      object is allowed to occupy more bytes of memory than
;      the integer giving the lowest address of dynamic
;      (garbage collectable) memory. mxlen is the name used to
;      refer to this maximum length of an object and for most
;      users of most implementations, provided dynamic memory
;      starts at an address of at least a few thousand words,
;      there is no problem.
;      if the default starting address is less than say 10000 or
;      20000, then a load time option should be provided where a
;      user can request that he be able to create larger
;      objects. this routine informs spitbol of this request if
;      any. the value returned is either an integer
;      representing the desired value of mxlen (and hence the
;      minimum dynamic store address which may result in
;      non-use of some store) or zero if a default is acceptable
;      in which mxlen is set to the lowest address allocated
;      to dynamic store before compilation starts.
;      if a non-zero value is returned, this is used for keyword
;      maXLngth. otherwise the initial low address of dynamic
;      memory is used for this keyword.
;
;      jsr  sysmx	     call to get mxlen
;      (WA)		     either mxlen or 0 for default
	EJC
;
;      sysou -- output record
;
sysou	EXP	2			; define eXTernal entry point
;
;      sysou is used to write a record to a file previously
;      associated with a sysio call.
;
;      (WA)		     ptr to fcblk
.IF    .csou
;			     or 0 for terminal or 1 for output
.FI
.IF    .cnbf
;      (XR)		     record to be written (scblk)
.ELSE
;      (XR)		     record to write (bcblk or scblk)
.FI
;      jsr  sysou	     call to output record
;      ppm  loc		     file full or no file after sysxi
;      ppm  loc		     return here if i/o error
;      (WA,WB,WC)	     destroyed
;
;      note that it is the sysou call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record output to the file.
	EJC
;
;      syspi -- print on interactive channel
;
syspi	EXP	1			; define eXTernal entry point
;
;      if spitbol is run from an online terminal, osint can
;      request that messages such as copies of compilation
;      errors be sent to the terminal (see syspp). if relevant
;      reply was made by syspp then syspi is called to send such
;      messages to the interactive channel.
;      syspi is also used for sending output to the terminal
;      through the special vaRIAble name, terminal.
;
;      (XR)		     ptr to line buffer (scblk)
;      (WA)		     line length
;      jsr  syspi	     call to print line
;      ppm  loc		     failure return
;      (WA,WB)		     destroyed
.IF    .cpol
	EJC
;
;      syspl -- provide interactive control of spitbol
;
syspl	EXP	3			; define eXTernal entry point
;
;      provides means for interface to take special actions,
;      such as interrupting execution, breakpointing, stepping,
;      and expression evaluation.  these last three options are
;      not presently implemented by the code calling syspl.
;
;
;      (WA)		     opcode as follows-
;			     =0 poll to allow osint to interrupt
;			     =1 breakpoint hit
;			     =2 completion of statement stepping
;			     =3 expression evaluation result
;      (WB)		     statement number
;      r_fcb		     o or ptr to head of fcblk chain
;      jsr  syspl	     call to syspl function
;      ppm  loc		     user interruption
;      ppm  loc		     step one statement
;      ppm  loc		     evaluate expression
;      ---		     resume execution
;			     (WA) = new polling interval
;
.FI
	EJC
;
;      syspp -- obtain print parameters
;
syspp	EXP	0			; define eXTernal entry point
;
;      syspp is called once during compilation to obtain
;      parameters required for correct printed output format
;      and to select other options. it may also be called again
;      after sysxi when a load module is resumed. in this
;      case the value returned in WA may be less than or equal
;      to that returned in initial call but may not be
;      greater.
;      the information returned is -
;      1.   line length in chars for standard print file
;      2.   no of lines/page. 0 is preferable for a non-paged
;	    device (e.g. online terminal) in which case listing
;	    page throws are suppressed and page headers
;	    resulting from -title,-stitl lines are kept short.
;      3.   an initial -nolist option to suppress listing unless
;	    the program contains an explicit -list.
;      4.   options to suppress listing of compilation and/or
;	    execution stats (useful for established programs) -
;	    combined with 3. gives possibility of listing
;	    file never being opened.
;      5.   option to have copies of errors sent to an
;	    interactive channel in addition to standard printer.
;      6.   option to keep page headers short (e.g. if listing
;	    to an online terminal).
;      7.   an option to choose eXTended or compact listing
;	    format. in the former a page eject and in the latter
;	    a few line feeds precede the printing of each
;	    of-- listing, compilation statistics, execution
;	    output and execution statistics.
;      8.   an option to suppress execution as though a
;	    -noexecute card were supplied.
;      9.   an option to request that name /terminal/  be pre-
;	    associated to an online terminal via syspi and sysri
;      10.  an intermediate (standard) listing option requiring
;	    that page ejects occur in source listings. redundant
;	    if eXTended option chosen but partially eXTends
;	    compact option.
;      11.  option to suppress sysid identification.
;
;      jsr  syspp	     call to get print parameters
;      (WA)		     print line length in chars
;      (WB)		     number of lines/page
;      (WC)		     bits value ...mlkjihgfedcba where
;			     a = 1 to send error copy to int.ch.
;			     b = 1 means std printer is int. ch.
;			     c = 1 for -nolist option
;			     d = 1 to suppress compiln. stats
;
;			     e = 1 to suppress execn. stats
;			     f = 1/0 for eXTnded/compact listing
;			     g = 1 for -noexecute
;			     h = 1 pre-associate /terminal/
;
;			     i = 1 for standard listing option.
;			     j = 1 suppresses listing header
;			     k = 1 for -print
;			     l = 1 for -noerrors
.IF    .culc
;
;			     m = 1 for -case 1
.FI
	EJC
;
;      syspr -- print line on standard output file
;
syspr	EXP	1			; define eXTernal entry point
;
;      syspr is used to print a single line on the standard
;      output file.
;
;      (XR)		     pointer to line buffer (scblk)
;      (WA)		     line length
;      jsr  syspr	     call to print line
;      ppm  loc		     too much o/p or no file after sysxi
;      (WA,WB)		     destroyed
;
;      the buffer pointed to is the length obtained from the
;      syspp call and is filled out with trailing blanks. the
;      value in WA is the actual line length which may be less
;      than the maximum line length possible. there is no space
;      control associated with the line, all lines are printed
;      single spaced. note that null lines (WA=0) are possible
;      in which case a blank line is to be printed.
;
;      the error exit is used for systems which limit the amount
;      of printed output. if possible, printing should be
;      permitted after this condition has been signalled once to
;      allow for dump and other diagnostic information.
;      assuming this to be possible, spitbol may make more syspr
;      calls. if the error return occurs another time, execution
;      is terminated by a call of sysej with ending code 998.
	EJC
;
;      sysrd -- read record from standard input file
;
sysrd	EXP	1			; define eXTernal entry point
;
;      sysrd is used to read a record from the standard input
;      file. the buffer provided is an scblk for a string the
;      length of which in characters is given in WC, this
;      corresponding to the maximum length of string which
;      spitbol is prepared to receive. at compile time it
;      corresponds to xxx in the most recent -inxxx card
;      (default 72) and at execution time to the most recent
;      ,r_r_ (record length) in the third arg of an input()
;      statement for the standard input file (default 80).
;      if fewer than (WC) characters are read, the length
;      field of the scblk must be adjusted before returning
;      unless the buffer is right padded with zeroes.
;      it is also permissible to take the alternative return
;      after such an adjustment has been made.
;      spitbol may continue to make calls after an endfile
;      return so this routine should be prepared to make
;      repeated endfile returns.
;
;      (XR)		     pointer to buffer (scblk ptr)
;      (WC)		     length of buffer in characters
;      jsr  sysrd	     call to read line
;      ppm  loc		     endfile or no i/p file after sysxi
.IF    .csfn
;			     or input file name change.	 if
;			     the former, scblk length is zero.
;			     if input file name change, length
;			     is non-zero. caller should re-issue
;			     sysrd to obtain input record.
.FI
;      (WA,WB,WC)	     destroyed
	EJC
;
;      sysri -- read record from interactive channel
;
sysri	EXP	1			; define eXTernal entry point
;
;      reads a record from online terminal for spitbol vaRIAble,
;      terminal. if online terminal is unavailable then code the
;      endfile return only.
;      the buffer provided is of length 258 characters. sysri
;      should replace the count in the second word of the scblk
;      by the actual character count unless buffer is right
;      padded with zeroes.
;      it is also permissible to take the alternative
;      return after adjusting the count.
;      the end of file return may be used if this makes
;      sense on the target machine (e.g. if there is an
;      eof character.)
;
;      (XR)		     ptr to 258 char buffer (scblk ptr)
;      jsr  sysri	     call to read line from terminal
;      ppm  loc		     end of file return
;      (WA,WB,WC)	     may be destroyed
	EJC
;
;      sysrw -- rewind file
;
sysrw	EXP	3			; define eXTernal entry point
;
;      sysrw is used to rewind a file i.e. reposition the file
;      at the start before the first record. the file should be
;      closed and the next read or write call will open the
;      file at the start.
;
;      (WA)		     ptr to fcblk or zero
;      (XR)		     rewind arg (scblk ptr)
;      jsr  sysrw	     call to rewind file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if rewind not allowed
;      ppm  loc		     return here if i/o error
	EJC
.IF    .cust
;
;      sysst -- set file pointer
;
sysst	EXP	0			; define eXTernal entry point
;
;      sysst is called to change the position of a file
;      pointer. this is accomplished in a system dependent
;      manner, and thus the 2nd and 3rd arguments are passed
;      unconverted.
;
;      (WA)		     fcblk pointer
;      (WB)		     2nd argument
;      (WC)		     3rd argument
;      jsr  sysst	     call to set file pointer
;      ppm  loc		     return here if invalid 2nd arg
;      ppm  loc		     return here if invalid 3rd arg
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if set not allowed
;      ppm  loc		     return here if i/o error
;
	EJC
.FI
;
;      systm -- get execution time so far
;
systm	EXP	0			; define eXTernal entry point
;
;      systm is used to obtain the amount of execution time
;      used so far since spitbol WAs given control. the units
;      are described as milliseconds in the spitbol output, but
;      the exact meaning is system dependent. where appropriate,
;      this value should relate to processor rather than clock
;      timing values.
;      if the symbol .ctmd is defined, the units are described
;      as deciseconds (0.1 second).
;
;      jsr  systm	     call to get timer value
;      (ia)		     time so far in milliseconds
;			     (deciseconds if .ctmd defined)
	EJC
;
;      systt -- trace toggle
;
systt	EXP	0			; define eXTernal entry point
;
;      called by spitbol function trace() with no args to
;      toggle the system trace switch.	this permits tracing of
;      labels in spitbol code to be turned on or off.
;
;      jsr  systt	     call to toggle trace switch
	EJC
;
;      sysul -- unload eXTernal function
;
sysul	EXP	0			; define eXTernal entry point
;
;      sysul is used to unload a function previously
;      loaded with a call to sysld.
;
;      (XR)		     ptr to control block (efblk)
;      jsr  sysul	     call to unload function
;
;      the function cannot be called following a sysul call
;      until another sysld call is made for the same function.
;
;      the efblk contains the function code pointer and also a
;      pointer to the vrblk containing the function name (see
;      definitions and data structures section).
.IF    .cnex
.ELSE
	EJC
;
;      sysxi -- exit to produce load module
;
sysxi	EXP	2			; define eXTernal entry point
;
;      when sysxi is called, XL contains either a string pointer
;      or zero. in the former case, the string gives the
;      character name of a program. the intention is that
;      spitbol execution should be terminated forthwith and
;      the named program loaded and executed. this type of chain
;      execution is very system dependent and implementors may
;      choose to omit it or find it impossible to provide.
;      if (XL) is zero,ia contains one of the following integers
;
;      -1, -2, -3, -4
;	    create if possible a load module containing only the
;	    impure area of memory which needs to be loaded with
;	    a compatible pure segment for subsequent executions.
;	    version numbers to check compatibility should be
;	    kept in both segments and checked on loading.
;	    to assist with this check, (XR) on entry is a
;	    pointer to an scblk containing the spitbol major
;	    version number v.v (see sysid).  the file thus
;	    created is called a save file.
;
;      0    if possible, return control to job control
;	    command level. the effect if available will be
;	    system dependent.
;
;      +1, +2, +3, +4
;	    create if possible a load module from all of
;	    memory. it should be possible to load and execute
;	    this module directly.
;
;      in the case of saved load modules, the status of open
;      files is not preserved and implementors may choose to
;      offer means of attaching files before execution of load
;      modules starts or leave it to the user to include
;      suitable input(), output() calls in his program.
;      sysxi should make a note that no i/o channels,
;      including standard files, have files attached so that
;      calls of sysin, sysou, syspr, sysrd should fail unless
;      new associations are made for the load module.
;      at least in the case of the standard output file, it is
;      recommended that either the user be required to attach
;      a file or that a default file is attached, since the
;      problem of error messages generated by the load module
;      is otherwise severe. as a last resort, if spitbol
;      attempts to write to the standard output file and gets a
;      reply indicating that such ouput is unacceptable it stops
;      by using an entry to sysej with ending code 998.
;      as described below, passing of some arguments makes it
;      clear that load module will use a standard output file.
;
;      if use is made of fcblks for i/o association, spitbol
;      builds a chain so that those in use may be found in sysxi
;      and sysej. the nodes are 4 words long. third word
;      contains link to next node or 0, fourth word contains
;      fcblk pointer.
	EJC
;
;      sysxi (continued)
;
;      (XL)		     zero or scblk ptr to first argument
;      (XR)		     ptr to v.v scblk
;      (ia)		     signed integer argument
;      (WA)		     scblk ptr to second argument
;      (WB)		     0 or ptr to head of fcblk chain
;      jsr  sysxi	     call to exit
;      ppm  loc		     requested action not possible
;      ppm  loc		     action caused irrecoverable error
;      (WB,WC,IA,XR,XL,CP)   should be preserved over call
;      (WA)		     0 in all cases except sucessful
;			     performance of exit(4) or exit(-4),
;			     in which case 1 should be returned.
;
;      loading and running the load module or returning from
;      jcl command level causes execution to resume at the point
;      after the error returns which follow the call of sysxi.
;      the value passed as exit argument is used to indicate
;      options required on resumption of load module.
;      +1 or -1 require that on resumption, sysid and syspp be
;      called and a heading printed on the standard output file.
;      +2 or -2 indicate that syspp will be called but not sysid
;      and no heading will be put on standard output file.
;      above options have the obvious implication that a
;      standard o/p file must be provided for the load module.
;      +3, +4, -3 or -4 indicate calls of neither sysid nor
;      syspp and no heading will be placed on standard output
;      file.
;      +4 or -4 indicate that execution is to continue after
;      creation of the save file or load module, although all
;      files will be closed by the sysxi action.  this permits
;      the user to checkpoint long-running programs while
;      continuing execution.
;
;      no return from sysxi is possible if another program
;      is loaded and entered.
.FI
	EJC
;
;      introduce the internal procedures.
;
acess	INP	r,1			;
acomp	INP	n,5			;
alloc	INP	e,0			;
.IF    .cnbf
.ELSE
alobf	INP	e,0			;
.FI
alocs	INP	e,0			;
alost	INP	e,0			;
.IF    .cnbf
.ELSE
apndb	INP	e,2			;
.FI
.IF    .cnra
arith	INP	n,2			;
.ELSE
arith	INP	n,3			;
.FI
asign	INP	r,1			;
asinp	INP	r,1			;
blkln	INP	e,0			;
cdgcg	INP	e,0			;
cdgex	INP	r,0			;
cdgnm	INP	r,0			;
cdgvl	INP	r,0			;
cdwrd	INP	e,0			;
cmgen	INP	r,0			;
cmpil	INP	e,0			;
cncrd	INP	e,0			;
copyb	INP	n,1			;
dffnc	INP	e,0			;
dtach	INP	e,0			;
dtype	INP	e,0			;
dumpr	INP	e,0			;
.IF    .ceng
enevs	INP	r,0			;
engts	INP	e,0			;
.FI
ermsg	INP	e,0			;
ertex	INP	e,0			;
evali	INP	r,4			;
evalp	INP	r,1			;
evals	INP	r,3			;
evalx	INP	r,1			;
exbld	INP	e,0			;
expan	INP	e,0			;
expap	INP	e,1			;
expdm	INP	n,0			;
expop	INP	n,0			;
.IF    .csfn
filnm	INP	e,0			;
.FI
.IF    .culc
flstg	INP	e,0			;
.FI
gbcol	INP	e,0			;
gbcpf	INP	e,0			;
gtarr	INP	e,2			;
	EJC
gtcod	INP	e,1			;
gtexp	INP	e,1			;
gtint	INP	e,1			;
gtnum	INP	e,1			;
gtnvr	INP	e,1			;
gtpat	INP	e,1			;
.IF    .cnra
.ELSE
gtrea	INP	e,1			;
.FI
gtsmi	INP	n,2			;
.IF    .cnbf
.ELSE
gtstb	INP	n,1			;
.FI
gtstg	INP	n,1			;
gtvar	INP	e,1			;
hashs	INP	e,0			;
icbld	INP	e,0			;
ident	INP	e,1			;
inout	INP	e,0			;
.IF    .cnbf
.ELSE
insbf	INP	e,2			;
.FI
insta	INP	e,0			;
iofcb	INP	n,3			;
ioppf	INP	n,0			;
ioput	INP	n,7			;
ktrex	INP	r,0			;
kwnam	INP	n,0			;
lcomp	INP	n,5			;
listr	INP	e,0			;
listt	INP	e,0			;
.IF    .csfn
newfn	INP	e,0			;
.FI
nexts	INP	e,0			;
patin	INP	n,2			;
patst	INP	n,1			;
pbild	INP	e,0			;
pconc	INP	e,0			;
pcopy	INP	n,0			;
.IF    .cnpf
.ELSE
prflr	INP	e,0			;
prflu	INP	e,0			;
.FI
prpar	INP	e,0			;
prtch	INP	e,0			;
prtic	INP	e,0			;
prtis	INP	e,0			;
prtin	INP	e,0			;
prtmi	INP	e,0			;
prtmm	INP	e,0			;
prtmx	INP	e,0			;
prtnl	INP	r,0			;
prtnm	INP	r,0			;
prtnv	INP	e,0			;
prtpg	INP	e,0			;
prtps	INP	e,0			;
prtsn	INP	e,0			;
prtst	INP	r,0			;
	EJC
prttr	INP	e,0			;
prtvl	INP	r,0			;
prtvn	INP	e,0			;
.IF    .cnra
.ELSE
rcbld	INP	e,0			;
.FI
readr	INP	e,0			;
.IF    .crel
relaj	INP	e,0			;
relcr	INP	e,0			;
reldn	INP	e,0			;
reloc	INP	e,0			;
relst	INP	e,0			;
relws	INP	e,0			;
.FI
rstrt	INP	e,0			;
.IF    .c370
sbool	INP	n,4			;
.FI
sbstr	INP	e,0			;
scane	INP	e,0			;
scngf	INP	e,0			;
setvr	INP	e,0			;
.IF    .cnsr
.ELSE
sorta	INP	n,1			;
sortc	INP	e,1			;
sortf	INP	e,0			;
sorth	INP	n,0			;
.FI
start	INP	e,0			;
stgcc	INP	e,0			;
tfind	INP	e,1			;
tmake	INP	e,0			;
trace	INP	n,2			;
trbld	INP	e,0			;
trimr	INP	e,0			;
trxeq	INP	r,0			;
vmake	INP	e,1			;
XScan	INP	e,0			;
XScni	INP	n,2			;
;
;      introduce the internal routines
;
arref	INR
cfunc	INR
exfal	INR
exint	INR
exits	INR
exiXR	INR
exnam	INR
exnul	INR
.IF    .cnra
.ELSE
exrea	INR
.FI
eXSid	INR
exvnm	INR
failp	INR
flpop	INR
indir	INR
match	INR
retrn	INR
stcov	INR
stmgo	INR
stopr	INR
succp	INR
sysab	INR
systu	INR
	TTL	s p i t b o l -- definitions and data structures
;      this section contains all symbol definitions and also
;      pictures of all data structures used in the system.
;
	SEC				; start of definitions section
;
;      definitions of machine parameters
;
;      the minimal translator should supply appropriate values
;      for the particular target machine for all the
;      equ  *
;      definitions given at the start of this section.
;      note that even if conditional assembly is used to omit
;      some feature (e.g. real arithmetic) a full set of cfp_-
;      values must be supplied. use dummy values if genuine
;      ones are not needed.
;
cfp_a	EQU	*			; number of characters in alphabet
;
cfp_b	EQU	*			; bytes/word addressing factor
;
cfp_c	EQU	*			; number of characters per word
;
cfp_f	EQU	*			; offset in bytes to chars in
;			     scblk. see scblk format.
;
cfp_i	EQU	*			; number of words in integer constant
;
cfp_m	EQU	*			; max positive integer in one word
;
cfp_n	EQU	*			; number of bits in one word
;
;      the following definitions require the supply of either
;      a single parameter if real arithmetic is omitted or
;      three parameters if real arithmetic is included.
;
.IF    .cnra
nstmx	EQU	*			; no. of decimal digits in cfp_m
.ELSE
;
cfp_r	EQU	*			; number of words in real constant
;
cfp_s	EQU	*			; number of sig digs for real output
;
cfp_x	EQU	*			; max digits in real exponent
.IF    .cncr
nstmx	EQU	*			; no. of decimal digits in cfp_m
;
mxdgs	EQU	cfp_s+cfp_x		; max digits in real number
;
;      max space for real (for +0.e+) needs five more places
;
nstmr	EQU	mxdgs+5			; max space for real
.ELSE
;
mxdgs	EQU	cfp_s+cfp_x		; max digits in real number
;
;
;      max space for real (for +0.e+) needs five more places
;
nstmx	EQU	mxdgs+5			; max space for real
.FI
.FI
.IF    .cucf
;
;      the following definition for cfp_u supplies a realistic
;      upper bound on the size of the alphabet.	 cfp_u is used
;      to save space in the scane bsw-iff-esw table and to ease
;      translation storage requirements.
;
cfp_u	EQU	*			; realistic upper bound on alphabet
.FI
	EJC
;
;      environment parameters
;
;      the spitbol program is essentially independent of
;      the definitions of these parameters. however, the
;      efficiency of the system may be affected. consequently,
;      these parameters may require tuning for a given version
;      the values given in comments have been successfully used.
;
;      e_srs is the number of words to reserve at the end of
;      storage for end of run processing. it should be
;      set as small as possible without causing memory overflow
;      in critical situations (e.g. memory overflow termination)
;      and should thus reserve sufficient space at least for
;      an scblk containing say 30 characters.
;
e_srs	EQU	*			; 30 words
;
;      e_sts is the number of words grabbed in a chunk when
;      storage is allocated in the static region. the minimum
;      permitted value is 256/cfp_b. larger values will lead
;      to increased efficiency at the cost of wasting memory.
;
e_sts	EQU	*			; 500 words
;
;      e_cbs is the size of code block allocated initially and
;      the expansion increment if overflow occurs. if this value
;      is too small or too large, excessive garbage collections
;      will occur during compilation and memory may be lost
;      in the case of a too large value.
;
e_cbs	EQU	*			; 500 words
;
;      e_hnb is the number of bucket headers in the vaRIAble
;      hash table. it should always be odd. larger values will
;      speed up compilation and indirect references at the
;      expense of additional storage for the hash table itself.
;
e_hnb	EQU	*			; 127 bucket headers
;
;      e_hnw is the maximum number of words of a string
;      name which participate in the string hash algorithm.
;      larger values give a better hash at the expense of taking
;      longer to compute the hash. there is some optimal value.
;
e_hnw	EQU	*			; 6 words
;
;      e_fsp.  if the amount of free space left after a garbage
;      collection is small compared to the total amount of space
;      in use garbage collector thrashing is likely to occur as
;      this space is used up.  e_fsp is a measure of the
;      minimum percentage of dynamic memory left as free space
;      before the system routine sysmm is called to try to
;      obtain more memory.
;
e_fsp	EQU	*			; 15 percent
.IF    .csed
;
;      e_sed.  if the amount of free space left in the sediment
;      after a garbage collection is a significant fraction of
;      the new sediment size, the sediment is marked for
;      collection on the next call to the garbage collector.
;
e_sed	EQU	*			; 25 percent
.FI
	EJC
;
;      definitions of codes for letters
;
ch_la	EQU	*			; letter a
ch_lb	EQU	*			; letter b
ch_lc	EQU	*			; letter c
ch_ld	EQU	*			; letter d
ch_le	EQU	*			; letter e
ch_lf	EQU	*			; letter f
ch_lg	EQU	*			; letter g
ch_lh	EQU	*			; letter h
ch_li	EQU	*			; letter i
ch_lj	EQU	*			; letter j
ch_lk	EQU	*			; letter k
ch_ll	EQU	*			; letter l
ch_lm	EQU	*			; letter m
ch_ln	EQU	*			; letter n
ch_lo	EQU	*			; letter o
ch_lp	EQU	*			; letter p
ch_lq	EQU	*			; letter q
ch_lr	EQU	*			; letter r
ch_ls	EQU	*			; letter s
ch_lt	EQU	*			; letter t
ch_lu	EQU	*			; letter u
ch_lv	EQU	*			; letter v
ch_lw	EQU	*			; letter w
ch_lx	EQU	*			; letter x
ch_ly	EQU	*			; letter y
ch_l_	EQU	*			; letter z
;
;      definitions of codes for digits
;
ch_d0	EQU	*			; digit 0
ch_d1	EQU	*			; digit 1
ch_d2	EQU	*			; digit 2
ch_d3	EQU	*			; digit 3
ch_d4	EQU	*			; digit 4
ch_d5	EQU	*			; digit 5
ch_d6	EQU	*			; digit 6
ch_d7	EQU	*			; digit 7
ch_d8	EQU	*			; digit 8
ch_d9	EQU	*			; digit 9
	EJC
;
;      definitions of codes for special characters
;
;      the names of these characters are related to their
;      original representation in the ebcdic set corresponding
;      to the description in standard snobol4 manuals and teXTs.
;
ch_am	EQU	*			; keyword operator (ampersand)
ch_as	EQU	*			; multiplication symbol (asterisk)
ch_at	EQU	*			; cursor position operator (at)
ch_bb	EQU	*			; left array bracket (less than)
ch_bl	EQU	*			; blank
ch_br	EQU	*			; alternation operator (vertical bar)
ch_cl	EQU	*			; goto symbol (colon)
ch_cm	EQU	*			; comma
ch_dl	EQU	*			; indirection operator (dollar)
ch_dt	EQU	*			; name operator (dot)
ch_dq	EQU	*			; double quote
ch_eq	EQU	*			; equal sign
ch_ex	EQU	*			; exponentiation operator (exclm)
ch_mn	EQU	*			; minus sign / hyphen
ch_nm	EQU	*			; number sign
ch_nt	EQU	*			; negation operator (not)
ch_pc	EQU	*			; percent
ch_pl	EQU	*			; plus sign
ch_pp	EQU	*			; left parenthesis
ch_rb	EQU	*			; right array bracket (grtr than)
ch_rp	EQU	*			; right parenthesis
ch_qu	EQU	*			; interrogation operator (question)
ch_sl	EQU	*			; slash
ch_sm	EQU	*			; semicolon
ch_sq	EQU	*			; single quote
ch_u_	EQU	*			; special identifier char (underline)
ch_ob	EQU	*			; opening bracket
ch_cb	EQU	*			; closing bracket
	EJC
;
;      remaining chars are optional additions to the standards.
.IF    .caht
;
;      tab characters - syntactically equivalent to blank
;
ch_ht	EQU	*			; horizontal tab
.FI
.IF    .cavt
ch_vt	EQU	*			; vertical tab
.FI
.IF    .caex
;
;      up arrow same as exclamation mark for exponentiation
;
ch_ey	EQU	*			; up arrow
.FI
.IF    .casl
;
;      lower case or shifted case alphabetic chars
;
ch_ua	EQU	*			; shifted a
ch_ub	EQU	*			; shifted b
ch_uc	EQU	*			; shifted c
ch_ud	EQU	*			; shifted d
ch_ue	EQU	*			; shifted e
ch_uf	EQU	*			; shifted f
ch_ug	EQU	*			; shifted g
ch_uh	EQU	*			; shifted h
ch_ui	EQU	*			; shifted i
ch_uj	EQU	*			; shifted j
ch_uk	EQU	*			; shifted k
ch_ul	EQU	*			; shifted l
ch_um	EQU	*			; shifted m
ch_un	EQU	*			; shifted n
ch_uo	EQU	*			; shifted o
ch_up	EQU	*			; shifted p
ch_uq	EQU	*			; shifted q
ch_ur	EQU	*			; shifted r
ch_us	EQU	*			; shifted s
ch_ut	EQU	*			; shifted t
ch_uu	EQU	*			; shifted u
ch_uv	EQU	*			; shifted v
ch_uw	EQU	*			; shifted w
ch_ux	EQU	*			; shifted x
ch_uy	EQU	*			; shifted y
ch_uz	EQU	*			; shifted z
.FI
;      if a delimiter other than ch_cm must be used in
;      the third argument of input(),output() then .ciod should
;      be defined and a parameter supplied for iodel.
;
.IF    .ciod
iodel	EQU	*			;
.ELSE
iodel	EQU	ch_cm			;
.FI
	EJC
;
;      data block formats and definitions
;
;      the following sections describe the detailed format of
;      all possible data blocks in static and dynamic memory.
;
;      every block has a name of the form xxblk where xx is a
;      unique two character identifier. the first word of every
;      block must contain a pointer to a program location in the
;      interpretor which is immediately preceded by an address
;      constant containing the value bl_xx where xx is the block
;      identifier. this provides a uniform mechanism for
;      distinguishing between the various block types.
;
;      in some cases, the contents of the first word is constant
;      for a given block type and merely serves as a pointer
;      to the identifying address constant. however, in other
;      cases there are several possibilities for the first
;      word in which case each of the several program entry
;      points must be preceded by the appropriate constant.
;
;      in each block, some of the fields are relocatable. this
;      means that they may contain a pointer to another block
;      in the dynamic area. (to be more precise, if they contain
;      a pointer within the dynamic area, then it is a pointer
;      to a block). such fields must be modified by the garbage
;      collector (procedure gbcol) whenever blocks are compacted
;      in the dynamic region. the garbage collector (actually
;      procedure gbcpf) requires that all such relocatable
;      fields in a block must be contiguous.
	EJC
;
;      the description format uses the following scheme.
;
;      1)   block title and two character identifier
;
;      2)   description of basic use of block and indication
;	    of circumstances under which it is constructed.
;
;      3)   picture of the block format. in these pictures low
;	    memory addresses are at the top of the page. fixed
;	    length fields are surrounded by i (letter i). fields
;	    which are fixed length but whose length is dependent
;	    on a configuration parameter are surrounded by *
;	    (asterisk). vaRIAble length fields are surrounded
;	    by / (slash).
;
;      4)   definition of symbolic offsets to fields in
;	    block and of the size of the block if fixed length
;	    or of the size of the fixed length fields if the
;	    block is vaRIAble length.
;	    note that some routines such as gbcpf assume
;	    certain offsets are equal. the definitions
;	    given here enforce this.  make changes to
;	    them only with due care.
;
;      definitions of common offsets
;
offs1	EQU	1			;
offs2	EQU	2			;
offs3	EQU	3			;
;
;      5)   detailed comments on the significance and formats
;	    of the various fields.
;
;      the order is alphabetical by identification code.
	EJC
;
;      definitions of block codes
;
;      this table provides a unique identification code for
;      each separate block type. the first word of a block in
;      the dynamic area always contains the address of a program
;      entry point. the block code is used as the entry point id
;      the order of these codes dictates the order of the table
;      used by the datatype function (scnmt in the constant sec)
;
;      block codes for accessible datatypes
;
;      note that real and buffer types are always included, even
;      if they are conditionally excluded elsewhere.  this main-
;      tains block type codes across all versions of spitbol,
;      providing consistancy for eXTernal functions.  but note
;      that the bcblk is out of alphabetic order, placed at the
;      end of the list so as not to change the block type
;      ordering in use in existing eXTernal functions.
;
bl_ar	EQU	0			; arblk	    array
bl_cd	EQU	bl_ar+1			; cdblk	    code
bl_ex	EQU	bl_cd+1			; exblk	    expression
bl_ic	EQU	bl_ex+1			; icblk	    integer
bl_nm	EQU	bl_ic+1			; nmblk	    name
bl_p0	EQU	bl_nm+1			; p0blk	    pattern
bl_p1	EQU	bl_p0+1			; p1blk	    pattern
bl_p2	EQU	bl_p1+1			; p2blk	    pattern
bl_rc	EQU	bl_p2+1			; rcblk	    real
bl_sc	EQU	bl_rc+1			; scblk	    string
bl_se	EQU	bl_sc+1			; seblk	    expression
bl_tb	EQU	bl_se+1			; tbblk	    table
bl_vc	EQU	bl_tb+1			; vcblk	    array
bl_xn	EQU	bl_vc+1			; xnblk	    eXTernal
bl_xr	EQU	bl_xn+1			; XRblk	    eXTernal
bl_bc	EQU	bl_xr+1			; bcblk	    buffer
bl_pd	EQU	bl_bc+1			; pdblk	    program defined datatype
;
bl__d	EQU	bl_pd+1			; number of block codes for data
;
;      other block codes
;
bl_tr	EQU	bl_pd+1			; trblk
bl_bf	EQU	bl_tr+1			; bfblk
bl_cc	EQU	bl_bf+1			; ccblk
bl_cm	EQU	bl_cc+1			; cmblk
bl_ct	EQU	bl_cm+1			; ctblk
bl_df	EQU	bl_ct+1			; dfblk
bl_ef	EQU	bl_df+1			; efblk
bl_ev	EQU	bl_ef+1			; evblk
bl_ff	EQU	bl_ev+1			; ffblk
bl_kv	EQU	bl_ff+1			; kvblk
bl_pf	EQU	bl_kv+1			; pfblk
bl_te	EQU	bl_pf+1			; teblk
;
bl__i	EQU	0			; default identification code
bl__t	EQU	bl_tr+1			; code for data or trace block
bl___	EQU	bl_te+1			; number of block codes
	EJC
;
;      field references
;
;      references to the fields of data blocks are symbolic
;      (i.e. use the symbolic offsets) with the following
;      exceptions.
;
;      1)   references to the first word are usually not
;	    symbolic since they use the (x) operand format.
;
;      2)   the code which constructs a block is often not
;	    symbolic and should be changed if the corresponding
;	    block format is modified.
;
;      3)   the plc and psc instructions imply an offset
;	    corresponding to the definition of cfp_f.
;
;      4)   there are non-symbolic references (easily changed)
;	    in the garbage collector (procedures gbcpf, blkln).
;
;      5)   the fields idval, fargs appear in several blocks
;	    and any changes must be made in parallel to all
;	    blocks containing the fields. the actual references
;	    to these fields are symbolic with the above
;	    listed exceptions.
;
;      6)   several spots in the code assume that the
;	    definitions of the fields vrval, teval, trnxt are
;	    the same (these are sections of code which search
;	    out along a trblk chain from a vaRIAble).
;
;      7)   references to the fields of an array block in the
;	    array reference routine arref are non-symbolic.
;
;      apart from the exceptions listed, references are symbolic
;      as far as possible and modifying the order or number
;      of fields will not require changes.
	EJC
;
;      common fields for function blocks
;
;      blocks which represent callable functions have two
;      common fields at the start of the block as follows.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    /					 /
;	    /	    rest of function block	 /
;	    /					 /
;	    +------------------------------------+
;
fcode	EQU	0			; pointer to code for function
fargs	EQU	1			; number of arguments
;
;      fcode is a pointer to the location in the interpretor
;      program which processes this type of function call.
;
;      fargs is the expected number of arguments. the actual
;      number of arguments is adjusted to this amount by
;      deleting eXTra arguments or supplying trailing nulls
;      for missing ones before transferring though fcode.
;      a value of 999 may be used in this field to indicate a
;      vaRIAble number of arguments (see svblk field svnar).
;
;      the block types which follow this scheme are.
;
;      ffblk		     field function
;      dfblk		     datatype function
;      pfblk		     program defined function
;      efblk		     eXTernal loaded function
	EJC
;
;      identification field
;
;
;      id   field
;
;      certain program accessible objects (those which contain
;      other data values and can be copied) are given a unique
;      identification number (see eXSid). this id value is an
;      address integer value which is always stored in word two.
;
idval	EQU	1			; id value field
;
;      the blocks containing an idval field are.
;
;      arblk		     array
.IF    .cnbf
.ELSE
;      bcblk		     buffer control block
.FI
;      pdblk		     program defined datatype
;      tbblk		     table
;      vcblk		     vector block (array)
;
;      note that a zero idval means that the block is only
;      half built and should not be dumped (see dumpr).
	EJC
;
;      array block (arblk)
;
;      an array block represents an array value other than one
;      with one dimension whose lower bound is one (see vcblk).
;      an arblk is built with a call to the functions convert
;      (s_cnv) or array (s_arr).
;
;	    +------------------------------------+
;	    i		     artyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     arlen		 i
;	    +------------------------------------+
;	    i		     arofs		 i
;	    +------------------------------------+
;	    i		     arndm		 i
;	    +------------------------------------+
;	    *		     arlbd		 *
;	    +------------------------------------+
;	    *		     ardim		 *
;	    +------------------------------------+
;	    *					 *
;	    * above 2 flds repeated for each dim *
;	    *					 *
;	    +------------------------------------+
;	    i		     arpro		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     arvls		 /
;	    /					 /
;	    +------------------------------------+
	EJC
;
;      array block (continued)
;
artyp	EQU	0			; pointer to dummy routine b_art
arlen	EQU	idval+1			; length of arblk in bytes
arofs	EQU	arlen+1			; offset in arblk to arpro field
arndm	EQU	arofs+1			; number of dimensions
arlbd	EQU	arndm+1			; low bound (first subscript)
ardim	EQU	arlbd+cfp_i		; dimension (first subscript)
arlb2	EQU	ardim+cfp_i		; low bound (second subscript)
ardm2	EQU	arlb2+cfp_i		; dimension (second subscript)
arpro	EQU	ardim+cfp_i		; array prototype (one dimension)
arvls	EQU	arpro+1			; start of values (one dimension)
arpr2	EQU	ardm2+cfp_i		; array prototype (two dimensions)
arvl2	EQU	arpr2+1			; start of values (two dimensions)
arsi_	EQU	arlbd			; number of standard fields in block
ardms	EQU	arlb2-arlbd		; size of info for one set of bounds
;
;      the bounds and dimension fields are signed integer
;      values and each occupy cfp_i words in the arblk.
;
;      the length of an arblk in bytes may not exceed mxlen.
;      this is required to keep name offsets garbage collectable
;
;      the actual values are arranged in row-wise order and
;      can contain a data pointer or a pointer to a trblk.
.IF    .cnbf
.ELSE
;
;      buffer control block (bcblk)
;
;      a bcblk is built for every bfblk.
;
;	    +------------------------------------+
;	    i		     bctyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     bclen		 i
;	    +------------------------------------+
;	    i		     bcbuf		 i
;	    +------------------------------------+
;
bctyp	EQU	0			; ptr to dummy routine b_bct
bclen	EQU	idval+1			; defined buffer length
bcbuf	EQU	bclen+1			; ptr to bfblk
bcsi_	EQU	bcbuf+1			; size of bcblk
;
;      a bcblk is an indirect control header for bfblk.
;      the reason for not storing this data directly
;      in the related bfblk is so that the bfblk can
;      maintain the same skeletal structure as an scblk
;      thus facilitating transparent string operations
;      (for the most part).  specifically, cfp_f is the
;      same for a bfblk as for an scblk.  by convention,
;      whereever a buffer value is employed, the bcblk
;      is pointed to.
;
;      the corresponding bfblk is pointed to by the
;      bcbuf pointer in the bcblk.
;
;      bclen is the current defined size of the character
;      array in the bfblk.  characters following the offset
;      of bclen are undefined.
;
	EJC
;
;      string buffer block (bfblk)
;
;      a bfblk is built by a call to buffer(...)
;
;	    +------------------------------------+
;	    i		     bftyp		 i
;	    +------------------------------------+
;	    i		     bfalc		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     bfchr		 /
;	    /					 /
;	    +------------------------------------+
;
bftyp	EQU	0			; ptr to dummy routine b_bft
bfalc	EQU	bftyp+1			; allocated size of buffer
bfchr	EQU	bfalc+1			; characters of string
bfsi_	EQU	bfchr			; size of standard fields in bfblk
;
;      the characters in the buffer are stored left justified.
;      the final word of defined characters is always zero
;      (character) padded.  any trailing allocation past the
;      word containing the last character contains
;      unpredictable contents and is never referenced.
;
;      note that the offset to the characters of the string
;      is given by cfp_f, as with an scblk.  however, the
;      offset which is occupied by the length for an scblk
;      is the total char space for bfblks, and routines which
;      deal with both must account for this difference.
;
;      the value of bfalc may not exceed mxlen.	 the value of
;      bclen is always less than or equal to bfalc.
;
.FI
	EJC
;
;      code construction block (ccblk)
;
;      at any one moment there is at most one ccblk into
;      which the compiler is currently storing code (cdwrd).
;
;	    +------------------------------------+
;	    i		     cctyp		 i
;	    +------------------------------------+
;	    i		     cclen		 i
.IF    .csln
;	    +------------------------------------+
;	    i		     ccsln		 i
.FI
;	    +------------------------------------+
;	    i		     ccuse		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cccod		 /
;	    /					 /
;	    +------------------------------------+
;
cctyp	EQU	0			; pointer to dummy routine b_cct
cclen	EQU	cctyp+1			; length of ccblk in bytes
.IF    .csln
ccsln	EQU	cclen+1			; source line number
ccuse	EQU	ccsln+1			; offset past last used word (bytes)
.ELSE
ccuse	EQU	cclen+1			; offset past last used word (bytes)
.FI
cccod	EQU	ccuse+1			; start of generated code in block
;
;      the reason that the ccblk is a separate block type from
;      the usual cdblk is that the garbage collector must
;      only process those fields which have been set (see gbcpf)
	EJC
;
;      code block (cdblk)
;
;      a code block is built for each statement compiled during
;      the initial compilation or by subsequent calls to code.
;
;	    +------------------------------------+
;	    i		     cdjmp		 i
;	    +------------------------------------+
;	    i		     cdstm		 i
.IF    .csln
;	    +------------------------------------+
;	    i		     cdsln		 i
.FI
;	    +------------------------------------+
;	    i		     cdlen		 i
;	    +------------------------------------+
;	    i		     cdfal		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cdcod		 /
;	    /					 /
;	    +------------------------------------+
;
cdjmp	EQU	0			; ptr to routine to execute statement
cdstm	EQU	cdjmp+1			; statement number
.IF    .csln
cdsln	EQU	cdstm+1			; source line number
cdlen	EQU	cdsln+1			; length of cdblk in bytes
cdfal	EQU	cdlen+1			; failure exit (see below)
.ELSE
cdlen	EQU	offs2			; length of cdblk in bytes
cdfal	EQU	offs3			; failure exit (see below)
.FI
cdcod	EQU	cdfal+1			; executable pseudo-code
cdsi_	EQU	cdcod			; number of standard fields in cdblk
;
;      cdstm is the statement number of the current statement.
;
;      cdjmp, cdfal are set as follows.
;
;      1)   if the failure exit is the next statement
;
;	    cdjmp = b_cds
;	    cdfal = ptr to cdblk for next statement
;
;      2)   if the failure exit is a simple label name
;
;	    cdjmp = b_cds
;	    cdfal is a ptr to the vrtra field of the vrblk
;
;      3)   if there is no failure exit (-nofail mode)
;
;	    cdjmp = b_cds
;	    cdfal = o_unf
;
;      4)   if the failure exit is complex or direct
;
;	    cdjmp = b_cdc
;	    cdfal is the offset to the o_gof word
	EJC
;
;      code block (continued)
;
;      cdcod is the start of the actual code. first we describe
;      the code generated for an expression. in an expression,
;      elements are fetched by name or by value. for example,
;      the binary equal operator fetches its left argument
;      by name and its right argument by value. these two
;      cases generate quite different code and are described
;      separately. first we consider the code by value case.
;
;      generation of code by value for expressions elements.
;
;      expression	     pointer to exblk or seblk
;
;      integer constant	     pointer to icblk
;
;      null constant	     pointer to nulls
;
;      pattern		     (resulting from preevaluation)
;			     =o_lpt
;			     pointer to p0blk,p1blk or p2blk
;
;      real constant	     pointer to rcblk
;
;      string constant	     pointer to scblk
;
;      vaRIAble		     pointer to vrget field of vrblk
;
;      addition		     value code for left operand
;			     value code for right operand
;			     =o_add
;
;      affirmation	     value code for operand
;			     =o_aff
;
;      alternation	     value code for left operand
;			     value code for right operand
;			     =o_alt
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aov
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amv
;			     number of subscripts
	EJC
;
;      code block (continued)
;
;      assignment	     (to natural vaRIAble)
;			     value code for right operand
;			     pointer to vrsto field of vrblk
;
;			     (to any other vaRIAble)
;			     name code for left operand
;			     value code for right operand
;			     =o_ass
;
;      compile error	     =o_cer
;
;
;      complementation	     value code for operand
;			     =o_com
;
;      concatenation	     (case of pred func left operand)
;			     value code for left operand
;			     =o_pop
;			     value code for right operand
;
;			     (all other cases)
;			     value code for left operand
;			     value code for right operand
;			     =o_cnc
;
;      cursor assignment     name code for operand
;			     =o_cas
;
;      division		     value code for left operand
;			     value code for right operand
;			     =o_dvd
;
;      exponentiation	     value code for left operand
;			     value code for right operand
;			     =o_exp
;
;      function call	     (case of call to system function)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     pointer to svfnc field of svblk
;
	EJC
;
;      code block (continued)
;
;      function call	     (case of non-system function 1 arg)
;			     value code for argument
;			     =o_fns
;			     pointer to vrblk for function
;
;			     (non-system function, gt 1 arg)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     =o_fnc
;			     number of arguments
;			     pointer to vrblk for function
;
;      immediate assignment  value code for left operand
;			     name code for right operand
;			     =o_ima
;
;      indirection	     value code for operand
;			     =o_inv
;
;      interrogation	     value code for operand
;			     =o_int
;
;      keyword reference     name code for operand
;			     =o_kwv
;
;      multiplication	     value code for left operand
;			     value code for right operand
;			     =o_mlt
;
;      name reference	     (natural vaRIAble case)
;			     pointer to nmblk for name
;
;			     (all other cases)
;			     name code for operand
;			     =o_nam
;
;      negation		     =o_nta
;			     cdblk offset of o_ntc word
;			     value code for operand
;			     =o_ntb
;			     =o_ntc
	EJC
;
;      code block (continued)
;
;      pattern assignment    value code for left operand
;			     name code for right operand
;			     =o_pas
;
;      pattern match	     value code for left operand
;			     value code for right operand
;			     =o_pmv
;
;      pattern replacement   name code for subject
;			     value code for pattern
;			     =o_pmn
;			     value code for replacement
;			     =o_rpl
;
;      selection	     (for first alternative)
;			     =o_sla
;			     cdblk offset to next o_slc word
;			     value code for first alternative
;			     =o_slb
;			     cdblk offset past alternatives
;
;			     (for subsequent alternatives)
;			     =o_slc
;			     cdblk offset to next o_slc,o_sld
;			     value code for alternative
;			     =o_slb
;			     offset in cdblk past alternatives
;
;			     (for last alternative)
;			     =o_sld
;			     value code for last alternative
;
;      subtraction	     value code for left operand
;			     value code for right operand
;			     =o_sub
	EJC
;
;      code block (continued)
;
;      generation of code by name for expression elements.
;
;      vaRIAble		     =o_lvn
;			     pointer to vrblk
;
;      expression	     (case of *natural vaRIAble)
;			     =o_lvn
;			     pointer to vrblk
;
;			     (all other cases)
;			     =o_lex
;			     pointer to exblk
;
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aon
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amn
;			     number of subscripts
;
;      compile error	     =o_cer
;
;      function call	     (same code as for value call)
;			     =o_fne
;
;      indirection	     value code for operand
;			     =o_inn
;
;      keyword reference     name code for operand
;			     =o_kwn
;
;      any other operand is an error in a name position
;
;      note that in this description, =o_xxx refers to the
;      generation of a word containing the address of another
;      word which contains the entry point address o_xxx.
	EJC
;
;      code block (continued)
;
;      now we consider the overall structure of the code block
;      for a statement with possible goto fields.
;
;      first comes the code for the statement body.
;      the statement body is an expression to be evaluated
;      by value although the value is not actually required.
;      normal value code is generated for the body of the
;      statement except in the case of a pattern match by
;      value, in which case the following is generated.
;
;			     value code for left operand
;			     value code for right operand
;			     =o_pms
;
;      next we have the code for the success goto. there are
;      several cases as follows.
;
;      1)   no success goto  ptr to cdblk for next statement
;
;      2)   simple label     ptr to vrtra field of vrblk
;
;      3)   complex goto     (code by name for goto operand)
;			     =o_goc
;
;      4)   direct goto	     (code by value for goto operand)
;			     =o_god
;
;      following this we generate code for the failure goto if
;      it is direct or if it is complex, simple failure gotos
;      having been handled by an appropriate setting of the
;      cdfal field of the cdblk. the generated code is one
;      of the following.
;
;      1)   complex fgoto    =o_fif
;			     =o_gof
;			     name code for goto operand
;			     =o_goc
;
;      2)   direct fgoto     =o_fif
;			     =o_gof
;			     value code for goto operand
;			     =o_god
;
;      an optimization occurs if the success and failure gotos
;      are identical and either complex or direct. in this case,
;      no code is generated for the success goto and control
;      is allowed to fall into the failure goto on success.
	EJC
;
;      compiler block (cmblk)
;
;      a compiler block (cmblk) is built by expan to represent
;      one node of a tree structured expression representation.
;
;	    +------------------------------------+
;	    i		     cmidn		 i
;	    +------------------------------------+
;	    i		     cmlen		 i
;	    +------------------------------------+
;	    i		     cmtyp		 i
;	    +------------------------------------+
;	    i		     cmopn		 i
;	    +------------------------------------+
;	    /		cmvls or cmrop		 /
;	    /					 /
;	    /		     cmlop		 /
;	    /					 /
;	    +------------------------------------+
;
cmidn	EQU	0			; pointer to dummy routine b_cmt
cmlen	EQU	cmidn+1			; length of cmblk in bytes
cmtyp	EQU	cmlen+1			; type (c_xxx, see list below)
cmopn	EQU	cmtyp+1			; operand pointer (see below)
cmvls	EQU	cmopn+1			; operand value pointers (see below)
cmrop	EQU	cmvls			; right (only) operator operand
cmlop	EQU	cmvls+1			; left operator operand
cmsi_	EQU	cmvls			; number of standard fields in cmblk
cmus_	EQU	cmsi_+1			; size of unary operator cmblk
cmbs_	EQU	cmsi_+2			; size of binary operator cmblk
cmar1	EQU	cmvls+1			; array subscript pointers
;
;      the cmopn and cmvls fields are set as follows
;
;      array reference	     cmopn = ptr to array operand
;			     cmvls = ptrs to subscript operands
;
;      function call	     cmopn = ptr to vrblk for function
;			     cmvls = ptrs to argument operands
;
;      selection	     cmopn = zero
;			     cmvls = ptrs to alternate operands
;
;      unary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to operand
;
;      binary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to right operand
;			     cmlop = ptr to left operand
	EJC
;
;      cmtyp is set to indicate the type of expression element
;      as shown by the following table of definitions.
;
c_arr	EQU	0			; array reference
c_fnc	EQU	c_arr+1			; function call
c_def	EQU	c_fnc+1			; deferred expression (unary *)
c_ind	EQU	c_def+1			; indirection (unary _)
c_key	EQU	c_ind+1			; keyword reference (unary ampersand)
c_ubo	EQU	c_key+1			; undefined binary operator
c_uuo	EQU	c_ubo+1			; undefined unary operator
c_uo_	EQU	c_uuo+1			; test value (=c_uuo+1=c_ubo+2)
c__nm	EQU	c_uuo+1			; number of codes for name operands
;
;      the remaining types indicate expression elements which
;      can only be evaluated by value (not by name).
;
c_bvl	EQU	c_uuo+1			; binary op with value operands
c_uvl	EQU	c_bvl+1			; unary operator with value operand
c_alt	EQU	c_uvl+1			; alternation (binary bar)
c_cnc	EQU	c_alt+1			; concatenation
c_cnp	EQU	c_cnc+1			; concatenation, not pattern match
c_unm	EQU	c_cnp+1			; unary op with name operand
c_bvn	EQU	c_unm+1			; binary op (operands by value, name)
c_ass	EQU	c_bvn+1			; assignment
c_int	EQU	c_ass+1			; interrogation
c_neg	EQU	c_int+1			; negation (unary not)
c_sel	EQU	c_neg+1			; selection
c_pmt	EQU	c_sel+1			; pattern match
;
c_pr_	EQU	c_bvn			; last preevaluable code
c__nv	EQU	c_pmt+1			; number of different cmblk types
	EJC
;
;      character table block (ctblk)
;
;      a character table block is used to hold logical character
;      tables for use with any,notany,span,break,breakx
;      patterns. each character table can be used to store
;      cfp_n distinct tables as bit columns. a bit column
;      allocated for each argument of more than one character
;      in length to one of the above listed pattern primitives.
;
;	    +------------------------------------+
;	    i		     cttyp		 i
;	    +------------------------------------+
;	    *					 *
;	    *					 *
;	    *		     ctchs		 *
;	    *					 *
;	    *					 *
;	    +------------------------------------+
;
cttyp	EQU	0			; pointer to dummy routine b_ctt
ctchs	EQU	cttyp+1			; start of character table words
ctsi_	EQU	ctchs+cfp_a		; number of words in ctblk
;
;      ctchs is cfp_a words long and consists of a one word
;      bit string value for each possible character in the
;      internal alphabet. each of the cfp_n possible bits in
;      a bitstring is used to form a column of bit indicators.
;      a bit is set on if the character is in the table and off
;      if the character is not present.
	EJC
;
;      datatype function block (dfblk)
;
;      a datatype function is used to control the construction
;      of a program defined datatype object. a call to the
;      system function data builds a dfblk for the datatype name
;
;      note that these blocks are built in static because pdblk
;      length is got from dflen field.	if dfblk was in dynamic
;      store this would cause trouble during pass two of garbage
;      collection.  scblk referred to by dfnam field is also put
;      in static so that there are no reloc. fields. this cuts
;      garbage collection task appreciably for pdblks which are
;      likely to be present in large numbers.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     dflen		 i
;	    +------------------------------------+
;	    i		     dfpdl		 i
;	    +------------------------------------+
;	    i		     dfnam		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     dffld		 /
;	    /					 /
;	    +------------------------------------+
;
dflen	EQU	fargs+1			; length of dfblk in bytes
dfpdl	EQU	dflen+1			; length of corresponding pdblk
dfnam	EQU	dfpdl+1			; pointer to scblk for datatype name
dffld	EQU	dfnam+1			; start of vrblk ptrs for field names
dfflb	EQU	dffld-1			; offset behind dffld for field func
dfsi_	EQU	dffld			; number of standard fields in dfblk
;
;      the fcode field points to the routine b_dfc
;
;      fargs (the number of arguments) is the number of fields.
	EJC
;
;      dope vector block (dvblk)
;
;      a dope vector is assembled for each possible operator in
;      the snobol4 language as part of the constant section.
;
;	    +------------------------------------+
;	    i		     dvopn		 i
;	    +------------------------------------+
;	    i		     dvtyp		 i
;	    +------------------------------------+
;	    i		     dvlpr		 i
;	    +------------------------------------+
;	    i		     dvrpr		 i
;	    +------------------------------------+
;
dvopn	EQU	0			; entry address (ptr to o_xxx)
dvtyp	EQU	dvopn+1			; type code (c_xxx, see cmblk)
dvlpr	EQU	dvtyp+1			; left precedence (llxxx, see below)
dvrpr	EQU	dvlpr+1			; right precedence (rrxxx, see below)
dvus_	EQU	dvlpr+1			; size of unary operator dv
dvbs_	EQU	dvrpr+1			; size of binary operator dv
dvubs	EQU	dvus_+dvbs_		; size of unop + binop (see scane)
;
;      the contents of the dvtyp field is copied into the cmtyp
;      field of the cmblk for the operator if it is used.
;
;      the cmopn field of an operator cmblk points to the dvblk
;      itself, providing the required entry address pointer ptr.
;
;      for normally undefined operators, the dvopn (and cmopn)
;      fields contain a word offset from r_uba of the function
;      block pointer for the operator (instead of o_xxx ptr).
;      for certain special operators, the dvopn field is not
;      required at all and is assembled as zero.
;
;      the left precedence is used in comparing an operator to
;      the left of some other operator. it therefore governs the
;      precedence of the operator towards its right operand.
;
;      the right precedence is used in comparing an operator to
;      the right of some other operator. it therefore governs
;      the precedence of the operator towards its left operand.
;
;      higher precedence values correspond to a tighter binding
;      capability. thus we have the left precedence lower
;      (higher) than the right precedence for right (left)
;      associative binary operators.
;
;      the left precedence of unary operators is set to an
;      arbitrary high value. the right value is not required and
;      consequently the dvrpr field is omitted for unary ops.
	EJC
;
;      table of operator precedence values
;
rrass	EQU	10			; right	    equal
llass	EQU	00			; left	    equal
rrpmt	EQU	20			; right	    question mark
llpmt	EQU	30			; left	    question mark
rramp	EQU	40			; right	    ampersand
llamp	EQU	50			; left	    ampersand
rralt	EQU	70			; right	    vertical bar
llalt	EQU	60			; left	    vertical bar
rrcnc	EQU	90			; right	    blank
llcnc	EQU	80			; left	    blank
rrats	EQU	110			; right	    at
llats	EQU	100			; left	    at
rrplm	EQU	120			; right	    plus, minus
llplm	EQU	130			; left	    plus, minus
rrnum	EQU	140			; right	    number
llnum	EQU	150			; left	    number
rrdvd	EQU	160			; right	    slash
lldvd	EQU	170			; left	    slash
rrmlt	EQU	180			; right	    asterisk
llmlt	EQU	190			; left	    asterisk
rrpct	EQU	200			; right	    percent
llpct	EQU	210			; left	    percent
rrexp	EQU	230			; right	    exclamation
llexp	EQU	220			; left	    exclamation
rrdld	EQU	240			; right	    dollar, dot
lldld	EQU	250			; left	    dollar, dot
rrnot	EQU	270			; right	    not
llnot	EQU	260			; left	    not
lluno	EQU	999			; left	    all unary operators
;
;      precedences are the same as in btl snobol4 with the
;      following exceptions.
;
;      1)   binary question mark is lowered and made left assoc-
;	    iative to reflect its new use for pattern matching.
;
;      2)   alternation and concatenation are made right
;	    associative for greater efficiency in pattern
;	    construction and matching respectively. this change
;	    is transparent to the snobol4 programmer.
;
;      3)   the equal sign has been added as a low precedence
;	    operator which is right associative to reflect its
;	    more general usage in this version of snobol4.
	EJC
;
;      eXTernal function block (efblk)
;
;      an eXTernal function block is used to control the calling
;      of an eXTernal function. it is built by a call to load.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     eflen		 i
;	    +------------------------------------+
;	    i		     efuse		 i
;	    +------------------------------------+
;	    i		     efcod		 i
;	    +------------------------------------+
;	    i		     efvar		 i
;	    +------------------------------------+
;	    i		     efrsl		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     eftar		 /
;	    /					 /
;	    +------------------------------------+
;
eflen	EQU	fargs+1			; length of efblk in bytes
efuse	EQU	eflen+1			; use count (for opsyn)
efcod	EQU	efuse+1			; ptr to code (from sysld)
efvar	EQU	efcod+1			; ptr to associated vrblk
efrsl	EQU	efvar+1			; result type (see below)
eftar	EQU	efrsl+1			; argument types (see below)
efsi_	EQU	eftar			; number of standard fields in efblk
;
;      the fcode field points to the routine b_efc.
;
;      efuse is used to keep track of multiple use when opsyn
;      is employed. the function is automatically unloaded
;      when there are no more references to the function.
;
;      efrsl and eftar are type codes as follows.
;
;	    0		     type is unconverted
;	    1		     type is string
;	    2		     type is integer
.IF    .cnra
.IF    .cnlf
;	    3		     type is file
.FI
.ELSE
;	    3		     type is real
.IF    .cnlf
;	    4		     type is file
.FI
.FI
	EJC
;
;      expression vaRIAble block (evblk)
;
;      in this version of spitbol, an expression can be used in
;      any position which would normally expect a name (for
;      example on the left side of equals or as the right
;      argument of binary dot). this corresponds to the creation
;      of a pseudo-vaRIAble which is represented by a pointer to
;      an expression vaRIAble block as follows.
;
;	    +------------------------------------+
;	    i		     evtyp		 i
;	    +------------------------------------+
;	    i		     evexp		 i
;	    +------------------------------------+
;	    i		     evvar		 i
;	    +------------------------------------+
;
evtyp	EQU	0			; pointer to dummy routine b_evt
evexp	EQU	evtyp+1			; pointer to exblk for expression
evvar	EQU	evexp+1			; pointer to trbev dummy trblk
evsi_	EQU	evvar+1			; size of evblk
;
;      the name of an expression vaRIAble is represented by a
;      base pointer to the evblk and an offset of evvar. this
;      value appears to be trapped by the dummy trbev block.
;
;      note that there is no need to allow for the case of an
;      expression vaRIAble which references an seblk since a
;      vaRIAble which is of the form *var is equivalent to var.
	EJC
;
;      expression block (exblk)
;
;      an expression block is built for each expression
;      referenced in a program or created by eval or convert
;      during execution of a program.
;
;	    +------------------------------------+
;	    i		     extyp		 i
;	    +------------------------------------+
;	    i		     eXStm		 i
.IF    .csln
;	    +------------------------------------+
;	    i		     eXSln		 i
.FI
;	    +------------------------------------+
;	    i		     exlen		 i
;	    +------------------------------------+
;	    i		     exflc		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     excod		 /
;	    /					 /
;	    +------------------------------------+
;
extyp	EQU	0			; ptr to routine b_exl to load expr
eXStm	EQU	cdstm			; stores stmnt no. during evaluation
.IF    .csln
eXSln	EQU	eXStm+1			; stores line no. during evaluation
exlen	EQU	eXSln+1			; length of exblk in bytes
.ELSE
exlen	EQU	eXStm+1			; length of exblk in bytes
.FI
exflc	EQU	exlen+1			; failure code (=o_fex)
excod	EQU	exflc+1			; pseudo-code for expression
exsi_	EQU	excod			; number of standard fields in exblk
;
;      there are two cases for excod depending on whether the
;      expression can be evaluated by name (see description
;      of cdblk for details of code for expressions).
;
;      if the expression can be evaluated by name we have.
;
;			     (code for expr by name)
;			     =o_rnm
;
;      if the expression can only be evaluated by value.
;
;			     (code for expr by value)
;			     =o_rvl
	EJC
;
;      field function block (ffblk)
;
;      a field function block is used to control the selection
;      of a field from a program defined datatype block.
;      a call to data creates an ffblk for each field.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     ffdfp		 i
;	    +------------------------------------+
;	    i		     ffnxt		 i
;	    +------------------------------------+
;	    i		     ffofs		 i
;	    +------------------------------------+
;
ffdfp	EQU	fargs+1			; pointer to associated dfblk
ffnxt	EQU	ffdfp+1			; ptr to next ffblk on chain or zero
ffofs	EQU	ffnxt+1			; offset (bytes) to field in pdblk
ffsi_	EQU	ffofs+1			; size of ffblk in words
;
;      the fcode field points to the routine b_ffc.
;
;      fargs always contains one.
;
;      ffdfp is used to verify that the correct program defined
;      datatype is being accessed by this call.
;      ffdfp is non-reloc. because dfblk is in static
;
;      ffofs is used to select the appropriate field. note that
;      it is an actual offset (not a field number)
;
;      ffnxt is used to point to the next ffblk of the same name
;      in the case where there are several fields of the same
;      name for different datatypes. zero marks the end of chain
	EJC
;
;      integer constant block (icblk)
;
;      an icblk is created for every integer referenced or
;      created by a program. note however that certain internal
;      integer values are stored as addresses (e.g. the length
;      field in a string constant block)
;
;	    +------------------------------------+
;	    i		     icget		 i
;	    +------------------------------------+
;	    *		     icval		 *
;	    +------------------------------------+
;
icget	EQU	0			; ptr to routine b_icl to load int
icval	EQU	icget+1			; integer value
icsi_	EQU	icval+cfp_i		; size of icblk
;
;      the length of the icval field is cfp_i.
	EJC
;
;      keyword vaRIAble block (kvblk)
;
;      a kvblk is used to represent a keyword pseudo-vaRIAble.
;      a kvblk is built for each keyword reference (kwnam).
;
;	    +------------------------------------+
;	    i		     kvtyp		 i
;	    +------------------------------------+
;	    i		     kvvar		 i
;	    +------------------------------------+
;	    i		     kvnum		 i
;	    +------------------------------------+
;
kvtyp	EQU	0			; pointer to dummy routine b_kvt
kvvar	EQU	kvtyp+1			; pointer to dummy block trbkv
kvnum	EQU	kvvar+1			; keyword number
kvsi_	EQU	kvnum+1			; size of kvblk
;
;      the name of a keyword vaRIAble is represented by a
;      base pointer to the kvblk and an offset of kvvar. the
;      value appears to be trapped by the pointer to trbkv.
	EJC
;
;      name block (nmblk)
;
;      a name block is used wherever a name must be stored as
;      a value following use of the unary dot operator.
;
;	    +------------------------------------+
;	    i		     nmtyp		 i
;	    +------------------------------------+
;	    i		     nmbas		 i
;	    +------------------------------------+
;	    i		     nmofs		 i
;	    +------------------------------------+
;
nmtyp	EQU	0			; ptr to routine b_nml to load name
nmbas	EQU	nmtyp+1			; base pointer for vaRIAble
nmofs	EQU	nmbas+1			; offset for vaRIAble
nmsi_	EQU	nmofs+1			; size of nmblk
;
;      the actual field representing the contents of the name
;      is found nmofs bytes past the address in nmbas.
;
;      the name is split into base and offset form to avoid
;      creation of a pointer into the middle of a block which
;      could not be handled properly by the garbage collector.
;
;      a name may be built for any vaRIAble (see section on
;      representations of vaRIAbles) this includes the
;      cases of pseudo-vaRIAbles.
	EJC
;
;      pattern block, no parameters (p0blk)
;
;      a p0blk is used to represent pattern nodes which do
;      not require the use of any parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;
pcode	EQU	0			; ptr to match routine (p_xxx)
pthen	EQU	pcode+1			; pointer to subsequent node
pasi_	EQU	pthen+1			; size of p0blk
;
;      pthen points to the pattern block for the subsequent
;      node to be matched. this is a pointer to the pattern
;      block ndnth if there is no subsequent (end of pattern)
;
;      pcode is a pointer to the match routine for the node.
	EJC
;
;      pattern block (one parameter)
;
;      a p1blk is used to represent pattern nodes which
;      require one parameter value.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;
parm1	EQU	pthen+1			; first parameter value
pbsi_	EQU	parm1+1			; size of p1blk in words
;
;      see p0blk for definitions of pcode, pthen
;
;      parm1 contains a parameter value used in matching the
;      node. for example, in a len pattern, it is the integer
;      argument to len. the details of the use of the parameter
;      field are included in the description of the individual
;      match routines. parm1 is always an address pointer which
;      is processed by the garbage collector.
	EJC
;
;      pattern block (two parameters)
;
;      a p2blk is used to represent pattern nodes which
;      require two parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
parm2	EQU	parm1+1			; second parameter value
pcsi_	EQU	parm2+1			; size of p2blk in words
;
;      see p1blk for definitions of pcode, pthen, parm1
;
;      parm2 is a parameter which performs the same sort of
;      function as parm1 (see description of p1blk).
;
;      parm2 is a non-relocatable field and is not
;      processed by the garbage collector. accordingly, it may
;      not contain a pointer to a block in dynamic memory.
	EJC
;
;      program-defined datatype block
;
;      a pdblk represents the data item formed by a call to a
;      datatype function as defined by the system function data.
;
;	    +------------------------------------+
;	    i		     pdtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     pddfp		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pdfld		 /
;	    /					 /
;	    +------------------------------------+
;
pdtyp	EQU	0			; ptr to dummy routine b_pdt
pddfp	EQU	idval+1			; ptr to associated dfblk
pdfld	EQU	pddfp+1			; start of field value pointers
pdfof	EQU	dffld-pdfld		; difference in offset to field ptrs
pdsi_	EQU	pdfld			; size of standard fields in pdblk
pddfs	EQU	dfsi_-pdsi_		; difference in dfblk, pdblk sizes
;
;      the pddfp pointer may be used to determine the datatype
;      and the names of the fields if required. the dfblk also
;      contains the length of the pdblk in bytes (field dfpdl).
;      pddfp is non-reloc. because dfblk is in static
;
;      pdfld values are stored in order from left to right.
;      they contain values or pointers to trblk chains.
	EJC
;
;      program defined function block (pfblk)
;
;      a pfblk is created for each call to the define function
;      and a pointer to the pfblk placed in the proper vrblk.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     pflen		 i
;	    +------------------------------------+
;	    i		     pfvbl		 i
;	    +------------------------------------+
;	    i		     pfnlo		 i
;	    +------------------------------------+
;	    i		     pfcod		 i
;	    +------------------------------------+
;	    i		     pfctr		 i
;	    +------------------------------------+
;	    i		     pfrtr		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pfarg		 /
;	    /					 /
;	    +------------------------------------+
;
pflen	EQU	fargs+1			; length of pfblk in bytes
pfvbl	EQU	pflen+1			; pointer to vrblk for function name
pfnlo	EQU	pfvbl+1			; number of locals
pfcod	EQU	pfnlo+1			; ptr to vrblk for entry label
pfctr	EQU	pfcod+1			; trblk ptr if call traced else 0
pfrtr	EQU	pfctr+1			; trblk ptr if return traced else 0
pfarg	EQU	pfrtr+1			; vrblk ptrs for arguments and locals
pfagb	EQU	pfarg-1			; offset behind pfarg for arg, local
pfsi_	EQU	pfarg			; number of standard fields in pfblk
;
;      the fcode field points to the routine b_pfc.
;
;      pfarg is stored in the following order.
;
;	    arguments (left to right)
;	    locals (left to right)
.IF    .cnra
.ELSE
	EJC
;
;      real constant block (rcblk)
;
;      an rcblk is created for every real referenced or
;      created by a program.
;
;	    +------------------------------------+
;	    i		     rcget		 i
;	    +------------------------------------+
;	    *		     rcval		 *
;	    +------------------------------------+
;
rcget	EQU	0			; ptr to routine b_rcl to load real
rcval	EQU	rcget+1			; real value
rcsi_	EQU	rcval+cfp_r		; size of rcblk
;
;      the length of the rcval field is cfp_r.
.FI
	EJC
;
;      string constant block (scblk)
;
;      an scblk is built for every string referenced or created
;      by a program.
;
;	    +------------------------------------+
;	    i		     scget		 i
;	    +------------------------------------+
;	    i		     sclen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     schar		 /
;	    /					 /
;	    +------------------------------------+
;
scget	EQU	0			; ptr to routine b_scl to load string
sclen	EQU	scget+1			; length of string in characters
schar	EQU	sclen+1			; characters of string
scsi_	EQU	schar			; size of standard fields in scblk
;
;      the characters of the string are stored left justified.
;      the final word is padded on the right with zeros.
;      (i.e. the character whose internal code is zero).
;
;      the value of sclen may not exceed mxlen. this ensures
;      that character offsets (e.g. the pattern match cursor)
;      can be correctly processed by the garbage collector.
;
;      note that the offset to the characters of the string
;      is given in bytes by cfp_f and that this value is
;      automatically allowed for in plc, psc.
;      note that for a spitbol scblk, the value of cfp_f
;      is given by cfp_b*schar.
	EJC
;
;      simple expression block (seblk)
;
;      an seblk is used to represent an expression of the form
;      *(natural vaRIAble). all other expressions are exblks.
;
;	    +------------------------------------+
;	    i		     setyp		 i
;	    +------------------------------------+
;	    i		     sevar		 i
;	    +------------------------------------+
;
setyp	EQU	0			; ptr to routine b_sel to load expr
sevar	EQU	setyp+1			; ptr to vrblk for vaRIAble
sesi_	EQU	sevar+1			; length of seblk in words
	EJC
;
;      standard vaRIAble block (svblk)
;
;      an svblk is assembled in the constant section for each
;      vaRIAble which satisfies one of the following conditions.
;
;      1)   it is the name of a system function
;      2)   it has an initial value
;      3)   it has a keyword association
;      4)   it has a standard i/o association
;      6)   it has a standard label association
;
;      if vrblks are constructed for any of these vaRIAbles,
;      then the vrsvp field points to the svblk (see vrblk)
;
;	    +------------------------------------+
;	    i		     svbit		 i
;	    +------------------------------------+
;	    i		     svlen		 i
;	    +------------------------------------+
;	    /		     svchs		 /
;	    +------------------------------------+
;	    i		     svknm		 i
;	    +------------------------------------+
;	    i		     svfnc		 i
;	    +------------------------------------+
;	    i		     svnar		 i
;	    +------------------------------------+
;	    i		     svlbl		 i
;	    +------------------------------------+
;	    i		     svval		 i
;	    +------------------------------------+
	EJC
;
;      standard vaRIAble block (continued)
;
svbit	EQU	0			; bit string indicating attributes
svlen	EQU	1			; (=sclen) length of name in chars
svchs	EQU	2			; (=schar) characters of name
svsi_	EQU	2			; number of standard fields in svblk
svpre	EQU	1			; set if preevaluation permitted
svffc	EQU	svpre+svpre		; set on if fast call permitted
svckw	EQU	svffc+svffc		; set on if keyword value constant
svprd	EQU	svckw+svckw		; set on if predicate function
svnbt	EQU	4			; number of bits to right of svknm
svknm	EQU	svprd+svprd		; set on if keyword association
svfnc	EQU	svknm+svknm		; set on if system function
svnar	EQU	svfnc+svfnc		; set on if system function
svlbl	EQU	svnar+svnar		; set on if system label
svval	EQU	svlbl+svlbl		; set on if predefined value
;
;      note that the last five bits correspond in order
;      to the fields which are present (see procedure gtnvr).
;
;      the following definitions are used in the svblk table
;
svfnf	EQU	svfnc+svnar		; function with no fast call
svfnn	EQU	svfnf+svffc		; function with fast call, no preeval
svfnp	EQU	svfnn+svpre		; function allowing preevaluation
svfpr	EQU	svfnn+svprd		; predicate function
svfnk	EQU	svfnn+svknm		; no preeval func + keyword
svkwv	EQU	svknm+svval		; keyword + value
svkwc	EQU	svckw+svknm		; keyword with constant value
svkvc	EQU	svkwv+svckw		; constant keyword + value
svkvl	EQU	svkvc+svlbl		; constant keyword + value + label
svfpk	EQU	svfnp+svkvc		; preeval fcn + const keywd + val
;
;      the svpre bit allows the compiler to preevaluate a call
;      to the associated system function if all the arguments
;      are themselves constants. functions in this category
;      must have no side effects and must never cause failure.
;      the call may generate an error condition.
;
;      the svffc bit allows the compiler to generate the special
;      fast call after adjusting the number of arguments. only
;      the item and apply functions fall outside this category.
;
;      the svckw bit is set if the associated keyword value is
;      a constant, thus allowing preevaluation for a value call.
;
;      the svprd bit is set on for all predicate functions to
;      enable the special concatenation code optimization.
	EJC
;
;      svblk (continued)
;
;      svknm		     keyword number
;
;	    svknm is present only for a standard keyword assoc.
;	    it contains a keyword number as defined by the
;	    keyword number table given later on.
;
;      svfnc		     system function pointer
;
;	    svfnc is present only for a system function assoc.
;	    it is a pointer to the actual code for the system
;	    function. the generated code for a fast call is a
;	    pointer to the svfnc field of the svblk for the
;	    function. the vrfnc field of the vrblk points to
;	    this same field, in which case, it serves as the
;	    fcode field for the function call.
;
;      svnar		     number of function arguments
;
;	    svnar is present only for a system function assoc.
;	    it is the number of arguments required for a call
;	    to the system function. the compiler uses this
;	    value to adjust the number of arguments in a fast
;	    call and in the case of a function called through
;	    the vrfnc field of the vrblk, the svnar field
;	    serves as the fargs field for o_fnc. a special
;	    case occurs if this value is set to 999. this is
;	    used to indicate that the function has a vaRIAble
;	    number of arguments and causes o_fnc to pass control
;	    without adjusting the argument count. the only
;	    predefined functions using this are apply and item.
;
;      svlbl		     system label pointer
;
;	    svlbl is present only for a standard label assoc.
;	    it is a pointer to a system label routine (l_xxx).
;	    the vrlbl field of the corresponding vrblk points to
;	    the svlbl field of the svblk.
;
;      svval		     system value pointer
;
;	    svval is present only for a standard value.
;	    it is a pointer to the pattern node (ndxxx) which
;	    is the standard initial value of the vaRIAble.
;	    this value is copied to the vrval field of the vrblk
	EJC
;
;      svblk (continued)
;
;      keyword number table
;
;      the following table gives symbolic names for keyword
;      numbers. these values are stored in the svknm field of
;      svblks and in the kvnum field of kvblks. see also
;      procedures asign, acess and kwnam.
;
;      unprotected keywords with one word integer values
;
k_abe	EQU	0			; abend
k_anc	EQU	k_abe+cfp_b		; anchor
.IF    .culc
k_cas	EQU	k_anc+cfp_b		; case
k_cod	EQU	k_cas+cfp_b		; code
.ELSE
k_cod	EQU	k_anc+cfp_b		; code
.FI
.IF    .ccmk
k_com	EQU	k_cod+cfp_b		; compare
k_dmp	EQU	k_com+cfp_b		; dump
.ELSE
k_dmp	EQU	k_cod+cfp_b		; dump
.FI
k_erl	EQU	k_dmp+cfp_b		; errlimit
k_ert	EQU	k_erl+cfp_b		; errtype
k_ftr	EQU	k_ert+cfp_b		; ftrace
k_fls	EQU	k_ftr+cfp_b		; fullscan
k_inp	EQU	k_fls+cfp_b		; input
k_mxl	EQU	k_inp+cfp_b		; maXLength
k_oup	EQU	k_mxl+cfp_b		; output
.IF    .cnpf
k_tra	EQU	k_oup+cfp_b		; trace
.ELSE
k_pfl	EQU	k_oup+cfp_b		; profile
k_tra	EQU	k_pfl+cfp_b		; trace
.FI
k_trm	EQU	k_tra+cfp_b		; trim
;
;      protected keywords with one word integer values
;
k_fnc	EQU	k_trm+cfp_b		; fnclevel
k_lst	EQU	k_fnc+cfp_b		; lastno
.IF    .csln
k_lln	EQU	k_lst+cfp_b		; lastline
k_lin	EQU	k_lln+cfp_b		; line
k_stn	EQU	k_lin+cfp_b		; stno
.ELSE
k_stn	EQU	k_lst+cfp_b		; stno
.FI
;
;      keywords with constant pattern values
;
k_abo	EQU	k_stn+cfp_b		; abort
k_arb	EQU	k_abo+pasi_		; arb
k_bal	EQU	k_arb+pasi_		; bal
k_fal	EQU	k_bal+pasi_		; fail
k_fen	EQU	k_fal+pasi_		; fence
k_rem	EQU	k_fen+pasi_		; rem
k_suc	EQU	k_rem+pasi_		; succeed
	EJC
;
;      keyword number table (continued)
;
;      special keywords
;
k_alp	EQU	k_suc+1			; alphabet
k_rtn	EQU	k_alp+1			; rtntype
k_stc	EQU	k_rtn+1			; stcount
k_etx	EQU	k_stc+1			; errteXT
.IF    .csfn
k_fil	EQU	k_etx+1			; file
k_lfl	EQU	k_fil+1			; lastfile
k_stl	EQU	k_lfl+1			; stlimit
.ELSE
k_stl	EQU	k_etx+1			; stlimit
.FI
.IF    .culk
k_lcs	EQU	k_stl+1			; lcase
k_ucs	EQU	k_lcs+1			; ucase
.FI
;
;      relative offsets of special keywords
;
k__al	EQU	k_alp-k_alp		; alphabet
k__rt	EQU	k_rtn-k_alp		; rtntype
k__sc	EQU	k_stc-k_alp		; stcount
k__et	EQU	k_etx-k_alp		; errteXT
.IF    .csfn
k__fl	EQU	k_fil-k_alp		; file
k__lf	EQU	k_lfl-k_alp		; lastfile
.FI
k__sl	EQU	k_stl-k_alp		; stlimit
.IF    .culk
k__lc	EQU	k_lcs-k_alp		; lcase
k__uc	EQU	k_ucs-k_alp		; ucase
k__n_	EQU	k__uc+1			; number of special cases
.ELSE
k__n_	EQU	k__sl+1			; number of special cases
.FI
;
;      symbols used in asign and acess procedures
;
k_p__	EQU	k_fnc			; first protected keyword
k_v__	EQU	k_abo			; first keyword with constant value
k_s__	EQU	k_alp			; first keyword with special acess
	EJC
;
;      format of a table block (tbblk)
;
;      a table block is used to represent a table value.
;      it is built by a call to the table or convert functions.
;
;	    +------------------------------------+
;	    i		     tbtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     tblen		 i
;	    +------------------------------------+
;	    i		     tbinv		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     tbbuk		 /
;	    /					 /
;	    +------------------------------------+
;
tbtyp	EQU	0			; pointer to dummy routine b_tbt
tblen	EQU	offs2			; length of tbblk in bytes
tbinv	EQU	offs3			; default initial lookup value
tbbuk	EQU	tbinv+1			; start of hash bucket pointers
tbsi_	EQU	tbbuk			; size of standard fields in tbblk
tbnbk	EQU	11			; default no. of buckets
;
;      the table block is a hash table which points to chains
;      of table element blocks representing the elements
;      in the table which hash into the same bucket.
;
;      tbbuk entries either point to the first teblk on the
;      chain or they point to the tbblk itself to indicate the
;      end of the chain.
	EJC
;
;      table element block (teblk)
;
;      a table element is used to represent a single entry in
;      a table (see description of tbblk format for hash table)
;
;	    +------------------------------------+
;	    i		     tetyp		 i
;	    +------------------------------------+
;	    i		     tesub		 i
;	    +------------------------------------+
;	    i		     teval		 i
;	    +------------------------------------+
;	    i		     tenxt		 i
;	    +------------------------------------+
;
tetyp	EQU	0			; pointer to dummy routine b_tet
tesub	EQU	tetyp+1			; subscript value
teval	EQU	tesub+1			; (=vrval) table element value
tenxt	EQU	teval+1			; link to next teblk
;      see s_cnv where relation is assumed with tenxt and tbbuk
tesi_	EQU	tenxt+1			; size of teblk in words
;
;      tenxt points to the next teblk on the hash chain from the
;      tbbuk chain for this hash index. at the end of the chain,
;      tenxt points back to the start of the tbblk.
;
;      teval contains a data pointer or a trblk pointer.
;
;      tesub contains a data pointer.
	EJC
;
;      trap block (trblk)
;
;      a trap block is used to represent a trace or input or
;      output association in response to a call to the trace
;      input or output system functions. see below for details
;
;	    +------------------------------------+
;	    i		     tridn		 i
;	    +------------------------------------+
;	    i		     trtyp		 i
;	    +------------------------------------+
;	    i  trval or trlbl or trnxt or trkvr	 i
;	    +------------------------------------+
;	    i	    trtag or trter or trtrf	 i
;	    +------------------------------------+
;	    i		 trfnc or trfpt		 i
;	    +------------------------------------+
;
tridn	EQU	0			; pointer to dummy routine b_trt
trtyp	EQU	tridn+1			; trap type code
trval	EQU	trtyp+1			; value of trapped vaRIAble (=vrval)
trnxt	EQU	trval			; ptr to next trblk on trblk chain
trlbl	EQU	trval			; ptr to actual label (traced label)
trkvr	EQU	trval			; vrblk pointer for keyword trace
trtag	EQU	trval+1			; trace tag
trter	EQU	trtag			; ptr to terminal vrblk or null
trtrf	EQU	trtag			; ptr to trblk holding fcblk ptr
trfnc	EQU	trtag+1			; trace function vrblk (zero if none)
trfpt	EQU	trfnc			; fcblk ptr for sysio
trsi_	EQU	trfnc+1			; number of words in trblk
;
trtin	EQU	0			; trace type for input association
trtac	EQU	trtin+1			; trace type for access trace
trtvl	EQU	trtac+1			; trace type for value trace
trtou	EQU	trtvl+1			; trace type for output association
trtfc	EQU	trtou+1			; trace type for fcblk identification
	EJC
;
;      trap block (continued)
;
;      vaRIAble input association
;
;	    the value field of the vaRIAble points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural vaRIAble, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtin
;	    trnxt points to next trblk or trval has vaRIAble val
;	    trter is a pointer to svblk if association is
;	    for input, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      vaRIAble access trace association
;
;	    the value field of the vaRIAble points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural vaRIAble, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtac
;	    trnxt points to next trblk or trval has vaRIAble val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      vaRIAble value trace association
;
;	    the value field of the vaRIAble points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural vaRIAble, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtvl
;	    trnxt points to next trblk or trval has vaRIAble val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
	EJC
;      trap block (continued)
;
;      vaRIAble output association
;
;	    the value field of the vaRIAble points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural vaRIAble, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtou
;	    trnxt points to next trblk or trval has vaRIAble val
;	    trter is a pointer to svblk if association is
;	    for output, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      function call trace
;
;	    the pfctr field of the corresponding pfblk is set
;	    to point to a trblk.
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      function return trace
;
;	    the pfrtr field of the corresponding pfblk is set
;	    to point to a trblk
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      label trace
;
;	    the vrlbl of the vrblk for the label is
;	    changed to point to a trblk and the vrtra field is
;	    set to b_vrt to activate the check.
;
;	    trtyp is set to trtin
;	    trlbl points to the actual label (cdblk) value
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
	EJC
;
;      trap block (continued)
;
;      keyword trace
;
;	    keywords which can be traced possess a unique
;	    location which is zero if there is no trace and
;	    points to a trblk if there is a trace. the locations
;	    are as follows.
;
;	    r_ert	     errtype
;	    r_fnc	     fnclevel
;	    r_stc	     stcount
;
;	    the format of the trblk is as follows.
;
;	    trtyp is set to trtin
;	    trkvr is a pointer to the vrblk for the keyword
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      input/output file arg1 trap block
;
;	    the value field of the vaRIAble points to a trblk
;	    instead of containing the data value. in the case of
;	    a natural vaRIAble, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv. this trap block is used
;	    to hold a pointer to the fcblk which an
;	    implementation may request to hold information
;	    about a file.
;
;	    trtyp is set to trtfc
;	    trnext points to next trblk or trval is vaRIAble val
;	    trfnm is 0
;	    trfpt is the fcblk pointer.
;
;      note that when multiple traps are set on a vaRIAble
;      the order is in ascending value of trtyp field.
;
;      input association (if present)
;      access trace (if present)
;      value trace (if present)
;      output association (if present)
;
;      the actual value of the vaRIAble is stored in the trval
;      field of the last trblk on the chain.
;
;      this implementation does not permit trace or i/o
;      associations to any of the pseudo-vaRIAbles.
	EJC
;
;      vector block (vcblk)
;
;      a vcblk is used to represent an array value which has
;      one dimension whose lower bound is one. all other arrays
;      are represented by arblks. a vcblk is created by the
;      system function array (s_arr) when passed an integer arg.
;
;	    +------------------------------------+
;	    i		     vctyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     vclen		 i
;	    +------------------------------------+
;	    i		     vcvls		 i
;	    +------------------------------------+
;
vctyp	EQU	0			; pointer to dummy routine b_vct
vclen	EQU	offs2			; length of vcblk in bytes
vcvls	EQU	offs3			; start of vector values
vcsi_	EQU	vcvls			; size of standard fields in vcblk
vcvlb	EQU	vcvls-1			; offset one word behind vcvls
vctbd	EQU	tbsi_-vcsi_		; difference in sizes - see prtvl
;
;      vcvls are either data pointers or trblk pointers
;
;      the dimension can be deduced from vclen.
	EJC
;
;      vaRIAble block (vrblk)
;
;      a vaRIAble block is built in the static memory area
;      for every vaRIAble referenced or created by a program.
;      the order of fields is assumed in the model vrblk stnvr.
;
;      note that since these blocks only occur in the static
;      region, it is permissible to point to any word in
;      the block and this is used to provide three distinct
;      access points from the generated code as follows.
;
;      1)   point to vrget (first word of vrblk) to load the
;	    value of the vaRIAble onto the main stack.
;
;      2)   point to vrsto (second word of vrblk) to store the
;	    top stack element as the value of the vaRIAble.
;
;      3)   point to vrtra (fourth word of vrblk) to jump to
;	    the label associated with the vaRIAble name.
;
;	    +------------------------------------+
;	    i		     vrget		 i
;	    +------------------------------------+
;	    i		     vrsto		 i
;	    +------------------------------------+
;	    i		     vrval		 i
;	    +------------------------------------+
;	    i		     vrtra		 i
;	    +------------------------------------+
;	    i		     vrlbl		 i
;	    +------------------------------------+
;	    i		     vrfnc		 i
;	    +------------------------------------+
;	    i		     vrnxt		 i
;	    +------------------------------------+
;	    i		     vrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		 vrchs = vrsvp		 /
;	    /					 /
;	    +------------------------------------+
	EJC
;
;      vaRIAble block (continued)
;
vrget	EQU	0			; pointer to routine to load value
vrsto	EQU	vrget+1			; pointer to routine to store value
vrval	EQU	vrsto+1			; vaRIAble value
vrvlo	EQU	vrval-vrsto		; offset to value from store field
vrtra	EQU	vrval+1			; pointer to routine to jump to label
vrlbl	EQU	vrtra+1			; pointer to code for label
vrlbo	EQU	vrlbl-vrtra		; offset to label from transfer field
vrfnc	EQU	vrlbl+1			; pointer to function block
vrnxt	EQU	vrfnc+1			; pointer to next vrblk on hash chain
vrlen	EQU	vrnxt+1			; length of name (or zero)
vrchs	EQU	vrlen+1			; characters of name (vrlen gt 0)
vrsvp	EQU	vrlen+1			; ptr to svblk (vrlen eq 0)
vrsi_	EQU	vrchs+1			; number of standard fields in vrblk
vrsof	EQU	vrlen-sclen		; offset to dummy scblk for name
vrsvo	EQU	vrsvp-vrsof		; pseudo-offset to vrsvp field
;
;      vrget = b_vrl if not input associated or access traced
;      vrget = b_vra if input associated or access traced
;
;      vrsto = b_vrs if not output associated or value traced
;      vrsto = b_vrv if output associated or value traced
;      vrsto = b_vre if value is protected pattern value
;
;      vrval points to the appropriate value unless the
;      vaRIAble is i/o/trace associated in which case, vrval
;      points to an appropriate trblk (trap block) chain.
;
;      vrtra = b_vrg if the label is not traced
;      vrtra = b_vrt if the label is traced
;
;      vrlbl points to a cdblk if there is a label
;      vrlbl points to the svblk svlbl field for a system label
;      vrlbl points to stndl for an undefined label
;      vrlbl points to a trblk if the label is traced
;
;      vrfnc points to a ffblk for a field function
;      vrfnc points to a dfblk for a datatype function
;      vrfnc points to a pfblk for a program defined function
;      vrfnc points to a efblk for an eXTernal loaded function
;      vrfnc points to svfnc (svblk) for a system function
;      vrfnc points to stndf if the function is undefined
;
;      vrnxt points to the next vrblk on this chain unless
;      this is the end of the chain in which case it is zero.
;
;      vrlen is the name length for a non-system vaRIAble.
;      vrlen is zero for a system vaRIAble.
;
;      vrchs is the name (ljrz) if vrlen is non-zero.
;      vrsvp is a ptr to the svblk if vrlen is zero.
	EJC
;
;      format of a non-relocatable eXTernal block (xnblk)
;
;      an xnblk is a block representing an unknown (eXTernal)
;      data value. the block contains no pointers to other
;      relocatable blocks. an xnblk is used by eXTernal function
;      processing or possibly for system i/o routines etc.
;      the macro-system itself does not use xnblks.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xntyp		 i
;	    +------------------------------------+
;	    i		     xnlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xndta		 /
;	    /					 /
;	    +------------------------------------+
;
xntyp	EQU	0			; pointer to dummy routine b_xnt
xnlen	EQU	xntyp+1			; length of xnblk in bytes
xndta	EQU	xnlen+1			; data words
xnsi_	EQU	xndta			; size of standard fields in xnblk
;
;      note that the term non-relocatable refers to the contents
;      and not the block itself. an xnblk can be moved around if
;      it is built in the dynamic memory area.
	EJC
;
;      relocatable eXTernal block (XRblk)
;
;      an XRblk is a block representing an unknown (eXTernal)
;      data value. the data area in this block consists only
;      of address values and any addresses pointing into the
;      dynamic memory area must point to the start of other
;      data blocks. see also description of xnblk.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xrtyp		 i
;	    +------------------------------------+
;	    i		     xrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xrptr		 /
;	    /					 /
;	    +------------------------------------+
;
xrtyp	EQU	0			; pointer to dummy routine b_xrt
xrlen	EQU	xrtyp+1			; length of XRblk in bytes
xrptr	EQU	xrlen+1			; start of address pointers
xrsi_	EQU	xrptr			; size of standard fields in XRblk
	EJC
;
;      s_cnv (convert) function switch constants.  the values
;      are tied to the order of the entries in the svctb table
;      and hence to the branch table in s_cnv.
;
cnvst	EQU	8			; max standard type code for convert
.IF    .cnra
cnvrt	EQU	cnvst			; no reals - same as standard types
.ELSE
cnvrt	EQU	cnvst+1			; convert code for reals
.FI
.IF    .cnbf
cnvbt	EQU	cnvrt			; no buffers - same as real code
.ELSE
cnvbt	EQU	cnvrt+1			; convert code for buffer
.FI
cnvtt	EQU	cnvbt+1			; bsw code for convert
;
;      input image length
;
iniln	EQU	1024			; default image length for compiler
inils	EQU	1024			; image length if -sequ in effect
;
ionmb	EQU	2			; name base used for iochn in sysio
ionmo	EQU	4			; name offset used for iochn in sysio
;
;      minimum value for keyword maXLngth
;      should be larger than iniln
;
mnlen	EQU	1024			; min value allowed keyword maXLngth
mxern	EQU	329			; err num inadequate startup memory
;
;      in general, meaningful mnemonics should be used for
;      offsets. however for small integers used often in
;      literals the following general definitions are provided.
;
num01	EQU	1			;
num02	EQU	2			;
num03	EQU	3			;
num04	EQU	4			;
num05	EQU	5			;
num06	EQU	6			;
num07	EQU	7			;
num08	EQU	8			;
num09	EQU	9			;
num10	EQU	10			;
num25	EQU	25			;
nm320	EQU	320			;
nm321	EQU	321			;
nini8	EQU	998			;
nini9	EQU	999			;
thsnd	EQU	1000			;
	EJC
;
;      numbers of undefined spitbol operators
;
opbun	EQU	5			; no. of binary undefined ops
opuun	EQU	6			; no of unary undefined ops
;
;      offsets used in prtsn, prtmi and acess
;
prsnf	EQU	13			; offset used in prtsn
prtmf	EQU	21			; offset to col 21 (prtmi)
rilen	EQU	1024			; buffer length for sysri
;
;      codes for stages of processing
;
stgic	EQU	0			; initial compile
stgxc	EQU	stgic+1			; execution compile (code)
stgev	EQU	stgxc+1			; expression eval during execution
stgxt	EQU	stgev+1			; execution time
stgce	EQU	stgxt+1			; initial compile after end line
stgxe	EQU	stgce+1			; exec. compile after end line
stgnd	EQU	stgce-stgic		; difference in stage after end
stgee	EQU	stgxe+1			; eval evaluating expression
stgno	EQU	stgee+1			; number of codes
	EJC
;
;
;      statement number pad count for listr
;
.IF    .csn6
stnpd	EQU	6			; statement no. pad count
.FI
.IF    .csn8
stnpd	EQU	8			; statement no. pad count
.FI
.IF    .csn5
stnpd	EQU	5			; statement no. pad count
.FI
;
;      syntax type codes
;
;      these codes are returned from the scane procedure.
;
;      they are spaced 3 apart for the benefit of expan.
;
t_uop	EQU	0			; unary operator
t_lpr	EQU	t_uop+3			; left paren
t_lbr	EQU	t_lpr+3			; left bracket
t_cma	EQU	t_lbr+3			; comma
t_fnc	EQU	t_cma+3			; function call
t_var	EQU	t_fnc+3			; vaRIAble
t_con	EQU	t_var+3			; constant
t_bop	EQU	t_con+3			; binary operator
t_rpr	EQU	t_bop+3			; right paren
t_rbr	EQU	t_rpr+3			; right bracket
t_col	EQU	t_rbr+3			; colon
t_smc	EQU	t_col+3			; semi-colon
;
;      the following definitions are used only in the goto field
;
t_fgo	EQU	t_smc+1			; failure goto
t_sgo	EQU	t_fgo+1			; success goto
;
;      the above codes are grouped so that codes for elements
;      which can legitimately immediately precede a unary
;      operator come first to facilitate operator syntax check.
;
t_uok	EQU	t_fnc			; last code ok before unary operator
	EJC
;
;      definitions of values for expan jump table
;
t_uo0	EQU	t_uop+0			; unary operator, state zero
t_uo1	EQU	t_uop+1			; unary operator, state one
t_uo2	EQU	t_uop+2			; unary operator, state two
t_lp0	EQU	t_lpr+0			; left paren, state zero
t_lp1	EQU	t_lpr+1			; left paren, state one
t_lp2	EQU	t_lpr+2			; left paren, state two
t_lb0	EQU	t_lbr+0			; left bracket, state zero
t_lb1	EQU	t_lbr+1			; left bracket, state one
t_lb2	EQU	t_lbr+2			; left bracket, state two
t_cm0	EQU	t_cma+0			; comma, state zero
t_cm1	EQU	t_cma+1			; comma, state one
t_cm2	EQU	t_cma+2			; comma, state two
t_fn0	EQU	t_fnc+0			; function call, state zero
t_fn1	EQU	t_fnc+1			; function call, state one
t_fn2	EQU	t_fnc+2			; function call, state two
t_va0	EQU	t_var+0			; vaRIAble, state zero
t_va1	EQU	t_var+1			; vaRIAble, state one
t_va2	EQU	t_var+2			; vaRIAble, state two
t_co0	EQU	t_con+0			; constant, state zero
t_co1	EQU	t_con+1			; constant, state one
t_co2	EQU	t_con+2			; constant, state two
t_bo0	EQU	t_bop+0			; binary operator, state zero
t_bo1	EQU	t_bop+1			; binary operator, state one
t_bo2	EQU	t_bop+2			; binary operator, state two
t_rp0	EQU	t_rpr+0			; right paren, state zero
t_rp1	EQU	t_rpr+1			; right paren, state one
t_rp2	EQU	t_rpr+2			; right paren, state two
t_rb0	EQU	t_rbr+0			; right bracket, state zero
t_rb1	EQU	t_rbr+1			; right bracket, state one
t_rb2	EQU	t_rbr+2			; right bracket, state two
t_cl0	EQU	t_col+0			; colon, state zero
t_cl1	EQU	t_col+1			; colon, state one
t_cl2	EQU	t_col+2			; colon, state two
t_sm0	EQU	t_smc+0			; semicolon, state zero
t_sm1	EQU	t_smc+1			; semicolon, state one
t_sm2	EQU	t_smc+2			; semicolon, state two
;
t_nes	EQU	t_sm2+1			; number of entries in branch table
	EJC
;
;	definition of offsets used in control card processing
;
.IF    .culc
cc_ca	EQU	0			; -case
cc_do	EQU	cc_ca+1			; -double
.ELSE
cc_do	EQU	0			; -double
.FI
.IF    .ccmk
cc_co	EQU	cc_do+1			; -compare
cc_du	EQU	cc_co+1			; -dump
.ELSE
cc_du	EQU	cc_do+1			; -dump
.FI
.IF    .cinc
cc_cp	EQU	cc_du+1			; -copy
cc_ej	EQU	cc_cp+1			; -eject
.ELSE
cc_ej	EQU	cc_du+1			; -eject
.FI
cc_er	EQU	cc_ej+1			; -errors
cc_ex	EQU	cc_er+1			; -execute
cc_fa	EQU	cc_ex+1			; -fail
.IF    .cinc
cc_in	EQU	cc_fa+1			; -include
.IF    .csln
cc_ln	EQU	cc_in+1			; -line
cc_li	EQU	cc_ln+1			; -list
.ELSE
cc_li	EQU	cc_in+1			; -list
.FI
.ELSE
.IF    .csln
cc_ln	EQU	cc_fa+1			; -line
cc_li	EQU	cc_ln+1			; -list
.ELSE
cc_li	EQU	cc_fa+1			; -list
.FI
.FI
cc_nr	EQU	cc_li+1			; -noerrors
cc_nx	EQU	cc_nr+1			; -noexecute
cc_nf	EQU	cc_nx+1			; -nofail
cc_nl	EQU	cc_nf+1			; -nolist
cc_no	EQU	cc_nl+1			; -noopt
cc_np	EQU	cc_no+1			; -noprint
cc_op	EQU	cc_np+1			; -optimise
cc_pr	EQU	cc_op+1			; -print
cc_si	EQU	cc_pr+1			; -single
cc_sp	EQU	cc_si+1			; -space
cc_st	EQU	cc_sp+1			; -stitl
cc_ti	EQU	cc_st+1			; -title
cc_tr	EQU	cc_ti+1			; -trace
cc_nc	EQU	cc_tr+1			; number of control cards
ccnoc	EQU	4			; no. of chars included in match
ccofs	EQU	7			; offset to start of title/subtitle
.IF    .cinc
ccinm	EQU	9			; max depth of include file nesting
.FI
	EJC
;
;      definitions of stack offsets used in cmpil procedure
;
;      see description at start of cmpil procedure for details
;      of use of these locations on the stack.
;
cmstm	EQU	0			; tree for statement body
cmsgo	EQU	cmstm+1			; tree for success goto
cmfgo	EQU	cmsgo+1			; tree for fail goto
cmcgo	EQU	cmfgo+1			; conditional goto flag
cmpcd	EQU	cmcgo+1			; previous cdblk pointer
cmffp	EQU	cmpcd+1			; failure fill in flag for previous
cmffc	EQU	cmffp+1			; failure fill in flag for current
cmsop	EQU	cmffc+1			; success fill in offset for previous
cmsoc	EQU	cmsop+1			; success fill in offset for current
cmlbl	EQU	cmsoc+1			; ptr to vrblk for current label
cmtra	EQU	cmlbl+1			; ptr to entry cdblk
;
cmnen	EQU	cmtra+1			; count of stack entries for cmpil
.IF    .cnpf
.ELSE
;
;      a few constants used by the profiler
pfpd1	EQU	8			; pad positions ...
pfpd2	EQU	20			; ... for profile ...
pfpd3	EQU	32			; ... printout
pf_i2	EQU	cfp_i+cfp_i		; size of table entry (2 ints)
.FI
.IF    .crel
	EJC
;
;      definition of limits and adjustments that are built by
;      relcr for use by the routines that relocate pointers
;      after a save file is reloaded.  see reloc etc. for usage.
;
;      a block of information is built that is used in
;      relocating pointers.  there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;
;      each structure takes the form:
;
;	    +------------------------------------+
;	    i	 address past end of section	 i
;	    +------------------------------------+
;	    i  adjustment from old to new adrs	 i
;	    +------------------------------------+
;	    i	 address of start of section	 i
;	    +------------------------------------+
;
;      the instances are ordered thusly:
;
;	    +------------------------------------+
;	    i		dynamic storage		 i
;	    +------------------------------------+
;	    i		static storage		 i
;	    +------------------------------------+
;	    i	    working section globals	 i
;	    +------------------------------------+
;	    i	       constant section		 i
;	    +------------------------------------+
;	    i		 code section		 i
;	    +------------------------------------+
;
;      symbolic names for these locations as offsets from
;      the first entry are provided here.
;
;      definitions within a section
;
rlend	EQU	0			; end
rladj	EQU	rlend+1			; adjustment
rlstr	EQU	rladj+1			; start
rssi_	EQU	rlstr+1			; size of section
rnsi_	EQU	5			; number of structures
;
;      overall definitions of all structures
;
rldye	EQU	0			; dynamic region end
rldya	EQU	rldye+1			; dynamic region adjustment
rldys	EQU	rldya+1			; dynamic region start
rlste	EQU	rldys+1			; static region end
rlsta	EQU	rlste+1			; static region adjustment
rlsts	EQU	rlsta+1			; static region start
rlwke	EQU	rlsts+1			; working section globals end
rlwka	EQU	rlwke+1			; working section globals adjustment
rlwks	EQU	rlwka+1			; working section globals start
rlcne	EQU	rlwks+1			; constants section end
rlcna	EQU	rlcne+1			; constants section adjustment
rlcns	EQU	rlcna+1			; constants section start
rlcde	EQU	rlcns+1			; code section end
rlcda	EQU	rlcde+1			; code section adjustment
rlcds	EQU	rlcda+1			; code section start
rlsi_	EQU	rlcds+1			; number of fields in structure
.FI
;
	TTL	s p i t b o l -- constant section
;
;      this section consists entirely of assembled constants.
;
;      all label names are five letters. the order is
;      approximately alphabetical, but in some cases (always
;      documented), constants must be placed in some special
;      order which must not be disturbed.
;
;      it must also be remembered that there is a requirement
;      for no forward references which also disturbs the
;      alphabetical order in some cases.
;
	SEC				; start of constant section
;
;      start of constant section
;
c_aaa	DAC	0			; first location of constant section
;
;      free store percentage (used by alloc)
;
alfsp	DAC	e_fsp			; free store percentage
;
;      bit constants for general use
;
bits0	DBC	0			; all zero bits
bits1	DBC	1			; one bit in low order position
bits2	DBC	2			; bit in position 2
bits3	DBC	4			; bit in position 3
bits4	DBC	8			; bit in position 4
bits5	DBC	16			; bit in position 5
bits6	DBC	32			; bit in position 6
bits7	DBC	64			; bit in position 7
bits8	DBC	128			; bit in position 8
bits9	DBC	256			; bit in position 9
bit10	DBC	512			; bit in position 10
bit11	DBC	1024			; bit in position 11
bit12	DBC	2048			; bit in position 12
;bitsm	dbc  cfp_m	      mask for max integer
bitsm	DBC	0			; mask for max integer (value filled in at runtime)
;
;      bit constants for svblk (svbit field) tests
;
btfnc	DBC	svfnc			; bit to test for function
btknm	DBC	svknm			; bit to test for keyword number
btlbl	DBC	svlbl			; bit to test for label
btffc	DBC	svffc			; bit to test for fast call
btckw	DBC	svckw			; bit to test for constant keyword
btkwv	DBC	svkwv			; bits to test for keword with value
btprd	DBC	svprd			; bit to test for predicate function
btpre	DBC	svpre			; bit to test for preevaluation
btval	DBC	svval			; bit to test for value
	EJC
;
;      list of names used for control card processing
;
.IF    .culc
ccnms	DTC	/case/
	DTC	/doub/
.ELSE
ccnms	DTC	/doub/
.FI
.IF    .ccmk
	DTC	/comp/
.FI
	DTC	/dump/
.IF    .cinc
	DTC	/copy/
.FI
	DTC	/ejec/
	DTC	/erro/
	DTC	/exec/
	DTC	/fail/
.IF    .cinc
	DTC	/incl/
.FI
.IF    .csln
	DTC	/line/
.FI
	DTC	/list/
	DTC	/noer/
	DTC	/noex/
	DTC	/nofa/
	DTC	/noli/
	DTC	/noop/
	DTC	/nopr/
	DTC	/opti/
	DTC	/prin/
	DTC	/sing/
	DTC	/spac/
	DTC	/stit/
	DTC	/titl/
	DTC	/trac/
;
;      header messages for dumpr procedure (scblk format)
;
dmhdk	DAC	b_scl			; dump of keyword values
	DAC	22			;
	DTC	/dump of keyword values/
;
dmhdv	DAC	b_scl			; dump of natural vaRIAbles
	DAC	25			;
	DTC	/dump of natural vaRIAbles/
	EJC
;
;      message teXT for compilation statistics
;
encm1	DAC	b_scl			;
.IF    .cbyt
	DAC	19			;
	DTC	/memory used (bytes)/
;
encm2	DAC	b_scl			;
	DAC	19			;
	DTC	/memory left (bytes)/
.ELSE
	DAC	19			;
	DTC	/memory used (words)/
;
encm2	DAC	b_scl			;
	DAC	19			;
	DTC	/memory left (words)/
.FI
;
encm3	DAC	b_scl			;
	DAC	11			;
	DTC	/comp errors/
;
encm4	DAC	b_scl			;
.IF    .ctmd
	DAC	19			;
	DTC	/comp time (decisec)/
.ELSE
	DAC	20			;
	DTC	/comp time (millisec)/
.FI
;
encm5	DAC	b_scl			; execution suppressed
	DAC	20			;
	DTC	/execution suppressed/
;
;      string constant for abnormal end
;
endab	DAC	b_scl			;
	DAC	12			;
	DTC	/abnormal end/
	EJC
;
;      memory overflow during initialisation
;
endmo	DAC	b_scl			;
endml	DAC	15			;
	DTC	/memory overflow/
;
;      string constant for message issued by l_end
;
endms	DAC	b_scl			;
	DAC	10			;
	DTC	/normal end/
;
;      fail message for stack fail section
;
endso	DAC	b_scl			; stack overflow in garbage collector
	DAC	36			;
	DTC	/stack overflow in garbage collection/
;
;      string constant for time up
;
endtu	DAC	b_scl			;
	DAC	15			;
	DTC	/error - time up/
	EJC
;
;      string constant for error message (error section)
;
ermms	DAC	b_scl			; error
	DAC	5			;
	DTC	/error/
;
ermns	DAC	b_scl			; string / -- /
	DAC	4			;
	DTC	/ -- /
;
;      string constant for page numbering
;
lstms	DAC	b_scl			; page
	DAC	5			;
	DTC	/page /
;
;      listing header message
;
headr	DAC	b_scl			;
	DAC	27			;
	DTC	/macro spitbol version 15.01/
;
headv	DAC	b_scl			; for exit() version no. check
	DAC	5			;
	DTC	/15.01/
.IF    .csed
;      free store percentage (used by gbcol)
;
gbsdp	DAC	e_sed			; sediment percentage
.FI
;
;      integer constants for general use
;      icbld optimisation uses the first three.
;
int_r	DAC	b_icl			;
intv0	DIC	+0			; 0
inton	DAC	b_icl			;
intv1	DIC	+1			; 1
inttw	DAC	b_icl			;
intv2	DIC	+2			; 2
intvt	DIC	+10			; 10
intvh	DIC	+100			; 100
intth	DIC	+1000			; 1000
;
;      table used in icbld optimisation
;
intab	DAC	int_r			; pointer to 0
	DAC	inton			; pointer to 1
	DAC	inttw			; pointer to 2
	EJC
;
;      special pattern nodes. the following pattern nodes
;      consist simply of a pcode pointer, see match routines
;      (p_xxx) for full details of their use and format).
;
ndabb	DAC	p_abb			; arbno
ndabd	DAC	p_abd			; arbno
ndarc	DAC	p_arc			; arb
ndexb	DAC	p_exb			; expression
ndfnb	DAC	p_fnb			; fence()
ndfnd	DAC	p_fnd			; fence()
ndexc	DAC	p_exc			; expression
ndimb	DAC	p_imb			; immediate assignment
ndimd	DAC	p_imd			; immediate assignment
ndnth	DAC	p_nth			; pattern end (null pattern)
ndpab	DAC	p_pab			; pattern assignment
ndpad	DAC	p_pad			; pattern assignment
nduna	DAC	p_una			; anchor point movement
;
;      keyword constant pattern nodes. the following nodes are
;      used as the values of pattern keywords and the initial
;      values of the corresponding natural vaRIAbles. all
;      nodes are in p0blk format and the order is tied to the
;      definitions of corresponding k_xxx symbols.
;
ndabo	DAC	p_abo			; abort
	DAC	ndnth			;
ndarb	DAC	p_arb			; arb
	DAC	ndnth			;
ndbal	DAC	p_bal			; bal
	DAC	ndnth			;
ndfal	DAC	p_fal			; fail
	DAC	ndnth			;
ndfen	DAC	p_fen			; fence
	DAC	ndnth			;
ndrem	DAC	p_rem			; rem
	DAC	ndnth			;
ndsuc	DAC	p_suc			; succeed
	DAC	ndnth			;
;
;      null string. all null values point to this string. the
;      svchs field contains a blank to provide for easy default
;      processing in trace, stoptr, lpad and rpad.
;      nullw contains 10 blanks which ensures an all blank word
;      but for very exceptional machines.
;
nulls	DAC	b_scl			; null string value
	DAC	0			; sclen = 0
nullw	DTC	/          /
;
.IF    .culk
;
;      constant strings for lcase and ucase keywords
;
lcase	DAC	b_scl			;
	DAC	26			;
	DTC	/abcdefghijklmnopqrstuvwxyz/
;
ucase	DAC	b_scl			;
	DAC	26			;
	DTC	/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
.FI
	EJC
;
;      operator dope vectors (see dvblk format)
;
opdvc	DAC	o_cnc			; concatenation
	DAC	c_cnc			;
	DAC	llcnc			;
	DAC	rrcnc			;
;
;      opdvs is used when scanning below the top level to
;      insure that the concatenation will not be later
;      mistaken for pattern matching
;
opdvp	DAC	o_cnc			; concatenation - not pattern match
	DAC	c_cnp			;
	DAC	llcnc			;
	DAC	rrcnc			;
;
;      note that the order of the remaining entries is tied to
;      the order of the coding in the scane procedure.
;
opdvs	DAC	o_ass			; assignment
	DAC	c_ass			;
	DAC	llass			;
	DAC	rrass			;
;
	DAC	6			; unary equal
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	o_pmv			; pattern match
	DAC	c_pmt			;
	DAC	llpmt			;
	DAC	rrpmt			;
;
	DAC	o_int			; interrogation
	DAC	c_uvl			;
	DAC	lluno			;
;
	DAC	1			; binary ampersand
	DAC	c_ubo			;
	DAC	llamp			;
	DAC	rramp			;
;
	DAC	o_kwv			; keyword reference
	DAC	c_key			;
	DAC	lluno			;
;
	DAC	o_alt			; alternation
	DAC	c_alt			;
	DAC	llalt			;
	DAC	rralt			;
	EJC
;
;      operator dope vectors (continued)
;
	DAC	5			; unary vertical bar
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	0			; binary at
	DAC	c_ubo			;
	DAC	llats			;
	DAC	rrats			;
;
	DAC	o_cas			; cursor assignment
	DAC	c_unm			;
	DAC	lluno			;
;
	DAC	2			; binary number sign
	DAC	c_ubo			;
	DAC	llnum			;
	DAC	rrnum			;
;
	DAC	7			; unary number sign
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	o_dvd			; division
	DAC	c_bvl			;
	DAC	lldvd			;
	DAC	rrdvd			;
;
	DAC	9			; unary slash
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	o_mlt			; multiplication
	DAC	c_bvl			;
	DAC	llmlt			;
	DAC	rrmlt			;
	EJC
;
;      operator dope vectors (continued)
;
	DAC	0			; deferred expression
	DAC	c_def			;
	DAC	lluno			;
;
	DAC	3			; binary percent
	DAC	c_ubo			;
	DAC	llpct			;
	DAC	rrpct			;
;
	DAC	8			; unary percent
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	o_exp			; exponentiation
	DAC	c_bvl			;
	DAC	llexp			;
	DAC	rrexp			;
;
	DAC	10			; unary exclamation
	DAC	c_uuo			;
	DAC	lluno			;
;
	DAC	o_ima			; immediate assignment
	DAC	c_bvn			;
	DAC	lldld			;
	DAC	rrdld			;
;
	DAC	o_inv			; indirection
	DAC	c_ind			;
	DAC	lluno			;
;
	DAC	4			; binary not
	DAC	c_ubo			;
	DAC	llnot			;
	DAC	rrnot			;
;
	DAC	0			; negation
	DAC	c_neg			;
	DAC	lluno			;
	EJC
;
;      operator dope vectors (continued)
;
	DAC	o_sub			; subtraction
	DAC	c_bvl			;
	DAC	llplm			;
	DAC	rrplm			;
;
	DAC	o_com			; complementation
	DAC	c_uvl			;
	DAC	lluno			;
;
	DAC	o_add			; addition
	DAC	c_bvl			;
	DAC	llplm			;
	DAC	rrplm			;
;
	DAC	o_aff			; affirmation
	DAC	c_uvl			;
	DAC	lluno			;
;
	DAC	o_pas			; pattern assignment
	DAC	c_bvn			;
	DAC	lldld			;
	DAC	rrdld			;
;
	DAC	o_nam			; name reference
	DAC	c_unm			;
	DAC	lluno			;
;
;      special dvs for goto operators (see procedure scngf)
;
opdvd	DAC	o_god			; direct goto
	DAC	c_uvl			;
	DAC	lluno			;
;
opdvn	DAC	o_goc			; complex normal goto
	DAC	c_unm			;
	DAC	lluno			;
	EJC
;
;      operator entry address pointers, used in code
;
oamn_	DAC	o_amn			; array ref (multi-subs by value)
oamv_	DAC	o_amv			; array ref (multi-subs by value)
oaon_	DAC	o_aon			; array ref (one sub by name)
oaov_	DAC	o_aov			; array ref (one sub by value)
ocer_	DAC	o_cer			; compilation error
ofex_	DAC	o_fex			; failure in expression evaluation
ofif_	DAC	o_fif			; failure during goto evaluation
ofnc_	DAC	o_fnc			; function call (more than one arg)
ofne_	DAC	o_fne			; function name error
ofns_	DAC	o_fns			; function call (single argument)
ogof_	DAC	o_gof			; set goto failure trap
oinn_	DAC	o_inn			; indirection by name
okwn_	DAC	o_kwn			; keyword reference by name
olex_	DAC	o_lex			; load expression by name
olpt_	DAC	o_lpt			; load pattern
olvn_	DAC	o_lvn			; load vaRIAble name
onta_	DAC	o_nta			; negation, first entry
ontb_	DAC	o_ntb			; negation, second entry
ontc_	DAC	o_ntc			; negation, third entry
opmn_	DAC	o_pmn			; pattern match by name
opms_	DAC	o_pms			; pattern match (statement)
opop_	DAC	o_pop			; pop top stack item
ornm_	DAC	o_rnm			; return name from expression
orpl_	DAC	o_rpl			; pattern replacement
orvl_	DAC	o_rvl			; return value from expression
osla_	DAC	o_sla			; selection, first entry
oslb_	DAC	o_slb			; selection, second entry
oslc_	DAC	o_slc			; selection, third entry
osld_	DAC	o_sld			; selection, fourth entry
ostp_	DAC	o_stp			; stop execution
ounf_	DAC	o_unf			; unexpected failure
	EJC
;
;      table of names of undefined binary operators for opsyn
;
opsnb	DAC	ch_at			; at
	DAC	ch_am			; ampersand
	DAC	ch_nm			; number
	DAC	ch_pc			; percent
	DAC	ch_nt			; not
;
;      table of names of undefined unary operators for opsyn
;
opnsu	DAC	ch_br			; vertical bar
	DAC	ch_eq			; equal
	DAC	ch_nm			; number
	DAC	ch_pc			; percent
	DAC	ch_sl			; slash
	DAC	ch_ex			; exclamation
.IF    .cnpf
.ELSE
;
;      address const containing profile table entry size
;
pfi2a	DAC	pf_i2			;
;
;      profiler message strings
;
pfms1	DAC  b_scl
	DAC	15
	DTC	/program profile/
pfms2	DAC  b_scl
	DAC	42
	DTC	/stmt    number of     -- execution time --/
pfms3	DAC  b_scl
	DAC	47
	DTC	/number  executions  total(msec) per excn(mcsec)/
.FI
;
.IF    .cnra
.ELSE
;
;      real constants for general use. note that the constants
;      starting at reav1 form a powers of ten table (used in
;      gtnum and gtstg)
;
reav0	DRC	+0.0			; 0.0
.IF    .cncr
.ELSE
reap1	DRC	+0.1			; 0.1
reap5	DRC	+0.5			; 0.5
.FI
reav1	DRC	+1.0			; 10**0
reavt	DRC	+1.0e+1			; 10**1
	DRC	+1.0e+2			; 10**2
	DRC	+1.0e+3			; 10**3
	DRC	+1.0e+4			; 10**4
	DRC	+1.0e+5			; 10**5
	DRC	+1.0e+6			; 10**6
	DRC	+1.0e+7			; 10**7
	DRC	+1.0e+8			; 10**8
	DRC	+1.0e+9			; 10**9
reatt	DRC	+1.0e+10		; 10**10
.FI
	EJC
;
;      string constants (scblk format) for dtype procedure
;
scarr	DAC	b_scl			; array
	DAC	5			;
	DTC	/array/
.IF    .cnbf
.ELSE
;
scbuf	DAC	b_scl			; buffer
	DAC	6			;
	DTC	/buffer/
.FI
;
sccod	DAC	b_scl			; code
	DAC	4			;
	DTC	/code/
;
scexp	DAC	b_scl			; expression
	DAC	10			;
	DTC	/expression/
;
scext	DAC	b_scl			; eXTernal
	DAC	8			;
	DTC	/eXTernal/
;
scint	DAC	b_scl			; integer
	DAC	7			;
	DTC	/integer/
;
scnam	DAC	b_scl			; name
	DAC	4			;
	DTC	/name/
;
scnum	DAC	b_scl			; numeric
	DAC	7			;
	DTC	/numeric/
;
scpat	DAC	b_scl			; pattern
	DAC	7			;
	DTC	/pattern/
.IF    .cnra
.ELSE
;
screa	DAC	b_scl			; real
	DAC	4			;
	DTC	/real/
.FI
;
scstr	DAC	b_scl			; string
	DAC	6			;
	DTC	/string/
;
sctab	DAC	b_scl			; table
	DAC	5			;
	DTC	/table/
.IF    .cnlf
scfil	DAC	b_scl			; file (for eXTended load arguments)
	DAC	4			;
	DTC	/file/
.FI
	EJC
;
;      string constants (scblk format) for kvrtn (see retrn)
;
scfrt	DAC	b_scl			; freturn
	DAC	7			;
	DTC	/freturn/
;
scnrt	DAC	b_scl			; nreturn
	DAC	7			;
	DTC	/nreturn/
;
scrtn	DAC	b_scl			; return
	DAC	6			;
	DTC	/return/
;
;      datatype name table for dtype procedure. the order of
;      these entries is tied to the b_xxx definitions for blocks
;
;      note that slots for buffer and real data types are filled
;      even if these data types are conditionalized out of the
;      implementation.	this is done so that the block numbering
;      at bl_ar etc. remains constant in all versions.
;
scnmt	DAC	scarr			; arblk	    array
	DAC	sccod			; cdblk	    code
	DAC	scexp			; exblk	    expression
	DAC	scint			; icblk	    integer
	DAC	scnam			; nmblk	    name
	DAC	scpat			; p0blk	    pattern
	DAC	scpat			; p1blk	    pattern
	DAC	scpat			; p2blk	    pattern
.IF    .cnra
	DAC	nulls			; rcblk	    no real in this version
.ELSE

	DAC	screa			; rcblk	    real
.FI
	DAC	scstr			; scblk	    string
	DAC	scexp			; seblk	    expression
	DAC	sctab			; tbblk	    table
	DAC	scarr			; vcblk	    array
	DAC	scext			; xnblk	    eXTernal
	DAC	scext			; XRblk	    eXTernal
.IF    .cnbf
	DAC	nulls			; bfblk	    no buffer in this version
.ELSE
	DAC	scbuf			; bfblk	    buffer
.FI
;
.IF    .cnra
.ELSE
;      string constant for real zero
;
scre0	DAC	b_scl			;
	DAC	2			;
	DTC	/0./
.FI
	EJC
;
;      used to re-initialise kvstl
;
.IF    .cs16
stlim	DIC	+32767			; default statement limit
.ELSE
.IF    .cs32
stlim	DIC	+2147483647		; default statement limit
.ELSE
stlim	DIC	+50000			; default statement limit
.FI
.FI
;
;      dummy function block used for undefined functions
;
stndf	DAC	o_fun			; ptr to undefined function err call
	DAC	0			; dummy fargs count for call circuit
;
;      dummy code block used for undefined labels
;
stndl	DAC	l_und			; code ptr points to undefined lbl
;
;      dummy operator block used for undefined operators
;
stndo	DAC	o_oun			; ptr to undefined operator err call
	DAC	0			; dummy fargs count for call circuit
;
;      standard vaRIAble block. this block is used to initialize
;      the first seven fields of a newly constructed vrblk.
;      its format is tied to the vrblk definitions (see gtnvr).
;
stnvr	DAC	b_vrl			; vrget
	DAC	b_vrs			; vrsto
	DAC	nulls			; vrval
	DAC	b_vrg			; vrtra
	DAC	stndl			; vrlbl
	DAC	stndf			; vrfnc
	DAC	0			; vrnxt
	EJC
;
;      messages used in end of run processing (stopr)
;
stpm1	DAC	b_scl			; in statement
	DAC	12			;
	DTC	/in statement/
;
stpm2	DAC	b_scl			;
	DAC	14			;
	DTC	/stmts executed/
;
stpm3	DAC	b_scl			;
.IF    .ctmd
	DAC	18			;
	DTC	/run time (decisec)/
.ELSE
	DAC	19			;
	DTC	/run time (millisec)/
.FI
;
stpm4	DAC	b_scl			;
	DAC	12			;
	DTC	_mcsec / stmt_
;
stpm5	DAC	b_scl			;
	DAC	13			;
	DTC	/regenerations/
.IF    .csln
;
stpm6	DAC	b_scl			; in line
	DAC	7			;
	DTC	/in line/
.FI
.IF    .csfn
;
stpm7	DAC	b_scl			; in file
	DAC	7			;
	DTC	/in file/
.FI
;
;      chars for /tu/ ending code
;
strtu	DTC	/tu/
;
;      table used by convert function to check datatype name
;      the entries are ordered to correspond to branch table
;      in s_cnv
;
svctb	DAC	scstr			; string
	DAC	scint			; integer
	DAC	scnam			; name
	DAC	scpat			; pattern
	DAC	scarr			; array
	DAC	sctab			; table
	DAC	scexp			; expression
	DAC	sccod			; code
	DAC	scnum			; numeric
.IF    .cnra
.ELSE
	DAC	screa			; real
.FI
.IF    .cnbf
.ELSE
	DAC	scbuf			; buffer
.FI
	DAC	0			; zero marks end of list
	EJC
;
;      messages (scblk format) used by trace procedures
;
;
tmasb	DAC	b_scl			; asterisks for trace statement no
	DAC	13			;
	DTC	/************ /

;
tmbeb	DAC	b_scl			; blank-equal-blank
	DAC	3			;
	DTC	/ = /
;
;      dummy trblk for expression vaRIAble
;
trbev	DAC	b_trt			; dummy trblk
;
;      dummy trblk for keyword vaRIAble
;
trbkv	DAC	b_trt			; dummy trblk
;
;      dummy code block to return control to trxeq procedure
;
trxdr	DAC	o_txr			; block points to return routine
trxdc	DAC	trxdr			; pointer to block
	EJC
;
;      standard vaRIAble blocks
;
;      see svblk format for full details of the format. the
;      vrblks are ordered by length and within each length the
;      order is alphabetical by name of the vaRIAble.
;
v_eqf	DBC	svfpr			; eq
	DAC	2			;
	DTC	/eq/
	DAC	s_eqf			;
	DAC	2			;
;
v_gef	DBC	svfpr			; ge
	DAC	2			;
	DTC	/ge/
	DAC	s_gef			;
	DAC	2			;
;
v_gtf	DBC	svfpr			; gt
	DAC	2			;
	DTC	/gt/
	DAC	s_gtf			;
	DAC	2			;
;
v_lef	DBC	svfpr			; le
	DAC	2			;
	DTC	/le/
	DAC	s_lef			;
	DAC	2			;
.IF    .cmth
;
v_lnf	DBC	svfnp			; ln
	DAC	2			;
	DTC	/ln/
	DAC	s_lnf			;
	DAC	1			;
.FI
;
v_ltf	DBC	svfpr			; lt
	DAC	2			;
	DTC	/lt/
	DAC	s_ltf			;
	DAC	2			;
;
v_nef	DBC	svfpr			; ne
	DAC	2			;
	DTC	/ne/
	DAC	s_nef			;
	DAC	2			;
.IF    .c370
;
v_orf	DBC	svfnp			; or
	DAC	2			;
	DTC	/or/
	DAC	s_orf			;
	DAC	2			;
.FI
.IF    .c370
;
v_abs	DBC	svfnp			; abs
	DAC	3			;
	DTC	/abs/
	DAC	s_abs			;
	DAC	1			;
.FI
.IF    .c370
;
v_and	DBC	svfnp			; and
	DAC	3			;
	DTC	/and/
	DAC	s_and			;
	DAC	2			;
.FI
;
v_any	DBC	svfnp			; any
	DAC	3			;
	DTC	/any/
	DAC	s_any			;
	DAC	1			;
;
v_arb	DBC	svkvc			; arb
	DAC	3			;
	DTC	/arb/
	DAC	k_arb			;
	DAC	ndarb			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_arg	DBC	svfnn			; arg
	DAC	3			;
	DTC	/arg/
	DAC	s_arg			;
	DAC	2			;
;
v_bal	DBC	svkvc			; bal
	DAC	3			;
	DTC	/bal/
	DAC	k_bal			;
	DAC	ndbal			;
.IF    .cmth
;
v_cos	DBC	svfnp			; cos
	DAC	3			;
	DTC	/cos/
	DAC	s_cos			;
	DAC	1			;
.FI
;
v_end	DBC	svlbl			; end
	DAC	3			;
	DTC	/end/
	DAC	l_end			;
.IF    .cmth
;
v_exp	DBC	svfnp			; exp
	DAC	3			;
	DTC	/exp/
	DAC	s_exp			;
	DAC	1			;
.FI
;
v_len	DBC	svfnp			; len
	DAC	3			;
	DTC	/len/
	DAC	s_len			;
	DAC	1			;
;
v_leq	DBC	svfpr			; leq
	DAC	3			;
	DTC	/leq/
	DAC	s_leq			;
	DAC	2			;
;
v_lge	DBC	svfpr			; lge
	DAC	3			;
	DTC	/lge/
	DAC	s_lge			;
	DAC	2			;
;
v_lgt	DBC	svfpr			; lgt
	DAC	3			;
	DTC	/lgt/
	DAC	s_lgt			;
	DAC	2			;
;
v_lle	DBC	svfpr			; lle
	DAC	3			;
	DTC	/lle/
	DAC	s_lle			;
	DAC	2			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_llt	DBC	svfpr			; llt
	DAC	3			;
	DTC	/llt/
	DAC	s_llt			;
	DAC	2			;
;
v_lne	DBC	svfpr			; lne
	DAC	3			;
	DTC	/lne/
	DAC	s_lne			;
	DAC	2			;
;
v_pos	DBC	svfnp			; pos
	DAC	3			;
	DTC	/pos/
	DAC	s_pos			;
	DAC	1			;
;
v_rem	DBC	svkvc			; rem
	DAC	3			;
	DTC	/rem/
	DAC	k_rem			;
	DAC	ndrem			;
.IF    .cust
;
v_set	DBC	svfnn			; set
	DAC	3			;
	DTC	/set/
	DAC	s_set			;
	DAC	3			;
.FI
.IF    .cmth
;
v_sin	DBC	svfnp			; sin
	DAC	3			;
	DTC	/sin/
	DAC	s_sin			;
	DAC	1			;
.FI
;
v_tab	DBC	svfnp			; tab
	DAC	3			;
	DTC	/tab/
	DAC	s_tab			;
	DAC	1			;
.IF    .cmth
;
v_tan	DBC	svfnp			; tan
	DAC	3			;
	DTC	/tan/
	DAC	s_tan			;
	DAC	1			;
.FI
.IF    .c370
;
v_xor	DBC	svfnp			; xor
	DAC	3			;
	DTC	/xor/
	DAC	s_xor			;
	DAC	2			;
.FI
.IF    .cmth
;
v_atn	DBC	svfnp			; atan
	DAC	4			;
	DTC	/atan/
	DAC	s_atn			;
	DAC	1			;
.FI
.IF    .culc
;
v_cas	DBC	svknm			; case
	DAC	4			;
	DTC	/case/
	DAC	k_cas			;
.FI
;
v_chr	DBC	svfnp			; char
	DAC	4			;
	DTC	/char/
	DAC	s_chr			;
	DAC	1			;
;
.IF    .cmth
;
v_chp	DBC	svfnp			; chop
	DAC	4			;
	DTC	/chop/
	DAC	s_chp			;
	DAC	1			;
.FI
v_cod	DBC	svfnk			; code
	DAC	4			;
	DTC	/code/
	DAC	k_cod			;
	DAC	s_cod			;
	DAC	1			;
;
v_cop	DBC	svfnn			; copy
	DAC	4			;
	DTC	/copy/
	DAC	s_cop			;
	DAC	1			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_dat	DBC	svfnn			; data
	DAC	4			;
	DTC	/data/
	DAC	s_dat			;
	DAC	1			;
;
v_dte	DBC	svfnn			; date
	DAC	4			;
	DTC	/date/
	DAC	s_dte			;
	DAC	1			;
;
v_dmp	DBC	svfnk			; dump
	DAC	4			;
	DTC	/dump/
	DAC	k_dmp			;
	DAC	s_dmp			;
	DAC	1			;
;
v_dup	DBC	svfnn			; dupl
	DAC	4			;
	DTC	/dupl/
	DAC	s_dup			;
	DAC	2			;
;
v_evl	DBC	svfnn			; eval
	DAC	4			;
	DTC	/eval/
	DAC	s_evl			;
	DAC	1			;
.IF    .cnex
.ELSE
;
v_ext	DBC	svfnn			; exit
	DAC	4			;
	DTC	/exit/
	DAC	s_ext			;
	DAC	2			;
.FI
;
v_fal	DBC	svkvc			; fail
	DAC	4			;
	DTC	/fail/
	DAC	k_fal			;
	DAC	ndfal			;
;
.IF    .csfn
v_fil	DBC	svknm			; file
	DAC	4			;
	DTC	/file/
	DAC	k_fil			;
;
.FI
v_hst	DBC	svfnn			; host
	DAC	4			;
	DTC	/host/
	DAC	s_hst			;
	DAC	5			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_itm	DBC	svfnf			; item
	DAC	4			;
	DTC	/item/
	DAC	s_itm			;
	DAC	999			;
.IF    .csln
;
v_lin	DBC	svknm			; line
	DAC	4			;
	DTC	/line/
	DAC	k_lin			;
.FI
.IF    .cnld
.ELSE
;
v_lod	DBC	svfnn			; load
	DAC	4			;
	DTC	/load/
	DAC	s_lod			;
	DAC	2			;
.FI
;
v_lpd	DBC	svfnp			; lpad
	DAC	4			;
	DTC	/lpad/
	DAC	s_lpd			;
	DAC	3			;
;
v_rpd	DBC	svfnp			; rpad
	DAC	4			;
	DTC	/rpad/
	DAC	s_rpd			;
	DAC	3			;
;
v_rps	DBC	svfnp			; rpos
	DAC	4			;
	DTC	/rpos/
	DAC	s_rps			;
	DAC	1			;
;
v_rtb	DBC	svfnp			; rtab
	DAC	4			;
	DTC	/rtab/
	DAC	s_rtb			;
	DAC	1			;
;
v_si_	DBC	svfnp			; size
	DAC	4			;
	DTC	/size/
	DAC	s_si_			;
	DAC	1			;
;
.IF    .cnsr
.ELSE
;
v_srt	DBC	svfnn			; sort
	DAC	4			;
	DTC	/sort/
	DAC	s_srt			;
	DAC	2			;
.FI
v_spn	DBC	svfnp			; span
	DAC	4			;
	DTC	/span/
	DAC	s_spn			;
	DAC	1			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
.IF    .cmth
;
v_sqr	DBC	svfnp			; sqrt
	DAC	4			;
	DTC	/sqrt/
	DAC	s_sqr			;
	DAC	1			;
.FI
v_stn	DBC	svknm			; stno
	DAC	4			;
	DTC	/stno/
	DAC	k_stn			;
;
v_tim	DBC	svfnn			; time
	DAC	4			;
	DTC	/time/
	DAC	s_tim			;
	DAC	0			;
;
v_trm	DBC	svfnk			; trim
	DAC	4			;
	DTC	/trim/
	DAC	k_trm			;
	DAC	s_trm			;
	DAC	1			;
;
v_abe	DBC	svknm			; abend
	DAC	5			;
	DTC	/abend/
	DAC	k_abe			;
;
v_abo	DBC	svkvl			; abort
	DAC	5			;
	DTC	/abort/
	DAC	k_abo			;
	DAC	l_abo			;
	DAC	ndabo			;
;
v_app	DBC	svfnf			; apply
	DAC	5			;
	DTC	/apply/
	DAC	s_app			;
	DAC	999			;
;
v_abn	DBC	svfnp			; arbno
	DAC	5			;
	DTC	/arbno/
	DAC	s_abn			;
	DAC	1			;
;
v_arr	DBC	svfnn			; array
	DAC	5			;
	DTC	/array/
	DAC	s_arr			;
	DAC	2			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_brk	DBC	svfnp			; break
	DAC	5			;
	DTC	/break/
	DAC	s_brk			;
	DAC	1			;
;
v_clr	DBC	svfnn			; clear
	DAC	5			;
	DTC	/clear/
	DAC	s_clr			;
	DAC	1			;
.IF    .c370
;
v_cmp	DBC	svfnp			; compl
	DAC	5			;
	DTC	/compl/
	DAC	s_cmp			;
	DAC	1			;
.FI
;
v_ejc	DBC	svfnn			; eject
	DAC	5			;
	DTC	/eject/
	DAC	s_ejc			;
	DAC	1			;
;
v_fen	DBC	svfpk			; fence
	DAC	5			;
	DTC	/fence/
	DAC	k_fen			;
	DAC	s_fnc			;
	DAC	1			;
	DAC	ndfen			;
;
v_fld	DBC	svfnn			; field
	DAC	5			;
	DTC	/field/
	DAC	s_fld			;
	DAC	2			;
;
v_idn	DBC	svfpr			; ident
	DAC	5			;
	DTC	/ident/
	DAC	s_idn			;
	DAC	2			;
;
v_inp	DBC	svfnk			; input
	DAC	5			;
	DTC	/input/
	DAC	k_inp			;
	DAC	s_inp			;
	DAC	3			;
.IF    .culk
;
v_lcs	DBC	svkwc			; lcase
	DAC	5			;
	DTC	/lcase/
	DAC	k_lcs			;
.FI
;
v_loc	DBC	svfnn			; local
	DAC	5			;
	DTC	/local/
	DAC	s_loc			;
	DAC	2			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_ops	DBC	svfnn			; opsyn
	DAC	5			;
	DTC	/opsyn/
	DAC	s_ops			;
	DAC	3			;
;
v_rmd	DBC	svfnp			; remdr
	DAC	5			;
	DTC	/remdr/
	DAC	s_rmd			;
	DAC	2			;
.IF    .cnsr
.ELSE
;
v_rsr	DBC	svfnn			; rsort
	DAC	5			;
	DTC	/rsort/
	DAC	s_rsr			;
	DAC	2			;
.FI
;
v_tbl	DBC	svfnn			; table
	DAC	5			;
	DTC	/table/
	DAC	s_tbl			;
	DAC	3			;
;
v_tra	DBC	svfnk			; trace
	DAC	5			;
	DTC	/trace/
	DAC	k_tra			;
	DAC	s_tra			;
	DAC	4			;
.IF    .culk
;
v_ucs	DBC	svkwc			; ucase
	DAC	5			;
	DTC	/ucase/
	DAC	k_ucs			;
.FI
;
v_anc	DBC	svknm			; anchor
	DAC	6			;
	DTC	/anchor/
	DAC	k_anc			;
.IF    .cnbf
.ELSE
;
v_apn	DBC	svfnn			; append
	DAC	6			;
	DTC	/append/
	DAC	s_apn			;
	DAC	2			;
.FI
;
v_bkx	DBC	svfnp			; breakx
	DAC	6			;
	DTC	/breakx/
	DAC	s_bkx			;
	DAC	1			;
;
.IF    .cnbf
.ELSE
v_buf	DBC	svfnn			; buffer
	DAC	6			;
	DTC	/buffer/
	DAC	s_buf			;
	DAC	2			;
.FI
;
v_def	DBC	svfnn			; define
	DAC	6			;
	DTC	/define/
	DAC	s_def			;
	DAC	2			;
;
v_det	DBC	svfnn			; detach
	DAC	6			;
	DTC	/detach/
	DAC	s_det			;
	DAC	1			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_dif	DBC	svfpr			; differ
	DAC	6			;
	DTC	/differ/
	DAC	s_dif			;
	DAC	2			;
;
v_ftr	DBC	svknm			; ftrace
	DAC	6			;
	DTC	/ftrace/
	DAC	k_ftr			;
;
.IF    .cnbf
.ELSE
v_ins	DBC	svfnn			; insert
	DAC	6			;
	DTC	/insert/
	DAC	s_ins			;
	DAC	4			;
;
.FI
v_lst	DBC	svknm			; lastno
	DAC	6			;
	DTC	/lastno/
	DAC	k_lst			;
;
v_nay	DBC	svfnp			; notany
	DAC	6			;
	DTC	/notany/
	DAC	s_nay			;
	DAC	1			;
;
v_oup	DBC	svfnk			; output
	DAC	6			;
	DTC	/output/
	DAC	k_oup			;
	DAC	s_oup			;
	DAC	3			;
;
v_ret	DBC	svlbl			; return
	DAC	6			;
	DTC	/return/
	DAC	l_rtn			;
;
v_rew	DBC	svfnn			; rewind
	DAC	6			;
	DTC	/rewind/
	DAC	s_rew			;
	DAC	1			;
;
v_stt	DBC	svfnn			; stoptr
	DAC	6			;
	DTC	/stoptr/
	DAC	s_stt			;
	DAC	2			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_sub	DBC	svfnn			; substr
	DAC	6			;
	DTC	/substr/
	DAC	s_sub			;
	DAC	3			;
;
v_unl	DBC	svfnn			; unload
	DAC	6			;
	DTC	/unload/
	DAC	s_unl			;
	DAC	1			;
;
v_col	DBC	svfnn			; collect
	DAC	7			;
	DTC	/collect/
	DAC	s_col			;
	DAC	1			;
.IF    .ccmk
;
v_com	DBC	svknm			; compare
	DAC	7			;
	DTC	/compare/
	DAC	k_com			;
.FI
;
v_cnv	DBC	svfnn			; convert
	DAC	7			;
	DTC	/convert/
	DAC	s_cnv			;
	DAC	2			;
;
v_enf	DBC	svfnn			; endfile
	DAC	7			;
	DTC	/endfile/
	DAC	s_enf			;
	DAC	1			;
;
v_etx	DBC	svknm			; errteXT
	DAC	7			;
	DTC	/errtext/
	DAC	k_etx			;
;
v_ert	DBC	svknm			; errtype
	DAC	7			;
	DTC	/errtype/
	DAC	k_ert			;
;
v_frt	DBC	svlbl			; freturn
	DAC	7			;
	DTC	/freturn/
	DAC	l_frt			;
;
v_int	DBC	svfpr			; integer
	DAC	7			;
	DTC	/integer/
	DAC	s_int			;
	DAC	1			;
;
v_nrt	DBC	svlbl			; nreturn
	DAC	7			;
	DTC	/nreturn/
	DAC	l_nrt			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
.IF    .cnpf
.ELSE
;
v_pfl	DBC	svknm			; profile
	DAC	7			;
	DTC	/profile/
	DAC	k_pfl			;
.FI
;
v_rpl	DBC	svfnp			; replace
	DAC	7			;
	DTC	/replace/
	DAC	s_rpl			;
	DAC	3			;
;
v_rvs	DBC	svfnp			; reverse
	DAC	7			;
	DTC	/reverse/
	DAC	s_rvs			;
	DAC	1			;
;
v_rtn	DBC	svknm			; rtntype
	DAC	7			;
	DTC	/rtntype/
	DAC	k_rtn			;
;
v_stx	DBC	svfnn			; setexit
	DAC	7			;
	DTC	/setexit/
	DAC	s_stx			;
	DAC	1			;
;
v_stc	DBC	svknm			; stcount
	DAC	7			;
	DTC	/stcount/
	DAC	k_stc			;
;
v_stl	DBC	svknm			; stlimit
	DAC	7			;
	DTC	/stlimit/
	DAC	k_stl			;
;
v_suc	DBC	svkvc			; succeed
	DAC	7			;
	DTC	/succeed/
	DAC	k_suc			;
	DAC	ndsuc			;
;
v_alp	DBC	svkwc			; alphabet
	DAC	8			;
	DTC	/alphabet/
	DAC	k_alp			;
;
v_cnt	DBC	svlbl			; continue
	DAC	8			;
	DTC	/continue/
	DAC	l_cnt			;
	EJC
;
;      standard vaRIAble blocks (continued)
;
v_dtp	DBC	svfnp			; datatype
	DAC	8			;
	DTC	/datatype/
	DAC	s_dtp			;
	DAC	1			;
;
v_erl	DBC	svknm			; errlimit
	DAC	8			;
	DTC	/errlimit/
	DAC	k_erl			;
;
v_fnc	DBC	svknm			; fnclevel
	DAC	8			;
	DTC	/fnclevel/
	DAC	k_fnc			;
;
v_fls	DBC	svknm			; fullscan
	DAC	8			;
	DTC	/fullscan/
	DAC	k_fls			;
;
.IF    .csfn
v_lfl	DBC	svknm			; lastfile
	DAC	8			;
	DTC	/lastfile/
	DAC	k_lfl			;
;
.FI
.IF    .csln
v_lln	DBC	svknm			; lastline
	DAC	8			;
	DTC	/lastline/
	DAC	k_lln			;
;
.FI
v_mxl	DBC	svknm			; maXLngth
	DAC	8			;
	DTC	/maxlngth/
	DAC	k_mxl			;
;
v_ter	DBC	0			; terminal
	DAC	8			;
	DTC	/terminal/
	DAC	0			;
;
.IF    .cbsp
v_bsp	DBC	svfnn			; backspace
	DAC	9			;
	DTC	/backspace/
	DAC	s_bsp			;
	DAC	1			;
;
.FI
v_pro	DBC	svfnn			; prototype
	DAC	9			;
	DTC	/prototype/
	DAC	s_pro			;
	DAC	1			;
;
v_scn	DBC	svlbl			; scontinue
	DAC	9			;
	DTC	/scontinue/
	DAC	l_scn			;
;
	DBC	0			; dummy entry to end list
	DAC	10			; length gt 9 (scontinue)
	EJC
;
;      list of svblk pointers for keywords to be dumped. the
;      list is in the order which appears on the dump output.
;
vdmkw	DAC	v_anc			; anchor
.IF    .culc
	DAC	v_cas			; ccase
.FI
	DAC	v_cod			; code
.IF    .ccmk
.IF    .ccmc
	DAC	v_com			; compare
.ELSE
	DAC	1			; compare not printed
.FI
.FI
	DAC	v_dmp			; dump
	DAC	v_erl			; errlimit
	DAC	v_etx			; errteXT
	DAC	v_ert			; errtype
.IF    .csfn
	DAC	v_fil			; file
.FI
	DAC	v_fnc			; fnclevel
	DAC	v_ftr			; ftrace
	DAC	v_fls			; fullscan
	DAC	v_inp			; input
.IF    .csfn
	DAC	v_lfl			; lastfile
.FI
.IF    .csln
	DAC	v_lln			; lastline
.FI
	DAC	v_lst			; lastno
.IF    .csln
	DAC	v_lin			; line
.FI
	DAC	v_mxl			; maXLength
	DAC	v_oup			; output
.IF    .cnpf
.ELSE
	DAC	v_pfl			; profile
.FI
	DAC	v_rtn			; rtntype
	DAC	v_stc			; stcount
	DAC	v_stl			; stlimit
	DAC	v_stn			; stno
	DAC	v_tra			; trace
	DAC	v_trm			; trim
	DAC	0			; end of list
;
;      table used by gtnvr to search svblk lists
;
vsrch	DAC	0			; dummy entry to get proper indexing
	DAC	v_eqf			; start of 1 char vaRIAbles (none)
	DAC	v_eqf			; start of 2 char vaRIAbles
	DAC	v_any			; start of 3 char vaRIAbles
.IF    .cmth
	DAC	v_atn			; start of 4 char vaRIAbles
.ELSE
.IF    .culc
	DAC	v_cas			; start of 4 char vaRIAbles
.ELSE
	DAC	v_chr			; start of 4 char vaRIAbles
.FI
.FI
	DAC	v_abe			; start of 5 char vaRIAbles
	DAC	v_anc			; start of 6 char vaRIAbles
	DAC	v_col			; start of 7 char vaRIAbles
	DAC	v_alp			; start of 8 char vaRIAbles
.IF    .cbsp
	DAC	v_bsp			; start of 9 char vaRIAbles
.ELSE
	DAC	v_pro			; start of 9 char vaRIAbles
.FI
;
;      last location in constant section
;
c_yyy	DAC	0			; last location in constant section
	TTL	s p i t b o l -- working storage section
;
;      the working storage section contains areas which are
;      changed during execution of the program. the value
;      assembled is the initial value before execution starts.
;
;      all these areas are fixed length areas. vaRIAble length
;      data is stored in the static or dynamic regions of the
;      allocated data areas.
;
;      the values in this area are described either as work
;      areas or as global values. a work area is used in an
;      ephemeral manner and the value is not saved from one
;      entry into a routine to another. a global value is a
;      less temporary location whose value is saved from one
;      call to another.
;
;      w_aaa marks the start of the working section whilst
;      w_yyy marks its end.  g_aaa marks the division between
;      temporary and global values.
;
;      global values are further subdivided to facilitate
;      processing by the garbage collector. r_aaa through
;      r_yyy are global values that may point into dynamic
;      storage and hence must be relocated after each garbage
;      collection.  they also serve as root pointers to all
;      allocated data that must be preserved.  pointers between
;      a_aaa and r_aaa may point into code, static storage,
;      or mark the limits of dynamic memory.  these pointers
;      must be adjusted when the working section is saved to a
;      file and subsequently reloaded at a different address.
;
;      a general part of the approach in this program is not
;      to overlap work areas between procedures even though a
;      small amount of space could be saved. such overlap is
;      considered a source of program errors and decreases the
;      information left behind after a system crash of any kind.
;
;      the names of these locations are labels with five letter
;      (a-y,_) names. as far as possible the order is kept
;      alphabetical by these names but in some cases there
;      are slight departures caused by other order requirements.
;
;      unless otherwise documented, the order of work areas
;      does not affect the execution of the spitbol program.
;
	SEC				; start of working storage section
	EJC
;
;      this area is not cleared by initial code
;
cmlab	DAC	b_scl			; string used to check label legality
	DAC	2			;
	DTC	/  /
;
;      label to mark start of work area
;
w_aaa	DAC	0			;
;
;      work areas for acess procedure
;
actrm	DAC	0			; trim indicator
;
;      work areas for alloc procedure
;
aldyn	DAC	0			; amount of dynamic store
allia	DIC	+0			; dump ia
allsv	DAC	0			; save WB in alloc
;
;      work areas for alost procedure
;
alsta	DAC	0			; save WA in alost
;
;      work areas for array function (s_arr)
;
arcdm	DAC	0			; count dimensions
arnel	DIC	+0			; count elements
arptr	DAC	0			; offset ptr into arblk
arsvl	DIC	+0			; save integer low bound
	EJC
;
;      work areas for arref routine
;
arfsi	DIC	+0			; save current evolving subscript
arfxs	DAC	0			; save base stack pointer
;
;      work areas for b_efc block routine
;
befof	DAC	0			; save offset ptr into efblk
;
;      work areas for b_pfc block routine
;
bpfpf	DAC	0			; save pfblk pointer
bpfsv	DAC	0			; save old function value
bpfxt	DAC	0			; pointer to stacked arguments
;
;      work area for collect function (s_col)
;
clsvi	DIC	+0			; save integer argument
;
;      work areas value for cncrd
;
cnscc	DAC	0			; pointer to control card string
cnswc	DAC	0			; word count
cnr_t	DAC	0			; pointer to r_ttl or r_stl
;
;      work areas for convert function (s_cnv)
;
cnvtp	DAC	0			; save ptr into scvtb
;
;      work areas for data function (s_dat)
;
datdv	DAC	0			; save vrblk ptr for datatype name
datxs	DAC	0			; save initial stack pointer
;
;      work areas for define function (s_def)
;
deflb	DAC	0			; save vrblk ptr for label
defna	DAC	0			; count function arguments
defvr	DAC	0			; save vrblk ptr for function name
defxs	DAC	0			; save initial stack pointer
;
;      work areas for dumpr procedure
;
dmarg	DAC	0			; dump argument
dmpsa	DAC	0			; preserve WA over prtvl call
.IF    .ccmk
dmpsb	DAC	0			; preserve WB over syscm call
.FI
dmpsv	DAC	0			; general scratch save
dmvch	DAC	0			; chain pointer for vaRIAble blocks
dmpch	DAC	0			; save sorted vrblk chain pointer
dmpkb	DAC	0			; dummy kvblk for use in dumpr
dmpkt	DAC	0			; kvvar trblk ptr (must follow dmpkb)
dmpkn	DAC	0			; keyword number (must follow dmpkt)
;
;      work area for dtach
;
dtcnb	DAC	0			; name base
dtcnm	DAC	0			; name ptr
;
;      work areas for dupl function (s_dup)
;
dupsi	DIC	+0			; store integer string length
;
;      work area for endfile (s_enf)
;
enfch	DAC	0			; for iochn chain head
	EJC
;
;      work areas for ertex
;
ertwa	DAC	0			; save WA
ertwb	DAC	0			; save WB
;
;      work areas for evali
;
evlin	DAC	0			; dummy pattern block pcode
evlis	DAC	0			; then node (must follow evlin)
evliv	DAC	0			; value of parm1 (must follow evlis)
evlio	DAC	0			; ptr to original node
evlif	DAC	0			; flag for simple/complex argument
;
;      work area for expan
;
expsv	DAC	0			; save op dope vector pointer
;
;      work areas for gbcol procedure
;
gbcfl	DAC	0			; garbage collector active flag
gbclm	DAC	0			; pointer to last move block (pass 3)
gbcnm	DAC	0			; dummy first move block
gbcns	DAC	0			; rest of dummy block (follows gbcnm)
.IF    .csed
.IF    .cepp
.ELSE
gbcmk	DAC	0			; bias when marking entry point
.FI
gbcia	DIC	+0			; dump IA
gbcsd	DAC	0			; first address beyond sediment
gbcsf	DAC	0			; free space within sediment
.FI
gbsva	DAC	0			; save WA
gbsvb	DAC	0			; save WB
gbsvc	DAC	0			; save WC
;
;      work areas for gtnvr procedure
;
gnvhe	DAC	0			; ptr to end of hash chain
gnvnw	DAC	0			; number of words in string name
gnvsa	DAC	0			; save WA
gnvsb	DAC	0			; save WB
gnvsp	DAC	0			; pointer into vsrch table
gnvst	DAC	0			; pointer to chars of string
;
;      work areas for gtarr
;
gtawa	DAC	0			; save WA
;
;      work areas for gtint
;
gtina	DAC	0			; save WA
gtinb	DAC	0			; save WB
	EJC
;
;      work areas for gtnum procedure
;
gtnnf	DAC	0			; zero/nonzero for result +/-
gtnsi	DIC	+0			; general integer save
.IF    .cnra
.ELSE
gtndf	DAC	0			; 0/1 for dec point so far no/yes
gtnes	DAC	0			; zero/nonzero exponent +/-
gtnex	DIC	+0			; real exponent
gtnsc	DAC	0			; scale (places after point)
gtnsr	DRC	+0.0			; general real save
gtnrd	DAC	0			; flag for ok real number
.FI
;
;      work areas for gtpat procedure
;
gtpsb	DAC	0			; save WB
;
;      work areas for gtstg procedure
;
gtssf	DAC	0			; 0/1 for result +/-
gtsvc	DAC	0			; save WC
gtsvb	DAC	0			; save WB
.IF    .cnra
.ELSE
.IF    .cncr
.ELSE
gtses	DAC	0			; char + or - for exponent +/-
gtsrs	DRC	+0.0			; general real save
.FI
.FI
;
;      work areas for gtvar procedure
;
gtvrc	DAC	0			; save WC
.IF    .cnbf
.ELSE
;
;      work areas for insbf
;
insab	DAC	0			; entry WA + entry WB
insln	DAC	0			; length of insertion string
inssa	DAC	0			; save entry WA
inssb	DAC	0			; save entry WB
inssc	DAC	0			; save entry WC
.FI
;
;      work areas for ioput
;
ioptt	DAC	0			; type of association
.IF    .cnld
.ELSE
;
;      work areas for load function
;
lodfn	DAC	0			; pointer to vrblk for func name
lodna	DAC	0			; count number of arguments
.FI
;
;      mxint is value of maximum positive integer. it is computed at runtime to allow
;      the compilation of spitbol on a machine with smaller word size the the target.
;
mxint	DAC	0			;
.IF    .cnpf
.ELSE
;
;      work area for profiler
;
pfsvw	DAC	0			; to save a w-reg
.FI
;
;      work areas for prtnm procedure
;
prnsi	DIC	+0			; scratch integer loc
;
;      work areas for prtsn procedure
;
prsna	DAC	0			; save WA
;
;      work areas for prtst procedure
;
prsva	DAC	0			; save WA
prsvb	DAC	0			; save WB
prsvc	DAC	0			; save char counter
;
;      work area for prtnl
;
prtsa	DAC	0			; save WA
prtsb	DAC	0			; save WB
;
;      work area for prtvl
;
prvsi	DAC	0			; save idval
;
;      work areas for pattern match routines
;
psave	DAC	0			; temporary save for current node ptr
psavc	DAC	0			; save cursor in p_spn, p_str
.IF    .crel
;
;      work area for relaj routine
;
rlals	DAC	0			; ptr to list of bounds and adjusts
;
;      work area for reldn routine
;
rldcd	DAC	0			; save code adjustment
rldst	DAC	0			; save static adjustment
rldls	DAC	0			; save list pointer
.FI
;
;      work areas for retrn routine
;
rtnbp	DAC	0			; to save a block pointer
rtnfv	DAC	0			; new function value (result)
rtnsv	DAC	0			; old function value (saved value)
;
;      work areas for substr function (s_sub)
;
sbssv	DAC	0			; save third argument
;
;      work areas for scan procedure
;
scnsa	DAC	0			; save WA
scnsb	DAC	0			; save WB
scnsc	DAC	0			; save WC
scnof	DAC	0			; save offset
.IF    .cnsr
.ELSE
	EJC
;
;      work area used by sorta, sortc, sortf, sorth
;
srtdf	DAC	0			; datatype field name
srtfd	DAC	0			; found dfblk address
srtff	DAC	0			; found field name
srtfo	DAC	0			; offset to field name
srtnr	DAC	0			; number of rows
srtof	DAC	0			; offset within row to sort key
srtrt	DAC	0			; root offset
srts1	DAC	0			; save offset 1
srts2	DAC	0			; save offset 2
srtsc	DAC	0			; save WC
srtsf	DAC	0			; sort array first row offset
srtsn	DAC	0			; save n
srtso	DAC	0			; offset to a(0)
srtsr	DAC	0			; 0, non-zero for sort, rsort
srtst	DAC	0			; stride from one row to next
srtwc	DAC	0			; dump WC
.FI
;
;      work areas for stopr routine
;
stpsi	DIC	+0			; save value of stcount
stpti	DIC	+0			; save time elapsed
;
;      work areas for tfind procedure
;
tfnsi	DIC	+0			; number of headers
;
;      work areas for XScan procedure
;
xscrt	DAC	0			; save return code
xscwb	DAC	0			; save register WB
;
;      start of global values in working section
;
g_aaa	DAC	0			;
;
;      global value for alloc procedure
;
alfsf	DIC	+0			; factor in free store pcntage check
;
;      global values for cmpil procedure
;
cmerc	DAC	0			; count of initial compile errors
cmpln	DAC	0			; line number of first line of stmt
cmpxs	DAC	0			; save stack ptr in case of errors
cmpsn	DAC	1			; number of next statement to compile
;
;      global values for cncrd
;
.IF    .cinc
cnsil	DAC	0			; save scnil during include process.
cnind	DAC	0			; current include file nest level
cnspt	DAC	0			; save scnpt during include process.
.FI
cnttl	DAC	0			; flag for -title, -stitl
;
;      global flag for suppression of compilation statistics.
;
cpsts	DAC	0			; suppress comp. stats if non zero
;
;      global values for control card switches
;
cswdb	DAC	0			; 0/1 for -single/-double
cswer	DAC	0			; 0/1 for -errors/-noerrors
cswex	DAC	0			; 0/1 for -execute/-noexecute
cswfl	DAC	1			; 0/1 for -nofail/-fail
cswin	DAC	iniln			; xxx for -inxxx
cswls	DAC	1			; 0/1 for -nolist/-list
cswno	DAC	0			; 0/1 for -optimise/-noopt
cswpr	DAC	0			; 0/1 for -noprint/-print
;
;      global location used by patst procedure
;
ctmsk	DBC	0			; last bit position used in r_ctp
curid	DAC	0			; current id value
	EJC
;
;      global value for cdwrd procedure
;
cwcof	DAC	0			; next word offset in current ccblk
.IF    .csed
;
;      global locations for dynamic storage pointers
;
dnams	DAC	0			; size of sediment in baus
.FI
;
;      global area for error processing.
;
erich	DAC	0			; copy error reports to int.chan if 1
erlst	DAC	0			; for listr when errors go to int.ch.
errft	DAC	0			; fatal error flag
errsp	DAC	0			; error suppression flag
;
;      global flag for suppression of execution stats
;
exsts	DAC	0			; suppress exec stats if set
;
;      global values for exfal and return
;
flprt	DAC	0			; location of fail offset for return
flptr	DAC	0			; location of failure offset on stack
;
;      global location to count garbage collections (gbcol)
;
.IF    .csed
gbsed	DIC	+0			; factor in sediment pcntage check
.FI
gbcnt	DAC	0			; count of garbage collections
;
;      global value for gtcod and gtexp
;
gtcef	DAC	0			; save fail ptr in case of error
;
;      global locations for gtstg procedure
;
.IF    .cnra
.ELSE
.IF    .cncr
.ELSE
gtsrn	DRC	+0.0			; rounding factor 0.5*10**-cfp_s
gtssc	DRC	+0.0			; scaling value 10**cfp_s
.FI
.FI
gtswk	DAC	0			; ptr to work area for gtstg
;
;      global flag for header printing
;
headp	DAC	0			; header printed flag
;
;      global values for vaRIAble hash table
;
hshnb	DIC	+0			; number of hash buckets
;
;      global areas for init
;
initr	DAC	0			; save terminal flag
	EJC
;
;      global values for keyword values which are stored as one
;      word integers. these values must be assembled in the
;      following order (as dictated by k_xxx definition values).
;
kvabe	DAC	0			; abend
kvanc	DAC	0			; anchor
.IF    .culc
kvcas	DAC	0			; case
.FI
kvcod	DAC	0			; code
.IF    .ccmk
kvcom	DAC	0			; compare
.FI
kvdmp	DAC	0			; dump
kverl	DAC	0			; errlimit
kvert	DAC	0			; errtype
kvftr	DAC	0			; ftrace
kvfls	DAC	1			; fullscan
kvinp	DAC	1			; input
kvmxl	DAC	5000			; maXLength
kvoup	DAC	1			; output
.IF    .cnpf
.ELSE
kvpfl	DAC	0			; profile
.FI
kvtra	DAC	0			; trace
kvtrm	DAC	0			; trim
kvfnc	DAC	0			; fnclevel
kvlst	DAC	0			; lastno
.IF    .csln
kvlln	DAC	0			; lastline
kvlin	DAC	0			; line
.FI
kvstn	DAC	0			; stno
;
;      global values for other keywords
;
kvalp	DAC	0			; alphabet
kvrtn	DAC	nulls			; rtntype (scblk pointer)
.IF    .cs16
kvstl	DIC	+32767			; stlimit
kvstc	DIC	+32767			; stcount (counts down from stlimit)
.ELSE
.IF    .cs32
kvstl	DIC	+2147483647		; stlimit
kvstc	DIC	+2147483647		; stcount (counts down from stlimit)
.ELSE
kvstl	DIC	+50000			; stlimit
kvstc	DIC	+50000			; stcount (counts down from stlimit)
.FI
.FI
;
;      global values for listr procedure
;
.IF    .cinc
lstid	DAC	0			; include depth of current image
.FI
lstlc	DAC	0			; count lines on source list page
lstnp	DAC	0			; max number of lines on page
lstpf	DAC	1			; set nonzero if current image listed
lstpg	DAC	0			; current source list page number
lstpo	DAC	0			; offset to   page nnn	 message
lstsn	DAC	0			; remember last stmnum listed
;
;      global maximum size of spitbol objects
;
mxlen	DAC	0			; initialised by sysmx call
;
;      global execution control vaRIAble
;
noxeq	DAC	0			; set non-zero to inhibit execution
.IF    .cnpf
.ELSE
;
;      global profiler values locations
;
pfdmp	DAC	0			; set non-0 if &profile set non-0
pffnc	DAC	0			; set non-0 if funct just entered
pfstm	DIC	+0			; to store starting time of stmt
pfetm	DIC	+0			; to store ending time of stmt
pfnte	DAC	0			; nr of table entries
pfste	DIC	+0			; gets int rep of table entry size
.FI
;
	EJC
;
;      global values used in pattern match routines
;
pmdfl	DAC	0			; pattern assignment flag
pmhbs	DAC	0			; history stack base pointer
pmssl	DAC	0			; length of subject string in chars
.IF    .cpol
;
;      global values for interface polling (syspl)
;
polcs	DAC	1			; poll interval start value
polct	DAC	1			; poll interval counter
.FI
;
;      global flags used for standard file listing options
;
prich	DAC	0			; printer on interactive channel
prstd	DAC	0			; tested by prtpg
prsto	DAC	0			; standard listing option flag
;
;      global values for print procedures
;
prbuf	DAC	0			; ptr to print bfr in static
precl	DAC	0			; eXTended/compact listing flag
prlen	DAC	0			; length of print buffer in chars
prlnw	DAC	0			; length of print buffer in words
profs	DAC	0			; offset to next location in prbuf
prtef	DAC	0			; endfile flag
	EJC
;
;      global area for readr
;
rdcln	DAC	0			; current statement line number
rdnln	DAC	0			; next statement line number
;
;      global amount of memory reserved for end of execution
;
rsmem	DAC	0			; reserve memory
;
;      global area for stmgo counters
;
stmcs	DAC	1			; counter startup value
stmct	DAC	1			; counter active value
;
;      adjustable global values
;
;      all the pointers in this section can point to the
;      dynamic or the static region.
;      when a save file is reloaded, these pointers must
;      be adjusted if static or dynamic memory is now
;      at a different address.	see routine reloc for
;      additional information.
;
;      some values cannot be move here because of adjacency
;      constraints.  they are handled specially by reloc et al.
;      these values are kvrtn,
;
;      values gtswk, kvalp, and prbuf are reinitialized by
;      procedure insta, and do not need to appear here.
;
;      values flprt, flptr, gtcef, and stbas point into the
;      stack and are explicitly adjusted by osint's restart
;      procedure.
;
a_aaa	DAC	0			; start of adjustable values
cmpss	DAC	0			; save subroutine stack ptr
dnamb	DAC	0			; start of dynamic area
dnamp	DAC	0			; next available loc in dynamic area
dname	DAC	0			; end of available dynamic area
hshtb	DAC	0			; pointer to start of vrblk hash tabl
hshte	DAC	0			; pointer past end of vrblk hash tabl
iniss	DAC	0			; save subroutine stack ptr
pftbl	DAC	0			; gets adrs of (imag) table base
prnmv	DAC	0			; vrblk ptr from last name search
statb	DAC	0			; start of static area
state	DAC	0			; end of static area
stxvr	DAC	nulls			; vrblk pointer or null

;
;      relocatable global values
;
;      all the pointers in this section can point to blocks in
;      the dynamic storage area and must be relocated by the
;      garbage collector. they are identified by r_xxx names.
;
r_aaa	DAC	0			; start of relocatable values
r_arf	DAC	0			; array block pointer for arref
r_ccb	DAC	0			; ptr to ccblk being built (cdwrd)
r_cim	DAC	0			; ptr to current compiler input str
r_cmp	DAC	0			; copy of r_cim used in cmpil
r_cni	DAC	0			; ptr to next compiler input string
r_cnt	DAC	0			; cdblk pointer for setexit continue
r_cod	DAC	0			; pointer to current cdblk or exblk
r_ctp	DAC	0			; ptr to current ctblk for patst
r_cts	DAC	0			; ptr to last string scanned by patst
r_ert	DAC	0			; trblk pointer for errtype trace
r_etx	DAC	nulls			; pointer to errteXT string
r_exs	DAC	0			; = save XL in expdm
r_fcb	DAC	0			; fcblk chain head
r_fnc	DAC	0			; trblk pointer for fnclevel trace
r_gtc	DAC	0			; keep code ptr for gtcod,gtexp
.IF    .cinc
r_ici	DAC	0			; saved r_cim during include process.
.IF    .csfn
r_ifa	DAC	0			; array of file names by incl. depth
r_ifl	DAC	0			; array of line nums by include depth
.FI
r_ifn	DAC	0			; last include file name
r_inc	DAC	0			; table of include file names seen
.FI
r_io1	DAC	0			; file arg1 for ioput
r_io2	DAC	0			; file arg2 for ioput
r_iof	DAC	0			; fcblk ptr or 0
r_ion	DAC	0			; name base ptr
r_iop	DAC	0			; predecessor block ptr for ioput
r_iot	DAC	0			; trblk ptr for ioput
.IF    .cnbf
.ELSE
r_pmb	DAC	0			; buffer ptr in pattern match
.FI
r_pms	DAC	0			; subject string ptr in pattern match
r_ra2	DAC	0			; replace second argument last time
r_ra3	DAC	0			; replace third argument last time
r_rpt	DAC	0			; ptr to ctblk replace table last usd
r_scp	DAC	0			; save pointer from last scane call
.IF    .csfn
r_sfc	DAC	nulls			; current source file name
r_sfn	DAC	0			; ptr to source file name table
.FI
r_sXL	DAC	0			; preserve XL in sortc
r_sxr	DAC	0			; preserve XR in sorta/sortc
r_stc	DAC	0			; trblk pointer for stcount trace
r_stl	DAC	0			; source listing sub-title
r_sxc	DAC	0			; code (cdblk) ptr for setexit trap
r_ttl	DAC	nulls			; source listing title
r_xsc	DAC	0			; string pointer for XScan
	EJC
;
;      the remaining pointers in this list are used to point
;      to function blocks for normally undefined operators.
;
r_uba	DAC	stndo			; binary at
r_ubm	DAC	stndo			; binary ampersand
r_ubn	DAC	stndo			; binary number sign
r_ubp	DAC	stndo			; binary percent
r_ubt	DAC	stndo			; binary not
r_uub	DAC	stndo			; unary vertical bar
r_uue	DAC	stndo			; unary equal
r_uun	DAC	stndo			; unary number sign
r_uup	DAC	stndo			; unary percent
r_uus	DAC	stndo			; unary slash
r_uux	DAC	stndo			; unary exclamation
r_yyy	DAC	0			; last relocatable location
;
;      global locations used in scan procedure
;
scnbl	DAC	0			; set non-zero if scanned past blanks
scncc	DAC	0			; non-zero to scan control card name
scngo	DAC	0			; set non-zero to scan goto field
scnil	DAC	0			; length of current input image
scnpt	DAC	0			; pointer to next location in r_cim
scnrs	DAC	0			; set non-zero to signal rescan
scnse	DAC	0			; start of current element
scntp	DAC	0			; save syntax type from last call
;
;      global value for indicating stage (see error section)
;
stage	DAC	0			; initial value = initial compile
	EJC
;
;      global stack pointer
;
stbas	DAC	0			; pointer past stack base
;
;      global values for setexit function (s_stx)
;
stxoc	DAC	0			; code pointer offset
stxof	DAC	0			; failure offset
;
;      global value for time keeping
;
timsx	DIC	+0			; time at start of execution
timup	DAC	0			; set when time up occurs
;
;      global values for XScan and XScni procedures
;
xsofs	DAC	0			; offset to current location in r_xsc
;
;      label to mark end of working section
;
w_yyy	DAC	0			;
	TTL	s p i t b o l -- minimal code
	SEC				; start of program section
s_aaa	ENT	bl__i			; mark start of code
.IF    .crel
	TTL	s p i t b o l -- relocation
;
;      relocation
;      the following section provides services to osint to
;      relocate portions of the workspace.  it is used when
;      a saved memory image must be restarted at a different
;      location.
;
;      relaj -- relocate a list of pointers
;
;      (WA)		     ptr past last pointer of list
;      (WB)		     ptr to first pointer of list
;      (XL)		     list of boundaries and adjustments
;      jsr  relaj	     call to process list of pointers
;      (WB)		     destroyed
;
relaj	PRC	e,0			; entry point
	MOV	-(XS),XR		; save XR
	MOV	-(XS),WA		; save WA
	MOV	rlals,XL		; save ptr to list of bounds
	MOV	XR,WB			; ptr to first pointer to process
;
;      merge here to check if done
;
rlaj0	MOV	XL,rlals		; restore XL
	BNE	XR,(XS),rlaj1		; proceed if more to do
	MOV	WA,(XS)+		; restore WA
	MOV	XR,(XS)+		; restore XR
	EXI				; return to caller
;
;      merge here to process next pointer on list
;
rlaj1	MOV	WA,(XR)			; load next pointer on list
	LCT	WB,=rnsi_		; number of sections of adjusters
;
;      merge here to process next section of stack list
;
rlaj2	BGT	WA,rlend(XL),rlaj3	; ok if past end of section
	BLT	WA,rlstr(XL),rlaj3	; or if before start of section
	ADD	WA,rladj(XL)		; within section, add adjustment
	MOV	(XR),WA			; return updated ptr to memory
	BRN	rlaj4			; done with this pointer
;
;      here if not within section
;
rlaj3	ADD	XL,*rssi_		; advance to next section
	BCT	WB,rlaj2		; jump if more to go
;
;      here when finished processing one pointer
;
rlaj4	ICA	XR			; increment to next ptr on list
	BRN	rlaj0			; jump to check	 for completion
	ENP				; end procedure relaj
	EJC
;
;      relcr -- create relocation info after save file reload
;
;      (WA)		     original s_aaa code section adr
;      (WB)		     original c_aaa constant section adr
;      (WC)		     original g_aaa working section adr
;      (XR)		     ptr to start of static region
;      (CP)		     ptr to start of dynamic region
;      (XL)		     ptr to area to receive information
;      jsr  relcr	     create relocation information
;      (WA,WB,WC,XR)	     destroyed
;
;      a block of information is built at (XL) that is used
;      in relocating pointers.	there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;      the layout of this structure is shown in the definitions
;      section, together with symbolic definitions of the
;      entries as offsets from XL.
;
relcr	PRC	e,0			; entry point
	ADD	XL,*rlsi_		; point past build area
	MOV	-(XL),WA		; save original code address
	MOV	WA,=s_aaa		; compute adjustment
	SUB	WA,(XL)			; as new s_aaa minus original s_aaa
	MOV	-(XL),WA		; save code adjustment
	MOV	WA,=s_yyy		; end of target code section
	SUB	WA,=s_aaa		; length of code section
	ADD	WA,num01(XL)		; plus original start address
	MOV	-(XL),WA		; end of original code section
	MOV	-(XL),WB		; save constant section address
	MOV	WB,=c_aaa		; start of constants section
	MOV	WA,=c_yyy		; end of constants section
	SUB	WA,WB			; length of constants section
	SUB	WB,(XL)			; new c_aaa minus original c_aaa
	MOV	-(XL),WB		; save constant adjustment
	ADD	WA,num01(XL)		; length plus original start adr
	MOV	-(XL),WA		; save as end of original constants
	MOV	-(XL),WC		; save working globals address
	MOV	WC,=g_aaa		; start of working globals section
	MOV	WA,=w_yyy		; end of working section
	SUB	WA,WC			; length of working globals
	SUB	WC,(XL)			; new g_aaa minus original g_aaa
	MOV	-(XL),WC		; save working globals adjustment
	ADD	WA,num01(XL)		; length plus original start adr
	MOV	-(XL),WA		; save as end of working globals
	MOV	WB,statb		; old start of static region
	MOV	-(XL),WB		; save
	SUB	XR,WB			; compute adjustment
	MOV	-(XL),XR		; save new statb minus old statb
	MOV	-(XL),state		; old end of static region
	MOV	WB,dnamb		; old start of dynamic region
	MOV	-(XL),WB		; save
	SCP	WA			; new start of dynamic
	SUB	WA,WB			; compute adjustment
	MOV	-(XL),WA		; save new dnamb minus old dnamb
	MOV	WC,dnamp		; old end of dynamic region in use
	MOV	-(XL),WC		; save as end of old dynamic region
	EXI
	ENP
	EJC
;
;      reldn -- relocate pointers in the dynamic region
;
;      (XL)		     list of boundaries and adjustments
;      (XR)		     ptr to first location to process
;      (WC)		     ptr past last location to process
;      jsr  reldn	     call to process blocks in dynamic
;      (WA,WB,WC,XR)	     destroyed
;
;      processes all blocks in the dynamic region.  within a
;      block, pointers to the code section, constant section,
;      working globals section, static region, and dynamic
;      region are relocated as needed.
;
reldn	PRC	e,0			; entry point
	MOV	rldcd,rlcda(XL)		; save code adjustment
	MOV	rldst,rlsta(XL)		; save static adjustment
	MOV	rldls,XL		; save list pointer
;
;      merge here to process the next block in dynamic
;
rld01	ADD	(XR),rldcd		; adjust block type word
	MOV	XL,(XR)			; load block type word
	LEI	XL			; load entry point id (bl_xx)
;
;      block type switch. note that blocks with no relocatable
;      fields just return to rld05 to continue to next block.
;
;      note that dfblks do not appear in dynamic, only in static.
;      ccblks and cmblks are not live when a save file is
;      created, and can be skipped.
;
;      further note:  static blocks other than vrblks discovered
;      while scanning dynamic must be adjusted at this time.
;      see processing of ffblk for example.
;
	EJC
;
;      reldn (continued)
;
	BSW	XL,bl___		; switch on block type
	IFF	bl_ar,rld03		; arblk
.IF    .cnbf
	IFF	bl_bc,rld05		; bcblk - dummy to fill out iffs
.ELSE
	IFF	bl_bc,rld06		; bcblk
.FI
	IFF	bl_bf,rld05		; bfblk
	IFF	bl_cc,rld05		; ccblk
	IFF	bl_cd,rld07		; cdblk
	IFF	bl_cm,rld05		; cmblk
	IFF	bl_ct,rld05		; ctblk
	IFF	bl_df,rld05		; dfblk
	IFF	bl_ef,rld08		; efblk
	IFF	bl_ev,rld09		; evblk
	IFF	bl_ex,rld10		; exblk
	IFF	bl_ff,rld11		; ffblk
	IFF	bl_ic,rld05		; icblk
	IFF	bl_kv,rld13		; kvblk
	IFF	bl_nm,rld13		; nmblk
	IFF	bl_p0,rld13		; p0blk
	IFF	bl_p1,rld14		; p1blk
	IFF	bl_p2,rld14		; p2blk
	IFF	bl_pd,rld15		; pdblk
	IFF	bl_pf,rld16		; pfblk
.IF    .cnra
.ELSE
	IFF	bl_rc,rld05		; rcblk
.FI
	IFF	bl_sc,rld05		; scblk
	IFF	bl_se,rld13		; seblk
	IFF	bl_tb,rld17		; tbblk
	IFF	bl_te,rld18		; teblk
	IFF	bl_tr,rld19		; trblk
	IFF	bl_vc,rld17		; vcblk
	IFF	bl_xn,rld05		; xnblk
	IFF	bl_xr,rld20		; XRblk
	ESW				; end of jump table
;
;      arblk
;
rld03	MOV	WA,arlen(XR)		; load length
	MOV	WB,arofs(XR)		; set offset to 1st reloc fld (arpro)
;
;      merge here to process pointers in a block
;
;      (XR)		     ptr to current block
;      (WC)		     ptr past last location to process
;      (WA)		     length (reloc flds + flds at start)
;      (WB)		     offset to first reloc field
;
rld04	ADD	WA,XR			; point past last reloc field
	ADD	WB,XR			; point to first reloc field
	MOV	XL,rldls		; point to list of bounds
	JSR	relaj			; adjust pointers
	EJC
;
;      reldn (continued)
;
;
;      merge here to advance to next block
;
;      (XR)		     ptr to current block
;      (WC)		     ptr past last location to process
;
rld05	MOV	WA,(XR)			; block type word
	JSR	blkln			; get length of block
	ADD	XR,WA			; point to next block
	BLT	XR,WC,rld01		; continue if more to process
	MOV	XL,rldls		; restore XL
	EXI				; return to caller if done
.IF    .cnbf
.ELSE
;
;      bcblk
;
rld06	MOV	WA,*bcsi_		; set length
	MOV	WB,*bcbuf		; and offset
	BRN	rld04			; all set
.FI
;
;      cdblk
;
rld07	MOV	WA,cdlen(XR)		; load length
	MOV	WB,*cdfal		; set offset
	BNE	(XR),=b_cdc,rld04	; jump back if not complex goto
	MOV	WB,*cdcod		; do not process cdfal word
	BRN	rld04			; jump back
;
;      efblk
;
;      if the efcod word points to an xnblk, the xnblk type
;      word will not be adjusted.  since this is implementation
;      dependent, we will not worry about it.
;
rld08	MOV	WA,*efrsl		; set length
	MOV	WB,*efcod		; and offset
	BRN	rld04			; all set
;
;      evblk
;
rld09	MOV	WA,*offs3		; point past third field
	MOV	WB,*evexp		; set offset
	BRN	rld04			; all set
;
;      exblk
;
rld10	MOV	WA,exlen(XR)		; load length
	MOV	WB,*exflc		; set offset
	BRN	rld04			; jump back
	EJC
;
;      reldn (continued)
;
;
;      ffblk
;
;      this block contains a ptr to a dfblk in the static rgn.
;      because there are multiple ffblks pointing to the same
;      dfblk (one for each field name), we only process the
;      dfblk when we encounter the ffblk for the first field.
;      the dfblk in turn contains a pointer to an scblk within
;      static.
;
rld11	BNE	ffofs(XR),*pdfld,rld12	; skip dfblk if not first field
	MOV	-(XS),XR		; save XR
	MOV	XR,ffdfp(XR)		; load old ptr to dfblk
	ADD	XR,rldst		; current location of dfblk
	ADD	(XR),rldcd		; adjust dfblk type word
	MOV	WA,dflen(XR)		; length of dfblk
	MOV	WB,*dfnam		; offset to dfnam field
	ADD	WA,XR			; point past last reloc field
	ADD	WB,XR			; point to first reloc field
	MOV	XL,rldls		; point to list of bounds
	JSR	relaj			; adjust pointers
	MOV	XR,dfnam(XR)		; pointer to static scblk
	ADD	(XR),rldcd		; adjust scblk type word
	MOV	XR,(XS)+		; restore ffblk pointer
;
;      ffblk (continued)
;
;      merge here to set up for adjustment of ptrs in ffblk
;
rld12	MOV	WA,*ffofs		; set length
	MOV	WB,*ffdfp		; set offset
	BRN	rld04			; all set
;
;      kvblk, nmblk, p0blk, seblk
;
rld13	MOV	WA,*offs2		; point past second field
	MOV	WB,*offs1		; offset is one (only reloc fld is 2)
	BRN	rld04			; all set
;
;      p1blk, p2blk
;
;      in p2blks, parm2 contains either a bit mask or the
;      name offset of a vaRIAble.  it never requires relocation.
;
rld14	MOV	WA,*parm2		; length (parm2 is non-relocatable)
	MOV	WB,*pthen		; set offset
	BRN	rld04			; all set
;
;      pdblk
;
;      note that the dfblk pointed to by this pdblk WAs
;      processed when the ffblk was encountered.  because
;      the data function will be called before any records are
;      defined, the ffblk is encountered before any
;      corresponding pdblk.
;
rld15	MOV	XL,pddfp(XR)		; load ptr to dfblk
	ADD	XL,rldst		; adjust for static relocation
	MOV	WA,dfpdl(XL)		; get pdblk length
	MOV	WB,*pddfp		; set offset
	BRN	rld04			; all set
	EJC
;
;      reldn (continued)
;
;
;      pfblk
;
rld16	ADD	pfvbl(XR),rldst		; adjust non-contiguous field
	MOV	WA,pflen(XR)		; get pfblk length
	MOV	WB,*pfcod		; offset to first reloc
	BRN	rld04			; all set
;
;      tbblk, vcblk
;
rld17	MOV	WA,offs2(XR)		; load length
	MOV	WB,*offs3		; set offset
	BRN	rld04			; jump back
;
;      teblk
;
rld18	MOV	WA,*tesi_		; set length
	MOV	WB,*tesub		; and offset
	BRN	rld04			; all set
;
;      trblk
;
rld19	MOV	WA,*trsi_		; set length
	MOV	WB,*trval		; and offset
	BRN	rld04			; all set
;
;      XRblk
;
rld20	MOV	WA,xrlen(XR)		; load length
	MOV	WB,*xrptr		; set offset
	BRN	rld04			; jump back
	ENP				; end procedure reldn
	EJC
;
;      reloc -- relocate storage after save file reload
;
;      (XL)		     list of boundaries and adjustments
;      jsr  reloc	     relocate all pointers
;      (WA,WB,WC,XR)	     destroyed
;
;      the list of boundaries and adjustments pointed to by
;      register XL is created by a call to relcr, which should
;      be consulted for information on its structure.
;
reloc	PRC	e,0			; entry point
	MOV	XR,rldys(XL)		; old start of dynamic
	MOV	WC,rldye(XL)		; old end of dynamic
	ADD	XR,rldya(XL)		; create new start of dynamic
	ADD	WC,rldya(XL)		; create new end of dynamic
	JSR	reldn			; relocate pointers in dynamic
	JSR	relws			; relocate pointers in working sect
	JSR	relst			; relocate pointers in static
	EXI				; return to caller
	ENP				; end procedure reloc
	EJC
;
;      relst -- relocate pointers in the static region
;
;      (XL)		     list of boundaries and adjustments
;      jsr  relst	     call to process blocks in static
;      (WA,WB,WC,XR)	     destroyed
;
;      only vrblks on the hash chain and any profile block are
;      processed.  other static blocks (dfblks) are processed
;      during processing of dynamic blocks.
;
;      global work locations will be processed at this point,
;      so pointers there can be relied upon.
;
relst	PRC	e,0			; entry point
	MOV	XR,pftbl		; profile table
	BZE	XR,rls01		; branch if no table allocated
	ADD	(XR),rlcda(XL)		; adjust block type word
;
;      here after dealing with profiler
;
rls01	MOV	WC,hshtb		; point to start of hash table
	MOV	WB,WC			; point to first hash bucket
	MOV	WA,hshte		; point beyond hash table
	JSR	relaj			; adjust bucket pointers
;
;      loop through slots in hash table
;
rls02	BEQ	WC,hshte,rls05		; done if none left
	MOV	XR,WC			; else copy slot pointer
	ICA	WC			; bump slot pointer
	SUB	XR,*vrnxt		; set offset to merge into loop
;
;      loop through vrblks on one hash chain
;
rls03	MOV	XR,vrnxt(XR)		; point to next vrblk on chain
	BZE	XR,rls02		; jump for next bucket if chain end
	MOV	WA,*vrlen		; offset of first loc past ptr fields
	MOV	WB,*vrget		; offset of first location in vrblk
	BNZ	vrlen(XR),rls04		; jump if not system vaRIAble
	MOV	WA,*vrsi_		; offset to include vrsvp field
;
;      merge here to process fields of vrblk
;
rls04	ADD	WA,XR			; create end ptr
	ADD	WB,XR			; create start ptr
	JSR	relaj			; adjust pointers in vrblk
	BRN	rls03			; check for another vrblk on chain
;
;      here when all vrblks processed
;
rls05	EXI				; return to caller
	ENP				; end procedure relst
	EJC
;
;      relws -- relocate pointers in the working section
;
;      (XL)		     list of boundaries and adjustments
;      jsr  relws	     call to process working section
;      (WA,WB,WC,XR)	     destroyed
;
;      pointers between a_aaa and r_yyy are examined and
;      adjusted if necessary.  the pointer kvrtn is also
;      adjusted although it lies outside this range.
;      dname is explicitly adjusted because the limits
;      on dynamic region in stack are to the area actively
;      in use (between dnamb and dnamp), and dname is outside
;      this range.
;
relws	PRC	e,0			; entry point
	MOV	WB,=a_aaa		; point to start of adjustables
	MOV	WA,=r_yyy		; point to end of adjustables
	JSR	relaj			; relocate adjustable pointers
	ADD	dname,rldya(XL)		; adjust ptr missed by relaj
	MOV	WB,=kvrtn		; case of kvrtn
	MOV	WA,WB			; handled specially
	ICA	WA			; one value to adjust
	JSR	relaj			; adjust kvrtn
	EXI				; return to caller
	ENP				; end procedure relws
.FI
	TTL	s p i t b o l -- initialization
;
;      initialisation
;      the following section receives control from the system
;      at the start of a run with the registers set as follows.
;
;      (WA)		     initial stack pointer
;      (XR)		     points to first word of data area
;      (XL)		     points to last word of data area
;
start	PRC	e,0			; entry point
;z-
	MOV	mxint,WB		;
	MOV	bitsm,WB		;
	ZER	WB			;
	MOV	XS,WA			; discard return
;z+
	JSR	systm			; initialise timer
.IF    .cnbt
	STI	timsx			; store time
	MOV	statb,XR		; start address of static
.ELSE
;
;      initialise work area (essential for batched runs)
;
	MOV	WB,XR			; preserve XR
	MOV	WA,=w_yyy		; point to end of work area
	SUB	WA,=w_aaa		; get length of work area
	BTW	WA			; convert to words
	LCT	WA,WA			; count for loop
	MOV	XR,=w_aaa		; set up index register
;
;      clear work space
;
ini01	ZER	(XR)+			; clear a word
	BCT	WA,ini01		; loop till done
	MOV	WA,=stndo		; undefined operators pointer
	MOV	WC,=r_yyy		; point to table end
	SUB	WC,=r_uba		; length of undef. operators table
	BTW	WC			; convert to words
	LCT	WC,WC			; loop counter
	MOV	XR,=r_uba		; set up XR
;
;      set correct value into undefined operators table
;
ini02	MOV	(XR)+,WA		; store value
	BCT	WC,ini02		; loop till all done
	MOV	WA,=num01		; get a 1
.IF    .cpol
	MOV	polcs,WA		; interface polling interval
	MOV	polct,WA		; interface polling interval
.FI
	MOV	cmpsn,WA		; statement no
	MOV	cswfl,WA		; nofail
	MOV	cswls,WA		; list
	MOV	kvinp,WA		; input
	MOV	kvoup,WA		; output
	MOV	lstpf,WA		; nothing for listr yet
	MOV	WA,=iniln		; input image length
	MOV	cswin,WA		; -in72
	EJC
	MOV	WA,=nulls		; get null string pointer
	MOV	kvrtn,WA		; return
	MOV	r_etx,WA		; errteXT
	MOV	r_ttl,WA		; title for listing
	MOV	stxvr,WA		; setexit
	STI	timsx			; store time in correct place
	LDI	stlim			; get default stlimit
	STI	kvstl			; statement limit
	STI	kvstc			; statement count
	MOV	statb,WB		; store start adrs of static
.FI
	MOV	rsmem,*e_srs		; reserve memory
	MOV	stbas,XS		; store stack base
	SSS	iniss			; save s-r stack ptr
;
;      now convert free store percentage to a suitable factor
;      for easy testing in alloc routine.
;
	LDI	intvh			; get 100
	DVI	alfsp			; form 100 / alfsp
	STI	alfsf			; store the factor
.IF    .csed
;
;      now convert free sediment percentage to a suitable factor
;      for easy testing in gbcol routine.
;
	LDI	intvh			; get 100
	DVI	gbsdp			; form 100 / gbsdp
	STI	gbsed			; store the factor
.FI
.IF    .cnra
.ELSE
.IF    .cncr
.ELSE
;
;      initialize values for real conversion routine
;
	LCT	WB,=cfp_s		; load counter for significant digits
	LDR	reav1			; load 1.0
;
;      loop to compute 10**(max number significant digits)
;
ini03	MLR	reavt			; * 10.0
	BCT	WB,ini03		; loop till done
	STR	gtssc			; store 10**(max sig digits)
	LDR	reap5			; load 0.5
	DVR	gtssc			; compute 0.5*10**(max sig digits)
	STR	gtsrn			; store as rounding bias
.FI
.FI
	ZER	WC			; set to read parameters
	JSR	prpar			; read them
	EJC
;
;      now compute starting address for dynamic store and if
;      necessary request more memory.
;
	SUB	XL,*e_srs		; allow for reserve memory
	MOV	WA,prlen		; get print buffer length
	ADD	WA,=cfp_a		; add no. of chars in alphabet
	ADD	WA,=nstmx		; add chars for gtstg bfr
	CTB	WA,8			; convert to bytes, allowing a margin
	MOV	XR,statb		; point to static base
	ADD	XR,WA			; increment for above buffers
	ADD	XR,*e_hnb		; increment for hash table
	ADD	XR,*e_sts		; bump for initial static block
	JSR	sysmx			; get mxlen
	MOV	kvmxl,WA		; provisionally store as maXLngth
	MOV	mxlen,WA		; and as mxlen
	BGT	XR,WA,ini06		; skip if static hi exceeds mxlen
	CTB	WA,1			; round up and make bigger than mxlen
	MOV	XR,WA			; use it instead
;
;      here to store values which mark initial division
;      of data area into static and dynamic
;
ini06	MOV	dnamb,XR		; dynamic base adrs
	MOV	dnamp,XR		; dynamic ptr
	BNZ	WA,ini07		; skip if non-zero mxlen
	DCA	XR			; point a word in front
	MOV	kvmxl,XR		; use as maXLngth
	MOV	mxlen,XR		; and as mxlen
	EJC
;
;      loop here if necessary till enough memory obtained
;      so that dname is above dnamb
;
ini07	MOV	dname,XL		; store dynamic end address
	BLT	dnamb,XL,ini09		; skip if high enough
	JSR	sysmm			; request more memory
	WTB	XR			; get as baus (sgd05)
	ADD	XL,XR			; bump by amount obtained
	BNZ	XR,ini07		; try again
.IF    .cera
	MOV	WA,=mxern		; insufficient memory for maXLength
	ZER	WB			; no column number info
	ZER	WC			; no line number info
	MOV	XR,=stgic		; initial compile stage
.IF    .csfn
	MOV	XL,=nulls		; no file name
.FI
	JSR	sysea			; advise of error
	PPM	ini08			; cant use error logic yet
	BRN	ini08			; force termination
;
;      insert teXT for error 329 in error message table
;
	ERB	329,requested maXLngth too large
.FI
ini08	MOV	XR,=endmo		; point to failure message
	MOV	WA,endml		; message length
	JSR	syspr			; print it (prtst not yet usable)
	PPM				; should not fail
	ZER	XL			; no fcb chain yet
	MOV	WB,=num10		; set special code value
	JSR	sysej			; pack up (stopr not yet usable)
;
;      initialise structures at start of static region
;
ini09	MOV	XR,statb		; point to static again
	JSR	insta			; initialize static
;
;      initialize number of hash headers
;
	MOV	WA,=e_hnb		; get number of hash headers
	MTI	WA			; convert to integer
	STI	hshnb			; store for use by gtnvr procedure
	LCT	WA,WA			; counter for clearing hash table
	MOV	hshtb,XR		; pointer to hash table
;
;      loop to clear hash table
;
ini11	ZER	(XR)+			; blank a word
	BCT	WA,ini11		; loop
	MOV	hshte,XR		; end of hash table adrs is kept
	MOV	state,XR		; store static end address
.IF    .csfn
;
;      init table to map statement numbers to source file names
;
	MOV	WC,=num01		; table will have only one bucket
	MOV	XL,=nulls		; default table value
	MOV	r_sfc,XL		; current source file name
	JSR	tmake			; create table
	MOV	r_sfn,XR		; save ptr to table
.FI
.IF    .cinc
;
;      initialize table to detect duplicate include file names
;
	MOV	WC,=num01		; table will have only one bucket
	MOV	XL,=nulls		; default table value
	JSR	tmake			; create table
	MOV	r_inc,XR		; save ptr to table
.IF    .csfn
;
;      initialize array to hold names of nested include files
;
	MOV	WA,=ccinm		; maximum nesting level
	MOV	XL,=nulls		; null string default value
	JSR	vmake			; create array
	PPM
	MOV	r_ifa,XR		; save ptr to array
;
;      init array to hold line numbers of nested include files
;
	MOV	WA,=ccinm		; maximum nesting level
	MOV	XL,=inton		; integer one default value
	JSR	vmake			; create array
	PPM
	MOV	r_ifl,XR		; save ptr to array
.FI
.FI
;z+
;
;      initialize vaRIAble blocks for input and output
;
	MOV	XL,=v_inp		; point to string /input/
	MOV	WB,=trtin		; trblk type for input
	JSR	inout			; perform input association
	MOV	XL,=v_oup		; point to string /output/
	MOV	WB,=trtou		; trblk type for output
	JSR	inout			; perform output association
	MOV	WC,initr		; terminal flag
	BZE	WC,ini13		; skip if no terminal
	JSR	prpar			; associate terminal
	EJC
;
;      check for expiry date
;
ini13	JSR	sysdc			; call date check
	MOV	flptr,XS		; in case stack overflows in compiler
;
;      now compile source input code
;
	JSR	cmpil			; call compiler
	MOV	r_cod,XR		; set ptr to first code block
	MOV	r_ttl,=nulls		; forget title
	MOV	r_stl,=nulls		; forget sub-title
	ZER	r_cim			; forget compiler input image
	ZER	r_ccb			; forget interim code block
.IF    .cinc
	ZER	cnind			; in case end occurred with include
	ZER	lstid			; listing include depth
.FI
	ZER	XL			; clear dud value
	ZER	WB			; dont shift dynamic store up
.IF    .csed
	ZER	dnams			; collect sediment too
	JSR	gbcol			; clear garbage left from compile
	MOV	dnams,XR		; record new sediment size
.ELSE
	JSR	gbcol			; clear garbage left from compile
.FI
	BNZ	cpsts,inix0		; skip if no listing of comp stats
	JSR	prtpg			; eject page
;
;      print compile statistics
;
	JSR	prtmm			; print memory usage
	MTI	cmerc			; get count of errors as integer
	MOV	XR,=encm3		; point to /compile errors/
	JSR	prtmi			; print it
	MTI	gbcnt			; garbage collection count
	SBI	intv1			; adjust for unavoidable collect
	MOV	XR,=stpm5		; point to /storage regenerations/
	JSR	prtmi			; print gbcol count
	JSR	systm			; get time
	SBI	timsx			; get compilation time
	MOV	XR,=encm4		; point to compilation time (msec)/
	JSR	prtmi			; print message
	ADD	lstlc,=num05		; bump line count
.IF    .cuej
	BZE	headp,inix0		; no eject if nothing printed
	JSR	prtpg			; eject printer
.FI
	EJC
;
;      prepare now to start execution
;
;      set default input record length
;
inix0	BGT	cswin,=iniln,inix1	; skip if not default -in72 used
	MOV	cswin,=inils		; else use default record length
;
;      reset timer
;
inix1	JSR	systm			; get time again
	STI	timsx			; store for end run processing
	ZER	gbcnt			; initialise collect count
	JSR	sysbx			; call before starting execution
	ADD	noxeq,cswex		; add -noexecute flag
	BNZ	noxeq,inix2		; jump if execution suppressed
.IF    .cuej
.ELSE
	BZE	headp,iniy0		; no eject if nothing printed (sgd11)
	JSR	prtpg			; eject printer
.FI
;
;      merge when listing file set for execution.  also
;      merge here when restarting a save file or load module.
;
iniy0	MNZ	headp			; mark headers out regardless
	ZER	-(XS)			; set failure location on stack
	MOV	flptr,XS		; save ptr to failure offset word
	MOV	XR,r_cod		; load ptr to entry code block
	MOV	stage,=stgxt		; set stage for execute time
.IF    .cpol
	MOV	polcs,=num01		; reset interface polling interval
	MOV	polct,=num01		; reset interface polling interval
.FI
.IF    .cnpf
.ELSE
	MOV	pfnte,cmpsn		; copy stmts compiled count in case
	MOV	pfdmp,kvpfl		; start profiling if &profile set
	JSR	systm			; time yet again
	STI	pfstm			;
.FI
	JSR	stgcc			; compute stmgo countdown counters
	BRI	(XR)			; start xeq with first statement
;
;      here if execution is suppressed
;
.IF    .cera
inix2	ZER	WA			; set abend value to zero
.ELSE
inix2	JSR	prtnl			; print a blank line
	MOV	XR,=encm5		; point to /execution suppressed/
	JSR	prtst			; print string
	JSR	prtnl			; output line
	ZER	WA			; set abend value to zero
.FI
	MOV	WB,=nini9		; set special code value
	ZER	XL			; no fcb chain
	JSR	sysej			; end of job, exit to system
	ENP				; end procedure start
;
;      here from osint to restart a save file or load module.
;
rstrt	PRC	e,0			; entry point
	MOV	XS,stbas		; discard return
	ZER	XL			; clear XL
	BRN	iniy0			; resume execution
	ENP				; end procedure rstrt

	TTL	s p i t b o l -- snobol4 operator routines
;
;      this section includes all routines which can be accessed
;      directly from the generated code except system functions.
;
;      all routines in this section start with a label of the
;      form o_xxx where xxx is three letters. the generated code
;      contains a pointer to the appropriate entry label.
;
;      since the general form of the generated code consists of
;      pointers to blocks whose first word is the address of the
;      actual entry point label (o_xxx).
;
;      these routines are in alphabetical order by their
;      entry label names (i.e. by the xxx of the o_xxx name)
;
;      these routines receive control as follows
;
;      (CP)		     pointer to next code word
;      (XS)		     current stack pointer
	EJC
;
;      binary plus (addition)
;
o_add	ENT				; entry point
;z+
	JSR	arith			; fetch arithmetic operands
	ERR	001,addition left operand is not numeric
	ERR	002,addition right operand is not numeric
.IF    .cnra
.ELSE
	PPM	oadd1			; jump if real operands
.FI
;
;      here to add two integers
;
	ADI	icval(XL)		; add right operand to left
	INO	exint			; return integer if no overflow
	ERB	003,addition caused integer overflow
.IF    .cnra
.ELSE
;
;      here to add two reals
;
oadd1	ADR	rcval(XL)		; add right operand to left
	RNO	exrea			; return real if no overflow
	ERB	261,addition caused real overflow
.FI
	EJC
;
;      unary plus (affirmation)
;
o_aff	ENT				; entry point
	MOV	XR,(XS)+		; load operand
	JSR	gtnum			; convert to numeric
	ERR	004,affirmation operand is not numeric
	MOV	-(XS),XR		; result if converted to numeric
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      binary bar (alternation)
;
o_alt	ENT				; entry point
	MOV	XR,(XS)+		; load right operand
	JSR	gtpat			; convert to pattern
	ERR	005,alternation right operand is not pattern
;
;      merge here from special (left alternation) case
;
oalt1	MOV	WB,=p_alt		; set pcode for alternative node
	JSR	pbild			; build alternative node
	MOV	XL,XR			; save address of alternative node
	MOV	XR,(XS)+		; load left operand
	JSR	gtpat			; convert to pattern
	ERR	006,alternation left operand is not pattern
	BEQ	XR,=p_alt,oalt2		; jump if left arg is alternation
	MOV	pthen(XL),XR		; set left operand as successor
	MOV	-(XS),XL		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      come here if left argument is itself an alternation
;
;      the result is more efficient if we make the replacement
;
;      (a / b) / c = a / (b / c)
;
oalt2	MOV	pthen(XL),parm1(XR)	; build the (b / c) node
	MOV	-(XS),pthen(XR)		; set a as new left arg
	MOV	XR,XL			; set (b / c) as new right arg
	BRN	oalt1			; merge back to build a / (b / c)
	EJC
;
;      array reference (multiple subscripts, by name)
;
o_amn	ENT				; entry point
	LCW	XR			; load number of subscripts
	MOV	WB,XR			; set flag for by name
	BRN	arref			; jump to array reference routine
	EJC
;
;      array reference (multiple subscripts, by value)
;
o_amv	ENT				; entry point
	LCW	XR			; load number of subscripts
	ZER	WB			; set flag for by value
	BRN	arref			; jump to array reference routine
	EJC
;
;      array reference (one subscript, by name)
;
o_aon	ENT				; entry point
	MOV	XR,(XS)			; load subscript value
	MOV	XL,num01(XS)		; load array value
	MOV	WA,(XL)			; load first word of array operand
	BEQ	WA,=b_vct,oaon2		; jump if vector reference
	BEQ	WA,=b_tbt,oaon3		; jump if table reference
;
;      here to use central array reference routine
;
oaon1	MOV	XR,=num01		; set number of subscripts to one
	MOV	WB,XR			; set flag for by name
	BRN	arref			; jump to array reference routine
;
;      here if we have a vector reference
;
oaon2	BNE	(XR),=b_icl,oaon1	; use long routine if not integer
	LDI	icval(XR)		; load integer subscript value
	MFI	WA,exfal		; copy as address int, fail if ovflo
	BZE	WA,exfal		; fail if zero
	ADD	WA,=vcvlb		; compute offset in words
	WTB	WA			; convert to bytes
	MOV	(XS),WA			; complete name on stack
	BLT	WA,vclen(XL),oaon4	; exit if subscript not too large
	BRN	exfal			; else fail
;
;      here for table reference
;
oaon3	MNZ	WB			; set flag for name reference
	JSR	tfind			; locate/create table element
	PPM	exfal			; fail if access fails
	MOV	num01(XS),XL		; store name base on stack
	MOV	(XS),WA			; store name offset on stack
;
;      here to exit with result on stack
;
oaon4	LCW	XR			; result on stack, get code word
	BRI	(XR)			; execute next code word
	EJC
;
;      array reference (one subscript, by value)
;
o_aov	ENT				; entry point
	MOV	XR,(XS)+		; load subscript value
	MOV	XL,(XS)+		; load array value
	MOV	WA,(XL)			; load first word of array operand
	BEQ	WA,=b_vct,oaov2		; jump if vector reference
	BEQ	WA,=b_tbt,oaov3		; jump if table reference
;
;      here to use central array reference routine
;
oaov1	MOV	-(XS),XL		; restack array value
	MOV	-(XS),XR		; restack subscript
	MOV	XR,=num01		; set number of subscripts to one
	ZER	WB			; set flag for value call
	BRN	arref			; jump to array reference routine
;
;      here if we have a vector reference
;
oaov2	BNE	(XR),=b_icl,oaov1	; use long routine if not integer
	LDI	icval(XR)		; load integer subscript value
	MFI	WA,exfal		; move as one word int, fail if ovflo
	BZE	WA,exfal		; fail if zero
	ADD	WA,=vcvlb		; compute offset in words
	WTB	WA			; convert to bytes
	BGE	WA,vclen(XL),exfal	; fail if subscript too large
	JSR	acess			; access value
	PPM	exfal			; fail if access fails
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      here for table reference by value
;
oaov3	ZER	WB			; set flag for value reference
	JSR	tfind			; call table search routine
	PPM	exfal			; fail if access fails
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      assignment
;
o_ass	ENT				; entry point
;
;      o_rpl (pattern replacement) merges here
;
oass0	MOV	WB,(XS)+		; load value to be assigned
	MOV	WA,(XS)+		; load name offset
	MOV	XL,(XS)			; load name base
	MOV	(XS),WB			; store assigned value as result
	JSR	asign			; perform assignment
	PPM	exfal			; fail if assignment fails
	LCW	XR			; result on stack, get code word
	BRI	(XR)			; execute next code word
	EJC
;
;      compilation error
;
o_cer	ENT				; entry point
	ERB	007,compilation error encountered during execution
	EJC
;
;      unary at (cursor assignment)
;
o_cas	ENT				; entry point
	MOV	WC,(XS)+		; load name offset (parm2)
	MOV	XR,(XS)+		; load name base (parm1)
	MOV	WB,=p_cas		; set pcode for cursor assignment
	JSR	pbild			; build node
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      concatenation
;
o_cnc	ENT				; entry point
	MOV	XR,(XS)			; load right argument
	BEQ	XR,=nulls,ocnc3		; jump if right arg is null
	MOV	XL,1(XS)		; load left argument
	BEQ	XL,=nulls,ocnc4		; jump if left argument is null
	MOV	WA,=b_scl		; get constant to test for string
	BNE	WA,(XL),ocnc2		; jump if left arg not a string
	BNE	WA,(XR),ocnc2		; jump if right arg not a string
;
;      merge here to concatenate two strings
;
ocnc1	MOV	WA,sclen(XL)		; load left argument length
	ADD	WA,sclen(XR)		; compute result length
	JSR	alocs			; allocate scblk for result
	MOV	1(XS),XR		; store result ptr over left argument
	PSC	XR			; prepare to store chars of result
	MOV	WA,sclen(XL)		; get number of chars in left arg
	PLC	XL			; prepare to load left arg chars
	MVC				; move characters of left argument
	MOV	XL,(XS)+		; load right arg pointer, pop stack
	MOV	WA,sclen(XL)		; load number of chars in right arg
	PLC	XL			; prepare to load right arg chars
	MVC				; move characters of right argument
	ZER	XL			; clear garbage value in XL
	LCW	XR			; result on stack, get code word
	BRI	(XR)			; execute next code word
;
;      come here if arguments are not both strings
;
ocnc2	JSR	gtstg			; convert right arg to string
	PPM	ocnc5			; jump if right arg is not string
	MOV	XL,XR			; save right arg ptr
	JSR	gtstg			; convert left arg to string
	PPM	ocnc6			; jump if left arg is not a string
	MOV	-(XS),XR		; stack left argument
	MOV	-(XS),XL		; stack right argument
	MOV	XL,XR			; move left arg to proper reg
	MOV	XR,(XS)			; move right arg to proper reg
	BRN	ocnc1			; merge back to concatenate strings
	EJC
;
;      concatenation (continued)
;
;      come here for null right argument
;
ocnc3	ICA	XS			; remove right arg from stack
	LCW	XR			; left argument on stack
	BRI	(XR)			; execute next code word
;
;      here for null left argument
;
ocnc4	ICA	XS			; unstack one argument
	MOV	(XS),XR			; store right argument
	LCW	XR			; result on stack, get code word
	BRI	(XR)			; execute next code word
;
;      here if right argument is not a string
;
ocnc5	MOV	XL,XR			; move right argument ptr
	MOV	XR,(XS)+		; load left arg pointer
;
;      merge here when left argument is not a string
;
ocnc6	JSR	gtpat			; convert left arg to pattern
	ERR	008,concatenation left operand is not a string or pattern
	MOV	-(XS),XR		; save result on stack
	MOV	XR,XL			; point to right operand
	JSR	gtpat			; convert to pattern
	ERR	009,concatenation right operand is not a string or pattern
	MOV	XL,XR			; move for pconc
	MOV	XR,(XS)+		; reload left operand ptr
	JSR	pconc			; concatenate patterns
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      complementation
;
o_com	ENT				; entry point
	MOV	XR,(XS)+		; load operand
	MOV	WA,(XR)			; load type word
;
;      merge back here after conversion
;
ocom1	BEQ	WA,=b_icl,ocom2		; jump if integer
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,ocom3		; jump if real
.FI
	JSR	gtnum			; else convert to numeric
	ERR	010,negation operand is not numeric
	BRN	ocom1			; back to check cases
;
;      here to complement integer
;
ocom2	LDI	icval(XR)		; load integer value
	NGI				; negate
	INO	exint			; return integer if no overflow
	ERB	011,negation caused integer overflow
.IF    .cnra
.ELSE
;
;      here to complement real
;
ocom3	LDR	rcval(XR)		; load real value
	NGR				; negate
	BRN	exrea			; return real result
.FI
	EJC
;
;      binary slash (division)
;
o_dvd	ENT				; entry point
	JSR	arith			; fetch arithmetic operands
	ERR	012,division left operand is not numeric
	ERR	013,division right operand is not numeric
.IF    .cnra
.ELSE
	PPM	odvd2			; jump if real operands
.FI
;
;      here to divide two integers
;
	DVI	icval(XL)		; divide left operand by right
	INO	exint			; result ok if no overflow
	ERB	014,division caused integer overflow
.IF    .cnra
.ELSE
;
;      here to divide two reals
;
odvd2	DVR	rcval(XL)		; divide left operand by right
	RNO	exrea			; return real if no overflow
	ERB	262,division caused real overflow
.FI
	EJC
;
;      exponentiation
;
o_exp	ENT				; entry point
	MOV	XR,(XS)+		; load exponent
	JSR	gtnum			; convert to number
	ERR	015,exponentiation right operand is not numeric
	MOV	XL,XR			; move exponent to XL
	MOV	XR,(XS)+		; load base
	JSR	gtnum			; convert to numeric
	ERR	016,exponentiation left operand is not numeric
.IF    .cnra
.ELSE
	BEQ	(XL),=b_rcl,oexp7	; jump if real exponent
.FI
	LDI	icval(XL)		; load exponent
	ILT	oex12			; jump if negative exponent
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,oexp3		; jump if base is real
.FI
;
;      here to exponentiate an integer base and integer exponent
;
	MFI	WA,oexp2		; convert exponent to 1 word integer
	LCT	WA,WA			; set loop counter
	LDI	icval(XR)		; load base as initial value
	BNZ	WA,oexp1		; jump into loop if non-zero exponent
	IEQ	oexp4			; error if 0**0
	LDI	intv1			; nonzero**0
	BRN	exint			; give one as result for nonzero**0
;
;      loop to perform exponentiation
;
oex13	MLI	icval(XR)		; multiply by base
	IOV	oexp2			; jump if overflow
oexp1	BCT	WA,oex13		; loop if more to go
	BRN	exint			; else return integer result
;
;      here if integer overflow
;
oexp2	ERB	017,exponentiation caused integer overflow
	EJC
;
;      exponentiation (continued)
.IF    .cnra
.ELSE
;
;      here to exponentiate a real to an integer power
;
oexp3	MFI	WA,oexp6		; convert exponent to one word
	LCT	WA,WA			; set loop counter
	LDR	rcval(XR)		; load base as initial value
	BNZ	WA,oexp5		; jump into loop if non-zero exponent
	REQ	oexp4			; error if 0.0**0
	LDR	reav1			; nonzero**0
	BRN	exrea			; return 1.0 if nonzero**zero
.FI
;
;      here for error of 0**0 or 0.0**0
;
oexp4	ERB	018,exponentiation result is undefined
.IF    .cnra
.ELSE
;
;      loop to perform exponentiation
;
oex14	MLR	rcval(XR)		; multiply by base
	ROV	oexp6			; jump if overflow
oexp5	BCT	WA,oex14		; loop till computation complete
	BRN	exrea			; then return real result
;
;      here if real overflow
;
oexp6	ERB	266,exponentiation caused real overflow
;
;      here with real exponent in (XL), numeric base in (XR)
;
.IF    .cmth
oexp7	BEQ	(XR),=b_rcl,oexp8	; jump if base real
	LDI	icval(XR)		; load integer base
	ITR				; convert to real
	JSR	rcbld			; create real in (XR)
;
;      here with real exponent in (XL)
;      numeric base in (XR) and ra
;
oexp8	ZER	WB			; set positive result flag
	LDR	rcval(XR)		; load base to ra
	RNE	oexp9			; jump if base non-zero
	LDR	rcval(XL)		; base is zero.	 check exponent
	REQ	oexp4			; jump if 0.0 ** 0.0
	LDR	reav0			; 0.0 to non-zero exponent yields 0.0
	BRN	exrea			; return zero result
;
;      here with non-zero base in (XR) and ra, exponent in (XL)
;
;      a negative base is allowed if the exponent is integral.
;
oexp9	RGT	oex10			; jump if base gt 0.0
	NGR				; make base positive
	JSR	rcbld			; create positive base in (XR)
	LDR	rcval(XL)		; examine exponent
	CHP				; chop to integral value
	RTI	oexp6			; convert to integer, br if too large
	SBR	rcval(XL)		; chop(exponent) - exponent
	RNE	oex11			; non-integral power with neg base
	MFI	WB			; record even/odd exponent
	ANB	WB,bits1		; odd exponent yields negative result
	LDR	rcval(XR)		; restore base to ra
;
;      here with positive base in ra and (XR), exponent in (XL)
;
oex10	LNF				; log of base
	ROV	oexp6			; too large
	MLR	rcval(XL)		; times exponent
	ROV	oexp6			; too large
	ETX				; e ** (exponent * ln(base))
	ROV	oexp6			; too large
	BZE	WB,exrea		; if no sign fixup required
	NGR				; negative result needed
	BRN	exrea			;
;
;      here for non-integral exponent with negative base
;
oex11	ERB	311,exponentiation of negative base to non-integral power
.ELSE
oexp7	ERB	267,exponentiation right operand is real not integer
.FI
.FI
;
;      here with negative integer exponent in IA
;
.IF    .cmth
oex12	MOV	-(XS),XR		; stack base
	ITR				; convert to real exponent
	JSR	rcbld			; real negative exponent in (XR)
	MOV	XL,XR			; put exponent in XL
	MOV	XR,(XS)+		; restore base value
	BRN	oexp7			; process real exponent
.ELSE
oex12	ERB	019,exponentiation right operand is negative
.FI
	EJC
;
;      failure in expression evaluation
;
;      this entry point is used if the evaluation of an
;      expression, initiated by the evalx procedure, fails.
;      control is returned to an appropriate point in evalx.
;
o_fex	ENT				; entry point
	BRN	evlx6			; jump to failure loc in evalx
	EJC
;
;      failure during evaluation of a complex or direct goto
;
o_fif	ENT				; entry point
	ERB	020,goto evaluation failure
	EJC
;
;      function call (more than one argument)
;
o_fnc	ENT				; entry point
	LCW	WA			; load number of arguments
	LCW	XR			; load function vrblk pointer
	MOV	XL,vrfnc(XR)		; load function pointer
	BNE	WA,fargs(XL),cfunc	; use central routine if wrong num
	BRI	(XL)			; jump to function if arg count ok
	EJC
;
;      function name error
;
o_fne	ENT				; entry point
	LCW	WA			; get next code word
	BNE	WA,=ornm_,ofne1		; fail if not evaluating expression
	BZE	num02(XS),evlx3		; ok if expr. was wanted by value
;
;      here for error
;
ofne1	ERB	021,function called by name returned a value
	EJC
;
;      function call (single argument)
;
o_fns	ENT				; entry point
	LCW	XR			; load function vrblk pointer
	MOV	WA,=num01		; set number of arguments to one
	MOV	XL,vrfnc(XR)		; load function pointer
	BNE	WA,fargs(XL),cfunc	; use central routine if wrong num
	BRI	(XL)			; jump to function if arg count ok
	EJC
;      call to undefined function
;
o_fun	ENT				; entry point
	ERB	022,undefined function called
	EJC
;
;      execute complex goto
;
o_goc	ENT				; entry point
	MOV	XR,num01(XS)		; load name base pointer
	BHI	XR,state,ogoc1		; jump if not natural vaRIAble
	ADD	XR,*vrtra		; else point to vrtra field
	BRI	(XR)			; and jump through it
;
;      here if goto operand is not natural vaRIAble
;
ogoc1	ERB	023,goto operand is not a natural vaRIAble
	EJC
;
;      execute direct goto
;
o_god	ENT				; entry point
	MOV	XR,(XS)			; load operand
	MOV	WA,(XR)			; load first word
	BEQ	WA,=b_cds,bcds0		; jump if code block to code routine
	BEQ	WA,=b_cdc,bcdc0		; jump if code block to code routine
	ERB	024,goto operand in direct goto is not code
	EJC
;
;      set goto failure trap
;
;      this routine is executed at the start of a complex or
;      direct failure goto to trap a subsequent fail (see exfal)
;
o_gof	ENT				; entry point
	MOV	XR,flptr		; point to fail offset on stack
	ICA	(XR)			; point failure to o_fif word
	ICP				; point to next code word
	LCW	XR			; fetch next code word
	BRI	(XR)			; execute it
	EJC
;
;      binary dollar (immediate assignment)
;
;      the pattern built by binary dollar is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
o_ima	ENT				; entry point
	MOV	WB,=p_imc		; set pcode for last node
	MOV	WC,(XS)+		; pop name offset (parm2)
	MOV	XR,(XS)+		; pop name base (parm1)
	JSR	pbild			; build p_imc node
	MOV	XL,XR			; save ptr to node
	MOV	XR,(XS)			; load left argument
	JSR	gtpat			; convert to pattern
	ERR	025,immediate assignment left operand is not pattern
	MOV	(XS),XR			; save ptr to left operand pattern
	MOV	WB,=p_ima		; set pcode for first node
	JSR	pbild			; build p_ima node
	MOV	pthen(XR),(XS)+		; set left operand as p_ima successor
	JSR	pconc			; concatenate to form final pattern
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      indirection (by name)
;
o_inn	ENT				; entry point
	MNZ	WB			; set flag for result by name
	BRN	indir			; jump to common routine
	EJC
;
;      interrogation
;
o_int	ENT				; entry point
	MOV	(XS),=nulls		; replace operand with null
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      indirection (by value)
;
o_inv	ENT				; entry point
	ZER	WB			; set flag for by value
	BRN	indir			; jump to common routine
	EJC
;
;      keyword reference (by name)
;
o_kwn	ENT				; entry point
	JSR	kwnam			; get keyword name
	BRN	exnam			; exit with result name
	EJC
;
;      keyword reference (by value)
;
o_kwv	ENT				; entry point
	JSR	kwnam			; get keyword name
	MOV	dnamp,XR		; delete kvblk
	JSR	acess			; access value
	PPM	exnul			; dummy (unused) failure return
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      load expression by name
;
o_lex	ENT				; entry point
	MOV	WA,*evsi_		; set size of evblk
	JSR	alloc			; allocate space for evblk
	MOV	(XR),=b_evt		; set type word
	MOV	evvar(XR),=trbev	; set dummy trblk pointer
	LCW	WA			; load exblk pointer
	MOV	evexp(XR),WA		; set exblk pointer
	MOV	XL,XR			; move name base to proper reg
	MOV	WA,*evvar		; set name offset = zero
	BRN	exnam			; exit with name in (XL,WA)
	EJC
;
;      load pattern value
;
o_lpt	ENT				; entry point
	LCW	XR			; load pattern pointer
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      load vaRIAble name
;
o_lvn	ENT				; entry point
	LCW	WA			; load vrblk pointer
	MOV	-(XS),WA		; stack vrblk ptr (name base)
	MOV	-(XS),*vrval		; stack name offset
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      binary asterisk (multiplication)
;
o_mlt	ENT				; entry point
	JSR	arith			; fetch arithmetic operands
	ERR	026,multiplication left operand is not numeric
	ERR	027,multiplication right operand is not numeric
.IF    .cnra
.ELSE
	PPM	omlt1			; jump if real operands
.FI
;
;      here to multiply two integers
;
	MLI	icval(XL)		; multiply left operand by right
	INO	exint			; return integer if no overflow
	ERB	028,multiplication caused integer overflow
.IF    .cnra
.ELSE
;
;      here to multiply two reals
;
omlt1	MLR	rcval(XL)		; multiply left operand by right
	RNO	exrea			; return real if no overflow
	ERB	263,multiplication caused real overflow
.FI
	EJC
;
;      name reference
;
o_nam	ENT				; entry point
	MOV	WA,*nmsi_		; set length of nmblk
	JSR	alloc			; allocate nmblk
	MOV	(XR),=b_nml		; set name block code
	MOV	nmofs(XR),(XS)+		; set name offset from operand
	MOV	nmbas(XR),(XS)+		; set name base from operand
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      negation
;
;      initial entry
;
o_nta	ENT				; entry point
	LCW	WA			; load new failure offset
	MOV	-(XS),flptr		; stack old failure pointer
	MOV	-(XS),WA		; stack new failure offset
	MOV	flptr,XS		; set new failure pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      entry after successful evaluation of operand
;
o_ntb	ENT				; entry point
	MOV	flptr,num02(XS)		; restore old failure pointer
	BRN	exfal			; and fail
;
;      entry for failure during operand evaluation
;
o_ntc	ENT				; entry point
	ICA	XS			; pop failure offset
	MOV	flptr,(XS)+		; restore old failure pointer
	BRN	exnul			; exit giving null result
	EJC
;
;      use of undefined operator
;
o_oun	ENT				; entry point
	ERB	029,undefined operator referenced
	EJC
;
;      binary dot (pattern assignment)
;
;      the pattern built by binary dot is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
o_pas	ENT				; entry point
	MOV	WB,=p_pac		; load pcode for p_pac node
	MOV	WC,(XS)+		; load name offset (parm2)
	MOV	XR,(XS)+		; load name base (parm1)
	JSR	pbild			; build p_pac node
	MOV	XL,XR			; save ptr to node
	MOV	XR,(XS)			; load left operand
	JSR	gtpat			; convert to pattern
	ERR	030,pattern assignment left operand is not pattern
	MOV	(XS),XR			; save ptr to left operand pattern
	MOV	WB,=p_paa		; set pcode for p_paa node
	JSR	pbild			; build p_paa node
	MOV	pthen(XR),(XS)+		; set left operand as p_paa successor
	JSR	pconc			; concatenate to form final pattern
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      pattern match (by name, for replacement)
;
o_pmn	ENT				; entry point
	ZER	WB			; set type code for match by name
	BRN	match			; jump to routine to start match
	EJC
;
;      pattern match (statement)
;
;      o_pms is used in place of o_pmv when the pattern match
;      occurs at the outer (statement) level since in this
;      case the substring value need not be constructed.
;
o_pms	ENT				; entry point
	MOV	WB,=num02		; set flag for statement to match
	BRN	match			; jump to routine to start match
	EJC
;
;      pattern match (by value)
;
o_pmv	ENT				; entry point
	MOV	WB,=num01		; set type code for value match
	BRN	match			; jump to routine to start match
	EJC
;
;      pop top item on stack
;
o_pop	ENT				; entry point
	ICA	XS			; pop top stack entry
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      terminate execution (code compiled for end statement)
;
o_stp	ENT				; entry point
	BRN	lend0			; jump to end circuit
	EJC
;
;      return name from expression
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a name. control is returned to the proper point in evalx.
;
o_rnm	ENT				; entry point
	BRN	evlx4			; return to evalx procedure
	EJC
;
;      pattern replacement
;
;      when this routine gets control, the following stack
;      entries have been made (see end of match routine p_nth)
;
;			     subject name base
;			     subject name offset
;			     initial cursor value
;			     final cursor value
;			     subject string pointer
;      (XS) ---------------- replacement value
;
o_rpl	ENT				; entry point
	JSR	gtstg			; convert replacement val to string
	ERR	031,pattern replacement right operand is not a string
;
;      get result length and allocate result scblk
;
	MOV	XL,(XS)			; load subject string pointer
.IF    .cnbf
.ELSE
	BEQ	(XL),=b_bct,orpl4	; branch if buffer assignment
.FI
	ADD	WA,sclen(XL)		; add subject string length
	ADD	WA,num02(XS)		; add starting cursor
	SUB	WA,num01(XS)		; minus final cursor = total length
	BZE	WA,orpl3		; jump if result is null
	MOV	-(XS),XR		; restack replacement string
	JSR	alocs			; allocate scblk for result
	MOV	WA,num03(XS)		; get initial cursor (part 1 len)
	MOV	num03(XS),XR		; stack result pointer
	PSC	XR			; point to characters of result
;
;      move part 1 (start of subject) to result
;
	BZE	WA,orpl1		; jump if first part is null
	MOV	XL,num01(XS)		; else point to subject string
	PLC	XL			; point to subject string chars
	MVC				; move first part to result
	EJC
;      pattern replacement (continued)
;
;      now move in replacement value
;
orpl1	MOV	XL,(XS)+		; load replacement string, pop
	MOV	WA,sclen(XL)		; load length
	BZE	WA,orpl2		; jump if null replacement
	PLC	XL			; else point to chars of replacement
	MVC				; move in chars (part 2)
;
;      now move in remainder of string (part 3)
;
orpl2	MOV	XL,(XS)+		; load subject string pointer, pop
	MOV	WC,(XS)+		; load final cursor, pop
	MOV	WA,sclen(XL)		; load subject string length
	SUB	WA,WC			; minus final cursor = part 3 length
	BZE	WA,oass0		; jump to assign if part 3 is null
	PLC	XL,WC			; else point to last part of string
	MVC				; move part 3 to result
	BRN	oass0			; jump to perform assignment
;
;      here if result is null
;
orpl3	ADD	XS,*num02		; pop subject str ptr, final cursor
	MOV	(XS),=nulls		; set null result
	BRN	oass0			; jump to assign null value
.IF    .cnbf
.ELSE
;
;      here for buffer substring assignment
;
orpl4	MOV	XL,XR			; copy scblk replacement ptr
	MOV	XR,(XS)+		; unstack bcblk ptr
	MOV	WB,(XS)+		; get final cursor value
	MOV	WA,(XS)+		; get initial cursor
	SUB	WB,WA			; get length in WB
	ADD	XS,*num01		; get rid of name offset
	MOV	(XS),XR			; store buffer result over name base
	JSR	insbf			; insert substring
	PPM				; convert fail impossible
	PPM	exfal			; fail if insert fails
	LCW	XR			; result on stack, get code word
	BRI	(XR)			; execute next code word
.FI
	EJC
;
;      return value from expression
;
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a value. control is returned to the proper point in evalx
;
o_rvl	ENT				; entry point
	BRN	evlx3			; return to evalx procedure
	EJC
;
;      selection
;
;      initial entry
;
o_sla	ENT				; entry point
	LCW	WA			; load new failure offset
	MOV	-(XS),flptr		; stack old failure pointer
	MOV	-(XS),WA		; stack new failure offset
	MOV	flptr,XS		; set new failure pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      entry after successful evaluation of alternative
;
o_slb	ENT				; entry point
	MOV	XR,(XS)+		; load result
	ICA	XS			; pop fail offset
	MOV	flptr,(XS)		; restore old failure pointer
	MOV	(XS),XR			; restack result
	LCW	WA			; load new code offset
	ADD	WA,r_cod		; point to absolute code location
	LCP	WA			; set new code pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      entry at start of subsequent alternatives
;
o_slc	ENT				; entry point
	LCW	WA			; load new fail offset
	MOV	(XS),WA			; store new fail offset
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      entry at start of last alternative
;
o_sld	ENT				; entry point
	ICA	XS			; pop failure offset
	MOV	flptr,(XS)+		; restore old failure pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      binary minus (subtraction)
;
o_sub	ENT				; entry point
	JSR	arith			; fetch arithmetic operands
	ERR	032,subtraction left operand is not numeric
	ERR	033,subtraction right operand is not numeric
.IF    .cnra
.ELSE
	PPM	osub1			; jump if real operands
.FI
;
;      here to subtract two integers
;
	SBI	icval(XL)		; subtract right operand from left
	INO	exint			; return integer if no overflow
	ERB	034,subtraction caused integer overflow
.IF    .cnra
.ELSE
;
;      here to subtract two reals
;
osub1	SBR	rcval(XL)		; subtract right operand from left
	RNO	exrea			; return real if no overflow
	ERB	264,subtraction caused real overflow
.FI
	EJC
;
;      dummy operator to return control to trxeq procedure
;
o_txr	ENT				; entry point
	BRN	trxq1			; jump into trxeq procedure
	EJC
;
;      unexpected failure
;
;      note that if a setexit trap is operating then
;      transfer to system label continue
;      will result in looping here.  difficult to avoid except
;      with a considerable overhead which is not worthwhile or
;      else by a technique such as setting kverl to zero.
;
o_unf	ENT				; entry point
	ERB	035,unexpected failure in -nofail mode
	TTL	s p i t b o l -- block action routines
;
;      the first word of every block in dynamic storage and the
;      vrget, vrsto and vrtra fields of a vrblk contain a
;      pointer to an entry point in the program. all such entry
;      points are in the following section except those for
;      pattern blocks which are in the pattern matching segment
;      later on (labels of the form p_xxx), and dope vectors
;      (d_xxx) which are in the dope vector section following
;      the pattern routines (dope vectors are used for cmblks).
;
;      the entry points in this section have labels of the
;      form b_xxy where xx is the two character block type for
;      the corresponding block and y is any letter.
;
;      in some cases, the pointers serve no other purpose than
;      to identify the block type. in this case the routine
;      is never executed and thus no code is assembled.
;
;      for each of these entry points corresponding to a block
;      an entry point identification is assembled (bl_xx).
;
;      the exact entry conditions depend on the manner in
;      which the routine is accessed and are documented with
;      the individual routines as required.
;
;      the order of these routines is alphabetical with the
;      following exceptions.
;
;      the routines for seblk and exblk entries occur first so
;      that expressions can be quickly identified from the fact
;      that their routines lie before the symbol b_e__.
;
;      these are immediately followed by the routine for a trblk
;      so that the test against the symbol b_t__ checks for
;      trapped values or expression values (see procedure evalp)
;
;      the pattern routines lie after this section so that
;      patterns are identified with routines starting at or
;      after the initial instruction in these routines (p_aaa).
;
;      the symbol b_aaa defines the first location for block
;      routines and the symbol p_yyy (at the end of the pattern
;      match routines section) defines the last such entry point
;
b_aaa	ENT	bl__i			; entry point of first block routine
	EJC
;
;      exblk
;
;      the routine for an exblk loads the expression onto
;      the stack as a value.
;
;      (XR)		     pointer to exblk
;
b_exl	ENT	bl_ex			; entry point (exblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      seblk
;
;      the routine for seblk is accessed from the generated
;      code to load the expression value onto the stack.
;
b_sel	ENT	bl_se			; entry point (seblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      define symbol which marks end of entries for expressions
;
b_e__	ENT	bl__i			; entry point
	EJC
;
;      trblk
;
;      the routine for a trblk is never executed
;
b_trt	ENT	bl_tr			; entry point (trblk)
;
;      define symbol marking end of trap and expression blocks
;
b_t__	ENT	bl__i			; end of trblk,seblk,exblk entries
	EJC
;
;      arblk
;
;      the routine for arblk is never executed
;
b_art	ENT	bl_ar			; entry point (arblk)
	EJC
;
;      bcblk
;
;      the routine for a bcblk is never executed
;
;      (XR)		     pointer to bcblk
;
b_bct	ENT	bl_bc			; entry point (bcblk)
	EJC
;
;      bfblk
;
;      the routine for a bfblk is never executed
;
;      (XR)		     pointer to bfblk
;
b_bft	ENT	bl_bf			; entry point (bfblk)
	EJC
;
;      ccblk
;
;      the routine for ccblk is never entered
;
b_cct	ENT	bl_cc			; entry point (ccblk)
	EJC
;
;      cdblk
;
;      the cdblk routines are executed from the generated code.
;      there are two cases depending on the form of cdfal.
;
;      entry for complex failure code at cdfal
;
;      (XR)		     pointer to cdblk
;
b_cdc	ENT	bl_cd			; entry point (cdblk)
bcdc0	MOV	XS,flptr		; pop garbage off stack
	MOV	(XS),cdfal(XR)		; set failure offset
	BRN	stmgo			; enter stmt
	EJC
;
;      cdblk (continued)
;
;      entry for simple failure code at cdfal
;
;      (XR)		     pointer to cdblk
;
b_cds	ENT	bl_cd			; entry point (cdblk)
bcds0	MOV	XS,flptr		; pop garbage off stack
	MOV	(XS),*cdfal		; set failure offset
	BRN	stmgo			; enter stmt
	EJC
;
;      cmblk
;
;      the routine for a cmblk is never executed
;
b_cmt	ENT	bl_cm			; entry point (cmblk)
	EJC
;
;      ctblk
;
;      the routine for a ctblk is never executed
;
b_ctt	ENT	bl_ct			; entry point (ctblk)
	EJC
;
;      dfblk
;
;      the routine for a dfblk is accessed from the o_fnc entry
;      to call a datatype function and build a pdblk.
;
;      (XL)		     pointer to dfblk
;
b_dfc	ENT	bl_df			; entry point
	MOV	WA,dfpdl(XL)		; load length of pdblk
	JSR	alloc			; allocate pdblk
	MOV	(XR),=b_pdt		; store type word
	MOV	pddfp(XR),XL		; store dfblk pointer
	MOV	WC,XR			; save pointer to pdblk
	ADD	XR,WA			; point past pdblk
	LCT	WA,fargs(XL)		; set to count fields
;
;      loop to acquire field values from stack
;
bdfc1	MOV	-(XR),(XS)+		; move a field value
	BCT	WA,bdfc1		; loop till all moved
	MOV	XR,WC			; recall pointer to pdblk
	BRN	eXSid			; exit setting id field
	EJC
;
;      efblk
;
;      the routine for an efblk is passed control form the o_fnc
;      entry to call an eXTernal function.
;
;      (XL)		     pointer to efblk
;
b_efc	ENT	bl_ef			; entry point (efblk)
.IF    .cnld
.ELSE
	MOV	WC,fargs(XL)		; load number of arguments
	WTB	WC			; convert to offset
	MOV	-(XS),XL		; save pointer to efblk
	MOV	XT,XS			; copy pointer to arguments
;
;      loop to convert arguments
;
befc1	ICA	XT			; point to next entry
	MOV	XR,(XS)			; load pointer to efblk
	DCA	WC			; decrement eftar offset
	ADD	XR,WC			; point to next eftar entry
	MOV	XR,eftar(XR)		; load eftar entry
.IF    .cnra
.IF    .cnlf
	BSW	XR,4			; switch on type
.ELSE
	BSW	XR,3			; switch on type
.FI
.ELSE
.IF    .cnlf
	BSW	XR,5			; switch on type
.ELSE
	BSW	XR,4			; switch on type
.FI
.FI
	IFF	0,befc7			; no conversion needed
	IFF	1,befc2			; string
	IFF	2,befc3			; integer
.IF    .cnra
.IF    .cnlf
	IFF	3,beff1			; file
.FI
.ELSE
	IFF	3,befc4			; real
.IF    .cnlf
	IFF	4,beff1			; file
.FI
.FI
	ESW				; end of switch on type
.IF    .cnlf
;
;      here to convert to file
;
beff1	MOV	-(XS),XT		; save entry pointer
	MOV	befof,WC		; save offset
	MOV	-(XS),(XT)		; stack arg pointer
	JSR	iofcb			; convert to fcb
	ERR	298,eXTernal function argument is not file
	ERR	298,eXTernal function argument is not file
	ERR	298,eXTernal function argument is not file
	MOV	XR,WA			; point to fcb
	MOV	XT,(XS)+		; reload entry pointer
	BRN	befc5			; jump to merge
.FI
;
;      here to convert to string
;
befc2	MOV	-(XS),(XT)		; stack arg ptr
	JSR	gtstg			; convert argument to string
	ERR	039,eXTernal function argument is not a string
	BRN	befc6			; jump to merge
	EJC
;
;      efblk (continued)
;
;      here to convert an integer
;
befc3	MOV	XR,(XT)			; load next argument
	MOV	befof,WC		; save offset
	JSR	gtint			; convert to integer
	ERR	040,eXTernal function argument is not integer
.IF    .cnra
.ELSE
	BRN	befc5			; merge with real case
;
;      here to convert a real
;
befc4	MOV	XR,(XT)			; load next argument
	MOV	befof,WC		; save offset
	JSR	gtrea			; convert to real
	ERR	265,eXTernal function argument is not real
.FI
;
;      integer case merges here
;
befc5	MOV	WC,befof		; restore offset
;
;      string merges here
;
befc6	MOV	(XT),XR			; store converted result
;
;      no conversion merges here
;
befc7	BNZ	WC,befc1		; loop back if more to go
;
;      here after converting all the arguments
;
	MOV	XL,(XS)+		; restore efblk pointer
	MOV	WA,fargs(XL)		; get number of args
	JSR	sysex			; call routine to call eXTernal fnc
	PPM	exfal			; fail if failure
	ERR	327,calling eXTernal function - not found
	ERR	326,calling eXTernal function - bad argument type
.IF    .cexp
	WTB	WA			; convert number of args to bytes
	ADD	XS,WA			; remove arguments from stack
.FI
	EJC
;
;      efblk (continued)
;
;      return here with result in XR
;
;      first defend against non-standard null string returned
;
	MOV	WB,efrsl(XL)		; get result type id
	BNZ	WB,befa8		; branch if not unconverted
	BNE	(XR),=b_scl,befc8	; jump if not a string
	BZE	sclen(XR),exnul		; return null if null
;
;      here if converted result to check for null string
;
befa8	BNE	WB,=num01,befc8		; jump if not a string
	BZE	sclen(XR),exnul		; return null if null
;
;      return if result is in dynamic storage
;
befc8	BLT	XR,dnamb,befc9		; jump if not in dynamic storage
	BLE	XR,dnamp,exiXR		; return result if already dynamic
;
;      here we copy a result into the dynamic region
;
befc9	MOV	WA,(XR)			; get possible type word
	BZE	WB,bef11		; jump if unconverted result
	MOV	WA,=b_scl		; string
	BEQ	WB,=num01,bef10		; yes jump
	MOV	WA,=b_icl		; integer
	BEQ	WB,=num02,bef10		; yes jump
.IF    .cnra
.ELSE
	MOV	WA,=b_rcl		; real
.FI
;
;      store type word in result
;
bef10	MOV	(XR),WA			; stored before copying to dynamic
;
;      merge for unconverted result
;
bef11	BEQ	(XR),=b_scl,bef12	; branch if string result
	JSR	blkln			; get length of block
	MOV	XL,XR			; copy address of old block
	JSR	alloc			; allocate dynamic block same size
	MOV	-(XS),XR		; set pointer to new block as result
	MVW				; copy old block to dynamic block
	ZER	XL			; clear garbage value
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      here to return a string result that was not in dynamic.
;      cannot use the simple word copy above because it will not
;      guarantee zero padding in the last word.
;
bef12	MOV	XL,XR			; save source string pointer
	MOV	WA,sclen(XR)		; fetch string length
	BZE	WA,exnul		; return null string if length zero
	JSR	alocs			; allocate space for string
	MOV	-(XS),XR		; save as result pointer
	PSC	XR			; prepare to store chars of result
	PLC	XL			; point to chars in source string
	MOV	WA,WC			; number of characters to copy
	MVC				; move characters to result string
	ZER	XL			; clear garbage value
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
.FI
	EJC
;
;      evblk
;
;      the routine for an evblk is never executed
;
b_evt	ENT	bl_ev			; entry point (evblk)
	EJC
;
;      ffblk
;
;      the routine for an ffblk is executed from the o_fnc entry
;      to call a field function and eXTract a field value/name.
;
;      (XL)		     pointer to ffblk
;
b_ffc	ENT	bl_ff			; entry point (ffblk)
	MOV	XR,XL			; copy ffblk pointer
	LCW	WC			; load next code word
	MOV	XL,(XS)			; load pdblk pointer
	BNE	(XL),=b_pdt,bffc2	; jump if not pdblk at all
	MOV	WA,pddfp(XL)		; load dfblk pointer from pdblk
;
;      loop to find correct ffblk for this pdblk
;
bffc1	BEQ	WA,ffdfp(XR),bffc3	; jump if this is the correct ffblk
	MOV	XR,ffnxt(XR)		; else link to next ffblk on chain
	BNZ	XR,bffc1		; loop back if another entry to check
;
;      here for bad argument
;
bffc2	ERB	041,field function argument is wrong datatype
	EJC
;
;      ffblk (continued)
;
;      here after locating correct ffblk
;
bffc3	MOV	WA,ffofs(XR)		; load field offset
	BEQ	WC,=ofne_,bffc5		; jump if called by name
	ADD	XL,WA			; else point to value field
	MOV	XR,(XL)			; load value
	BNE	(XR),=b_trt,bffc4	; jump if not trapped
	SUB	XL,WA			; else restore name base,offset
	MOV	(XS),WC			; save next code word over pdblk ptr
	JSR	acess			; access value
	PPM	exfal			; fail if access fails
	MOV	WC,(XS)			; restore next code word
;
;      here after getting value in (XR), XL is garbage
;
bffc4	MOV	(XS),XR			; store value on stack (over pdblk)
	MOV	XR,WC			; copy next code word
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to routine for next code word
;
;      here if called by name
;
bffc5	MOV	-(XS),WA		; store name offset (base is set)
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      icblk
;
;      the routine for icblk is executed from the generated
;      code to load an integer value onto the stack.
;
;      (XR)		     pointer to icblk
;
b_icl	ENT	bl_ic			; entry point (icblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      kvblk
;
;      the routine for a kvblk is never executed.
;
b_kvt	ENT	bl_kv			; entry point (kvblk)
	EJC
;
;      nmblk
;
;      the routine for a nmblk is executed from the generated
;      code for the case of loading a name onto the stack
;      where the name is that of a natural vaRIAble which can
;      be preevaluated at compile time.
;
;      (XR)		     pointer to nmblk
;
b_nml	ENT	bl_nm			; entry point (nmblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      pdblk
;
;      the routine for a pdblk is never executed
;
b_pdt	ENT	bl_pd			; entry point (pdblk)
	EJC
;
;      pfblk
;
;      the routine for a pfblk is executed from the entry o_fnc
;      to call a program defined function.
;
;      (XL)		     pointer to pfblk
;
;      the following stack entries are made before passing
;      control to the program defined function.
;
;			     saved value of first argument
;			     .
;			     saved value of last argument
;			     saved value of first local
;			     .
;			     saved value of last local
;			     saved value of function name
;			     saved code block ptr (r_cod)
;			     saved code pointer (-r_cod)
;			     saved value of flprt
;			     saved value of flptr
;			     pointer to pfblk
;      flptr --------------- zero (to be overwritten with offs)
;
b_pfc	ENT	bl_pf			; entry point (pfblk)
	MOV	bpfpf,XL		; save pfblk ptr (need not be reloc)
	MOV	XR,XL			; copy for the moment
	MOV	XL,pfvbl(XR)		; point to vrblk for function
;
;      loop to find old value of function
;
bpf01	MOV	WB,XL			; save pointer
	MOV	XL,vrval(XL)		; load value
	BEQ	(XL),=b_trt,bpf01	; loop if trblk
;
;      set value to null and save old function value
;
	MOV	bpfsv,XL		; save old value
	MOV	XL,WB			; point back to block with value
	MOV	vrval(XL),=nulls	; set value to null
	MOV	WA,fargs(XR)		; load number of arguments
	ADD	XR,*pfarg		; point to pfarg entries
	BZE	WA,bpf04		; jump if no arguments
	MOV	XT,XS			; ptr to last arg
	WTB	WA			; convert no. of args to bytes offset
	ADD	XT,WA			; point before first arg
	MOV	bpfxt,XT		; remember arg pointer
	EJC
;
;      pfblk (continued)
;
;      loop to save old argument values and set new ones
;
bpf02	MOV	XL,(XR)+		; load vrblk ptr for next argument
;
;      loop through possible trblk chain to find value
;
bpf03	MOV	WC,XL			; save pointer
	MOV	XL,vrval(XL)		; load next value
	BEQ	(XL),=b_trt,bpf03	; loop back if trblk
;
;      save old value and get new value
;
	MOV	WA,XL			; keep old value
	MOV	XT,bpfxt		; point before next stacked arg
	MOV	WB,-(XT)		; load argument (new value)
	MOV	(XT),WA			; save old value
	MOV	bpfxt,XT		; keep arg ptr for next time
	MOV	XL,WC			; point back to block with value
	MOV	vrval(XL),WB		; set new value
	BNE	XS,bpfxt,bpf02		; loop if not all done
;
;      now process locals
;
bpf04	MOV	XL,bpfpf		; restore pfblk pointer
	MOV	WA,pfnlo(XL)		; load number of locals
	BZE	WA,bpf07		; jump if no locals
	MOV	WB,=nulls		; get null constant
	LCT	WA,WA			; set local counter
;
;      loop to process locals
;
bpf05	MOV	XL,(XR)+		; load vrblk ptr for next local
;
;      loop through possible trblk chain to find value
;
bpf06	MOV	WC,XL			; save pointer
	MOV	XL,vrval(XL)		; load next value
	BEQ	(XL),=b_trt,bpf06	; loop back if trblk
;
;      save old value and set null as new value
;
	MOV	-(XS),XL		; stack old value
	MOV	XL,WC			; point back to block with value
	MOV	vrval(XL),WB		; set null as new value
	BCT	WA,bpf05		; loop till all locals processed
	EJC
;
;      pfblk (continued)
;
;      here after processing arguments and locals
;
.IF    .cnpf
bpf07	MOV	WA,r_cod		; load old code block pointer
.ELSE
bpf07	ZER	XR			; zero reg XR in case
	BZE	kvpfl,bpf7c		; skip if profiling is off
	BEQ	kvpfl,=num02,bpf7a	; branch on type of profile
;
;      here if &profile = 1
;
	JSR	systm			; get current time
	STI	pfetm			; save for a sec
	SBI	pfstm			; find time used by caller
	JSR	icbld			; build into an icblk
	LDI	pfetm			; reload current time
	BRN	bpf7b			; merge
;
;	here if &profile = 2
;
bpf7a	LDI	pfstm			; get start time of calling stmt
	JSR	icbld			; assemble an icblk round it
	JSR	systm			; get now time
;
;      both types of profile merge here
;
bpf7b	STI	pfstm			; set start time of 1st func stmt
	MNZ	pffnc			; flag function entry
;
;      no profiling merges here
;
bpf7c	MOV	-(XS),XR		; stack icblk ptr (or zero)
	MOV	WA,r_cod		; load old code block pointer
.FI
	SCP	WB			; get code pointer
	SUB	WB,WA			; make code pointer into offset
	MOV	XL,bpfpf		; recall pfblk pointer
	MOV	-(XS),bpfsv		; stack old value of function name
	MOV	-(XS),WA		; stack code block pointer
	MOV	-(XS),WB		; stack code offset
	MOV	-(XS),flprt		; stack old flprt
	MOV	-(XS),flptr		; stack old failure pointer
	MOV	-(XS),XL		; stack pointer to pfblk
	ZER	-(XS)			; dummy zero entry for fail return
	CHK				; check for stack overflow
	MOV	flptr,XS		; set new fail return value
	MOV	flprt,XS		; set new flprt
	MOV	WA,kvtra		; load trace value
	ADD	WA,kvftr		; add ftrace value
	BNZ	WA,bpf09		; jump if tracing possible
	ICV	kvfnc			; else bump fnclevel
;
;      here to actually jump to function
;
bpf08	MOV	XR,pfcod(XL)		; point to vrblk of entry label
	MOV	XR,vrlbl(XR)		; point to target code
	BEQ	XR,=stndl,bpf17		; test for undefined label
	BNE	(XR),=b_trt,bpf8a	; jump if not trapped
	MOV	XR,trlbl(XR)		; else load ptr to real label code
bpf8a	BRI	(XR)			; off to execute function
;
;      here if tracing is possible
;
bpf09	MOV	XR,pfctr(XL)		; load possible call trace trblk
	MOV	XL,pfvbl(XL)		; load vrblk pointer for function
	MOV	WA,*vrval		; set name offset for vaRIAble
	BZE	kvtra,bpf10		; jump if trace mode is off
	BZE	XR,bpf10		; or if there is no call trace
;
;      here if call traced
;
	DCV	kvtra			; decrement trace count
	BZE	trfnc(XR),bpf11		; jump if print trace
	JSR	trxeq			; execute function type trace
	EJC
;
;      pfblk (continued)
;
;      here to test for ftrace trace
;
bpf10	BZE	kvftr,bpf16		; jump if ftrace is off
	DCV	kvftr			; else decrement ftrace
;
;      here for print trace
;
bpf11	JSR	prtsn			; print statement number
	JSR	prtnm			; print function name
	MOV	WA,=ch_pp		; load left paren
	JSR	prtch			; print left paren
	MOV	XL,num01(XS)		; recover pfblk pointer
	BZE	fargs(XL),bpf15		; skip if no arguments
	ZER	WB			; else set argument counter
	BRN	bpf13			; jump into loop
;
;      loop to print argument values
;
bpf12	MOV	WA,=ch_cm		; load comma
	JSR	prtch			; print to separate from last arg
;
;      merge here first time (no comma required)
;
bpf13	MOV	(XS),WB			; save arg ctr (over failoffs is ok)
	WTB	WB			; convert to byte offset
	ADD	XL,WB			; point to next argument pointer
	MOV	XR,pfarg(XL)		; load next argument vrblk ptr
	SUB	XL,WB			; restore pfblk pointer
	MOV	XR,vrval(XR)		; load next value
	JSR	prtvl			; print argument value
	EJC
;
;      here after dealing with one argument
;
	MOV	WB,(XS)			; restore argument counter
	ICV	WB			; increment argument counter
	BLT	WB,fargs(XL),bpf12	; loop if more to print
;
;      merge here in no args case to print paren
;
bpf15	MOV	WA,=ch_rp		; load right paren
	JSR	prtch			; print to terminate output
	JSR	prtnl			; terminate print line
;
;      merge here to exit with test for fnclevel trace
;
bpf16	ICV	kvfnc			; increment fnclevel
	MOV	XL,r_fnc		; load ptr to possible trblk
	JSR	ktrex			; call keyword trace routine
;
;      call function after trace tests complete
;
	MOV	XL,num01(XS)		; restore pfblk pointer
	BRN	bpf08			; jump back to execute function
;
;      here if calling a function whose entry label is undefined
;
bpf17	MOV	flptr,num02(XS)		; reset so exfal can return to evalx
	ERB	286,function call to undefined entry label
.IF    .cnra
.ELSE
	EJC
;
;      rcblk
;
;      the routine for an rcblk is executed from the generated
;      code to load a real value onto the stack.
;
;      (XR)		     pointer to rcblk
;
b_rcl	ENT	bl_rc			; entry point (rcblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.FI
	EJC
;
;      scblk
;
;      the routine for an scblk is executed from the generated
;      code to load a string value onto the stack.
;
;      (XR)		     pointer to scblk
;
b_scl	ENT	bl_sc			; entry point (scblk)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      tbblk
;
;      the routine for a tbblk is never executed
;
b_tbt	ENT	bl_tb			; entry point (tbblk)
	EJC
;
;      teblk
;
;      the routine for a teblk is never executed
;
b_tet	ENT	bl_te			; entry point (teblk)
	EJC
;
;      vcblk
;
;      the routine for a vcblk is never executed
;
b_vct	ENT	bl_vc			; entry point (vcblk)
	EJC
;
;      vrblk
;
;      the vrblk routines are executed from the generated code.
;      there are six entries for vrblk covering various cases
;
b_vr_	ENT	bl__i			; mark start of vrblk entry points
;
;      entry for vrget (trapped case). this routine is called
;      from the generated code to load the value of a vaRIAble.
;      this entry point is used if an access trace or input
;      association is currently active.
;
;      (XR)		     pointer to vrget field of vrblk
;
b_vra	ENT	bl__i			; entry point
	MOV	XL,XR			; copy name base (vrget = 0)
	MOV	WA,*vrval		; set name offset
	JSR	acess			; access value
	PPM	exfal			; fail if access fails
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      vrblk (continued)
;
;      entry for vrsto (error case. this routine is called from
;      the executed code for an attempt to modify the value
;      of a protected (pattern valued) natural vaRIAble.
;
b_vre	ENT				; entry point
	ERB	042,attempt to change value of protected vaRIAble
	EJC
;
;      vrblk (continued)
;
;      entry for vrtra (untrapped case). this routine is called
;      from the executed code to transfer to a label.
;
;      (XR)		     pointer to vrtra field of vrblk
;
b_vrg	ENT				; entry point
	MOV	XR,vrlbo(XR)		; load code pointer
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to routine for next code word
	EJC
;
;      vrblk (continued)
;
;      entry for vrget (untrapped case). this routine is called
;      from the generated code to load the value of a vaRIAble.
;
;      (XR)		     points to vrget field of vrblk
;
b_vrl	ENT				; entry point
	MOV	-(XS),vrval(XR)		; load value onto stack (vrget = 0)
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      vrblk (continued)
;
;      entry for vrsto (untrapped case). this routine is called
;      from the generated code to store the value of a vaRIAble.
;
;      (XR)		     pointer to vrsto field of vrblk
;
b_vrs	ENT				; entry point
	MOV	vrvlo(XR),(XS)		; store value, leave on stack
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      vrblk (continued)
;
;      vrtra (trapped case). this routine is called from the
;      generated code to transfer to a label when a label
;      trace is currently active.
;
b_vrt	ENT				; entry point
	SUB	XR,*vrtra		; point back to start of vrblk
	MOV	XL,XR			; copy vrblk pointer
	MOV	WA,*vrval		; set name offset
	MOV	XR,vrlbl(XL)		; load pointer to trblk
	BZE	kvtra,bvrt2		; jump if trace is off
	DCV	kvtra			; else decrement trace count
	BZE	trfnc(XR),bvrt1		; jump if print trace case
	JSR	trxeq			; else execute full trace
	BRN	bvrt2			; merge to jump to label
;
;      here for print trace -- print colon ( label name )
;
bvrt1	JSR	prtsn			; print statement number
	MOV	XR,XL			; copy vrblk pointer
	MOV	WA,=ch_cl		; colon
	JSR	prtch			; print it
	MOV	WA,=ch_pp		; left paren
	JSR	prtch			; print it
	JSR	prtvn			; print label name
	MOV	WA,=ch_rp		; right paren
	JSR	prtch			; print it
	JSR	prtnl			; terminate line
	MOV	XR,vrlbl(XL)		; point back to trblk
;
;      merge here to jump to label
;
bvrt2	MOV	XR,trlbl(XR)		; load pointer to actual code
	BRI	(XR)			; execute statement at label
	EJC
;
;      vrblk (continued)
;
;      entry for vrsto (trapped case). this routine is called
;      from the generated code to store the value of a vaRIAble.
;      this entry is used when a value trace or output
;      association is currently active.
;
;      (XR)		     pointer to vrsto field of vrblk
;
b_vrv	ENT				; entry point
	MOV	WB,(XS)			; load value (leave copy on stack)
	SUB	XR,*vrsto		; point to vrblk
	MOV	XL,XR			; copy vrblk pointer
	MOV	WA,*vrval		; set offset
	JSR	asign			; call assignment routine
	PPM	exfal			; fail if assignment fails
	LCW	XR			; else get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      xnblk
;
;      the routine for an xnblk is never executed
;
b_xnt	ENT	bl_xn			; entry point (xnblk)
	EJC
;
;      XRblk
;
;      the routine for an XRblk is never executed
;
b_xrt	ENT	bl_xr			; entry point (XRblk)
;
;      mark entry address past last block action routine
;
b_yyy	ENT	bl__i			; last block routine entry point
	TTL	s p i t b o l -- pattern matching routines
;
;      the following section consists of the pattern matching
;      routines. all pattern nodes contain a pointer (pcode)
;      to one of the routines in this section (p_xxx).
;
;      note that this section follows the b_xxx routines to
;      enable a fast test for the pattern datatype.
;
p_aaa	ENT	bl__i			; entry to mark first pattern
;
;
;      the entry conditions to the match routine are as follows
;      (see o_pmn, o_pmv, o_pms and procedure match).
;
;      stack contents.
;
;			     name base (o_pmn only)
;			     name offset (o_pmn only)
;			     type (0-o_pmn, 1-o_pmv, 2-o_pms)
;      pmhbs --------------- initial cursor (zero)
;			     initial node pointer
;      XS ------------------ =ndabo (anchored), =nduna (unanch)
;
;      register values.
;
;	    (XS)	     set as shown in stack diagram
;	    (XR)	     pointer to initial pattern node
;	    (WB)	     initial cursor (zero)
;
;      global pattern values
;
;	    r_pms	     pointer to subject string scblk
;	    pmssl	     length of subject string in chars
;	    pmdfl	     dot flag, initially zero
;	    pmhbs	     set as shown in stack diagram
;
;      control is passed by branching through the pcode
;      field of the initial pattern node (bri (XR)).
	EJC
;
;      description of algorithm
;
;      a pattern structure is represented as a linked graph
;      of nodes with the following structure.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
;      pcode is a pointer to the routine which will perform
;      the match of this particular node type.
;
;      pthen is a pointer to the successor node. i.e. the node
;      to be matched if the attempt to match this node succeeds.
;      if this is the last node of the pattern pthen points
;      to the dummy node ndnth which initiates pattern exit.
;
;      parm1, parm2 are parameters whose use varies with the
;      particular node. they are only present if required.
;
;      alternatives are handled with the special alternative
;      node whose parameter points to the node to be matched
;      if there is a failure on the successor path.
;
;      the following example illustrates the manner in which
;      the structure is built up. the pattern is
;
;      (a / b / c) (d / e)   where / is alternation
;
;      in the diagram, the node marked + represents an
;      alternative node and the dotted line from a + node
;      represents the parameter pointer to the alternative.
;
;      +---+	 +---+	   +---+     +---+
;      i + i-----i a i-----i + i-----i d i-----
;      +---+	 +---+	i  +---+     +---+
;	 .		i    .
;	 .		i    .
;      +---+	 +---+	i  +---+
;      i + i-----i b i--i  i e i-----
;      +---+	 +---+	i  +---+
;	 .		i
;	 .		i
;      +---+		i
;      i c i------------i
;      +---+
	EJC
;
;      during the match, the registers are used as follows.
;
;      (XR)		     points to the current node
;      (XL)		     scratch
;      (XS)		     main stack pointer
;      (WB)		     cursor (number of chars matched)
;      (wa,WC)		     scratch
;
;      to keep track of alternatives, the main stack is used as
;      a history stack and contains two word entries.
;
;      word 1		     saved cursor value
;      word 2		     node to match on failure
;
;      when a failure occurs, the most recent entry on this
;      stack is popped off to restore the cursor and point
;      to the node to be matched as an alternative. the entry
;      at the bottom of the stack points to the following
;      special nodes depending on the scan mode.
;
;      anchored mode	     the bottom entry points to the
;			     special node ndabo which causes an
;			     abort. the cursor value stored
;			     with this entry is always zero.
;
;      unanchored mode	     the bottom entry points to the
;			     special node nduna which moves the
;			     anchor point and restarts the match
;			     the cursor saved with this entry
;			     is the number of characters which
;			     lie before the initial anchor point
;			     (i.e. the number of anchor moves).
;			     this entry is three words long and
;			     also contains the initial pattern.
;
;      entries are made on this history stack by alternative
;      nodes and by some special compound patterns as described
;      later on. the following global locations are used during
;      pattern matching.
;
;      r_pms		     pointer to subject string
;      pmssl		     length of subject string
;      pmdfl		     flag set non-zero for dot patterns
;      pmhbs		     base ptr for current history stack
;
;      the following exit points are available to match routines
;
;      succP		     success in matching current node
;      failp		     failure in matching current node
	EJC
;
;      compound patterns
;
;      some patterns have implicit alternatives and their
;      representation in the pattern structure consists of a
;      linked set of nodes as indicated by these diagrams.
;
;      as before, the + represents an alternative node and
;      the dotted line from a + node is the parameter pointer
;      to the alternative pattern.
;
;      arb
;      ---
;
;	    +---+	     this node (p_arb) matches null
;	    i b i-----	     and stacks cursor, successor ptr,
;	    +---+	     cursor (copy) and a ptr to ndarc.
;
;
;
;
;      bal
;      ---
;
;	    +---+	     the p_bal node scans a balanced
;	    i b i-----	     string and then stacks a pointer
;	    +---+	     to itself on the history stack.
	EJC
;
;      compound pattern structures (continued)
;
;
;      arbno
;      -----
;
;	    +---+	     this alternative node matches null
;      +----i + i-----	     the first time and stacks a pointer
;      i    +---+	     to the argument pattern x.
;      i      .
;      i      .
;      i    +---+	     node (p_aba) to stack cursor
;      i    i a i	     and history stack base ptr.
;      i    +---+
;      i      i
;      i      i
;      i    +---+	     this is the argument pattern. as
;      i    i x i	     indicated, the successor of the
;      i    +---+	     pattern is the p_abc node
;      i      i
;      i      i
;      i    +---+	     this node (p_abc) pops pmhbs,
;      +----i c i	     stacks old pmhbs and ptr to ndabd
;	    +---+	     (unless optimization has occurred)
;
;      structure and execution of this pattern resemble those of
;      recursive pattern matching and immediate assignment.
;      the alternative node at the head of the structure matches
;      null initially but on subsequent failure ensures attempt
;      to match the argument.  before the argument is matched
;      p_aba stacks the cursor, pmhbs and a ptr to p_abb.  if
;      the argument cant be matched , p_abb removes this special
;      stack entry and fails.
;      if argument is matched , p_abc restores the outer pmhbs
;      value (saved by p_aba) .	 then if the argument has left
;      alternatives on stack it stacks the inner value of pmhbs
;      and a ptr to ndabd. if argument left nothing on the stack
;      it optimises by removing items stacked by p_aba.	 finally
;      a check is made that argument matched more than the null
;      string (check is intended to prevent useless looping).
;      if so the successor is again the alternative node at the
;      head of the structure , ensuring a possible eXTra attempt
;      to match the arg if necessary.  if not , the successor to
;      alternative is taken so as to terminate the loop.  p_abd
;      restores inner pmhbs ptr and fails , thus trying to match
;      alternatives left by the arbno argument.
	EJC
;
;      compound pattern structures (continued)
;
;      breakx
;      ------
;
;	    +---+	     this node is a break node for
;      +----i b i	     the argument to breakx, identical
;      i    +---+	     to an ordinary break node.
;      i      i
;      i      i
;      i    +---+	     this alternative node stacks a
;      i    i + i-----	     pointer to the breakx node to
;      i    +---+	     allow for subsequent failure
;      i      .
;      i      .
;      i    +---+	     this is the breakx node itself. it
;      +----i x i	     matches one character and then
;	    +---+	     proceeds back to the break node.
;
;
;
;
;      fence
;      -----
;
;	    +---+	     the fence node matches null and
;	    i f i-----	     stacks a pointer to node ndabo to
;	    +---+	     abort on a subsequent rematch
;
;
;
;
;      succeed
;      -------
;
;	    +---+	     the node for succeed matches null
;	    i s i-----	     and stacks a pointer to itself
;	    +---+	     to repeat the match on a failure.
	EJC
;
;      compound patterns (continued)
;
;      binary dot (pattern assignment)
;      -------------------------------
;
;	    +---+	     this node (p_paa) saves the current
;	    i a i	     cursor and a pointer to the
;	    +---+	     special node ndpab on the stack.
;	      i
;	      i
;	    +---+	     this is the structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     pattern assignment call.
;	      i
;	      i
;	    +---+	     this node (p_pac) saves the cursor,
;	    i c i-----	     a ptr to itself, the cursor (copy)
;	    +---+	     and a ptr to ndpad on the stack.
;
;
;      the function of the match routine for ndpab (p_pab)
;      is simply to unstack itself and fail back onto the stack.
;
;      the match routine for p_pac also sets the global pattern
;      flag pmdfl non-zero to indicate that pattern assignments
;      may have occured in the pattern match
;
;      if pmdfl is set at the end of the match (see p_nth), the
;      history stack is scanned for matching ndpab-ndpad pairs
;      and the corresponding pattern assignments are executed.
;
;      the function of the match routine for ndpad (p_pad)
;      is simply to remove its entry from the stack and fail.
;      this includes removing the special node pointer stored
;      in addition to the standard two entries on the stack.
	EJC
;
;      compount pattern structures (continued)
;
;      fence (function)
;      ----------------
;
;	    +---+	     this node (p_fna) saves the
;	    i a i	     current history stack and a
;	    +---+	     pointer to ndfnb on the stack.
;	      i
;	      i
;	    +---+	     this is the pattern structure
;	    i x i	     given as the argument to the
;	    +---+	     fence function.
;	      i
;	      i
;	    +---+	     this node p_fnc restores the outer
;	    i c i	     history stack ptr saved in p_fna,
;	    +---+	     and stacks the inner stack base
;			     ptr and a pointer to ndfnd on the
;			     stack.
;
;      ndfnb (f_fnb) simply is the failure exit for pattern
;      argument failure, and it pops itself and fails onto the
;      stack.
;
;      the match routine p_fnc allows for an optimization when
;      the fence pattern leaves no alternatives.  in this case,
;      the ndfnb entry is popped, and the match continues.
;
;      ndfnd (p_fnd) is entered when the pattern fails after
;      going through a non-optimized p_fnc, and it pops the
;      stack back past the innter stack base created by p_fna
	EJC
;
;      compound patterns (continued)
;
;      expression patterns (recursive pattern matches)
;      -----------------------------------------------
;
;      initial entry for a pattern node is to the routine p_exa.
;      if the evaluated result of the expression is itself a
;      pattern, then the following steps are taken to arrange
;      for proper recursive processing.
;
;      1)   a pointer to the current node (the p_exa node) is
;	    stored on the history stack with a dummy cursor.
;
;      2)   a special history stack entry is made in which the
;	    node pointer points to ndexb, and the cursor value
;	    is the saved value of pmhbs on entry to this node.
;	    the match routine for ndexb (p_exb) restores pmhbs
;	    from this cursor entry, pops off the p_exa node
;	    pointer and fails.
;
;      3)   the resulting history stack pointer is saved in
;	    pmhbs to establish a new level of history stack.
;
;      after matching a pattern, the end of match routine gets
;      control (p_nth). this routine proceeds as follows.
;
;      1)   load the current value of pmhbs and recognize the
;	    outer level case by the fact that the associated
;	    cursor in this case is the pattern match type code
;	    which is less than 3. terminate the match in this
;	    case and continue execution of the program.
;
;      2)   otherwise make a special history stack entry in
;	    which the node pointer points to the special node
;	    ndexc and the cursor is the current value of pmhbs.
;	    the match routine for ndexc (p_exc) resets pmhbs to
;	    this (inner) value and and then fails.
;
;      3)   using the history stack entry made on starting the
;	    expression (accessible with the current value of
;	    pmhbs), restore the p_exa node pointer and the old
;	    pmhbs setting. take the successor and continue.
;
;      an optimization is possible if the expression pattern
;      makes no entries on the history stack. in this case,
;      instead of building the p_exc node in step 2, it is more
;      efficient to simply pop off the p_exb entry and its
;      associated node pointer. the effect is the same.
	EJC
;
;      compound patterns (continued)
;
;      binary dollar (immediate assignment)
;      ------------------------------------
;
;	    +---+	     this node (p_ima) stacks the cursor
;	    i a i	     pmhbs and a ptr to ndimb and resets
;	    +---+	     the stack ptr pmhbs.
;	      i
;	      i
;	    +---+	     this is the left structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     immediate assignment call.
;	      i
;	      i
;	    +---+	     this node (p_imc) performs the
;	    i c i-----	     assignment, pops pmhbs and stacks
;	    +---+	     the old pmhbs and a ptr to ndimd.
;
;
;      the structure and execution of this pattern are similar
;      to those of the recursive expression pattern matching.
;
;      the match routine for ndimb (p_imb) restores the outer
;      level value of pmhbs, unstacks the saved cursor and fails
;
;      the match routine p_imc uses the current value of pmhbs
;      to locate the p_imb entry. this entry is used to make
;      the assignment and restore the outer level value of
;      pmhbs. finally, the inner level value of pmhbs and a
;      pointer to the special node ndimd are stacked.
;
;      the match routine for ndimd (p_imd) restores the inner
;      level value of pmhbs and fails back into the stack.
;
;      an optimization occurs if the inner pattern makes no
;      entries on the history stack. in this case, p_imc pops
;      the p_imb entry instead of making a p_imd entry.
	EJC
;
;      arbno
;
;      see compound patterns section for stucture and
;      algorithm for matching this node type.
;
;      no parameters
;
p_aba	ENT	bl_p0			; p0blk
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),XR		; stack dummy node ptr
	MOV	-(XS),pmhbs		; stack old stack base ptr
	MOV	-(XS),=ndabb		; stack ptr to node ndabb
	MOV	pmhbs,XS		; store new stack base ptr
	BRN	succp			; succeed
	EJC
;
;      arbno (remove p_aba special stack entry)
;
;      no parameters (dummy pattern)
;
p_abb	ENT				; entry point
	MOV	pmhbs,WB		; restore history stack base ptr
	BRN	flpop			; fail and pop dummy node ptr
	EJC
;
;      arbno (check if arg matched null string)
;
;      no parameters (dummy pattern)
;
p_abc	ENT	bl_p0			; p0blk
	MOV	XT,pmhbs		; keep p_abb stack base
	MOV	WA,num03(XT)		; load initial cursor
	MOV	pmhbs,num01(XT)		; restore outer stack base ptr
	BEQ	XT,XS,pabc1		; jump if no history stack entries
	MOV	-(XS),XT		; else save inner pmhbs entry
	MOV	-(XS),=ndabd		; stack ptr to special node ndabd
	BRN	pabc2			; merge
;
;      optimise case of no eXTra entries on stack from arbno arg
;
pabc1	ADD	XS,*num04		; remove ndabb entry and cursor
;
;      merge to check for matching of null string
;
pabc2	BNE	WA,WB,succp		; allow further attempt if non-null
	MOV	XR,pthen(XR)		; bypass alternative node so as to ...
	BRN	succp			; ... refuse further match attempts
	EJC
;
;      arbno (try for alternatives in arbno argument)
;
;      no parameters (dummy pattern)
;
p_abd	ENT				; entry point
	MOV	pmhbs,WB		; restore inner stack base ptr
	BRN	failp			; and fail
	EJC
;
;      abort
;
;      no parameters
;
p_abo	ENT	bl_p0			; p0blk
	BRN	exfal			; signal statement failure
	EJC
;
;      alternation
;
;      parm1		     alternative node
;
p_alt	ENT	bl_p1			; p1blk
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),parm1(XR)		; stack pointer to alternative
	CHK				; check for stack overflow
	BRN	succp			; if all ok, then succeed
	EJC
;
;      any (one character argument) (1-char string also)
;
;      parm1		     character argument
;
p_ans	ENT	bl_p1			; p1blk
	BEQ	WB,pmssl,failp		; fail if no chars left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; point to current character
	LCH	WA,(XL)			; load current character
	BNE	WA,parm1(XR),failp	; fail if no match
	ICV	WB			; else bump cursor
	BRN	succp			; and succeed
	EJC
;
;      any (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit in ctblk
;
p_any	ENT	bl_p2			; p2blk
;
;      expression argument case merges here
;
pany1	BEQ	WB,pmssl,failp		; fail if no characters left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; get char ptr to current character
	LCH	WA,(XL)			; load current character
	MOV	XL,parm1(XR)		; point to ctblk
	WTB	WA			; change to byte offset
	ADD	XL,WA			; point to entry in ctblk
	MOV	WA,ctchs(XL)		; load word from ctblk
	ANB	WA,parm2(XR)		; and with selected bit
	ZRB	WA,failp		; fail if no match
	ICV	WB			; else bump cursor
	BRN	succp			; and succeed
	EJC
;
;      any (expression argument)
;
;      parm1		     expression pointer
;
p_ayd	ENT	bl_p1			; p1blk
	JSR	evals			; evaluate string argument
	ERR	043,any evaluated argument is not a string
	PPM	failp			; fail if evaluation failure
	PPM	pany1			; merge multi-char case if ok
	EJC
;
;      p_arb		     initial arb match
;
;      no parameters
;
;      the p_arb node is part of a compound pattern structure
;      for an arb pattern (see description of compound patterns)
;
p_arb	ENT	bl_p0			; p0blk
	MOV	XR,pthen(XR)		; load successor pointer
	MOV	-(XS),WB		; stack dummy cursor
	MOV	-(XS),XR		; stack successor pointer
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),=ndarc		; stack ptr to special node ndarc
	BRI	(XR)			; execute next node matching null
	EJC
;
;      p_arc		     eXTend arb match
;
;      no parameters (dummy pattern)
;
p_arc	ENT				; entry point
	BEQ	WB,pmssl,flpop		; fail and pop stack to successor
	ICV	WB			; else bump cursor
	MOV	-(XS),WB		; stack updated cursor
	MOV	-(XS),XR		; restack pointer to ndarc node
	MOV	XR,num02(XS)		; load successor pointer
	BRI	(XR)			; off to reexecute successor node
	EJC
;
;      bal
;
;      no parameters
;
;      the p_bal node is part of the compound structure built
;      for bal (see section on compound patterns).
;
p_bal	ENT	bl_p0			; p0blk
	ZER	WC			; zero parentheses level counter
	MOV	XL,r_pms		; point to subject string
	PLC	XL,WB			; point to current character
	BRN	pbal2			; jump into scan loop
;
;      loop to scan out characters
;
pbal1	LCH	WA,(XL)+		; load next character, bump pointer
	ICV	WB			; push cursor for character
	BEQ	WA,=ch_pp,pbal3		; jump if left paren
	BEQ	WA,=ch_rp,pbal4		; jump if right paren
	BZE	WC,pbal5		; else succeed if at outer level
;
;      here after processing one character
;
pbal2	BNE	WB,pmssl,pbal1		; loop back unless end of string
	BRN	failp			; in which case, fail
;
;      here on left paren
;
pbal3	ICV	WC			; bump paren level
	BRN	pbal2			; loop back to check end of string
;
;      here for right paren
;
pbal4	BZE	WC,failp		; fail if no matching left paren
	DCV	WC			; else decrement level counter
	BNZ	WC,pbal2		; loop back if not at outer level
;
;      here after successfully scanning a balanced string
;
pbal5	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),XR		; stack ptr to bal node for eXTend
	BRN	succp			; and succeed
	EJC
;
;      break (expression argument)
;
;      parm1		     expression pointer
;
p_bkd	ENT	bl_p1			; p1blk
	JSR	evals			; evaluate string expression
	ERR	044,break evaluated argument is not a string
	PPM	failp			; fail if evaluation fails
	PPM	pbrk1			; merge with multi-char case if ok
	EJC
;
;      break (one character argument)
;
;      parm1		     character argument
;
p_bks	ENT	bl_p1			; p1blk
	MOV	WC,pmssl		; get subject string length
	SUB	WC,WB			; get number of characters left
	BZE	WC,failp		; fail if no characters left
	LCT	WC,WC			; set counter for chars left
	MOV	XL,r_pms		; point to subject string
	PLC	XL,WB			; point to current character
;
;      loop to scan till break character found
;
pbks1	LCH	WA,(XL)+		; load next char, bump pointer
	BEQ	WA,parm1(XR),succp	; succeed if break character found
	ICV	WB			; else push cursor
	BCT	WC,pbks1		; loop back if more to go
	BRN	failp			; fail if end of string, no break chr
	EJC
;
;      break (multi-character argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
p_brk	ENT	bl_p2			; p2blk
;
;      expression argument merges here
;
pbrk1	MOV	WC,pmssl		; load subject string length
	SUB	WC,WB			; get number of characters left
	BZE	WC,failp		; fail if no characters left
	LCT	WC,WC			; set counter for characters left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; point to current character
	MOV	psave,XR		; save node pointer
;
;      loop to search for break character
;
pbrk2	LCH	WA,(XL)+		; load next char, bump pointer
	MOV	XR,parm1(XR)		; load pointer to ctblk
	WTB	WA			; convert to byte offset
	ADD	XR,WA			; point to ctblk entry
	MOV	WA,ctchs(XR)		; load ctblk word
	MOV	XR,psave		; restore node pointer
	ANB	WA,parm2(XR)		; and with selected bit
	NZB	WA,succp		; succeed if break character found
	ICV	WB			; else push cursor
	BCT	WC,pbrk2		; loop back unless end of string
	BRN	failp			; fail if end of string, no break chr
	EJC
;
;      breakx (eXTension)
;
;      this is the entry which causes an eXTension of a breakx
;      match when failure occurs. see section on compound
;      patterns for full details of breakx matching.
;
;      no parameters
;
p_bkx	ENT	bl_p0			; p0blk
	ICV	WB			; step cursor past previous break chr
	BRN	succp			; succeed to rematch break
	EJC
;
;      breakx (expression argument)
;
;      see section on compound patterns for full structure of
;      breakx pattern. the actual character matching uses a
;      break node. however, the entry for the expression
;      argument case is separated to get proper error messages.
;
;      parm1		     expression pointer
;
p_bxd	ENT	bl_p1			; p1blk
	JSR	evals			; evaluate string argument
	ERR	045,breakx evaluated argument is not a string
	PPM	failp			; fail if evaluation fails
	PPM	pbrk1			; merge with break if all ok
	EJC
;
;      cursor assignment
;
;      parm1		     name base
;      parm2		     name offset
;
p_cas	ENT	bl_p2			; p2blk
	MOV	-(XS),XR		; save node pointer
	MOV	-(XS),WB		; save cursor
	MOV	XL,parm1(XR)		; load name base
	MTI	WB			; load cursor as integer
	MOV	WB,parm2(XR)		; load name offset
	JSR	icbld			; get icblk for cursor value
	MOV	WA,WB			; move name offset
	MOV	WB,XR			; move value to assign
	JSR	asinp			; perform assignment
	PPM	flpop			; fail on assignment failure
	MOV	WB,(XS)+		; else restore cursor
	MOV	XR,(XS)+		; restore node pointer
	BRN	succp			; and succeed matching null
	EJC
;
;      expression node (p_exa, initial entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      parm1		     expression pointer
;
p_exa	ENT	bl_p1			; p1blk
	JSR	evalp			; evaluate expression
	PPM	failp			; fail if evaluation fails
	BLO	WA,=p_aaa,pexa1		; jump if result is not a pattern
;
;      here if result of expression is a pattern
;
	MOV	-(XS),WB		; stack dummy cursor
	MOV	-(XS),XR		; stack ptr to p_exa node
	MOV	-(XS),pmhbs		; stack history stack base ptr
	MOV	-(XS),=ndexb		; stack ptr to special node ndexb
	MOV	pmhbs,XS		; store new stack base pointer
	MOV	XR,XL			; copy node pointer
	BRI	(XR)			; match first node in expression pat
;
;      here if result of expression is not a pattern
;
pexa1	BEQ	WA,=b_scl,pexa2		; jump if it is already a string
	MOV	-(XS),XL		; else stack result
	MOV	XL,XR			; save node pointer
	JSR	gtstg			; convert result to string
	ERR	046,expression does not evaluate to pattern
	MOV	WC,XR			; copy string pointer
	MOV	XR,XL			; restore node pointer
	MOV	XL,WC			; copy string pointer again
;
;      merge here with string pointer in XL
;
pexa2	BZE	sclen(XL),succp		; just succeed if null string
	BRN	pstr1			; else merge with string circuit
	EJC
;
;      expression node (p_exb, remove ndexb entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
p_exb	ENT				; entry point
	MOV	pmhbs,WB		; restore outer level stack pointer
	BRN	flpop			; fail and pop p_exa node ptr
	EJC
;
;      expression node (p_exc, remove ndexc entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
p_exc	ENT				; entry point
	MOV	pmhbs,WB		; restore inner stack base pointer
	BRN	failp			; and fail into expr pattern alternvs
	EJC
;
;      fail
;
;      no parameters
;
p_fal	ENT	bl_p0			; p0blk
	BRN	failp			; just signal failure
	EJC
;
;      fence
;
;      see compound patterns section for the structure and
;      algorithm for matching this node type.
;
;      no parameters
;
p_fen	ENT	bl_p0			; p0blk
	MOV	-(XS),WB		; stack dummy cursor
	MOV	-(XS),=ndabo		; stack ptr to abort node
	BRN	succp			; and succeed matching null
	EJC
;
;      fence (function)
;
;      see compound patterns comments at start of this section
;      for details of scheme
;
;      no parameters
;
p_fna	ENT	bl_p0			; p0blk
	MOV	-(XS),pmhbs		; stack current history stack base
	MOV	-(XS),=ndfnb		; stack indir ptr to p_fnb (failure)
	MOV	pmhbs,XS		; begin new history stack
	BRN	succp			; succeed
	EJC
;
;      fence (function) (reset history stack and fail)
;
;      no parameters (dummy pattern)
;
p_fnb	ENT	bl_p0			; p0blk
	MOV	pmhbs,WB		; restore outer pmhbs stack base
	BRN	failp			; ...and fail
	EJC
;
;      fence (function) (make fence trap entry on stack)
;
;      no parameters (dummy pattern)
;
p_fnc	ENT	bl_p0			; p0blk
	MOV	XT,pmhbs		; get inner stack base ptr
	MOV	pmhbs,num01(XT)		; restore outer stack base
	BEQ	XT,XS,pfnc1		; optimize if no alternatives
	MOV	-(XS),XT		; else stack inner stack base
	MOV	-(XS),=ndfnd		; stack ptr to ndfnd
	BRN	succp			; succeed
;
;      here when fence function left nothing on the stack
;
pfnc1	ADD	XS,*num02		; pop off p_fnb entry
	BRN	succp			; succeed
	EJC
;
;      fence (function) (skip past alternatives on failure)
;
;      no parameters (dummy pattern)
;
p_fnd	ENT	bl_p0			; p0blk
	MOV	XS,WB			; pop stack to fence() history base
	BRN	flpop			; pop base entry and fail
	EJC
;
;      immediate assignment (initial entry, save current cursor)
;
;      see compound patterns description for details of the
;      structure and algorithm for matching this node type.
;
;      no parameters
;
p_ima	ENT	bl_p0			; p0blk
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),XR		; stack dummy node pointer
	MOV	-(XS),pmhbs		; stack old stack base pointer
	MOV	-(XS),=ndimb		; stack ptr to special node ndimb
	MOV	pmhbs,XS		; store new stack base pointer
	BRN	succp			; and succeed
	EJC
;
;      immediate assignment (remove cursor mark entry)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
p_imb	ENT				; entry point
	MOV	pmhbs,WB		; restore history stack base ptr
	BRN	flpop			; fail and pop dummy node ptr
	EJC
;
;      immediate assignment (perform actual assignment)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      parm1		     name base of vaRIAble
;      parm2		     name offset of vaRIAble
;
p_imc	ENT	bl_p2			; p2blk
	MOV	XT,pmhbs		; load pointer to p_imb entry
	MOV	WA,WB			; copy final cursor
	MOV	WB,num03(XT)		; load initial cursor
	MOV	pmhbs,num01(XT)		; restore outer stack base pointer
	BEQ	XT,XS,pimc1		; jump if no history stack entries
	MOV	-(XS),XT		; else save inner pmhbs pointer
	MOV	-(XS),=ndimd		; and a ptr to special node ndimd
	BRN	pimc2			; merge
;
;      here if no entries made on history stack
;
pimc1	ADD	XS,*num04		; remove ndimb entry and cursor
;
;      merge here to perform assignment
;
pimc2	MOV	-(XS),WA		; save current (final) cursor
	MOV	-(XS),XR		; save current node pointer
	MOV	XL,r_pms		; point to subject string
	SUB	WA,WB			; compute substring length
	JSR	sbstr			; build substring
	MOV	WB,XR			; move result
	MOV	XR,(XS)			; reload node pointer
	MOV	XL,parm1(XR)		; load name base
	MOV	WA,parm2(XR)		; load name offset
	JSR	asinp			; perform assignment
	PPM	flpop			; fail if assignment fails
	MOV	XR,(XS)+		; else restore node pointer
	MOV	WB,(XS)+		; restore cursor
	BRN	succp			; and succeed
	EJC
;
;      immediate assignment (remove ndimd entry on failure)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
p_imd	ENT				; entry point
	MOV	pmhbs,WB		; restore inner stack base pointer
	BRN	failp			; and fail
	EJC
;
;      len (integer argument)
;
;      parm1		     integer argument
;
p_len	ENT	bl_p1			; p1blk
;
;      expression argument case merges here
;
plen1	ADD	WB,parm1(XR)		; push cursor indicated amount
	BLE	WB,pmssl,succp		; succeed if not off end
	BRN	failp			; else fail
	EJC
;
;      len (expression argument)
;
;      parm1		     expression pointer
;
p_lnd	ENT	bl_p1			; p1blk
	JSR	evali			; evaluate integer argument
	ERR	047,len evaluated argument is not integer
	ERR	048,len evaluated argument is negative or too large
	PPM	failp			; fail if evaluation fails
	PPM	plen1			; merge with normal circuit if ok
	EJC
;
;      notany (expression argument)
;
;      parm1		     expression pointer
;
p_nad	ENT	bl_p1			; p1blk
	JSR	evals			; evaluate string argument
	ERR	049,notany evaluated argument is not a string
	PPM	failp			; fail if evaluation fails
	PPM	pnay1			; merge with multi-char case if ok
	EJC
;
;      notany (one character argument)
;
;      parm1		     character argument
;
p_nas	ENT	bl_p1			; entry point
	BEQ	WB,pmssl,failp		; fail if no chars left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; point to current character in strin
	LCH	WA,(XL)			; load current character
	BEQ	WA,parm1(XR),failp	; fail if match
	ICV	WB			; else bump cursor
	BRN	succp			; and succeed
	EJC
;
;      notany (multi-character string argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
p_nay	ENT	bl_p2			; p2blk
;
;      expression argument case merges here
;
pnay1	BEQ	WB,pmssl,failp		; fail if no characters left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; point to current character
	LCH	WA,(XL)			; load current character
	WTB	WA			; convert to byte offset
	MOV	XL,parm1(XR)		; load pointer to ctblk
	ADD	XL,WA			; point to entry in ctblk
	MOV	WA,ctchs(XL)		; load entry from ctblk
	ANB	WA,parm2(XR)		; and with selected bit
	NZB	WA,failp		; fail if character is matched
	ICV	WB			; else bump cursor
	BRN	succp			; and succeed
	EJC
;
;      end of pattern match
;
;      this routine is entered on successful completion.
;      see description of expression patterns in compound
;      pattern section for handling of recursion in matching.
;
;      this pattern also results from an attempt to convert the
;      null string to a pattern via convert()
;
;      no parameters (dummy pattern)
;
p_nth	ENT	bl_p0			; p0blk (dummy)
	MOV	XT,pmhbs		; load pointer to base of stack
	MOV	WA,num01(XT)		; load saved pmhbs (or pattern type)
	BLE	WA,=num02,pnth2		; jump if outer level (pattern type)
;
;      here we are at the end of matching an expression pattern
;
	MOV	pmhbs,WA		; restore outer stack base pointer
	MOV	XR,num02(XT)		; restore pointer to p_exa node
	BEQ	XT,XS,pnth1		; jump if no history stack entries
	MOV	-(XS),XT		; else stack inner stack base ptr
	MOV	-(XS),=ndexc		; stack ptr to special node ndexc
	BRN	succp			; and succeed
;
;      here if no history stack entries during pattern
;
pnth1	ADD	XS,*num04		; remove p_exb entry and node ptr
	BRN	succp			; and succeed
;
;      here if end of match at outer level
;
pnth2	MOV	pmssl,WB		; save final cursor in safe place
	BZE	pmdfl,pnth6		; jump if no pattern assignments
	EJC
;
;      end of pattern match (continued)
;
;      now we must perform pattern assignments. this is done by
;      scanning the history stack for matching ndpab-ndpad pairs
;
pnth3	DCA	XT			; point past cursor entry
	MOV	WA,-(XT)		; load node pointer
	BEQ	WA,=ndpad,pnth4		; jump if ndpad entry
	BNE	WA,=ndpab,pnth5		; jump if not ndpab entry
;
;      here for ndpab entry, stack initial cursor
;      note that there must be more entries on the stack.
;
	MOV	-(XS),num01(XT)		; stack initial cursor
	CHK				; check for stack overflow
	BRN	pnth3			; loop back if ok
;
;      here for ndpad entry. the starting cursor from the
;      matching ndpad entry is now the top stack entry.
;
pnth4	MOV	WA,num01(XT)		; load final cursor
	MOV	WB,(XS)			; load initial cursor from stack
	MOV	(XS),XT			; save history stack scan ptr
	SUB	WA,WB			; compute length of string
;
;      build substring and perform assignment
;
	MOV	XL,r_pms		; point to subject string
	JSR	sbstr			; construct substring
	MOV	WB,XR			; copy substring pointer
	MOV	XT,(XS)			; reload history stack scan ptr
	MOV	XL,num02(XT)		; load pointer to p_pac node with nam
	MOV	WA,parm2(XL)		; load name offset
	MOV	XL,parm1(XL)		; load name base
	JSR	asinp			; perform assignment
	PPM	exfal			; match fails if name eval fails
	MOV	XT,(XS)+		; else restore history stack ptr
	EJC
;
;      end of pattern match (continued)
;
;      here check for end of entries
;
pnth5	BNE	XT,XS,pnth3		; loop if more entries to scan
;
;      here after dealing with pattern assignments
;
pnth6	MOV	XS,pmhbs		; wipe out history stack
	MOV	WB,(XS)+		; load initial cursor
	MOV	WC,(XS)+		; load match type code
	MOV	WA,pmssl		; load final cursor value
	MOV	XL,r_pms		; point to subject string
	ZER	r_pms			; clear subject string ptr for gbcol
	BZE	WC,pnth7		; jump if call by name
	BEQ	WC,=num02,pnth9		; exit if statement level call
;
;      here we have a call by value, build substring
;
	SUB	WA,WB			; compute length of string
	JSR	sbstr			; build substring
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      here for call by name, make stack entries for o_rpl
;
pnth7	MOV	-(XS),WB		; stack initial cursor
	MOV	-(XS),WA		; stack final cursor
.IF    .cnbf
.ELSE
	BZE	r_pmb,pnth8		; skip if subject not buffer
	MOV	XL,r_pmb		; else get ptr to bcblk instead
.FI
;
;      here with XL pointing to scblk or bcblk
;
pnth8	MOV	-(XS),XL		; stack subject pointer
;
;      here to obey next code word
;
pnth9	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
p_pos	ENT	bl_p1			; p1blk
;
;      optimize pos if it is the first pattern element,
;      unanchored mode, cursor is zero and pos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisible provided
;      the argument is either a simple integer or an
;      expression that is an untraced vaRIAble (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point.)
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
	BEQ	WB,parm1(XR),succp	; succeed if at right location
	BNZ	WB,failp		; don't look further if cursor not 0
	MOV	XT,pmhbs		; get history stack base ptr
	BNE	XR,-(XT),failp		; fail if pos is not first node
;
;      expression argument circuit merges here
;
ppos2	BNE	-(XT),=nduna,failp	; fail if not unanchored mode
	MOV	WB,parm1(XR)		; get desired cursor position
	BGT	WB,pmssl,exfal		; abort if off end
	MOV	num02(XT),WB		; fake number of unanchored moves
	BRN	succp			; continue match with adjusted cursor
	EJC
;
;      pos (expression argument)
;
;      parm1		     expression pointer
;
p_psd	ENT	bl_p1			; p1blk
	JSR	evali			; evaluate integer argument
	ERR	050,pos evaluated argument is not integer
	ERR	051,pos evaluated argument is negative or too large
	PPM	failp			; fail if evaluation fails
	PPM	ppos1			; process expression case
;
ppos1	BEQ	WB,parm1(XR),succp	; succeed if at right location
	BNZ	WB,failp		; don't look further if cursor not 0
	BNZ	evlif,failp		; fail if complex argument
	MOV	XT,pmhbs		; get history stack base ptr
	MOV	WA,evlio		; get original node ptr
	BNE	WA,-(XT),failp		; fail if pos is not first node
	BRN	ppos2			; merge with integer argument code
	EJC
;
;      pattern assignment (initial entry, save cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters
;
p_paa	ENT	bl_p0			; p0blk
	MOV	-(XS),WB		; stack initial cursor
	MOV	-(XS),=ndpab		; stack ptr to ndpab special node
	BRN	succp			; and succeed matching null
	EJC
;
;      pattern assignment (remove saved cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
p_pab	ENT				; entry point
	BRN	failp			; just fail (entry is already popped)
	EJC
;
;      pattern assignment (end of match, make assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      parm1		     name base of vaRIAble
;      parm2		     name offset of vaRIAble
;
p_pac	ENT	bl_p2			; p2blk
	MOV	-(XS),WB		; stack dummy cursor value
	MOV	-(XS),XR		; stack pointer to p_pac node
	MOV	-(XS),WB		; stack final cursor
	MOV	-(XS),=ndpad		; stack ptr to special ndpad node
	MNZ	pmdfl			; set dot flag non-zero
	BRN	succp			; and succeed
	EJC
;
;      pattern assignment (remove assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy node)
;
p_pad	ENT				; entry point
	BRN	flpop			; fail and remove p_pac node
	EJC
;
;      rem
;
;      no parameters
;
p_rem	ENT	bl_p0			; p0blk
	MOV	WB,pmssl		; point cursor to end of string
	BRN	succp			; and succeed
	EJC
;
;      rpos (expression argument)
;
;      optimize rpos if it is the first pattern element,
;      unanchored mode, cursor is zero and rpos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisibly provided
;      the argument is either a simple integer or an
;      expression that is an untraced vaRIAble (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point).
;
;      parm1		     expression pointer
;
p_rpd	ENT	bl_p1			; p1blk
	JSR	evali			; evaluate integer argument
	ERR	052,rpos evaluated argument is not integer
	ERR	053,rpos evaluated argument is negative or too large
	PPM	failp			; fail if evaluation fails
	PPM	prps1			; merge with normal case if ok
;
prps1	MOV	WC,pmssl		; get length of string
	SUB	WC,WB			; get number of characters remaining
	BEQ	WC,parm1(XR),succp	; succeed if at right location
	BNZ	WB,failp		; don't look further if cursor not 0
	BNZ	evlif,failp		; fail if complex argument
	MOV	XT,pmhbs		; get history stack base ptr
	MOV	WA,evlio		; get original node ptr
	BNE	WA,-(XT),failp		; fail if pos is not first node
	BRN	prps2			; merge with integer arg code
	EJC
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
p_rps	ENT	bl_p1			; p1blk
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
	MOV	WC,pmssl		; get length of string
	SUB	WC,WB			; get number of characters remaining
	BEQ	WC,parm1(XR),succp	; succeed if at right location
	BNZ	WB,failp		; don't look further if cursor not 0
	MOV	XT,pmhbs		; get history stack base ptr
	BNE	XR,-(XT),failp		; fail if rpos is not first node
;
;      expression argument merges here
;
prps2	BNE	-(XT),=nduna,failp	; fail if not unanchored mode
	MOV	WB,pmssl		; point to end of string
	BLT	WB,parm1(XR),failp	; fail if string not long enough
	SUB	WB,parm1(XR)		; else set new cursor
	MOV	num02(XT),WB		; fake number of unanchored moves
	BRN	succp			; continue match with adjusted cursor
	EJC
;
;      rtab (integer argument)
;
;      parm1		     integer argument
;
p_rtb	ENT	bl_p1			; p1blk
;
;      expression argument case merges here
;
prtb1	MOV	WC,WB			; save initial cursor
	MOV	WB,pmssl		; point to end of string
	BLT	WB,parm1(XR),failp	; fail if string not long enough
	SUB	WB,parm1(XR)		; else set new cursor
	BGE	WB,WC,succp		; and succeed if not too far already
	BRN	failp			; in which case, fail
	EJC
;
;      rtab (expression argument)
;
;      parm1		     expression pointer
;
p_rtd	ENT	bl_p1			; p1blk
	JSR	evali			; evaluate integer argument
	ERR	054,rtab evaluated argument is not integer
	ERR	055,rtab evaluated argument is negative or too large
	PPM	failp			; fail if evaluation fails
	PPM	prtb1			; merge with normal case if success
	EJC
;
;      span (expression argument)
;
;      parm1		     expression pointer
;
p_spd	ENT	bl_p1			; p1blk
	JSR	evals			; evaluate string argument
	ERR	056,span evaluated argument is not a string
	PPM	failp			; fail if evaluation fails
	PPM	pspn1			; merge with multi-char case if ok
	EJC
;
;      span (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
p_spn	ENT	bl_p2			; p2blk
;
;      expression argument case merges here
;
pspn1	MOV	WC,pmssl		; copy subject string length
	SUB	WC,WB			; calculate number of characters left
	BZE	WC,failp		; fail if no characters left
	MOV	XL,r_pms		; point to subject string
	PLC	XL,WB			; point to current character
	MOV	psavc,WB		; save initial cursor
	MOV	psave,XR		; save node pointer
	LCT	WC,WC			; set counter for chars left
;
;      loop to scan matching characters
;
pspn2	LCH	WA,(XL)+		; load next character, bump pointer
	WTB	WA			; convert to byte offset
	MOV	XR,parm1(XR)		; point to ctblk
	ADD	XR,WA			; point to ctblk entry
	MOV	WA,ctchs(XR)		; load ctblk entry
	MOV	XR,psave		; restore node pointer
	ANB	WA,parm2(XR)		; and with selected bit
	ZRB	WA,pspn3		; jump if no match
	ICV	WB			; else push cursor
	BCT	WC,pspn2		; loop back unless end of string
;
;      here after scanning matching characters
;
pspn3	BNE	WB,psavc,succp		; succeed if chars matched
	BRN	failp			; else fail if null string matched
	EJC
;
;      span (one character argument)
;
;      parm1		     character argument
;
p_sps	ENT	bl_p1			; p1blk
	MOV	WC,pmssl		; get subject string length
	SUB	WC,WB			; calculate number of characters left
	BZE	WC,failp		; fail if no characters left
	MOV	XL,r_pms		; else point to subject string
	PLC	XL,WB			; point to current character
	MOV	psavc,WB		; save initial cursor
	LCT	WC,WC			; set counter for characters left
;
;      loop to scan matching characters
;
psps1	LCH	WA,(XL)+		; load next character, bump pointer
	BNE	WA,parm1(XR),psps2	; jump if no match
	ICV	WB			; else push cursor
	BCT	WC,psps1		; and loop unless end of string
;
;      here after scanning matching characters
;
psps2	BNE	WB,psavc,succp		; succeed if chars matched
	BRN	failp			; fail if null string matched
	EJC
;
;      multi-character string
;
;      note that one character strings use the circuit for
;      one character any arguments (p_an1).
;
;      parm1		     pointer to scblk for string arg
;
p_str	ENT	bl_p1			; p1blk
	MOV	XL,parm1(XR)		; get pointer to string
;
;      merge here after evaluating expression with string value
;
pstr1	MOV	psave,XR		; save node pointer
	MOV	XR,r_pms		; load subject string pointer
	PLC	XR,WB			; point to current character
	ADD	WB,sclen(XL)		; compute new cursor position
	BGT	WB,pmssl,failp		; fail if past end of string
	MOV	psavc,WB		; save updated cursor
	MOV	WA,sclen(XL)		; get number of chars to compare
	PLC	XL			; point to chars of test string
	CMC	failp,failp		; compare, fail if not equal
	MOV	XR,psave		; if all matched, restore node ptr
	MOV	WB,psavc		; restore updated cursor
	BRN	succp			; and succeed
	EJC
;
;      succeed
;
;      see section on compound patterns for details of the
;      structure and algorithms for matching this node type
;
;      no parameters
;
p_suc	ENT	bl_p0			; p0blk
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),XR		; stack pointer to this node
	BRN	succp			; succeed matching null
	EJC
;
;      tab (integer argument)
;
;      parm1		     integer argument
;
p_tab	ENT	bl_p1			; p1blk
;
;      expression argument case merges here
;
ptab1	BGT	WB,parm1(XR),failp	; fail if too far already
	MOV	WB,parm1(XR)		; else set new cursor position
	BLE	WB,pmssl,succp		; succeed if not off end
	BRN	failp			; else fail
	EJC
;
;      tab (expression argument)
;
;      parm1		     expression pointer
;
p_tbd	ENT	bl_p1			; p1blk
	JSR	evali			; evaluate integer argument
	ERR	057,tab evaluated argument is not integer
	ERR	058,tab evaluated argument is negative or too large
	PPM	failp			; fail if evaluation fails
	PPM	ptab1			; merge with normal case if ok
	EJC
;
;      anchor movement
;
;      no parameters (dummy node)
;
p_una	ENT				; entry point
	MOV	XR,WB			; copy initial pattern node pointer
	MOV	WB,(XS)			; get initial cursor
	BEQ	WB,pmssl,exfal		; match fails if at end of string
	ICV	WB			; else increment cursor
	MOV	(XS),WB			; store incremented cursor
	MOV	-(XS),XR		; restack initial node ptr
	MOV	-(XS),=nduna		; restack unanchored node
	BRI	(XR)			; rematch first node
	EJC
;
;      end of pattern match routines
;
;      the following entry point marks the end of the pattern
;      matching routines and also the end of the entry points
;      referenced from the first word of blocks in dynamic store
;
p_yyy	ENT	bl__i			; mark last entry in pattern section
	TTL	s p i t b o l -- snobol4 built-in label routines
;
;      the following section contains the routines for labels
;      which have a predefined meaning in snobol4.
;
;      control is passed directly to the label name entry point.
;
;      entry names are of the form l_xxx where xxx is the three
;      letter vaRIAble name identifier.
;
;      entries are in alphabetical order
	EJC
;
;      abort
;
l_abo	ENT				; entry point
;
;      merge here if execution terminates in error
;
labo1	MOV	WA,kvert		; load error code
	BZE	WA,labo3		; jump if no error has occured
.IF    .csax
	JSR	sysax			; call after execution proc
.FI
.IF    .cera
.IF    .csfn
	MOV	WC,kvstn		; current statement
	JSR	filnm			; obtain file name for this statement
.FI
.IF    .csln
	MOV	XR,r_cod		; current code block
	MOV	WC,cdsln(XR)		; line number
.ELSE
	ZER	WC			; line number
.FI
	ZER	WB			; column number
	MOV	XR,stage		;
	JSR	sysea			; advise system of error
	PPM	stpr4			; if system does not want print
.FI
	JSR	prtpg			; else eject printer
.IF    .cera
	BZE	XR,labo2		; did sysea request print
	JSR	prtst			; print teXT from sysea
.FI
labo2	JSR	ermsg			; print error message
	ZER	XR			; indicate no message to print
	BRN	stopr			; jump to routine to stop run
;
;      here if no error had occured
;
labo3	ERB	036,goto abort with no preceding error
	EJC
;
;      continue
;
l_cnt	ENT				; entry point
;
;      merge here after execution error
;
lcnt1	MOV	XR,r_cnt		; load continuation code block ptr
	BZE	XR,lcnt3		; jump if no previous error
	ZER	r_cnt			; clear flag
	MOV	r_cod,XR		; else store as new code block ptr
	BNE	(XR),=b_cdc,lcnt2	; jump if not complex go
	MOV	WA,stxoc		; get offset of error
	BGE	WA,stxof,lcnt4		; jump if error in goto evaluation
;
;      here if error did not occur in complex failure goto
;
lcnt2	ADD	XR,stxof		; add failure offset
	LCP	XR			; load code pointer
	MOV	XS,flptr		; reset stack pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      here if no previous error
;
lcnt3	ICV	errft			; fatal error
	ERB	037,goto continue with no preceding error
;
;      here if error in evaluation of failure goto.
;      cannot continue back to failure goto!
;
lcnt4	ICV	errft			; fatal error
	ERB	332,goto continue with error in failure goto
	EJC
;
;      end
;
l_end	ENT				; entry point
;
;      merge here from end code circuit
;
lend0	MOV	XR,=endms		; point to message /normal term.../
	BRN	stopr			; jump to routine to stop run
	EJC
;
;      freturn
;
l_frt	ENT				; entry point
	MOV	WA,=scfrt		; point to string /freturn/
	BRN	retrn			; jump to common return routine
	EJC
;
;      nreturn
;
l_nrt	ENT				; entry point
	MOV	WA,=scnrt		; point to string /nreturn/
	BRN	retrn			; jump to common return routine
	EJC
;
;      return
;
l_rtn	ENT				; entry point
	MOV	WA,=scrtn		; point to string /return/
	BRN	retrn			; jump to common return routine
	EJC
;
;      scontinue
;
l_scn	ENT				; entry point
	MOV	XR,r_cnt		; load continuation code block ptr
	BZE	XR,lscn2		; jump if no previous error
	ZER	r_cnt			; clear flag
	BNE	kvert,=nm320,lscn1	; error must be user interrupt
	BEQ	kvert,=nm321,lscn2	; detect scontinue loop
	MOV	r_cod,XR		; else store as new code block ptr
	ADD	XR,stxoc		; add resume offset
	LCP	XR			; load code pointer
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      here if no user interrupt
;
lscn1	ICV	errft			; fatal error
	ERB	331,goto scontinue with no user interrupt
;
;      here if in scontinue loop or if no previous error
;
lscn2	ICV	errft			; fatal error
	ERB	321,goto scontinue with no preceding error
	EJC
;
;      undefined label
;
l_und	ENT				; entry point
	ERB	038,goto undefined label
	TTL	s p i t b o l -- predefined snobol4 functions
;
;      the following section contains coding for functions
;      which are predefined and available at the snobol level.
;
;      these routines receive control directly from the code or
;      indirectly through the o_fnc, o_fns or cfunc routines.
;      in both cases the conditions on entry are as follows
;
;      the arguments are on the stack. the number of arguments
;      has been adjusted to correspond to the svblk svnar field.
;
;      in certain functions the direct call is not permitted
;      and in these instances we also have.
;
;      (wa)		     actual number of arguments in call
;
;      control returns by placing the function result value on
;      on the stack and continuing execution with the next
;      word from the generated code.
;
;      the names of the entry points of these functions are of
;      the form s_xxx where xxx is the three letter code for
;      the system vaRIAble name. the functions are in order
;      alphabetically by their entry names.
	EJC
.IF    .c370
;
;      abs
;
s_abs	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtnum			; make numeric
	ERR	xxx,abs argument not numeric
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,sabs1		; jump if real
.FI
	LDI	icval(XR)		; load integer value
	IGE	exiXR			; no change if not negative
	NGI				; produce absolute value
	INO	exint			; return integer if no overflow
	ERB	xxx,abs caused integer overflow
.IF    .cnra
.ELSE
;
;      here to process real argument
;
sabs1	LDR	rcval(XR)		; load real value
	RGE	exiXR			; no change if not negative
	NGR				; produce absolute value
	RNO	exrea			; return real if no overflow
	ERB	xxx,abs caused real overflow
.FI
.FI
.IF    .c370
;
;      and
;
s_and	ENT				; entry point
	MNZ	WB			; signal two arguments
	JSR	sbool			; call string boolean routine
	ERR	xxx,and first argument is not a string
	ERR	xxx,and second argument is not a string
	ERR	xxx,and arguments not same length
	PPM	exits			; null string arguments
;
;      here to process (WC) words.  result is stacked.
;
sand1	MOV	WA,(XL)+		; get next cfp_c chars from arg 1
	ANB	WA,(XR)			; and with characters from arg 2
	MOV	(XR)+,WA		; put back in memory
	BCT	WC,sand1		; loop over all words in string block
	BRN	exits			; fetch next code word
	EJC
.FI
;
;      any
;
s_any	ENT				; entry point
	MOV	WB,=p_ans		; set pcode for single char case
	MOV	XL,=p_any		; pcode for multi-char case
	MOV	WC,=p_ayd		; pcode for expression case
	JSR	patst			; call common routine to build node
	ERR	059,any argument is not a string or expression
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
.IF    .cnbf
.ELSE
;
;      append
;
s_apn	ENT				; entry point
	MOV	XL,(XS)+		; get append argument
	MOV	XR,(XS)+		; get bcblk
	BEQ	(XR),=b_bct,sapn1	; ok if first arg is bcblk
	ERB	275,append first argument is not a buffer
;
;      here to do the append
;
sapn1	JSR	apndb			; do the append
	ERR	276,append second argument is not a string
	PPM	exfal			; no room - fail
	BRN	exnul			; exit with null result
	EJC
.FI
;
;      apply
;
;      apply does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
s_app	ENT				; entry point
	BZE	WA,sapp3		; jump if no arguments
	DCV	WA			; else get applied func arg count
	MOV	WB,WA			; copy
	WTB	WB			; convert to bytes
	MOV	XT,XS			; copy stack pointer
	ADD	XT,WB			; point to function argument on stack
	MOV	XR,(XT)			; load function ptr (apply 1st arg)
	BZE	WA,sapp2		; jump if no args for applied func
	LCT	WB,WA			; else set counter for loop
;
;      loop to move arguments up on stack
;
sapp1	DCA	XT			; point to next argument
	MOV	num01(XT),(XT)		; move argument up
	BCT	WB,sapp1		; loop till all moved
;
;      merge here to call function (wa = number of arguments)
;
sapp2	ICA	XS			; adjust stack ptr for apply 1st arg
	JSR	gtnvr			; get vaRIAble block addr for func
	PPM	sapp3			; jump if not natural vaRIAble
	MOV	XL,vrfnc(XR)		; else point to function block
	BRN	cfunc			; go call applied function
;
;      here for invalid first argument
;
sapp3	ERB	060,apply first arg is not natural vaRIAble name
	EJC
;
;      arbno
;
;      arbno builds a compound pattern. see description at
;      start of pattern matching section for structure formed.
;
s_abn	ENT				; entry point
	ZER	XR			; set parm1 = 0 for the moment
	MOV	WB,=p_alt		; set pcode for alternative node
	JSR	pbild			; build alternative node
	MOV	XL,XR			; save ptr to alternative pattern
	MOV	WB,=p_abc		; pcode for p_abc
	ZER	XR			; p0blk
	JSR	pbild			; build p_abc node
	MOV	pthen(XR),XL		; put alternative node as successor
	MOV	WA,XL			; remember alternative node pointer
	MOV	XL,XR			; copy p_abc node ptr
	MOV	XR,(XS)			; load arbno argument
	MOV	(XS),WA			; stack alternative node pointer
	JSR	gtpat			; get arbno argument as pattern
	ERR	061,arbno argument is not pattern
	JSR	pconc			; concat arg with p_abc node
	MOV	XL,XR			; remember ptr to concd patterns
	MOV	WB,=p_aba		; pcode for p_aba
	ZER	XR			; p0blk
	JSR	pbild			; build p_aba node
	MOV	pthen(XR),XL		; concatenate nodes
	MOV	XL,(XS)			; recall ptr to alternative node
	MOV	parm1(XL),XR		; point alternative back to argument
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      arg
;
s_arg	ENT				; entry point
	JSR	gtsmi			; get second arg as small integer
	ERR	062,arg second argument is not integer
	PPM	exfal			; fail if out of range or negative
	MOV	WA,XR			; save argument number
	MOV	XR,(XS)+		; load first argument
	JSR	gtnvr			; locate vrblk
	PPM	sarg1			; jump if not natural vaRIAble
	MOV	XR,vrfnc(XR)		; else load function block pointer
	BNE	(XR),=b_pfc,sarg1	; jump if not program defined
	BZE	WA,exfal		; fail if arg number is zero
	BGT	WA,fargs(XR),exfal	; fail if arg number is too large
	WTB	WA			; else convert to byte offset
	ADD	XR,WA			; point to argument selected
	MOV	XR,pfagb(XR)		; load argument vrblk pointer
	BRN	exvnm			; exit to build nmblk
;
;      here if 1st argument is bad
;
sarg1	ERB	063,arg first argument is not program function name
	EJC
;
;      array
;
s_arr	ENT				; entry point
	MOV	XL,(XS)+		; load initial element value
	MOV	XR,(XS)+		; load first argument
	JSR	gtint			; convert first arg to integer
	PPM	sar02			; jump if not integer
;
;      here for integer first argument, build vcblk
;
	LDI	icval(XR)		; load integer value
	ILE	sar10			; jump if zero or neg (bad dimension)
	MFI	WA,sar11		; else convert to one word, test ovfl
	JSR	vmake			; create vector
	PPM	sar11			; fail if too large
	BRN	eXSid			; exit setting idval
	EJC
;
;      array (continued)
;
;      here if first argument is not an integer
;
sar02	MOV	-(XS),XR		; replace argument on stack
	JSR	XScni			; initialize scan of first argument
	ERR	064,array first argument is not integer or string
	PPM	exnul			; dummy (unused) null string exit
	MOV	-(XS),r_xsc		; save prototype pointer
	MOV	-(XS),XL		; save default value
	ZER	arcdm			; zero count of dimensions
	ZER	arptr			; zero offset to indicate pass one
	LDI	intv1			; load integer one
	STI	arnel			; initialize element count
;
;      the following code is executed twice. the first time
;      (arptr eq 0), it is used to count the number of elements
;      and number of dimensions. the second time (arptr gt 0) is
;      used to actually fill in the dim,lbd fields of the arblk.
;
sar03	LDI	intv1			; load one as default low bound
	STI	arsvl			; save as low bound
	MOV	WC,=ch_cl		; set delimiter one = colon
	MOV	XL,=ch_cm		; set delimiter two = comma
	ZER	WA			; retain blanks in prototype
	JSR	XScan			; scan next bound
	BNE	WA,=num01,sar04		; jump if not colon
;
;      here we have a colon ending a low bound
;
	JSR	gtint			; convert low bound
	ERR	065,array first argument lower bound is not integer
	LDI	icval(XR)		; load value of low bound
	STI	arsvl			; store low bound value
	MOV	WC,=ch_cm		; set delimiter one = comma
	MOV	XL,WC			; and delimiter two = comma
	ZER	WA			; retain blanks in prototype
	JSR	XScan			; scan high bound
	EJC
;
;      array (continued)
;
;      merge here to process upper bound
;
sar04	JSR	gtint			; convert high bound to integer
	ERR	066,array first argument upper bound is not integer
	LDI	icval(XR)		; get high bound
	SBI	arsvl			; subtract lower bound
	IOV	sar10			; bad dimension if overflow
	ILT	sar10			; bad dimension if negative
	ADI	intv1			; add 1 to get dimension
	IOV	sar10			; bad dimension if overflow
	MOV	XL,arptr		; load offset (also pass indicator)
	BZE	XL,sar05		; jump if first pass
;
;      here in second pass to store lbd and dim in arblk
;
	ADD	XL,(XS)			; point to current location in arblk
	STI	cfp_i(XL)		; store dimension
	LDI	arsvl			; load low bound
	STI	(XL)			; store low bound
	ADD	arptr,*ardms		; bump offset to next bounds
	BRN	sar06			; jump to check for end of bounds
;
;      here in pass 1
;
sar05	ICV	arcdm			; bump dimension count
	MLI	arnel			; multiply dimension by count so far
	IOV	sar11			; too large if overflow
	STI	arnel			; else store updated element count
;
;      merge here after processing one set of bounds
;
sar06	BNZ	WA,sar03		; loop back unless end of bounds
	BNZ	arptr,sar09		; jump if end of pass 2
	EJC
;
;      array (continued)
;
;      here at end of pass one, build arblk
;
	LDI	arnel			; get number of elements
	MFI	WB,sar11		; get as addr integer, test ovflo
	WTB	WB			; else convert to length in bytes
	MOV	WA,*arsi_		; set size of standard fields
	LCT	WC,arcdm		; set dimension count to control loop
;
;      loop to allow space for dimensions
;
sar07	ADD	WA,*ardms		; allow space for one set of bounds
	BCT	WC,sar07		; loop back till all accounted for
	MOV	XL,WA			; save size (=arofs)
;
;      now allocate space for arblk
;
	ADD	WA,WB			; add space for elements
	ICA	WA			; allow for arpro prototype field
	BGT	WA,mxlen,sar11		; fail if too large
	JSR	alloc			; else allocate arblk
	MOV	WB,(XS)			; load default value
	MOV	(XS),XR			; save arblk pointer
	MOV	WC,WA			; save length in bytes
	BTW	WA			; convert length back to words
	LCT	WA,WA			; set counter to control loop
;
;      loop to clear entire arblk to default value
;
sar08	MOV	(XR)+,WB		; set one word
	BCT	WA,sar08		; loop till all set
	EJC
;
;      array (continued)
;
;      now set initial fields of arblk
;
	MOV	XR,(XS)+		; reload arblk pointer
	MOV	WB,(XS)			; load prototype
	MOV	(XR),=b_art		; set type word
	MOV	arlen(XR),WC		; store length in bytes
	ZER	idval(XR)		; zero id till we get it built
	MOV	arofs(XR),XL		; set prototype field ptr
	MOV	arndm(XR),arcdm		; set number of dimensions
	MOV	WC,XR			; save arblk pointer
	ADD	XR,XL			; point to prototype field
	MOV	(XR),WB			; store prototype ptr in arblk
	MOV	arptr,*arlbd		; set offset for pass 2 bounds scan
	MOV	r_xsc,WB		; reset string pointer for XScan
	MOV	(XS),WC			; store arblk pointer on stack
	ZER	xsofs			; reset offset ptr to start of string
	BRN	sar03			; jump back to rescan bounds
;
;      here after filling in bounds information (end pass two)
;
sar09	MOV	XR,(XS)+		; reload pointer to arblk
	BRN	eXSid			; exit setting idval
;
;      here for bad dimension
;
sar10	ERB	067,array dimension is zero, negative or out of range
;
;      here if array is too large
;
sar11	ERB	068,array size exceeds maximum permitted
	EJC
.IF    .cmth
;
;      atan
;
s_atn	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	301,atan argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	ATN				; take arctangent
	BRN	exrea			; overflow, out of range not possible
	EJC
.FI
.IF    .cbsp
	EJC
;
;      backspace
;
s_bsp	ENT				; entry point
	JSR	iofcb			; call fcblk routine
	ERR	316,backspace argument is not a suitable name
	ERR	316,backspace argument is not a suitable name
	ERR	317,backspace file does not exist
	JSR	sysbs			; call backspace file function
	ERR	317,backspace file does not exist
	ERR	318,backspace file does not permit backspace
	ERR	319,backspace caused non-recoverable error
	BRN	exnul			; return null as result
	EJC
.FI
.IF    .cnbf
.ELSE
;
;      buffer
;
s_buf	ENT				; entry point
	MOV	XL,(XS)+		; get initial value
	MOV	XR,(XS)+		; get requested allocation
	JSR	gtint			; convert to integer
	ERR	269,buffer first argument is not integer
	LDI	icval(XR)		; get value
	ILE	sbf01			; branch if negative or zero
	MFI	WA,sbf02		; move with overflow check
	JSR	alobf			; allocate the buffer
	JSR	apndb			; copy it in
	ERR	270,buffer second argument is not a string or buffer
	ERR	271,buffer initial value too big for allocation
	BRN	eXSid			; exit setting idval
;
;      here for invalid allocation size
;
sbf01	ERB	272,buffer first argument is not positive
;
;      here for allocation size integer overflow
;
sbf02	ERB	273,buffer size exceeds value of maXLngth keyword
	EJC
.FI
;
;      break
;
s_brk	ENT				; entry point
	MOV	WB,=p_bks		; set pcode for single char case
	MOV	XL,=p_brk		; pcode for multi-char case
	MOV	WC,=p_bkd		; pcode for expression case
	JSR	patst			; call common routine to build node
	ERR	069,break argument is not a string or expression
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      breakx
;
;      breakx is a compound pattern. see description at start
;      of pattern matching section for structure formed.
;
s_bkx	ENT				; entry point
	MOV	WB,=p_bks		; pcode for single char argument
	MOV	XL,=p_brk		; pcode for multi-char argument
	MOV	WC,=p_bxd		; pcode for expression case
	JSR	patst			; call common routine to build node
	ERR	070,breakx argument is not a string or expression
;
;      now hook breakx node on at front end
;
	MOV	-(XS),XR		; save ptr to break node
	MOV	WB,=p_bkx		; set pcode for breakx node
	JSR	pbild			; build it
	MOV	pthen(XR),(XS)		; set break node as successor
	MOV	WB,=p_alt		; set pcode for alternation node
	JSR	pbild			; build (parm1=alt=breakx node)
	MOV	WA,XR			; save ptr to alternation node
	MOV	XR,(XS)			; point to break node
	MOV	pthen(XR),WA		; set alternate node as successor
	LCW	XR			; result on stack
	BRI	(XR)			; execute next code word
	EJC
;
;      char
;
s_chr	ENT				; entry point
	JSR	gtsmi			; convert arg to integer
	ERR	281,char argument not integer
	PPM	schr1			; too big error exit
	BGE	WC,=cfp_a,schr1		; see if out of range of host set
	MOV	WA,=num01		; if not set scblk allocation
	MOV	WB,WC			; save char code
	JSR	alocs			; allocate 1 bau scblk
	MOV	XL,XR			; copy scblk pointer
	PSC	XL			; get set to stuff char
	SCH	WB,(XL)			; stuff it
	CSC	XL			; complete store character
	ZER	XL			; clear slop in XL
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      here if char argument is out of range
;
schr1	ERB	282,char argument not in range
	EJC
.IF    .cmth
;
;      chop
;
s_chp	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	302,chop argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	CHP				; truncate to integer valued real
	BRN	exrea			; no overflow possible
	EJC
.FI
;
;      clear
;
s_clr	ENT				; entry point
	JSR	XScni			; initialize to scan argument
	ERR	071,clear argument is not a string
	PPM	sclr2			; jump if null
;
;      loop to scan out names in first argument. vaRIAbles in
;      the list are flagged by setting vrget of vrblk to zero.
;
sclr1	MOV	WC,=ch_cm		; set delimiter one = comma
	MOV	XL,WC			; delimiter two = comma
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan next vaRIAble name
	JSR	gtnvr			; locate vrblk
	ERR	072,clear argument has null vaRIAble name
	ZER	vrget(XR)		; else flag by zeroing vrget field
	BNZ	WA,sclr1		; loop back if stopped by comma
;
;      here after flagging vaRIAbles in argument list
;
sclr2	MOV	WB,hshtb		; point to start of hash table
;
;      loop through slots in hash table
;
sclr3	BEQ	WB,hshte,exnul		; exit returning null if none left
	MOV	XR,WB			; else copy slot pointer
	ICA	WB			; bump slot pointer
	SUB	XR,*vrnxt		; set offset to merge into loop
;
;      loop through vrblks on one hash chain
;
sclr4	MOV	XR,vrnxt(XR)		; point to next vrblk on chain
	BZE	XR,sclr3		; jump for next bucket if chain end
	BNZ	vrget(XR),sclr5		; jump if not flagged
	EJC
;
;      clear (continued)
;
;      here for flagged vaRIAble, do not set value to null
;
	JSR	setvr			; for flagged var, restore vrget
	BRN	sclr4			; and loop back for next vrblk
;
;      here to set value of a vaRIAble to null
;      protected vaRIAbles (arb, etc) are exempt
;
sclr5	BEQ	vrsto(XR),=b_vre,sclr4	; check for protected vaRIAble
	MOV	XL,XR			; copy vrblk pointer
;
;      loop to locate value at end of possible trblk chain
;
sclr6	MOV	WA,XL			; save block pointer
	MOV	XL,vrval(XL)		; load next value field
	BEQ	(XL),=b_trt,sclr6	; loop back if trapped
;
;      now store the null value
;
	MOV	XL,WA			; restore block pointer
	MOV	vrval(XL),=nulls	; store null constant value
	BRN	sclr4			; loop back for next vrblk
	EJC
;
;      code
;
s_cod	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtcod			; convert to code
	PPM	exfal			; fail if conversion is impossible
	MOV	-(XS),XR		; stack result
	ZER	r_ccb			; forget interim code block
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      collect
;
s_col	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtint			; convert to integer
	ERR	073,collect argument is not integer
	LDI	icval(XR)		; load collect argument
	STI	clsvi			; save collect argument
	ZER	WB			; set no move up
	ZER	r_ccb			; forget interim code block
.IF    .csed
	ZER	dnams			; collect sediment too
	JSR	gbcol			; perform garbage collection
	MOV	dnams,XR		; record new sediment size
.ELSE
	JSR	gbcol			; perform garbage collection
.FI
	MOV	WA,dname		; point to end of memory
	SUB	WA,dnamp		; subtract next location
	BTW	WA			; convert bytes to words
	MTI	WA			; convert words available as integer
	SBI	clsvi			; subtract argument
	IOV	exfal			; fail if overflow
	ILT	exfal			; fail if not enough
	ADI	clsvi			; else recompute available
	BRN	exint			; and exit with integer result
	EJC
.IF    .c370
;
;      compl
;
s_cmp	ENT				; entry point
	ZER	WB			; signal one argument
	JSR	sbool			; call string boolean routine
	PPM				; only one argument, cannot get here
	ERR	xxx,compl argument is not a string
	PPM				; cannot have two strings unequal
	PPM	exits			; null string argument
;
;      here to process (wa) characters.	 result is stacked.
;
	LCT	WC,WA			; prepare count
	PLC	XL			; prepare to load chars from (XL)
	PSC	XR			; prepare to store chars into (XR)
scmp1	LCH	WA,(XL)+		; get next char from arg 1
	CMB	WA			; complement
	SCH	WA,(XR)+		; store into result
	BCT	WC,scmp1		; loop over all chars in string block
	CSC				; complete store character
	BRN	exits			; fetch next code word.
	EJC
.FI
;
;      convert
;
s_cnv	ENT				; entry point
	JSR	gtstg			; convert second argument to string
	PPM	scv29			; error if second argument not string
	BZE	WA,scv29		; or if null string
.IF    .culc
	JSR	flstg			; fold lower case to upper case
.FI
	MOV	XL,(XS)			; load first argument
	BNE	(XL),=b_pdt,scv01	; jump if not program defined
;
;      here for program defined datatype
;
	MOV	XL,pddfp(XL)		; point to dfblk
	MOV	XL,dfnam(XL)		; load datatype name
	JSR	ident			; compare with second arg
	PPM	exits			; exit if ident with arg as result
	BRN	exfal			; else fail
;
;      here if not program defined datatype
;
scv01	MOV	-(XS),XR		; save string argument
	MOV	XL,=svctb		; point to table of names to compare
	ZER	WB			; initialize counter
	MOV	WC,WA			; save length of argument string
;
;      loop through table entries
;
scv02	MOV	XR,(XL)+		; load next table entry, bump pointer
	BZE	XR,exfal		; fail if zero marking end of list
	BNE	WC,sclen(XR),scv05	; jump if wrong length
	MOV	cnvtp,XL		; else store table pointer
	PLC	XR			; point to chars of table entry
	MOV	XL,(XS)			; load pointer to string argument
	PLC	XL			; point to chars of string arg
	MOV	WA,WC			; set number of chars to compare
	CMC	scv04,scv04		; compare, jump if no match
	EJC
;
;      convert (continued)
;
;      here we have a match
;
scv03	MOV	XL,WB			; copy entry number
	ICA	XS			; pop string arg off stack
	MOV	XR,(XS)+		; load first argument
	BSW	XL,cnvtt		; jump to appropriate routine
	IFF	0,scv06			; string
	IFF	1,scv07			; integer
	IFF	2,scv09			; name
	IFF	3,scv10			; pattern
	IFF	4,scv11			; array
	IFF	5,scv19			; table
	IFF	6,scv25			; expression
	IFF	7,scv26			; code
	IFF	8,scv27			; numeric
.IF    .cnra
.ELSE
	IFF	cnvrt,scv08		; real
.FI
.IF    .cnbf
.ELSE
	IFF	cnvbt,scv28		; buffer
.FI
	ESW				; end of switch table
;
;      here if no match with table entry
;
scv04	MOV	XL,cnvtp		; restore table pointer, merge
;
;      merge here if lengths did not match
;
scv05	ICV	WB			; bump entry number
	BRN	scv02			; loop back to check next entry
;
;      here to convert to string
;
scv06	MOV	-(XS),XR		; replace string argument on stack
	JSR	gtstg			; convert to string
	PPM	exfal			; fail if conversion not possible
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      convert (continued)
;
;      here to convert to integer
;
scv07	JSR	gtint			; convert to integer
	PPM	exfal			; fail if conversion not possible
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.IF    .cnra
.ELSE
;
;      here to convert to real
;
scv08	JSR	gtrea			; convert to real
	PPM	exfal			; fail if conversion not possible
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.FI
;
;      here to convert to name
;
scv09	BEQ	(XR),=b_nml,exiXR	; return if already a name
	JSR	gtnvr			; else try string to name convert
	PPM	exfal			; fail if conversion not possible
	BRN	exvnm			; else exit building nmblk for vrblk
;
;      here to convert to pattern
;
scv10	JSR	gtpat			; convert to pattern
	PPM	exfal			; fail if conversion not possible
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      convert to array
;
;      if the first argument is a table, then we go through
;      an intermediate array of addresses that is sorted to
;      provide a result ordered by time of entry in the
;      original table.	see c3.762.
;
scv11	MOV	-(XS),XR		; save argument on stack
	ZER	WA			; use table chain block addresses
	JSR	gtarr			; get an array
	PPM	exfal			; fail if empty table
	PPM	exfal			; fail if not convertible
	MOV	XL,(XS)+		; reload original arg
	BNE	(XL),=b_tbt,eXSid	; exit if original not a table
	MOV	-(XS),XR		; sort the intermediate array
	MOV	-(XS),=nulls		; on first column
	ZER	WA			; sort ascending
	JSR	sorta			; do sort
	PPM	exfal			; if sort fails, so shall we
	MOV	WB,XR			; save array result
	LDI	ardim(XR)		; load dim 1 (number of elements)
	MFI	WA			; get as one word integer
	LCT	WA,WA			; copy to control loop
	ADD	XR,*arvl2		; point to first element in array
;
;      here for each row of this 2-column array
;
scv12	MOV	XL,(XR)			; get teblk address
	MOV	(XR)+,tesub(XL)		; replace with subscript
	MOV	(XR)+,teval(XL)		; replace with value
	BCT	WA,scv12		; loop till all copied over
	MOV	XR,WB			; retrieve array address
	BRN	eXSid			; exit setting id field
;
;      convert to table
;
scv19	MOV	WA,(XR)			; load first word of block
	MOV	-(XS),XR		; replace arblk pointer on stack
	BEQ	WA,=b_tbt,exits		; return arg if already a table
	BNE	WA,=b_art,exfal		; else fail if not an array
	EJC
;
;      convert (continued)
;
;      here to convert an array to table
;
	BNE	arndm(XR),=num02,exfal	; fail if not 2-dim array
	LDI	ardm2(XR)		; load dim 2
	SBI	intv2			; subtract 2 to compare
	INE	exfal			; fail if dim2 not 2
;
;      here we have an arblk of the right shape
;
	LDI	ardim(XR)		; load dim 1 (number of elements)
	MFI	WA			; get as one word integer
	LCT	WB,WA			; copy to control loop
	ADD	WA,=tbsi_		; add space for standard fields
	WTB	WA			; convert length to bytes
	JSR	alloc			; allocate space for tbblk
	MOV	WC,XR			; copy tbblk pointer
	MOV	-(XS),XR		; save tbblk pointer
	MOV	(XR)+,=b_tbt		; store type word
	ZER	(XR)+			; store zero for idval for now
	MOV	(XR)+,WA		; store length
	MOV	(XR)+,=nulls		; null initial lookup value
;
;      loop to initialize bucket ptrs to point to table
;
scv20	MOV	(XR)+,WC		; set bucket ptr to point to tbblk
	BCT	WB,scv20		; loop till all initialized
	MOV	WB,*arvl2		; set offset to first arblk element
;
;      loop to copy elements from array to table
;
scv21	MOV	XL,num01(XS)		; point to arblk
	BEQ	WB,arlen(XL),scv24	; jump if all moved
	ADD	XL,WB			; else point to current location
	ADD	WB,*num02		; bump offset
	MOV	XR,(XL)			; load subscript name
	DCA	XL			; adjust ptr to merge (trval=1+1)
	EJC
;
;      convert (continued)
;
;      loop to chase down trblk chain for value
;
scv22	MOV	XL,trval(XL)		; point to next value
	BEQ	(XL),=b_trt,scv22	; loop back if trapped
;
;      here with name in XR, value in XL
;
scv23	MOV	-(XS),XL		; stack value
	MOV	XL,num01(XS)		; load tbblk pointer
	JSR	tfind			; build teblk (note WB gt 0 by name)
	PPM	exfal			; fail if acess fails
	MOV	teval(XL),(XS)+		; store value in teblk
	BRN	scv21			; loop back for next element
;
;      here after moving all elements to tbblk
;
scv24	MOV	XR,(XS)+		; load tbblk pointer
	ICA	XS			; pop arblk pointer
	BRN	eXSid			; exit setting idval
;
;      convert to expression
;
.IF    .cevb
scv25	ZER	WB			; by value
	JSR	gtexp			; convert to expression
.ELSE
scv25	JSR	gtexp			; convert to expression
.FI
	PPM	exfal			; fail if conversion not possible
	ZER	r_ccb			; forget interim code block
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      convert to code
;
scv26	JSR	gtcod			; convert to code
	PPM	exfal			; fail if conversion is not possible
	ZER	r_ccb			; forget interim code block
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
;
;      convert to numeric
;
scv27	JSR	gtnum			; convert to numeric
	PPM	exfal			; fail if unconvertible
scv31	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
.IF    .cnbf
.ELSE
;
;      convert to buffer
;
scv28	MOV	-(XS),XR		; stack first arg for procedure
	JSR	gtstb			; get string or buffer
	PPM	exfal			; fail if conversion not possible
	BNZ	WB,scv30		; jump if already a buffer
	MOV	XL,XR			; save string pointer
	JSR	alobf			; allocate buffer of same size
	JSR	apndb			; copy in the string
	PPM				; already string - cant fail to cnv
	PPM				; must be enough room
	BRN	eXSid			; exit setting idval field
;
;      here if argument is already a buffer
;
scv30	MOV	XR,WB			; return buffer without conversion
	BRN	scv31			; merge to return result
	EJC
.FI
;
;      second argument not string or null
;
scv29	ERB	074,convert second argument is not a string
;
;      copy
;
s_cop	ENT				; entry point
	JSR	copyb			; copy the block
	PPM	exits			; return if no idval field
	BRN	eXSid			; exit setting id value
	EJC
.IF    .cmth
;
;      cos
;
s_cos	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	303,cos argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	COS				; take cosine
	RNO	exrea			; if no overflow, return result in ra
	ERB	322,cos argument is out of range
	EJC
.FI
;
;      data
;
s_dat	ENT				; entry point
	JSR	XScni			; prepare to scan argument
	ERR	075,data argument is not a string
	ERR	076,data argument is null
;
;      scan out datatype name
;
	MOV	WC,=ch_pp		; delimiter one = left paren
	MOV	XL,WC			; delimiter two = left paren
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan datatype name
	BNZ	WA,sdat1		; skip if left paren found
	ERB	077,data argument is missing a left paren
;
;      here after scanning datatype name
;
.IF    .culc
sdat1	MOV	WA,sclen(XR)		; get length
	BZE	WA,sdt1a		; avoid folding if null string
	JSR	flstg			; fold lower case to upper case
sdt1a	MOV	XL,XR			; save name ptr
.ELSE
sdat1	MOV	XL,XR			; save name ptr
.FI
	MOV	WA,sclen(XR)		; get length
	CTB	WA,scsi_		; compute space needed
	JSR	alost			; request static store for name
	MOV	-(XS),XR		; save datatype name
	MVW				; copy name to static
	MOV	XR,(XS)			; get name ptr
	ZER	XL			; scrub dud register
	JSR	gtnvr			; locate vrblk for datatype name
	ERR	078,data argument has null datatype name
	MOV	datdv,XR		; save vrblk pointer for datatype
	MOV	datxs,XS		; store starting stack value
	ZER	WB			; zero count of field names
;
;      loop to scan field names and stack vrblk pointers
;
sdat2	MOV	WC,=ch_rp		; delimiter one = right paren
	MOV	XL,=ch_cm		; delimiter two = comma
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan next field name
	BNZ	WA,sdat3		; jump if delimiter found
	ERB	079,data argument is missing a right paren
;
;      here after scanning out one field name
;
sdat3	JSR	gtnvr			; locate vrblk for field name
	ERR	080,data argument has null field name
	MOV	-(XS),XR		; stack vrblk pointer
	ICV	WB			; increment counter
	BEQ	WA,=num02,sdat2		; loop back if stopped by comma
	EJC
;
;      data (continued)
;
;      now build the dfblk
;
	MOV	WA,=dfsi_		; set size of dfblk standard fields
	ADD	WA,WB			; add number of fields
	WTB	WA			; convert length to bytes
	MOV	WC,WB			; preserve no. of fields
	JSR	alost			; allocate space for dfblk
	MOV	WB,WC			; get no of fields
	MOV	XT,datxs		; point to start of stack
	MOV	WC,(XT)			; load datatype name
	MOV	(XT),XR			; save dfblk pointer on stack
	MOV	(XR)+,=b_dfc		; store type word
	MOV	(XR)+,WB		; store number of fields (fargs)
	MOV	(XR)+,WA		; store length (dflen)
	SUB	WA,*pddfs		; compute pdblk length (for dfpdl)
	MOV	(XR)+,WA		; store pdblk length (dfpdl)
	MOV	(XR)+,WC		; store datatype name (dfnam)
	LCT	WC,WB			; copy number of fields
;
;      loop to move field name vrblk pointers to dfblk
;
sdat4	MOV	(XR)+,-(XT)		; move one field name vrblk pointer
	BCT	WC,sdat4		; loop till all moved
;
;      now define the datatype function
;
	MOV	WC,WA			; copy length of pdblk for later loop
	MOV	XR,datdv		; point to vrblk
	MOV	XT,datxs		; point back on stack
	MOV	XL,(XT)			; load dfblk pointer
	JSR	dffnc			; define function
	EJC
;
;      data (continued)
;
;      loop to build ffblks
;
;
;      notice that the ffblks are constructed in reverse order
;      so that the required offsets can be obtained from
;      successive decrementation of the pdblk length (in WC).
;
sdat5	MOV	WA,*ffsi_		; set length of ffblk
	JSR	alloc			; allocate space for ffblk
	MOV	(XR),=b_ffc		; set type word
	MOV	fargs(XR),=num01	; store fargs (always one)
	MOV	XT,datxs		; point back on stack
	MOV	ffdfp(XR),(XT)		; copy dfblk ptr to ffblk
	DCA	WC			; decrement old dfpdl to get next ofs
	MOV	ffofs(XR),WC		; set offset to this field
	ZER	ffnxt(XR)		; tentatively set zero forward ptr
	MOV	XL,XR			; copy ffblk pointer for dffnc
	MOV	XR,(XS)			; load vrblk pointer for field
	MOV	XR,vrfnc(XR)		; load current function pointer
	BNE	(XR),=b_ffc,sdat6	; skip if not currently a field func
;
;      here we must chain an old ffblk ptr to preserve it in the
;      case of multiple field functions with the same name
;
	MOV	ffnxt(XL),XR		; link new ffblk to previous chain
;
;      merge here to define field function
;
sdat6	MOV	XR,(XS)+		; load vrblk pointer
	JSR	dffnc			; define field function
	BNE	XS,datxs,sdat5		; loop back till all done
	ICA	XS			; pop dfblk pointer
	BRN	exnul			; return with null result
	EJC
;
;      datatype
;
s_dtp	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	dtype			; get datatype
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      date
;
s_dte	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtint			; convert to an integer
	ERR	330,date argument is not integer
	JSR	sysdt			; call system date routine
	MOV	WA,num01(XL)		; load length for sbstr
	BZE	WA,exnul		; return null if length is zero
	ZER	WB			; set zero offset
	JSR	sbstr			; use sbstr to build scblk
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      define
;
s_def	ENT				; entry point
	MOV	XR,(XS)+		; load second argument
	ZER	deflb			; zero label pointer in case null
	BEQ	XR,=nulls,sdf01		; jump if null second argument
	JSR	gtnvr			; else find vrblk for label
	PPM	sdf12			; jump if not a vaRIAble name
	MOV	deflb,XR		; else set specified entry
;
;      scan function name
;
sdf01	JSR	XScni			; prepare to scan first argument
	ERR	081,define first argument is not a string
	ERR	082,define first argument is null
	MOV	WC,=ch_pp		; delimiter one = left paren
	MOV	XL,WC			; delimiter two = left paren
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan out function name
	BNZ	WA,sdf02		; jump if left paren found
	ERB	083,define first argument is missing a left paren
;
;      here after scanning out function name
;
sdf02	JSR	gtnvr			; get vaRIAble name
	ERR	084,define first argument has null function name
	MOV	defvr,XR		; save vrblk pointer for function nam
	ZER	WB			; zero count of arguments
	MOV	defxs,XS		; save initial stack pointer
	BNZ	deflb,sdf03		; jump if second argument given
	MOV	deflb,XR		; else default is function name
;
;      loop to scan argument names and stack vrblk pointers
;
sdf03	MOV	WC,=ch_rp		; delimiter one = right paren
	MOV	XL,=ch_cm		; delimiter two = comma
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan out next argument name
	BNZ	WA,sdf04		; skip if delimiter found
	ERB	085,null arg name or missing ) in define first arg.
	EJC
;
;      define (continued)
;
;      here after scanning an argument name
;
sdf04	BNE	XR,=nulls,sdf05		; skip if non-null
	BZE	WB,sdf06		; ignore null if case of no arguments
;
;      here after dealing with the case of no arguments
;
sdf05	JSR	gtnvr			; get vrblk pointer
	PPM	sdf03			; loop back to ignore null name
	MOV	-(XS),XR		; stack argument vrblk pointer
	ICV	WB			; increment counter
	BEQ	WA,=num02,sdf03		; loop back if stopped by a comma
;
;      here after scanning out function argument names
;
sdf06	MOV	defna,WB		; save number of arguments
	ZER	WB			; zero count of locals
;
;      loop to scan local names and stack vrblk pointers
;
sdf07	MOV	WC,=ch_cm		; set delimiter one = comma
	MOV	XL,WC			; set delimiter two = comma
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan out next local name
	BNE	XR,=nulls,sdf08		; skip if non-null
	BZE	WA,sdf09		; exit scan if end of string
;
;      here after scanning out a local name
;
sdf08	JSR	gtnvr			; get vrblk pointer
	PPM	sdf07			; loop back to ignore null name
	ICV	WB			; if ok, increment count
	MOV	-(XS),XR		; stack vrblk pointer
	BNZ	WA,sdf07		; loop back if stopped by a comma
	EJC
;
;      define (continued)
;
;      here after scanning locals, build pfblk
;
sdf09	MOV	WA,WB			; copy count of locals
	ADD	WA,defna		; add number of arguments
	MOV	WC,WA			; set sum args+locals as loop count
	ADD	WA,=pfsi_		; add space for standard fields
	WTB	WA			; convert length to bytes
	JSR	alloc			; allocate space for pfblk
	MOV	XL,XR			; save pointer to pfblk
	MOV	(XR)+,=b_pfc		; store first word
	MOV	(XR)+,defna		; store number of arguments
	MOV	(XR)+,WA		; store length (pflen)
	MOV	(XR)+,defvr		; store vrblk ptr for function name
	MOV	(XR)+,WB		; store number of locals
	ZER	(XR)+			; deal with label later
	ZER	(XR)+			; zero pfctr
	ZER	(XR)+			; zero pfrtr
	BZE	WC,sdf11		; skip if no args or locals
	MOV	WA,XL			; keep pfblk pointer
	MOV	XT,defxs		; point before arguments
	LCT	WC,WC			; get count of args+locals for loop
;
;      loop to move locals and args to pfblk
;
sdf10	MOV	(XR)+,-(XT)		; store one entry and bump pointers
	BCT	WC,sdf10		; loop till all stored
	MOV	XL,WA			; recover pfblk pointer
	EJC
;
;      define (continued)
;
;      now deal with label
;
sdf11	MOV	XS,defxs		; pop stack
	MOV	pfcod(XL),deflb		; store label vrblk in pfblk
	MOV	XR,defvr		; point back to vrblk for function
	JSR	dffnc			; define function
	BRN	exnul			; and exit returning null
;
;      here for erroneous label
;
sdf12	ERB	086,define function entry point is not defined label
	EJC
;
;      detach
;
s_det	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtvar			; locate vaRIAble
	ERR	087,detach argument is not appropriate name
	JSR	dtach			; detach i/o association from name
	BRN	exnul			; return null result
	EJC
;
;      differ
;
s_dif	ENT				; entry point
	MOV	XR,(XS)+		; load second argument
	MOV	XL,(XS)+		; load first argument
	JSR	ident			; call ident comparison routine
	PPM	exfal			; fail if ident
	BRN	exnul			; return null if differ
	EJC
;
;      dump
;
s_dmp	ENT				; entry point
	JSR	gtsmi			; load dump arg as small integer
	ERR	088,dump argument is not integer
	ERR	089,dump argument is negative or too large
	JSR	dumpr			; else call dump routine
	BRN	exnul			; and return null as result
	EJC
;
;      dupl
;
s_dup	ENT				; entry point
	JSR	gtsmi			; get second argument as small integr
	ERR	090,dupl second argument is not integer
	PPM	sdup7			; jump if negative or too big
	MOV	WB,XR			; save duplication factor
	JSR	gtstg			; get first arg as string
	PPM	sdup4			; jump if not a string
;
;      here for case of duplication of a string
;
	MTI	WA			; acquire length as integer
	STI	dupsi			; save for the moment
	MTI	WB			; get duplication factor as integer
	MLI	dupsi			; form product
	IOV	sdup3			; jump if overflow
	IEQ	exnul			; return null if result length = 0
	MFI	WA,sdup3		; get as addr integer, check ovflo
;
;      merge here with result length in wa
;
sdup1	MOV	XL,XR			; save string pointer
	JSR	alocs			; allocate space for string
	MOV	-(XS),XR		; save as result pointer
	MOV	WC,XL			; save pointer to argument string
	PSC	XR			; prepare to store chars of result
	LCT	WB,WB			; set counter to control loop
;
;      loop through duplications
;
sdup2	MOV	XL,WC			; point back to argument string
	MOV	WA,sclen(XL)		; get number of characters
	PLC	XL			; point to chars in argument string
	MVC				; move characters to result string
	BCT	WB,sdup2		; loop till all duplications done
	ZER	XL			; clear garbage value
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      dupl (continued)
;
;      here if too large, set max length and let alocs catch it
;
sdup3	MOV	WA,dname		; set impossible length for alocs
	BRN	sdup1			; merge back
;
;      here if not a string
;
sdup4	JSR	gtpat			; convert argument to pattern
	ERR	091,dupl first argument is not a string or pattern
;
;      here to duplicate a pattern argument
;
	MOV	-(XS),XR		; store pattern on stack
	MOV	XR,=ndnth		; start off with null pattern
	BZE	WB,sdup6		; null pattern is result if dupfac=0
	MOV	-(XS),WB		; preserve loop count
;
;      loop to duplicate by successive concatenation
;
sdup5	MOV	XL,XR			; copy current value as right argumnt
	MOV	XR,num01(XS)		; get a new copy of left
	JSR	pconc			; concatenate
	DCV	(XS)			; count down
	BNZ	(XS),sdup5		; loop
	ICA	XS			; pop loop count
;
;      here to exit after constructing pattern
;
sdup6	MOV	(XS),XR			; store result on stack
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
;
;      fail if second arg is out of range
;
sdup7	ICA	XS			; pop first argument
	BRN	exfal			; fail
	EJC
;
;      eject
;
s_ejc	ENT				; entry point
	JSR	iofcb			; call fcblk routine
	ERR	092,eject argument is not a suitable name
	PPM	sejc1			; null argument
	ERR	093,eject file does not exist
	JSR	sysef			; call eject file function
	ERR	093,eject file does not exist
	ERR	094,eject file does not permit page eject
	ERR	095,eject caused non-recoverable output error
	BRN	exnul			; return null as result
;
;      here to eject standard output file
;
sejc1	JSR	sysep			; call routine to eject printer
	BRN	exnul			; exit with null result
	EJC
;
;      endfile
;
s_enf	ENT				; entry point
	JSR	iofcb			; call fcblk routine
	ERR	096,endfile argument is not a suitable name
	ERR	097,endfile argument is null
	ERR	098,endfile file does not exist
	JSR	sysen			; call endfile routine
	ERR	098,endfile file does not exist
	ERR	099,endfile file does not permit endfile
	ERR	100,endfile caused non-recoverable output error
	MOV	WB,XL			; remember vrblk ptr from iofcb call
	MOV	XR,XL			; copy pointer
;
;      loop to find trtrf block
;
senf1	MOV	XL,XR			; remember previous entry
	MOV	XR,trval(XR)		; chain along
	BNE	(XR),=b_trt,exnul	; skip out if chain end
	BNE	trtyp(XR),=trtfc,senf1	; loop if not found
	MOV	trval(XL),trval(XR)	; remove trtrf
	MOV	enfch,trtrf(XR)		; point to head of iochn
	MOV	WC,trfpt(XR)		; point to fcblk
	MOV	XR,WB			; filearg1 vrblk from iofcb
	JSR	setvr			; reset it
	MOV	XL,=r_fcb		; ptr to head of fcblk chain
	SUB	XL,*num02		; adjust ready to enter loop
;
;      find fcblk
;
senf2	MOV	XR,XL			; copy ptr
	MOV	XL,num02(XL)		; get next link
	BZE	XL,senf4		; stop if chain end
	BEQ	num03(XL),WC,senf3	; jump if fcblk found
	BRN	senf2			; loop
;
;      remove fcblk
;
senf3	MOV	num02(XR),num02(XL)	; delete fcblk from chain
;
;      loop which detaches all vbls on iochn chain
;
senf4	MOV	XL,enfch		; get chain head
	BZE	XL,exnul		; finished if chain end
	MOV	enfch,trtrf(XL)		; chain along
	MOV	WA,ionmo(XL)		; name offset
	MOV	XL,ionmb(XL)		; name base
	JSR	dtach			; detach name
	BRN	senf4			; loop till done
	EJC
;
;      eq
;
s_eqf	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	101,eq first argument is not numeric
	ERR	102,eq second argument is not numeric
	PPM	exfal			; fail if lt
	PPM	exnul			; return null if eq
	PPM	exfal			; fail if gt
	EJC
;
;      eval
;
s_evl	ENT				; entry point
	MOV	XR,(XS)+		; load argument
.IF    .cevb
.ELSE
	JSR	gtexp			; convert to expression
	ERR	103,eval argument is not expression
.FI
	LCW	WC			; load next code word
	BNE	WC,=ofne_,sevl1		; jump if called by value
	SCP	XL			; copy code pointer
	MOV	WA,(XL)			; get next code word
	BNE	WA,=ornm_,sevl2		; by name unless expression
	BNZ	num01(XS),sevl2		; jump if by name
;
;      here if called by value
;
sevl1	ZER	WB			; set flag for by value
.IF    .cevb
	MOV	-(XS),WC		; save code word
	JSR	gtexp			; convert to expression
	ERR	103,eval argument is not expression
	ZER	r_ccb			; forget interim code block
	ZER	WB			; set flag for by value
.ELSE
	MOV	-(XS),WC		; save code word
.FI
	JSR	evalx			; evaluate expression by value
	PPM	exfal			; fail if evaluation fails
	MOV	XL,XR			; copy result
	MOV	XR,(XS)			; reload next code word
	MOV	(XS),XL			; stack result
	BRI	(XR)			; jump to execute next code word
;
;      here if called by name
;
sevl2	MOV	WB,=num01		; set flag for by name
.IF    .cevb
	JSR	gtexp			; convert to expression
	ERR	103,eval argument is not expression
	ZER	r_ccb			; forget interim code block
	MOV	WB,=num01		; set flag for by name
.FI
	JSR	evalx			; evaluate expression by name
	PPM	exfal			; fail if evaluation fails
	BRN	exnam			; exit with name
.IF    .cnex
.ELSE
	EJC
;
;      exit
;
s_ext	ENT				; entry point
	ZER	WB			; clear amount of static shift
	ZER	r_ccb			; forget interim code block
.IF    .csed
	ZER	dnams			; collect sediment too
	JSR	gbcol			; compact memory by collecting
	MOV	dnams,XR		; record new sediment size
.ELSE
	JSR	gbcol			; compact memory by collecting
.FI
	JSR	gtstg			;
	ERR	288,exit second argument is not a string
	MOV	XL,XR			; copy second arg string pointer
	JSR	gtstg			; convert arg to string
	ERR	104,exit first argument is not suitable integer or string
	MOV	-(XS),XL		; save second argument
	MOV	XL,XR			; copy first arg string ptr
	JSR	gtint			; check it is integer
	PPM	seXT1			; skip if unconvertible
	ZER	XL			; note it is integer
	LDI	icval(XR)		; get integer arg
;
;      merge to call osint exit routine
;
seXT1	MOV	WB,r_fcb		; get fcblk chain header
	MOV	XR,=headv		; point to v.v string
	MOV	WA,(XS)+		; provide second argument scblk
	JSR	sysxi			; call eXTernal routine
	ERR	105,exit action not available in this implementation
	ERR	106,exit action caused irrecoverable error
	IEQ	exnul			; return if argument 0
	IGT	seXT2			; skip if positive
	NGI				; make positive
;
;      check for option respecification
;
;      sysxi returns 0 in wa when a file has been resumed,
;      1 when this is a continuation of an exit(4) or exit(-4)
;      action.
;
seXT2	MFI	WC			; get value in work reg
	ADD	WA,WC			; prepare to test for continue
	BEQ	WA,=num05,seXT5		; continued execution if 4 plus 1
	ZER	gbcnt			; resuming execution so reset
	BGE	WC,=num03,seXT3		; skip if was 3 or 4
	MOV	-(XS),WC		; save value
	ZER	WC			; set to read options
	JSR	prpar			; read syspp options
	MOV	WC,(XS)+		; restore value
;
;      deal with header option (fiddled by prpar)
;
seXT3	MNZ	headp			; assume no headers
	BNE	WC,=num01,seXT4		; skip if not 1
	ZER	headp			; request header printing
;
;      almost ready to resume running
;
seXT4	JSR	systm			; get execution time start (sgd11)
	STI	timsx			; save as initial time
	LDI	kvstc			; reset to ensure ...
	STI	kvstl			; ... correct execution stats
	JSR	stgcc			; recompute countdown counters
	BRN	exnul			; resume execution
;
;      here after exit(4) or exit(-4) -- create save file
;      or load module and continue execution.
;
;      return integer 1 to signal the continuation of the
;      original execution.
;
seXT5	MOV	XR,=inton		; integer one
	BRN	exiXR			; return as result
.FI
	EJC
.IF    .cmth
;
;      exp
;
s_exp	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	304,exp argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	ETX				; take exponential
	RNO	exrea			; if no overflow, return result in ra
	ERB	305,exp produced real overflow
	EJC
.FI
;
;      field
;
s_fld	ENT				; entry point
	JSR	gtsmi			; get second argument (field number)
	ERR	107,field second argument is not integer
	PPM	exfal			; fail if out of range
	MOV	WB,XR			; else save integer value
	MOV	XR,(XS)+		; load first argument
	JSR	gtnvr			; point to vrblk
	PPM	sfld1			; jump (error) if not vaRIAble name
	MOV	XR,vrfnc(XR)		; else point to function block
	BNE	(XR),=b_dfc,sfld1	; error if not datatype function
;
;      here if first argument is a datatype function name
;
	BZE	WB,exfal		; fail if argument number is zero
	BGT	WB,fargs(XR),exfal	; fail if too large
	WTB	WB			; else convert to byte offset
	ADD	XR,WB			; point to field name
	MOV	XR,dfflb(XR)		; load vrblk pointer
	BRN	exvnm			; exit to build nmblk
;
;      here for bad first argument
;
sfld1	ERB	108,field first argument is not datatype name
	EJC
;
;      fence
;
s_fnc	ENT				; entry point
	MOV	WB,=p_fnc		; set pcode for p_fnc
	ZER	XR			; p0blk
	JSR	pbild			; build p_fnc node
	MOV	XL,XR			; save pointer to it
	MOV	XR,(XS)+		; get argument
	JSR	gtpat			; convert to pattern
	ERR	259,fence argument is not pattern
	JSR	pconc			; concatenate to p_fnc node
	MOV	XL,XR			; save ptr to concatenated pattern
	MOV	WB,=p_fna		; set for p_fna pcode
	ZER	XR			; p0blk
	JSR	pbild			; construct p_fna node
	MOV	pthen(XR),XL		; set pattern as pthen
	MOV	-(XS),XR		; set as result
	LCW	XR			; get next code word
	BRI	(XR)			; execute next code word
	EJC
;
;      ge
;
s_gef	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	109,ge first argument is not numeric
	ERR	110,ge second argument is not numeric
	PPM	exfal			; fail if lt
	PPM	exnul			; return null if eq
	PPM	exnul			; return null if gt
	EJC
;
;      gt
;
s_gtf	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	111,gt first argument is not numeric
	ERR	112,gt second argument is not numeric
	PPM	exfal			; fail if lt
	PPM	exfal			; fail if eq
	PPM	exnul			; return null if gt
	EJC
;
;      host
;
s_hst	ENT				; entry point
	MOV	WC,(XS)+		; get fifth arg
	MOV	WB,(XS)+		; get fourth arg
	MOV	XR,(XS)+		; get third arg
	MOV	XL,(XS)+		; get second arg
	MOV	WA,(XS)+		; get first arg
	JSR	syshs			; enter syshs routine
	ERR	254,erroneous argument for host
	ERR	255,error during execution of host
	PPM	shst1			; store host string
	PPM	exnul			; return null result
	PPM	exiXR			; return XR
	PPM	exfal			; fail return
	PPM	shst3			; store actual string
	PPM	shst4			; return copy of XR
;
;      return host string
;
shst1	BZE	XL,exnul		; null string if syshs uncooperative
	MOV	WA,sclen(XL)		; length
	ZER	WB			; zero offset
;
;      copy string and return
;
shst2	JSR	sbstr			; build copy of string
	MOV	-(XS),XR		; stack the result
	LCW	XR			; load next code word
	BRI	(XR)			; execute it
;
;      return actual string pointed to by XL
;
shst3	ZER	WB			; treat XL like an scblk ptr
	SUB	WB,=cfp_f		; by creating a negative offset
	BRN	shst2			; join to copy string
;
;      return copy of block pointed to by XR
;
shst4	MOV	-(XS),XR		; stack results
	JSR	copyb			; make copy of block
	PPM	exits			; if not an aggregate structure
	BRN	eXSid			; set current id value otherwise
	EJC
;
;      ident
;
s_idn	ENT				; entry point
	MOV	XR,(XS)+		; load second argument
	MOV	XL,(XS)+		; load first argument
	JSR	ident			; call ident comparison routine
	PPM	exnul			; return null if ident
	BRN	exfal			; fail if differ
	EJC
;
;      input
;
s_inp	ENT				; entry point
	ZER	WB			; input flag
	JSR	ioput			; call input/output assoc. routine
	ERR	113,input third argument is not a string
	ERR	114,inappropriate second argument for input
	ERR	115,inappropriate first argument for input
	ERR	116,inappropriate file specification for input
	PPM	exfal			; fail if file does not exist
	ERR	117,input file cannot be read
	ERR	289,input channel currently in use
	BRN	exnul			; return null string
	EJC
.IF    .cnbf
.ELSE
;
;      insert
;
s_ins	ENT				; entry point
	MOV	XL,(XS)+		; get string arg
	JSR	gtsmi			; get replace length
	ERR	277,insert third argument not integer
	PPM	exfal			; fail if out of range
	MOV	WB,WC			; copy to proper reg
	JSR	gtsmi			; get replace position
	ERR	278,insert second argument not integer
	PPM	exfal			; fail if out of range
	BZE	WC,exfal		; fail if zero
	DCV	WC			; decrement to get offset
	MOV	WA,WC			; put in proper register
	MOV	XR,(XS)+		; get buffer
	BEQ	(XR),=b_bct,sins1	; press on if type ok
	ERB	279,insert first argument is not a buffer
;
;      here when everything loaded up
;
sins1	JSR	insbf			; call to insert
	ERR	280,insert fourth argument is not a string
	PPM	exfal			; fail if out of range
	BRN	exnul			; else ok - exit with null
	EJC
.FI
;
;      integer
;
s_int	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtnum			; convert to numeric
	PPM	exfal			; fail if non-numeric
	BEQ	WA,=b_icl,exnul		; return null if integer
	BRN	exfal			; fail if real
	EJC
;
;      item
;
;      item does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
s_itm	ENT				; entry point
;
;      deal with case of no args
;
	BNZ	WA,sitm1		; jump if at least one arg
	MOV	-(XS),=nulls		; else supply garbage null arg
	MOV	WA,=num01		; and fix argument count
;
;      check for name/value cases
;
sitm1	SCP	XR			; get current code pointer
	MOV	XL,(XR)			; load next code word
	DCV	WA			; get number of subscripts
	MOV	XR,WA			; copy for arref
	BEQ	XL,=ofne_,sitm2		; jump if called by name
;
;      here if called by value
;
	ZER	WB			; set code for call by value
	BRN	arref			; off to array reference routine
;
;      here for call by name
;
sitm2	MNZ	WB			; set code for call by name
	LCW	WA			; load and ignore ofne_ call
	BRN	arref			; off to array reference routine
	EJC
;
;      le
;
s_lef	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	118,le first argument is not numeric
	ERR	119,le second argument is not numeric
	PPM	exnul			; return null if lt
	PPM	exnul			; return null if eq
	PPM	exfal			; fail if gt
	EJC
;
;      len
;
s_len	ENT				; entry point
	MOV	WB,=p_len		; set pcode for integer arg case
	MOV	WA,=p_lnd		; set pcode for expr arg case
	JSR	patin			; call common routine to build node
	ERR	120,len argument is not integer or expression
	ERR	121,len argument is negative or too large
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      leq
;
s_leq	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	122,leq first argument is not a string
	ERR	123,leq second argument is not a string
	PPM	exfal			; fail if llt
	PPM	exnul			; return null if leq
	PPM	exfal			; fail if lgt
	EJC
;
;      lge
;
s_lge	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	124,lge first argument is not a string
	ERR	125,lge second argument is not a string
	PPM	exfal			; fail if llt
	PPM	exnul			; return null if leq
	PPM	exnul			; return null if lgt
	EJC
;
;      lgt
;
s_lgt	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	126,lgt first argument is not a string
	ERR	127,lgt second argument is not a string
	PPM	exfal			; fail if llt
	PPM	exfal			; fail if leq
	PPM	exnul			; return null if lgt
	EJC
;
;      lle
;
s_lle	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	128,lle first argument is not a string
	ERR	129,lle second argument is not a string
	PPM	exnul			; return null if llt
	PPM	exnul			; return null if leq
	PPM	exfal			; fail if lgt
	EJC
;
;      llt
;
s_llt	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	130,llt first argument is not a string
	ERR	131,llt second argument is not a string
	PPM	exnul			; return null if llt
	PPM	exfal			; fail if leq
	PPM	exfal			; fail if lgt
	EJC
;
;      lne
;
s_lne	ENT				; entry point
	JSR	lcomp			; call string comparison routine
	ERR	132,lne first argument is not a string
	ERR	133,lne second argument is not a string
	PPM	exnul			; return null if llt
	PPM	exfal			; fail if leq
	PPM	exnul			; return null if lgt
	EJC
.IF    .cmth
;
;      ln
;
s_lnf	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	306,ln argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	REQ	slnf1			; overflow if argument is 0
	RLT	slnf2			; error if argument less than 0
	LNF				; take natural logarithm
	RNO	exrea			; if no overflow, return result in ra
slnf1	ERB	307,ln produced real overflow
;
;      here for bad argument
;
slnf2	ERB	315,ln argument negative
	EJC
.FI
;
;      local
;
s_loc	ENT				; entry point
	JSR	gtsmi			; get second argument (local number)
	ERR	134,local second argument is not integer
	PPM	exfal			; fail if out of range
	MOV	WB,XR			; save local number
	MOV	XR,(XS)+		; load first argument
	JSR	gtnvr			; point to vrblk
	PPM	sloc1			; jump if not vaRIAble name
	MOV	XR,vrfnc(XR)		; else load function pointer
	BNE	(XR),=b_pfc,sloc1	; jump if not program defined
;
;      here if we have a program defined function name
;
	BZE	WB,exfal		; fail if second arg is zero
	BGT	WB,pfnlo(XR),exfal	; or too large
	ADD	WB,fargs(XR)		; else adjust offset to include args
	WTB	WB			; convert to bytes
	ADD	XR,WB			; point to local pointer
	MOV	XR,pfagb(XR)		; load vrblk pointer
	BRN	exvnm			; exit building nmblk
;
;      here if first argument is no good
;
sloc1	ERB	135,local first arg is not a program function name
.IF    .cnld
.ELSE
	EJC
;
;      load
;
s_lod	ENT				; entry point
	JSR	gtstg			; load library name
	ERR	136,load second argument is not a string
	MOV	XL,XR			; save library name
	JSR	XScni			; prepare to scan first argument
	ERR	137,load first argument is not a string
	ERR	138,load first argument is null
	MOV	-(XS),XL		; stack library name
	MOV	WC,=ch_pp		; set delimiter one = left paren
	MOV	XL,WC			; set delimiter two = left paren
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan function name
	MOV	-(XS),XR		; save ptr to function name
	BNZ	WA,slod1		; jump if left paren found
	ERB	139,load first argument is missing a left paren
;
;      here after successfully scanning function name
;
slod1	JSR	gtnvr			; locate vrblk
	ERR	140,load first argument has null function name
	MOV	lodfn,XR		; save vrblk pointer
	ZER	lodna			; zero count of arguments
;
;      loop to scan argument datatype names
;
slod2	MOV	WC,=ch_rp		; delimiter one is right paren
	MOV	XL,=ch_cm		; delimiter two is comma
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan next argument name
	ICV	lodna			; bump argument count
	BNZ	WA,slod3		; jump if ok delimiter was found
	ERB	141,load first argument is missing a right paren
	EJC
;
;      load (continued)
;
;      come here to analyze the datatype pointer in (XR). this
;      code is used both for arguments (wa=1,2) and for the
;      result datatype (with wa set to zero).
;
.IF    .culc
slod3	MOV	WB,WA			; save scan mode
	MOV	WA,sclen(XR)		; datatype length
	BZE	WA,sld3a		; bypass if null string
	JSR	flstg			; fold to upper case
sld3a	MOV	WA,WB			; restore scan mode
	MOV	-(XS),XR		; stack datatype name pointer
.ELSE
slod3	MOV	-(XS),XR		; stack datatype name pointer
.FI
	MOV	WB,=num01		; set string code in case
	MOV	XL,=scstr		; point to /string/
	JSR	ident			; check for match
	PPM	slod4			; jump if match
	MOV	XR,(XS)			; else reload name
	ADD	WB,WB			; set code for integer (2)
	MOV	XL,=scint		; point to /integer/
	JSR	ident			; check for match
	PPM	slod4			; jump if match
.IF    .cnra
.ELSE
	MOV	XR,(XS)			; else reload string pointer
	ICV	WB			; set code for real (3)
	MOV	XL,=screa		; point to /real/
	JSR	ident			; check for match
	PPM	slod4			; jump if match
.FI
.IF    .cnlf
	MOV	XR,(XS)			; reload string pointer
	ICV	WB			; code for file (4, or 3 if no reals)
	MOV	XL,=scfil		; point to /file/
	JSR	ident			; check for match
	PPM	slod4			; jump if match
.FI
	ZER	WB			; else get code for no convert
;
;      merge here with proper datatype code in WB
;
slod4	MOV	(XS),WB			; store code on stack
	BEQ	WA,=num02,slod2		; loop back if arg stopped by comma
	BZE	WA,slod5		; jump if that was the result type
;
;      here we scan out the result type (arg stopped by ) )
;
	MOV	WC,mxlen		; set dummy (impossible) delimiter 1
	MOV	XL,WC			; and delimiter two
	MNZ	WA			; skip/trim blanks in prototype
	JSR	XScan			; scan result name
	ZER	WA			; set code for processing result
	BRN	slod3			; jump back to process result name
	EJC
;
;      load (continued)
;
;      here after processing all args and result
;
slod5	MOV	WA,lodna		; get number of arguments
	MOV	WC,WA			; copy for later
	WTB	WA			; convert length to bytes
	ADD	WA,*efsi_		; add space for standard fields
	JSR	alloc			; allocate efblk
	MOV	(XR),=b_efc		; set type word
	MOV	fargs(XR),WC		; set number of arguments
	ZER	efuse(XR)		; set use count (dffnc will set to 1)
	ZER	efcod(XR)		; zero code pointer for now
	MOV	efrsl(XR),(XS)+		; store result type code
	MOV	efvar(XR),lodfn		; store function vrblk pointer
	MOV	eflen(XR),WA		; store efblk length
	MOV	WB,XR			; save efblk pointer
	ADD	XR,WA			; point past end of efblk
	LCT	WC,WC			; set number of arguments for loop
;
;      loop to set argument type codes from stack
;
slod6	MOV	-(XR),(XS)+		; store one type code from stack
	BCT	WC,slod6		; loop till all stored
;
;      now load the eXTernal function and perform definition
;
	MOV	XR,(XS)+		; load function string name
.IF    .culc
	MOV	WA,sclen(XR)		; function name length
	JSR	flstg			; fold to upper case
.FI
	MOV	XL,(XS)			; load library name
	MOV	(XS),WB			; store efblk pointer
	JSR	sysld			; call function to load eXTernal func
	ERR	142,load function does not exist
	ERR	143,load function caused input error during load
	ERR	328,load function - insufficient memory
	MOV	XL,(XS)+		; recall efblk pointer
	MOV	efcod(XL),XR		; store code pointer
	MOV	XR,lodfn		; point to vrblk for function
	JSR	dffnc			; perform function definition
	BRN	exnul			; return null result
.FI
	EJC
;
;      lpad
;
s_lpd	ENT				; entry point
	JSR	gtstg			; get pad character
	ERR	144,lpad third argument is not a string
	PLC	XR			; point to character (null is blank)
	LCH	WB,(XR)			; load pad character
	JSR	gtsmi			; get pad length
	ERR	145,lpad second argument is not integer
	PPM	slpd4			; skip if negative or large
;
;      merge to check first arg
;
slpd1	JSR	gtstg			; get first argument (string to pad)
	ERR	146,lpad first argument is not a string
	BGE	WA,WC,exiXR		; return 1st arg if too long to pad
	MOV	XL,XR			; else move ptr to string to pad
;
;      now we are ready for the pad
;
;      (XL)		     pointer to string to pad
;      (WB)		     pad character
;      (WC)		     length to pad string to
;
	MOV	WA,WC			; copy length
	JSR	alocs			; allocate scblk for new string
	MOV	-(XS),XR		; save as result
	MOV	WA,sclen(XL)		; load length of argument
	SUB	WC,WA			; calculate number of pad characters
	PSC	XR			; point to chars in result string
	LCT	WC,WC			; set counter for pad loop
;
;      loop to perform pad
;
slpd2	SCH	WB,(XR)+		; store pad character, bump ptr
	BCT	WC,slpd2		; loop till all pad chars stored
	CSC	XR			; complete store characters
;
;      now copy string
;
	BZE	WA,slpd3		; exit if null string
	PLC	XL			; else point to chars in argument
	MVC				; move characters to result string
	ZER	XL			; clear garbage XL
;
;      here to exit with result on stack
;
slpd3	LCW	XR			; load next code word
	BRI	(XR)			; execute it
;
;      here if 2nd arg is negative or large
;
slpd4	ZER	WC			; zero pad count
	BRN	slpd1			; merge
	EJC
;
;      lt
;
s_ltf	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	147,lt first argument is not numeric
	ERR	148,lt second argument is not numeric
	PPM	exnul			; return null if lt
	PPM	exfal			; fail if eq
	PPM	exfal			; fail if gt
	EJC
;
;      ne
;
s_nef	ENT				; entry point
	JSR	acomp			; call arithmetic comparison routine
	ERR	149,ne first argument is not numeric
	ERR	150,ne second argument is not numeric
	PPM	exnul			; return null if lt
	PPM	exfal			; fail if eq
	PPM	exnul			; return null if gt
	EJC
;
;      notany
;
s_nay	ENT				; entry point
	MOV	WB,=p_nas		; set pcode for single char arg
	MOV	XL,=p_nay		; pcode for multi-char arg
	MOV	WC,=p_nad		; set pcode for expr arg
	JSR	patst			; call common routine to build node
	ERR	151,notany argument is not a string or expression
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      opsyn
;
s_ops	ENT				; entry point
	JSR	gtsmi			; load third argument
	ERR	152,opsyn third argument is not integer
	ERR	153,opsyn third argument is negative or too large
	MOV	WB,WC			; if ok, save third argumnet
	MOV	XR,(XS)+		; load second argument
	JSR	gtnvr			; locate vaRIAble block
	ERR	154,opsyn second arg is not natural vaRIAble name
	MOV	XL,vrfnc(XR)		; if ok, load function block pointer
	BNZ	WB,sops2		; jump if operator opsyn case
;
;      here for function opsyn (third arg zero)
;
	MOV	XR,(XS)+		; load first argument
	JSR	gtnvr			; get vrblk pointer
	ERR	155,opsyn first arg is not natural vaRIAble name
;
;      merge here to perform function definition
;
sops1	JSR	dffnc			; call function definer
	BRN	exnul			; exit with null result
;
;      here for operator opsyn (third arg non-zero)
;
sops2	JSR	gtstg			; get operator name
	PPM	sops5			; jump if not string
	BNE	WA,=num01,sops5		; error if not one char long
	PLC	XR			; else point to character
	LCH	WC,(XR)			; load character name
	EJC
;
;      opsyn (continued)
;
;      now set to search for matching unary or binary operator
;      name as appropriate. note that there are =opbun undefined
;      binary operators and =opuun undefined unary operators.
;
	MOV	WA,=r_uub		; point to unop pointers in case
	MOV	XR,=opnsu		; point to names of unary operators
	ADD	WB,=opbun		; add no. of undefined binary ops
	BEQ	WB,=opuun,sops3		; jump if unop (third arg was 1)
	MOV	WA,=r_uba		; else point to binary operator ptrs
	MOV	XR,=opsnb		; point to names of binary operators
	MOV	WB,=opbun		; set number of undefined binops
;
;      merge here to check list (WB = number to check)
;
sops3	LCT	WB,WB			; set counter to control loop
;
;      loop to search for name match
;
sops4	BEQ	WC,(XR),sops6		; jump if names match
	ICA	WA			; else push pointer to function ptr
	ICA	XR			; bump pointer
	BCT	WB,sops4		; loop back till all checked
;
;      here if bad operator name
;
sops5	ERB	156,opsyn first arg is not correct operator name
;
;      come here on finding a match in the operator name table
;
sops6	MOV	XR,WA			; copy pointer to function block ptr
	SUB	XR,*vrfnc		; make it look like dummy vrblk
	BRN	sops1			; merge back to define operator
	EJC
.IF    .c370
;
;      or
;
s_orf	ENT				; entry point
	MNZ	WB			; signal two arguments
	JSR	sbool			; call string boolean routine
	ERR	xxx,or first argument is not a string
	ERR	xxx,or second argument is not a string
	ERR	xxx,or arguments not same length
	PPM	exits			; null string arguments
;
;      here to process (WC) words.  result is stacked.
;
sorf1	MOV	WA,(XL)+		; get next cfp_c chars from arg 1
	ORB	WA,(XR)			; or with characters from arg 2
	MOV	(XR)+,WA		; put back in memory
	BCT	WC,sorf1		; loop over all words in string block
	BRN	exits			; fetch next code word
	EJC
.FI
;
;      output
;
s_oup	ENT				; entry point
	MOV	WB,=num03		; output flag
	JSR	ioput			; call input/output assoc. routine
	ERR	157,output third argument is not a string
	ERR	158,inappropriate second argument for output
	ERR	159,inappropriate first argument for output
	ERR	160,inappropriate file specification for output
	PPM	exfal			; fail if file does not exist
	ERR	161,output file cannot be written to
	ERR	290,output channel currently in use
	BRN	exnul			; return null string
	EJC
;
;      pos
;
s_pos	ENT				; entry point
	MOV	WB,=p_pos		; set pcode for integer arg case
	MOV	WA,=p_psd		; set pcode for expression arg case
	JSR	patin			; call common routine to build node
	ERR	162,pos argument is not integer or expression
	ERR	163,pos argument is negative or too large
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      prototype
;
s_pro	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	MOV	WB,tblen(XR)		; length if table, vector (=vclen)
	BTW	WB			; convert to words
	MOV	WA,(XR)			; load type word of argument block
	BEQ	WA,=b_art,spro4		; jump if array
	BEQ	WA,=b_tbt,spro1		; jump if table
	BEQ	WA,=b_vct,spro3		; jump if vector
.IF    .cnbf
.ELSE
	BEQ	WA,=b_bct,spr05		; jump if buffer
.FI
	ERB	164,prototype argument is not valid object
;
;      here for table
;
spro1	SUB	WB,=tbsi_		; subtract standard fields
;
;      merge for vector
;
spro2	MTI	WB			; convert to integer
	BRN	exint			; exit with integer result
;
;      here for vector
;
spro3	SUB	WB,=vcsi_		; subtract standard fields
	BRN	spro2			; merge
;
;      here for array
;
spro4	ADD	XR,arofs(XR)		; point to prototype field
	MOV	XR,(XR)			; load prototype
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.IF    .cnbf
.ELSE
;
;      here for buffer
;
spr05	MOV	XR,bcbuf(XR)		; point to bfblk
	MTI	bfalc(XR)		; load allocated length
	BRN	exint			; exit with integer allocation
.FI
	EJC
;
;      remdr
;
s_rmd	ENT				; entry point
.IF    .cmth
	JSR	arith			; get two integers or two reals
	ERR	166,remdr first argument is not numeric
	ERR	165,remdr second argument is not numeric
	PPM	srm06			; if real
.ELSE
	MOV	XR,(XS)			; load second argument
	JSR	gtint			; convert to integer
	ERR	165,remdr second argument is not integer
	MOV	(XS),XR			; place converted arg in stack
	JSR	arith			; convert args
	PPM	srm04			; first arg not integer
	PPM				; second arg checked above
.IF    .cnra
.ELSE
	PPM	srm01			; first arg real
.FI
.FI
;
;      both arguments integer
;
	ZER	WB			; set positive flag
	LDI	icval(XR)		; load left argument value
	IGE	srm01			; jump if positive
	MNZ	WB			; set negative flag
srm01	RMI	icval(XL)		; get remainder
	IOV	srm05			; error if overflow
;
;      make sign of result match sign of first argument
;
	BZE	WB,srm03		; if result should be positive
	ILE	exint			; if should be negative, and is
srm02	NGI				; adjust sign of result
	BRN	exint			; return result
srm03	ILT	srm02			; should be pos, and result negative
	BRN	exint			; should be positive, and is
;
;      fail first argument
;
srm04	ERB	166,remdr first argument is not numeric
;
;      fail if overflow
;
srm05	ERB	167,remdr caused integer overflow
.IF    .cmth
;
;      here with 1st argument in (XR), 2nd in (XL), both real
;
;      result = n1 - chop(n1/n2)*n2
;
srm06	ZER	WB			; set positive flag
	LDR	rcval(XR)		; load left argument value
	RGE	srm07			; jump if positive
	MNZ	WB			; set negative flag
srm07	DVR	rcval(XL)		; compute n1/n2
	ROV	srm10			; jump if overflow
	CHP				; chop result
	MLR	rcval(XL)		; times n2
	SBR	rcval(XR)		; compute difference
;
;      make sign of result match sign of first argument
;      -result is in ra at this point
;
	BZE	WB,srm09		; if result should be positive
	RLE	exrea			; if should be negative, and is
srm08	NGR				; adjust sign of result
	BRN	exrea			; return result
srm09	RLT	srm08			; should be pos, and result negative
	BRN	exrea			; should be positive, and is
;
;      fail if overflow
;
srm10	ERB	312,remdr caused real overflow
.FI
	EJC
;
;      replace
;
;      the actual replace operation uses an scblk whose cfp_a
;      chars contain the translated versions of all the chars.
;      the table pointer is remembered from call to call and
;      the table is only built when the arguments change.
;
;      we also perform an optimization gleaned from spitbol 370.
;      if the second argument is &alphabet, there is no need to
;      to build a replace table.  the third argument can be
;      used directly as the replace table.
;
s_rpl	ENT				; entry point
	JSR	gtstg			; load third argument as string
	ERR	168,replace third argument is not a string
	MOV	XL,XR			; save third arg ptr
	JSR	gtstg			; get second argument
	ERR	169,replace second argument is not a string
;
;      check to see if this is the same table as last time
;
	BNE	XR,r_ra2,srpl1		; jump if 2nd argument different
	BEQ	XL,r_ra3,srpl4		; jump if args same as last time
;
;      here we build a new replace table (note wa = 2nd arg len)
;
srpl1	MOV	WB,sclen(XL)		; load 3rd argument length
	BNE	WA,WB,srpl6		; jump if arguments not same length
	BEQ	XR,kvalp,srpl5		; jump if 2nd arg is alphabet string
	BZE	WB,srpl6		; jump if null 2nd argument
	MOV	r_ra3,XL		; save third arg for next time in
	MOV	r_ra2,XR		; save second arg for next time in
	MOV	XL,kvalp		; point to alphabet string
	MOV	WA,sclen(XL)		; load alphabet scblk length
	MOV	XR,r_rpt		; point to current table (if any)
	BNZ	XR,srpl2		; jump if we already have a table
;
;      here we allocate a new table
;
	JSR	alocs			; allocate new table
	MOV	WA,WC			; keep scblk length
	MOV	r_rpt,XR		; save table pointer for next time
;
;      merge here with pointer to new table block in (XR)
;
srpl2	CTB	WA,scsi_		; compute length of scblk
	MVW				; copy to get initial table values
	EJC
;
;      replace (continued)
;
;      now we must plug selected entries as required. note that
;      we are short of index registers for the following loop.
;      hence the need to repeatedly re-initialise char ptr XL
;
	MOV	XL,r_ra2		; point to second argument
	LCT	WB,WB			; number of chars to plug
	ZER	WC			; zero char offset
	MOV	XR,r_ra3		; point to 3rd arg
	PLC	XR			; get char ptr for 3rd arg
;
;      loop to plug chars
;
srpl3	MOV	XL,r_ra2		; point to 2nd arg
	PLC	XL,WC			; point to next char
	ICV	WC			; increment offset
	LCH	WA,(XL)			; get next char
	MOV	XL,r_rpt		; point to translate table
	PSC	XL,WA			; convert char to offset into table
	LCH	WA,(XR)+		; get translated char
	SCH	WA,(XL)			; store in table
	CSC	XL			; complete store characters
	BCT	WB,srpl3		; loop till done
	EJC
;
;      replace (continued)
;
;      here to use r_rpt as replace table.
;
srpl4	MOV	XL,r_rpt		; replace table to use
;
;      here to perform translate using table in XL.
;
.IF    .cnbf
srpl5	JSR	gtstg			; get first argument
	ERR	170,replace first argument is not a string
.ELSE
;
;      if first arg is a buffer, perform translate in place.
;
srpl5	JSR	gtstb			; get first argument
	ERR	170,replace first argument is not a string or buffer
	BNZ	WB,srpl7		; branch if buffer
.FI
	BZE	WA,exnul		; return null if null argument
	MOV	-(XS),XL		; stack replace table to use
	MOV	XL,XR			; copy pointer
	MOV	WC,WA			; save length
	CTB	WA,schar		; get scblk length
	JSR	alloc			; allocate space for copy
	MOV	WB,XR			; save address of copy
	MVW				; move scblk contents to copy
	MOV	XR,(XS)+		; unstack replace table
	PLC	XR			; point to chars of table
	MOV	XL,WB			; point to string to translate
	PLC	XL			; point to chars of string
	MOV	WA,WC			; set number of chars to translate
	TRC				; perform translation
srpl8	MOV	-(XS),WB		; stack result
	LCW	XR			; load next code word
	BRI	(XR)			; execute it
;
;      error point
;
srpl6	ERB	171,null or unequally long 2nd, 3rd args to replace
.IF    .cnbf
.ELSE
;
;      here to perform replacement within buffer
;
srpl7	BZE	WA,srpl8		; return buffer unchanged if empty
	MOV	WC,XR			; copy bfblk pointer to WC
	MOV	XR,XL			; translate table to XR
	PLC	XR			; point to chars of table
	MOV	XL,WC			; point to string to translate
	PLC	XL			; point to chars of string
	TRC				; perform translation
	BRN	srpl8			; stack result and exit
.FI
	EJC
;
;      rewind
;
s_rew	ENT				; entry point
	JSR	iofcb			; call fcblk routine
	ERR	172,rewind argument is not a suitable name
	ERR	173,rewind argument is null
	ERR	174,rewind file does not exist
	JSR	sysrw			; call system rewind function
	ERR	174,rewind file does not exist
	ERR	175,rewind file does not permit rewind
	ERR	176,rewind caused non-recoverable error
	BRN	exnul			; exit with null result if no error
	EJC
;
;      reverse
;
s_rvs	ENT				; entry point
.IF    .cnbf
	JSR	gtstg			; load string argument
	ERR	177,reverse argument is not a string
.ELSE
	JSR	gtstb			; load string or buffer argument
	ERR	177,reverse argument is not a string or buffer
	BNZ	WB,srvs3		; branch if buffer
.FI
	BZE	WA,exiXR		; return argument if null
	MOV	XL,XR			; else save pointer to string arg
	JSR	alocs			; allocate space for new scblk
	MOV	-(XS),XR		; store scblk ptr on stack as result
	PSC	XR			; prepare to store in new scblk
	PLC	XL,WC			; point past last char in argument
	LCT	WC,WC			; set loop counter
;
;      loop to move chars in reverse order
;
srvs1	LCH	WB,-(XL)		; load next char from argument
	SCH	WB,(XR)+		; store in result
	BCT	WC,srvs1		; loop till all moved
;
;      here when complete to execute next code word
;
srvs4	CSC	XR			; complete store characters
	ZER	XL			; clear garbage XL
srvs2	LCW	XR			; load next code word
	BRI	(XR)			; execute it
.IF    .cnbf
.ELSE
;
;      here if argument is a buffer.  perform reverse in place.
;
srvs3	MOV	-(XS),WB		; stack buffer as result
	BZE	WA,srvs2		; return buffer unchanged if empty
	MOV	XL,XR			; copy bfblk pointer to XL
	PSC	XR			; prepare to store at first char
	PLC	XL,WA			; point past last char in argument
	RSH	WA,1			; operate on half the string
	LCT	WC,WA			; set loop counter
;
;      loop to swap chars from end to end.  note that in the
;      case of an odd count, the middle char is not touched.
;
srvs5	LCH	WB,-(XL)		; load next char from end
	LCH	WA,(XR)			; load next char from front
	SCH	WB,(XR)+		; store end char in front
	SCH	WA,(XL)			; store front char at end
	BCT	WC,srvs5		; loop till all moved
	BRN	srvs4			; complete store
.FI
	EJC
;
;      rpad
;
s_rpd	ENT				; entry point
	JSR	gtstg			; get pad character
	ERR	178,rpad third argument is not a string
	PLC	XR			; point to character (null is blank)
	LCH	WB,(XR)			; load pad character
	JSR	gtsmi			; get pad length
	ERR	179,rpad second argument is not integer
	PPM	srpd3			; skip if negative or large
;
;      merge to check first arg.
;
srpd1	JSR	gtstg			; get first argument (string to pad)
	ERR	180,rpad first argument is not a string
	BGE	WA,WC,exiXR		; return 1st arg if too long to pad
	MOV	XL,XR			; else move ptr to string to pad
;
;      now we are ready for the pad
;
;      (XL)		     pointer to string to pad
;      (WB)		     pad character
;      (WC)		     length to pad string to
;
	MOV	WA,WC			; copy length
	JSR	alocs			; allocate scblk for new string
	MOV	-(XS),XR		; save as result
	MOV	WA,sclen(XL)		; load length of argument
	SUB	WC,WA			; calculate number of pad characters
	PSC	XR			; point to chars in result string
	LCT	WC,WC			; set counter for pad loop
;
;      copy argument string
;
	BZE	WA,srpd2		; jump if argument is null
	PLC	XL			; else point to argument chars
	MVC				; move characters to result string
	ZER	XL			; clear garbage XL
;
;      loop to supply pad characters
;
srpd2	SCH	WB,(XR)+		; store pad character, bump ptr
	BCT	WC,srpd2		; loop till all pad chars stored
	CSC	XR			; complete character storing
	LCW	XR			; load next code word
	BRI	(XR)			; execute it
;
;      here if 2nd arg is negative or large
;
srpd3	ZER	WC			; zero pad count
	BRN	srpd1			; merge
	EJC
;
;      rtab
;
s_rtb	ENT				; entry point
	MOV	WB,=p_rtb		; set pcode for integer arg case
	MOV	WA,=p_rtd		; set pcode for expression arg case
	JSR	patin			; call common routine to build node
	ERR	181,rtab argument is not integer or expression
	ERR	182,rtab argument is negative or too large
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
.IF    .cust
;
;      set
;
s_set	ENT				; entry point
	MOV	r_io2,(XS)+		; save third arg (whence)
.IF    .cusr
	MOV	XR,(XS)+		; get second arg (offset)
	JSR	gtrea			; convert to real
	ERR	324,set second argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
.ELSE
	MOV	r_io1,(XS)+		; save second arg (offset)
.FI
	JSR	iofcb			; call fcblk routine
	ERR	291,set first argument is not a suitable name
	ERR	292,set first argument is null
	ERR	295,set file does not exist
.IF    .cusr
.ELSE
	MOV	WB,r_io1		; load second arg
.FI
	MOV	WC,r_io2		; load third arg
	JSR	sysst			; call system set routine
	ERR	293,inappropriate second argument to set
	ERR	294,inappropriate third argument to set
	ERR	295,set file does not exist
	ERR	296,set file does not permit setting file pointer
	ERR	297,set caused non-recoverable i/o error
.IF    .cusr
	RTI	exrea			; return real position if not able
	BRN	exint			; to return integer position
.ELSE
	BRN	exint			; otherwise return position
.FI
	EJC
.FI
;
;      tab
;
s_tab	ENT				; entry point
	MOV	WB,=p_tab		; set pcode for integer arg case
	MOV	WA,=p_tbd		; set pcode for expression arg case
	JSR	patin			; call common routine to build node
	ERR	183,tab argument is not integer or expression
	ERR	184,tab argument is negative or too large
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      rpos
;
s_rps	ENT				; entry point
	MOV	WB,=p_rps		; set pcode for integer arg case
	MOV	WA,=p_rpd		; set pcode for expression arg case
	JSR	patin			; call common routine to build node
	ERR	185,rpos argument is not integer or expression
	ERR	186,rpos argument is negative or too large
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.IF    .cnsr
.ELSE
	EJC
;
;      rsort
;
s_rsr	ENT				; entry point
	MNZ	WA			; mark as rsort
	JSR	sorta			; call sort routine
	PPM	exfal			; if conversion fails, so shall we
	BRN	eXSid			; return, setting idval
.FI
	EJC
;
;      setexit
;
s_stx	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	MOV	WA,stxvr		; load old vrblk pointer
	ZER	XL			; load zero in case null arg
	BEQ	XR,=nulls,sstx1		; jump if null argument (reset call)
	JSR	gtnvr			; else get specified vrblk
	PPM	sstx2			; jump if not natural vaRIAble
	MOV	XL,vrlbl(XR)		; else load label
	BEQ	XL,=stndl,sstx2		; jump if label is not defined
	BNE	(XL),=b_trt,sstx1	; jump if not trapped
	MOV	XL,trlbl(XL)		; else load ptr to real label code
;
;      here to set/reset setexit trap
;
sstx1	MOV	stxvr,XR		; store new vrblk pointer (or null)
	MOV	r_sxc,XL		; store new code ptr (or zero)
	BEQ	WA,=nulls,exnul		; return null if null result
	MOV	XR,WA			; else copy vrblk pointer
	BRN	exvnm			; and return building nmblk
;
;      here if bad argument
;
sstx2	ERB	187,setexit argument is not label name or null
.IF    .cmth
;
;      sin
;
s_sin	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	308,sin argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	SIN				; take sine
	RNO	exrea			; if no overflow, return result in ra
	ERB	323,sin argument is out of range
	EJC
.FI
.IF    .cmth
;
;      sqrt
;
s_sqr	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	313,sqrt argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	RLT	ssqr1			; negative number
	SQR				; take square root
	BRN	exrea			; no overflow possible, result in ra
;
;      here if bad argument
;
ssqr1	ERB	314,sqrt argument negative
	EJC
.FI
.IF    .cnsr
.ELSE
	EJC
;
;      sort
;
s_srt	ENT				; entry point
	ZER	WA			; mark as sort
	JSR	sorta			; call sort routine
	PPM	exfal			; if conversion fails, so shall we
	BRN	eXSid			; return, setting idval
.FI
	EJC
;
;      span
;
s_spn	ENT				; entry point
	MOV	WB,=p_sps		; set pcode for single char arg
	MOV	XL,=p_spn		; set pcode for multi-char arg
	MOV	WC,=p_spd		; set pcode for expression arg
	JSR	patst			; call common routine to build node
	ERR	188,span argument is not a string or expression
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      size
;
s_si_	ENT				; entry point
.IF    .cnbf
	JSR	gtstg			; load string argument
	ERR	189,size argument is not a string
.ELSE
	JSR	gtstb			; load string argument
	ERR	189,size argument is not a string or buffer
.FI
;
;      merge with bfblk or scblk ptr in XR.  wa has length.
;
	MTI	WA			; load length as integer
	BRN	exint			; exit with integer result
	EJC
;
;      stoptr
;
s_stt	ENT				; entry point
	ZER	XL			; indicate stoptr case
	JSR	trace			; call trace procedure
	ERR	190,stoptr first argument is not appropriate name
	ERR	191,stoptr second argument is not trace type
	BRN	exnul			; return null
	EJC
;
;      substr
;
s_sub	ENT				; entry point
	JSR	gtsmi			; load third argument
	ERR	192,substr third argument is not integer
	PPM	exfal			; jump if negative or too large
	MOV	sbssv,XR		; save third argument
	JSR	gtsmi			; load second argument
	ERR	193,substr second argument is not integer
	PPM	exfal			; jump if out of range
	MOV	WC,XR			; save second argument
	BZE	WC,exfal		; jump if second argument zero
	DCV	WC			; else decrement for ones origin
.IF    .cnbf
	JSR	gtstg			; load first argument
	ERR	194,substr first argument is not a string
.ELSE
	JSR	gtstb			; load first argument
	ERR	194,substr first argument is not a string or buffer
.FI
;
;      merge with bfblk or scblk ptr in XR.  wa has length
;
	MOV	WB,WC			; copy second arg to WB
	MOV	WC,sbssv		; reload third argument
	BNZ	WC,ssub2		; skip if third arg given
	MOV	WC,WA			; else get string length
	BGT	WB,WC,exfal		; fail if improper
	SUB	WC,WB			; reduce by offset to start
;
;      merge
;
ssub2	MOV	XL,WA			; save string length
	MOV	WA,WC			; set length of substring
	ADD	WC,WB			; add 2nd arg to 3rd arg
	BGT	WC,XL,exfal		; jump if improper substring
	MOV	XL,XR			; copy pointer to first arg
	JSR	sbstr			; build substring
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      table
;
s_tbl	ENT				; entry point
	MOV	XL,(XS)+		; get initial lookup value
	ICA	XS			; pop second argument
	JSR	gtsmi			; load argument
	ERR	195,table argument is not integer
	ERR	196,table argument is out of range
	BNZ	WC,stbl1		; jump if non-zero
	MOV	WC,=tbnbk		; else supply default value
;
;      merge here with number of headers in WC
;
stbl1	JSR	tmake			; make table
	BRN	eXSid			; exit setting idval
	EJC
.IF    .cmth
;
;      tan
;
s_tan	ENT				; entry point
	MOV	XR,(XS)+		; get argument
	JSR	gtrea			; convert to real
	ERR	309,tan argument not numeric
	LDR	rcval(XR)		; load accumulator with argument
	TAN				; take tangent
	RNO	exrea			; if no overflow, return result in ra
	ERB	310,tan produced real overflow or argument is out of range
	EJC
.FI
;
;      time
;
s_tim	ENT				; entry point
	JSR	systm			; get timer value
	SBI	timsx			; subtract starting time
	BRN	exint			; exit with integer value
	EJC
;
;      trace
;
s_tra	ENT				; entry point
	BEQ	num03(XS),=nulls,str02	; jump if first argument is null
	MOV	XR,(XS)+		; load fourth argument
	ZER	XL			; tentatively set zero pointer
	BEQ	XR,=nulls,str01		; jump if 4th argument is null
	JSR	gtnvr			; else point to vrblk
	PPM	str03			; jump if not vaRIAble name
	MOV	XL,XR			; else save vrblk in trfnc
;
;      here with vrblk or zero in XL
;
str01	MOV	XR,(XS)+		; load third argument (tag)
	ZER	WB			; set zero as trtyp value for now
	JSR	trbld			; build trblk for trace call
	MOV	XL,XR			; move trblk pointer for trace
	JSR	trace			; call trace procedure
	ERR	198,trace first argument is not appropriate name
	ERR	199,trace second argument is not trace type
	BRN	exnul			; return null
;
;      here to call system trace toggle routine
;
str02	JSR	systt			; call it
	ADD	XS,*num04		; pop trace arguments
	BRN	exnul			; return
;
;      here for bad fourth argument
;
str03	ERB	197,trace fourth arg is not function name or null
	EJC
;
;      trim
;
s_trm	ENT				; entry point
.IF    .cnbf
	JSR	gtstg			; load argument as string
	ERR	200,trim argument is not a string
.ELSE
	JSR	gtstb			; load argument as string
	ERR	200,trim argument is not a string or buffer
	BNZ	WB,strm0		; branch if buffer
.FI
	BZE	WA,exnul		; return null if argument is null
	MOV	XL,XR			; copy string pointer
	CTB	WA,schar		; get block length
	JSR	alloc			; allocate copy same size
	MOV	WB,XR			; save pointer to copy
	MVW				; copy old string block to new
	MOV	XR,WB			; restore ptr to new block
	JSR	trimr			; trim blanks (WB is non-zero)
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.IF    .cnbf
.ELSE
;
;      argument is a buffer, perform trim in place.
;
strm0	MOV	-(XS),WB		; stack buffer as result
	BZE	WA,strm6		; return buffer unchanged if empty
	MOV	XL,XR			; get bfblk ptr
	MOV	XR,WB			; copy bcblk ptr to XR
	PLC	XL,WA			; point past last character
	MOV	WC,=ch_bl		; load blank character
;
;      loop through characters from right to left
;
strm1	LCH	WB,-(XL)		; load next character
.IF    .caht
	BEQ	WB,=ch_ht,strm2		; jump if horizontal tab
.FI
	BNE	WB,WC,strm3		; jump if non-blank found
strm2	DCV	WA			; else decrement character count
	BNZ	WA,strm1		; loop back if more to check
;
;      here when buffer trim complete
;
strm3	MOV	bclen(XR),WA		; set new length in bcblk
	MOV	XR,bcbuf(XR)		; get bfblk ptr
	MOV	WB,WA			; copy length
	CTB	WB,0			; words needed converted to bytes
	SUB	WB,WA			; number of zeros needed
	PSC	XR,WA			; ready for storing zeros
	ZER	WC			; set zero char
;
;      loop to zero pad last word of characters
;
strm4	BZE	WB,strm5		; loop while more to be done
	SCH	WC,(XR)+		; store zero character
	DCV	WB			; decrement count
	BRN	strm4			; continue loop
strm5	CSC	XR			; complete store characters
strm6	LCW	XR			; get next code word
	BRI	(XR)			; execute it
.FI
	EJC
;
;      unload
;
s_unl	ENT				; entry point
	MOV	XR,(XS)+		; load argument
	JSR	gtnvr			; point to vrblk
	ERR	201,unload argument is not natural vaRIAble name
	MOV	XL,=stndf		; get ptr to undefined function
	JSR	dffnc			; undefine named function
	BRN	exnul			; return null as result
.IF    .c370
	EJC
;
;      xor
;
s_xor	ENT				; entry point
	MNZ	WB			; signal two arguments
	JSR	sbool			; call string boolean routine
	ERR	xxx,xor first argument is not a string
	ERR	xxx,xor second argument is not a string
	ERR	xxx,xor arguments not same length
	PPM	exits			; null string arguments
;
;      here to process (WC) words.  result is stacked.
;
sxor1	MOV	WA,(XL)+		; get next cfp_c chars from arg 1
	XOB	WA,(XR)			; xor with characters from arg 2
	MOV	(XR)+,WA		; put back in memory
	BCT	WC,sxor1		; loop over all words in string block
	BRN	exits			; fetch next code word
.FI
	TTL	s p i t b o l -- utility routines
;
;      the following section contains utility routines used for
;      various purposes throughout the system. these differ
;      from the procedures in the utility procedures section in
;      they are not in procedure form and they do not return
;      to their callers. they are accessed with a branch type
;      instruction after setting the registers to appropriate
;      parameter values.
;
;      the register values required for each routine are
;      documented at the start of each routine. registers not
;      mentioned may contain any values except that XR,XL
;      can only contain proper collectable pointers.
;
;      some of these routines will tolerate garbage pointers
;      in XL,XR on entry. this is always documented and in
;      each case, the routine clears these garbage values before
;      exiting after completing its task.
;
;      the routines have names consisting of five letters
;      and are assembled in alphabetical order.
	EJC
;      arref -- array reference
;
;      (XL)		     may be non-collectable
;      (XR)		     number of subscripts
;      (WB)		     set zero/nonzero for value/name
;			     the value in WB must be collectable
;      stack		     subscripts and array operand
;      brn  arref	     jump to call function
;
;      arref continues by executing the next code word with
;      the result name or value placed on top of the stack.
;      to deal with the problem of accessing subscripts in the
;      order of stacking, XL is used as a subscript pointer
;      working below the stack pointer.
;
arref	RTN
	MOV	WA,XR			; copy number of subscripts
	MOV	XT,XS			; point to stack front
	WTB	XR			; convert to byte offset
	ADD	XT,XR			; point to array operand on stack
	ICA	XT			; final value for stack popping
	MOV	arfxs,XT		; keep for later
	MOV	XR,-(XT)		; load array operand pointer
	MOV	r_arf,XR		; keep array pointer
	MOV	XR,XT			; save pointer to subscripts
	MOV	XL,r_arf		; point XL to possible vcblk or tbblk
	MOV	WC,(XL)			; load first word
	BEQ	WC,=b_art,arf01		; jump if arblk
	BEQ	WC,=b_vct,arf07		; jump if vcblk
	BEQ	WC,=b_tbt,arf10		; jump if tbblk
	ERB	235,subscripted operand is not table or array
;
;      here for array (arblk)
;
arf01	BNE	WA,arndm(XL),arf09	; jump if wrong number of dims
	LDI	intv0			; get initial subscript of zero
	MOV	XT,XR			; point before subscripts
	ZER	WA			; initial offset to bounds
	BRN	arf03			; jump into loop
;
;      loop to compute subscripts by multiplications
;
arf02	MLI	ardm2(XR)		; multiply total by next dimension
;
;      merge here first time
;
arf03	MOV	XR,-(XT)		; load next subscript
	STI	arfsi			; save current subscript
	LDI	icval(XR)		; load integer value in case
	BEQ	(XR),=b_icl,arf04	; jump if it was an integer
	EJC
;
;      arref (continued)
;
;
	JSR	gtint			; convert to integer
	PPM	arf12			; jump if not integer
	LDI	icval(XR)		; if ok, load integer value
;
;      here with integer subscript in (ia)
;
arf04	MOV	XR,r_arf		; point to array
	ADD	XR,WA			; offset to next bounds
	SBI	arlbd(XR)		; subtract low bound to compare
	IOV	arf13			; out of range fail if overflow
	ILT	arf13			; out of range fail if too small
	SBI	ardim(XR)		; subtract dimension
	IGE	arf13			; out of range fail if too large
	ADI	ardim(XR)		; else restore subscript offset
	ADI	arfsi			; add to current total
	ADD	WA,*ardms		; point to next bounds
	BNE	XT,XS,arf02		; loop back if more to go
;
;      here with integer subscript computed
;
	MFI	WA			; get as one word integer
	WTB	WA			; convert to offset
	MOV	XL,r_arf		; point to arblk
	ADD	WA,arofs(XL)		; add offset past bounds
	ICA	WA			; adjust for arpro field
	BNZ	WB,arf08		; exit with name if name call
;
;      merge here to get value for value call
;
arf05	JSR	acess			; get value
	PPM	arf13			; fail if acess fails
;
;      return value
;
arf06	MOV	XS,arfxs		; pop stack entries
	ZER	r_arf			; finished with array pointer
	MOV	-(XS),XR		; stack result
	LCW	XR			; get next code word
	BRI	(XR)			; execute it
	EJC
;
;      arref (continued)
;
;      here for vector
;
arf07	BNE	WA,=num01,arf09		; error if more than 1 subscript
	MOV	XR,(XS)			; else load subscript
	JSR	gtint			; convert to integer
	PPM	arf12			; error if not integer
	LDI	icval(XR)		; else load integer value
	SBI	intv1			; subtract for ones offset
	MFI	WA,arf13		; get subscript as one word
	ADD	WA,=vcvls		; add offset for standard fields
	WTB	WA			; convert offset to bytes
	BGE	WA,vclen(XL),arf13	; fail if out of range subscript
	BZE	WB,arf05		; back to get value if value call
;
;      return name
;
arf08	MOV	XS,arfxs		; pop stack entries
	ZER	r_arf			; finished with array pointer
	BRN	exnam			; else exit with name
;
;      here if subscript count is wrong
;
arf09	ERB	236,array referenced with wrong number of subscripts
;
;      table
;
arf10	BNE	WA,=num01,arf11		; error if more than 1 subscript
	MOV	XR,(XS)			; else load subscript
	JSR	tfind			; call table search routine
	PPM	arf13			; fail if failed
	BNZ	WB,arf08		; exit with name if name call
	BRN	arf06			; else exit with value
;
;      here for bad table reference
;
arf11	ERB	237,table referenced with more than one subscript
;
;      here for bad subscript
;
arf12	ERB	238,array subscript is not integer
;
;      here to signal failure
;
arf13	ZER	r_arf			; finished with array pointer
	BRN	exfal			; fail
	EJC
;
;      cfunc -- call a function
;
;      cfunc is used to call a snobol level function. it is
;      used by the apply function (s_app), the function
;      trace routine (trxeq) and the main function call entry
;      (o_fnc, o_fns). in the latter cases, cfunc is used only
;      if the number of arguments is incorrect.
;
;      (XL)		     pointer to function block
;      (wa)		     actual number of arguments
;      (XS)		     points to stacked arguments
;      brn  cfunc	     jump to call function
;
;      cfunc continues by executing the function
;
cfunc	RTN
	BLT	WA,fargs(XL),cfnc1	; jump if too few arguments
	BEQ	WA,fargs(XL),cfnc3	; jump if correct number of args
;
;      here if too many arguments supplied, pop them off
;
	MOV	WB,WA			; copy actual number
	SUB	WB,fargs(XL)		; get number of eXTra args
	WTB	WB			; convert to bytes
	ADD	XS,WB			; pop off unwanted arguments
	BRN	cfnc3			; jump to go off to function
;
;      here if too few arguments
;
cfnc1	MOV	WB,fargs(XL)		; load required number of arguments
	BEQ	WB,=nini9,cfnc3		; jump if case of var num of args
	SUB	WB,WA			; calculate number missing
	LCT	WB,WB			; set counter to control loop
;
;      loop to supply eXTra null arguments
;
cfnc2	MOV	-(XS),=nulls		; stack a null argument
	BCT	WB,cfnc2		; loop till proper number stacked
;
;      merge here to jump to function
;
cfnc3	BRI	(XL)			; jump through fcode field
	EJC
;
;      exfal -- exit signalling snobol failure
;
;      (XL,XR)		     may be non-collectable
;      brn  exfal	     jump to fail
;
;      exfal continues by executing the appropriate fail goto
;
exfal	RTN
	MOV	XS,flptr		; pop stack
	MOV	XR,(XS)			; load failure offset
	ADD	XR,r_cod		; point to failure code location
	LCP	XR			; set code pointer
	LCW	XR			; load next code word
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to execute next code word
	EJC
;
;      exint -- exit with integer result
;
;      (XL,XR)		     may be non-collectable
;      (ia)		     integer value
;      brn  exint	     jump to exit with integer
;
;      exint continues by executing the next code word
;      which it does by falling through to exiXR
;
exint	RTN
	ZER	XL			; clear dud value
	JSR	icbld			; build icblk
	EJC
;      exiXR -- exit with result in (XR)
;
;      (XR)		     result
;      (XL)		     may be non-collectable
;      brn  exiXR	     jump to exit with result in (XR)
;
;      exiXR continues by executing the next code word
;      which it does by falling through to exits.
exiXR	RTN
;
	MOV	-(XS),XR		; stack result
;
;
;      exits -- exit with result if any stacked
;
;      (XR,XL)		     may be non-collectable
;
;      brn  exits	     enter exits routine
;
exits	RTN
	LCW	XR			; load next code word
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to execute next code word
	EJC
;
;      exnam -- exit with name in (XL,WA)
;
;      (XL)		     name base
;      (wa)		     name offset
;      (XR)		     may be non-collectable
;      brn  exnam	     jump to exit with name in (XL,WA)
;
;      exnam continues by executing the next code word
;
exnam	RTN
	MOV	-(XS),XL		; stack name base
	MOV	-(XS),WA		; stack name offset
	LCW	XR			; load next code word
	BRI	(XR)			; execute it
	EJC
;
;      exnul -- exit with null result
;
;      (XL,XR)		     may be non-collectable
;      brn  exnul	     jump to exit with null value
;
;      exnul continues by executing the next code word
;
exnul	RTN
	MOV	-(XS),=nulls		; stack null value
	LCW	XR			; load next code word
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to execute next code word
	EJC
.IF    .cnra
.ELSE
;
;      exrea -- exit with real result
;
;      (XL,XR)		     may be non-collectable
;      (RA)		     real value
;      brn  exrea	     jump to exit with real value
;
;      exrea continues by executing the next code word
;
exrea	RTN
	ZER	XL			; clear dud value
	JSR	rcbld			; build rcblk
	BRN	exiXR			; jump to exit with result in XR
.FI
	EJC
;
;      eXSid -- exit setting id field
;
;      eXSid is used to exit after building any of the following
;      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
;
;      (XR)		     ptr to block with idval field
;      (XL)		     may be non-collectable
;      brn  eXSid	     jump to exit after setting id field
;
;      eXSid continues by executing the next code word
;
eXSid	RTN
	MOV	WA,curid		; load current id value
	BNE	WA,mxint,exsi1		; jump if no overflow
	ZER	WA			; else reset for wraparound
;
;      here with old idval in wa
;
exsi1	ICV	WA			; bump id value
	MOV	curid,WA		; store for next time
	MOV	idval(XR),WA		; store id value
	BRN	exiXR			; exit with result in (XR)
	EJC
;
;      exvnm -- exit with name of vaRIAble
;
;      exvnm exits after stacking a value which is a nmblk
;      referencing the name of a given natural vaRIAble.
;
;      (XR)		     vrblk pointer
;      (XL)		     may be non-collectable
;      brn  exvnm	     exit with vrblk pointer in XR
;
exvnm	RTN
	MOV	XL,XR			; copy name base pointer
	MOV	WA,*nmsi_		; set size of nmblk
	JSR	alloc			; allocate nmblk
	MOV	(XR),=b_nml		; store type word
	MOV	nmbas(XR),XL		; store name base
	MOV	nmofs(XR),*vrval	; store name offset
	BRN	exiXR			; exit with result in XR
	EJC
;
;      flpop -- fail and pop in pattern matching
;
;      flpop pops the node and cursor on the stack and then
;      drops through into failp to cause pattern failure
;
;      (XL,XR)		     may be non-collectable
;      brn  flpop	     jump to fail and pop stack
;
flpop	RTN
	ADD	XS,*num02		; pop two entries off stack
	EJC
;
;      failp -- failure in matching pattern node
;
;      failp is used after failing to match a pattern node.
;      see pattern match routines for details of use.
;
;      (XL,XR)		     may be non-collectable
;      brn  failp	     signal failure to match
;
;      failp continues by matching an alternative from the stack
;
failp	RTN
	MOV	XR,(XS)+		; load alternative node pointer
	MOV	WB,(XS)+		; restore old cursor
	MOV	XL,(XR)			; load pcode entry pointer
	BRI	XL			; jump to execute code for node
	EJC
;
;      indir -- compute indirect reference
;
;      (WB)		     nonzero/zero for by name/value
;      brn  indir	     jump to get indirect ref on stack
;
;      indir continues by executing the next code word
;
indir	RTN
	MOV	XR,(XS)+		; load argument
	BEQ	(XR),=b_nml,indr2	; jump if a name
	JSR	gtnvr			; else convert to vaRIAble
	ERR	239,indirection operand is not name
	BZE	WB,indr1		; skip if by value
	MOV	-(XS),XR		; else stack vrblk ptr
	MOV	-(XS),*vrval		; stack name offset
	LCW	XR			; load next code word
	MOV	XL,(XR)			; load entry address
	BRI	XL			; jump to execute next code word
;
;      here to get value of natural vaRIAble
;
indr1	BRI	(XR)			; jump through vrget field of vrblk
;
;      here if operand is a name
;
indr2	MOV	XL,nmbas(XR)		; load name base
	MOV	WA,nmofs(XR)		; load name offset
	BNZ	WB,exnam		; exit if called by name
	JSR	acess			; else get value first
	PPM	exfal			; fail if access fails
	BRN	exiXR			; else return with value in XR
	EJC
;
;      match -- initiate pattern match
;
;      (WB)		     match type code
;      brn  match	     jump to initiate pattern match
;
;      match continues by executing the pattern match. see
;      pattern match routines (p_xxx) for full details.
;
match	RTN
	MOV	XR,(XS)+		; load pattern operand
	JSR	gtpat			; convert to pattern
	ERR	240,pattern match right operand is not pattern
	MOV	XL,XR			; if ok, save pattern pointer
	BNZ	WB,mtch1		; jump if not match by name
	MOV	WA,(XS)			; else load name offset
	MOV	-(XS),XL		; save pattern pointer
	MOV	XL,num02(XS)		; load name base
	JSR	acess			; access subject value
	PPM	exfal			; fail if access fails
	MOV	XL,(XS)			; restore pattern pointer
	MOV	(XS),XR			; stack subject string val for merge
	ZER	WB			; restore type code
;
;      merge here with subject value on stack
;
.IF    .cnbf
mtch1	JSR	gtstg			; convert subject to string
	ERR	241,pattern match left operand is not a string
	MOV	-(XS),WB		; stack match type code
.ELSE
mtch1	MOV	WC,WB			; save match type in WC
	JSR	gtstb			; convert subject to string
	ERR	241,pattern match left operand is not a string or buffer
	MOV	r_pmb,WB		; set to zero/bcblk if string/buffer
	MOV	-(XS),WC		; stack match type code
.FI
	MOV	r_pms,XR		; if ok, store subject string pointer
	MOV	pmssl,WA		; and length
	ZER	-(XS)			; stack initial cursor (zero)
	ZER	WB			; set initial cursor
	MOV	pmhbs,XS		; set history stack base ptr
	ZER	pmdfl			; reset pattern assignment flag
	MOV	XR,XL			; set initial node pointer
	BNZ	kvanc,mtch2		; jump if anchored
;
;      here for unanchored
;
	MOV	-(XS),XR		; stack initial node pointer
	MOV	-(XS),=nduna		; stack pointer to anchor move node
	BRI	(XR)			; start match of first node
;
;      here in anchored mode
;
mtch2	ZER	-(XS)			; dummy cursor value
	MOV	-(XS),=ndabo		; stack pointer to abort node
	BRI	(XR)			; start match of first node
	EJC
;
;      retrn -- return from function
;
;      (wa)		     string pointer for return type
;      brn  retrn	     jump to return from (snobol) func
;
;      retrn continues by executing the code at the return point
;      the stack is cleaned of any garbage left by other
;      routines which may have altered flptr since function
;      entry by using flprt, reserved for use only by
;      function call and return.
;
retrn	RTN
	BNZ	kvfnc,rtn01		; jump if not level zero
	ERB	242,function return from level zero
;
;      here if not level zero return
;
rtn01	MOV	XS,flprt		; pop stack
	ICA	XS			; remove failure offset
	MOV	XR,(XS)+		; pop pfblk pointer
	MOV	flptr,(XS)+		; pop failure pointer
	MOV	flprt,(XS)+		; pop old flprt
	MOV	WB,(XS)+		; pop code pointer offset
	MOV	WC,(XS)+		; pop old code block pointer
	ADD	WB,WC			; make old code pointer absolute
	LCP	WB			; restore old code pointer
	MOV	r_cod,WC		; restore old code block pointer
	DCV	kvfnc			; decrement function level
	MOV	WB,kvtra		; load trace
	ADD	WB,kvftr		; add ftrace
	BZE	WB,rtn06		; jump if no tracing possible
;
;      here if there may be a trace
;
	MOV	-(XS),WA		; save function return type
	MOV	-(XS),XR		; save pfblk pointer
	MOV	kvrtn,WA		; set rtntype for trace function
	MOV	XL,r_fnc		; load fnclevel trblk ptr (if any)
	JSR	ktrex			; execute possible fnclevel trace
	MOV	XL,pfvbl(XR)		; load vrblk ptr (sgd13)
	BZE	kvtra,rtn02		; jump if trace is off
	MOV	XR,pfrtr(XR)		; else load return trace trblk ptr
	BZE	XR,rtn02		; jump if not return traced
	DCV	kvtra			; else decrement trace count
	BZE	trfnc(XR),rtn03		; jump if print trace
	MOV	WA,*vrval		; else set name offset
	MOV	kvrtn,num01(XS)		; make sure rtntype is set right
	JSR	trxeq			; execute full trace
	EJC
;
;      retrn (continued)
;
;      here to test for ftrace
;
rtn02	BZE	kvftr,rtn05		; jump if ftrace is off
	DCV	kvftr			; else decrement ftrace
;
;      here for print trace of function return
;
rtn03	JSR	prtsn			; print statement number
	MOV	XR,num01(XS)		; load return type
	JSR	prtst			; print it
	MOV	WA,=ch_bl		; load blank
	JSR	prtch			; print it
	MOV	XL,0(XS)		; load pfblk ptr
	MOV	XL,pfvbl(XL)		; load function vrblk ptr
	MOV	WA,*vrval		; set vrblk name offset
	BNE	XR,=scfrt,rtn04		; jump if not freturn case
;
;      for freturn, just print function name
;
	JSR	prtnm			; print name
	JSR	prtnl			; terminate print line
	BRN	rtn05			; merge
;
;      here for return or nreturn, print function name = value
;
rtn04	JSR	prtnv			; print name = value
;
;      here after completing trace
;
rtn05	MOV	XR,(XS)+		; pop pfblk pointer
	MOV	WA,(XS)+		; pop return type string
;
;      merge here if no trace required
;
rtn06	MOV	kvrtn,WA		; set rtntype keyword
	MOV	XL,pfvbl(XR)		; load pointer to fn vrblk
	EJC
;      retrn (continued)
;
;      get value of function
;
rtn07	MOV	rtnbp,XL		; save block pointer
	MOV	XL,vrval(XL)		; load value
	BEQ	(XL),=b_trt,rtn07	; loop back if trapped
	MOV	rtnfv,XL		; else save function result value
	MOV	rtnsv,(XS)+		; save original function value
.IF    .cnpf
	MOV	WB,fargs(XR)		; get number of arguments
.ELSE
	MOV	XL,(XS)+		; pop saved pointer
	BZE	XL,rtn7c		; no action if none
	BZE	kvpfl,rtn7c		; jump if no profiling
	JSR	prflu			; else profile last func stmt
	BEQ	kvpfl,=num02,rtn7a	; branch on value of profile keywd
;
;      here if &profile = 1. start time must be frigged to
;      appear earlier than it actually is, by amount used before
;      the call.
;
	LDI	pfstm			; load current time
	SBI	icval(XL)		; frig by subtracting saved amount
	BRN	rtn7b			; and merge
;
;      here if &profile = 2
;
rtn7a	LDI	icval(XL)		; load saved time
;
;      both profile types merge here
;
rtn7b	STI	pfstm			; store back correct start time
;
;      merge here if no profiling
;
rtn7c	MOV	WB,fargs(XR)		; get number of args
.FI
	ADD	WB,pfnlo(XR)		; add number of locals
	BZE	WB,rtn10		; jump if no args/locals
	LCT	WB,WB			; else set loop counter
	ADD	XR,pflen(XR)		; and point to end of pfblk
;
;      loop to restore functions and locals
;
rtn08	MOV	XL,-(XR)		; load next vrblk pointer
;
;      loop to find value block
;
rtn09	MOV	WA,XL			; save block pointer
	MOV	XL,vrval(XL)		; load pointer to next value
	BEQ	(XL),=b_trt,rtn09	; loop back if trapped
	MOV	XL,WA			; else restore last block pointer
	MOV	vrval(XL),(XS)+		; restore old vaRIAble value
	BCT	WB,rtn08		; loop till all processed
;
;      now restore function value and exit
;
rtn10	MOV	XL,rtnbp		; restore ptr to last function block
	MOV	vrval(XL),rtnsv		; restore old function value
	MOV	XR,rtnfv		; reload function result
	MOV	XL,r_cod		; point to new code block
	MOV	kvlst,kvstn		; set lastno from stno
	MOV	kvstn,cdstm(XL)		; reset proper stno value
.IF    .csln
	MOV	kvlln,kvlin		; set lastline from line
	MOV	kvlin,cdsln(XL)		; reset proper line value
.FI
	MOV	WA,kvrtn		; load return type
	BEQ	WA,=scrtn,exiXR		; exit with result in XR if return
	BEQ	WA,=scfrt,exfal		; fail if freturn
	EJC
;
;      retrn (continued)
;
;      here for nreturn
;
	BEQ	(XR),=b_nml,rtn11	; jump if is a name
	JSR	gtnvr			; else try convert to vaRIAble name
	ERR	243,function result in nreturn is not name
	MOV	XL,XR			; if ok, copy vrblk (name base) ptr
	MOV	WA,*vrval		; set name offset
	BRN	rtn12			; and merge
;
;      here if returned result is a name
;
rtn11	MOV	XL,nmbas(XR)		; load name base
	MOV	WA,nmofs(XR)		; load name offset
;
;      merge here with returned name in (XL,WA)
;
rtn12	MOV	XR,XL			; preserve XL
	LCW	WB			; load next word
	MOV	XL,XR			; restore XL
	BEQ	WB,=ofne_,exnam		; exit if called by name
	MOV	-(XS),WB		; else save code word
	JSR	acess			; get value
	PPM	exfal			; fail if access fails
	MOV	XL,XR			; if ok, copy result
	MOV	XR,(XS)			; reload next code word
	MOV	(XS),XL			; store result on stack
	MOV	XL,(XR)			; load routine address
	BRI	XL			; jump to execute next code word
	EJC
;
;      stcov -- signal statement counter overflow
;
;      brn  stcov	     jump to signal statement count oflo
;
;      permit up to 10 more statements to be obeyed so that
;      setexit trap can regain control.
;      stcov continues by issuing the error message
;
stcov	RTN
	ICV	errft			; fatal error
	LDI	intvt			; get 10
	ADI	kvstl			; add to former limit
	STI	kvstl			; store as new stlimit
	LDI	intvt			; get 10
	STI	kvstc			; set as new count
	JSR	stgcc			; recompute countdown counters
	ERB	244,statement count exceeds value of stlimit keyword
	EJC
;
;      stmgo -- start execution of new statement
;
;      (XR)		     pointer to cdblk for new statement
;      brn  stmgo	     jump to execute new statement
;
;      stmgo continues by executing the next statement
;
stmgo	RTN
	MOV	r_cod,XR		; set new code block pointer
	DCV	stmct			; see if time to check something
	BZE	stmct,stgo2		; jump if so
	MOV	kvlst,kvstn		; set lastno
	MOV	kvstn,cdstm(XR)		; set stno
.IF    .csln
	MOV	kvlln,kvlin		; set lastline
	MOV	kvlin,cdsln(XR)		; set line
.FI
	ADD	XR,*cdcod		; point to first code word
	LCP	XR			; set code pointer
;
;      here to execute first code word of statement
;
stgo1	LCW	XR			; load next code word
	ZER	XL			; clear garbage XL
	BRI	(XR)			; execute it
;
;      check profiling, polling, stlimit, statement tracing
;
stgo2	BZE	kvpfl,stgo3		; skip if no profiling
	JSR	prflu			; else profile the statement in kvstn
;
;      here when finished with profiling
;
stgo3	MOV	kvlst,kvstn		; set lastno
	MOV	kvstn,cdstm(XR)		; set stno
.IF    .csln
	MOV	kvlln,kvlin		; set lastline
	MOV	kvlin,cdsln(XR)		; set line
.FI
	ADD	XR,*cdcod		; point to first code word
	LCP	XR			; set code pointer
.IF    .cpol
;
;      here to check for polling
;
	MOV	-(XS),stmcs		; save present count start on stack
	DCV	polct			; poll interval within stmct
	BNZ	polct,stgo4		; jump if not poll time yet
	ZER	WA			; =0 for poll
	MOV	WB,kvstn		; statement number
	MOV	XL,XR			; make collectable
	JSR	syspl			; allow interactive access
	ERR	320,user interrupt
	PPM				; single step
	PPM				; expression evaluation
	MOV	XR,XL			; restore code block pointer
	MOV	polcs,WA		; poll interval start value
	JSR	stgcc			; recompute counter values
.FI
;
;      check statement limit
;
stgo4	LDI	kvstc			; get stmt count
	ILT	stgo5			; omit counting if negative
	MTI	(XS)+			; reload start value of counter
	NGI				; negate
	ADI	kvstc			; stmt count minus counter
	STI	kvstc			; replace it
	ILE	stcov			; fail if stlimit reached
	BZE	r_stc,stgo5		; jump if no statement trace
	ZER	XR			; clear garbage value in XR
	MOV	XL,r_stc		; load pointer to stcount trblk
	JSR	ktrex			; execute keyword trace
;
;      reset stmgo counter
;
stgo5	MOV	stmct,stmcs		; reset counter
	BRN	stgo1			; fetch next code word
	EJC
;
;      stopr -- terminate run
;
;      (XR)		     points to ending message
;      brn stopr	     jump to terminate run
;
;      terminate run and print statistics.  on entry XR points
;      to ending message or is zero if message	printed already.
;
stopr	RTN
.IF    .csax
	BZE	XR,stpra		; skip if sysax already called
	JSR	sysax			; call after execution proc
stpra	ADD	dname,rsmem		; use the reserve memory
.ELSE
	ADD	dname,rsmem		; use the reserve memory
.FI
	BNE	XR,=endms,stpr0		; skip if not normal end message
	BNZ	exsts,stpr3		; skip if exec stats suppressed
	ZER	erich			; clear errors to int.ch. flag
;
;      look to see if an ending message is supplied
;
stpr0	JSR	prtpg			; eject printer
	BZE	XR,stpr1		; skip if no message
	JSR	prtst			; print message
;
;      merge here if no message to print
;
stpr1	JSR	prtis			; print blank line
.IF    .csfn
	BNZ	gbcfl,stpr5		; if in garbage collection, skip
	MOV	XR,=stpm7		; point to message /in file xxx/
	JSR	prtst			; print it
	MOV	profs,=prtmf		; set column offset
	MOV	WC,kvstn		; get statement number
	JSR	filnm			; get file name
	MOV	XR,XL			; prepare to print
	JSR	prtst			; print file name
	JSR	prtis			; print to interactive channel
.FI
.IF    .csln
.IF    .csfn
.ELSE
	BNZ	gbcfl,stpr5		; if in garbage collection, skip
.FI
	MOV	XR,r_cod		; get code pointer
	MTI	cdsln(XR)		; get source line number
	MOV	XR,=stpm6		; point to message /in line xxx/
	JSR	prtmx			; print it
.FI
stpr5	MTI	kvstn			; get statement number
	MOV	XR,=stpm1		; point to message /in statement xxx/
	JSR	prtmx			; print it
	JSR	systm			; get current time
	SBI	timsx			; minus start time = elapsed exec tim
	STI	stpti			; save for later
	MOV	XR,=stpm3		; point to msg /execution time msec /
	JSR	prtmx			; print it
	LDI	kvstl			; get statement limit
	ILT	stpr2			; skip if negative
	SBI	kvstc			; minus counter = course count
	STI	stpsi			; save
	MOV	WA,stmcs		; refine with counter start value
	SUB	WA,stmct		; minus current counter
	MTI	WA			; convert to integer
	ADI	stpsi			; add in course count
	STI	stpsi			; save
	MOV	XR,=stpm2		; point to message /stmts executed/
	JSR	prtmx			; print it
.IF    .ctmd
.ELSE
	LDI	stpti			; reload elapsed time
	MLI	intth			; *1000 (microsecs)
	IOV	stpr2			; jump if we cannot compute
	DVI	stpsi			; divide by statement count
	IOV	stpr2			; jump if overflow
	MOV	XR,=stpm4		; point to msg (mcsec per statement /
	JSR	prtmx			; print it
.FI
	EJC
;
;      stopr (continued)
;
;      merge to skip message (overflow or negative stlimit)
;
stpr2	MTI	gbcnt			; load count of collections
	MOV	XR,=stpm5		; point to message /regenerations /
	JSR	prtmx			; print it
	JSR	prtmm			; print memory usage
	JSR	prtis			; one more blank for luck
;
;      check if dump requested
;
.IF    .cnpf
stpr3	MOV	XR,kvdmp		; load dump keyword
.ELSE
stpr3	JSR	prflr			; print profile if wanted
;
	MOV	XR,kvdmp		; load dump keyword
.FI
	JSR	dumpr			; execute dump if requested
	MOV	XL,r_fcb		; get fcblk chain head
	MOV	WA,kvabe		; load abend value
	MOV	WB,kvcod		; load code value
	JSR	sysej			; exit to system
.IF    .cera
;
;      here after sysea call and suppressing error msg print
;
stpr4	RTN
	ADD	dname,rsmem		; use the reserve memory
	BZE	exsts,stpr1		; if execution stats requested
	BRN	stpr3			; check if dump or profile needed
.FI

	EJC
;
;      succp -- signal successful match of a pattern node
;
;      see pattern match routines for details
;
;      (XR)		     current node
;      (WB)		     current cursor
;      (XL)		     may be non-collectable
;      brn  succp	     signal successful pattern match
;
;      succp continues by matching the successor node
;
succp	RTN
	MOV	XR,pthen(XR)		; load successor node
	MOV	XL,(XR)			; load node code entry address
	BRI	XL			; jump to match successor node
	EJC
;
;      sysab -- print /abnormal end/ and terminate
;
sysab	RTN
	MOV	XR,=endab		; point to message
	MOV	kvabe,=num01		; set abend flag
	JSR	prtnl			; skip to new line
	BRN	stopr			; jump to pack up
	EJC
;
;      systu -- print /time up/ and terminate
;
systu	RTN
	MOV	XR,=endtu		; point to message
	MOV	WA,strtu		; get chars /tu/
	MOV	kvcod,WA		; put in kvcod
	MOV	WA,timup		; check state of timeup switch
	MNZ	timup			; set switch
	BNZ	WA,stopr		; stop run if already set
	ERB	245,translation/execution time expired
	TTL	s p i t b o l -- utility procedures
;
;      the following section contains procedures which are
;      used for various purposes throughout the system.
;
;      each procedure is preceded by a description of the
;      calling sequence. usually the arguments are in registers
;      but arguments can also occur on the stack and as
;      parameters assembled after the jsr instruction.
;
;      the following considerations apply to these descriptions.
;
;      1)   the stack pointer (XS) is not changed unless the
;	    change is explicitly documented in the call.
;
;      2)   registers whose entry values are not mentioned
;	    may contain any value except that XL,XR may only
;	    contain proper (collectable) pointer values.
;	    this condition on means that the called routine
;	    may if it chooses preserve XL,XR by stacking.
;
;      3)   registers not mentioned on exit contain the same
;	    values as they did on entry except that values in
;	    XR,XL may have been relocated by the collector.
;
;      4)   registers which are destroyed on exit may contain
;	    any value except that values in XL,XR are proper
;	    (collectable) pointers.
;
;      5)   the code pointer register points to the current
;	    code location on entry and is unchanged on exit.
;
;      in the above description, a collectable pointer is one
;      which either points outside the dynamic region or
;      points to the start of a block in the dynamic region.
;
;      in those cases where the calling sequence contains
;      parameters which are used as alternate return points,
;      these parameters may be replaced by error codes
;      assembled with the err instruction. this will result
;      in the posting of the error if the return is taken.
;
;      the procedures all have names consisting of five letters
;      and are in alphabetical order by their names.
	EJC
;
;      acess - access vaRIAble value with trace/input checks
;
;      acess loads the value of a vaRIAble. trace and input
;      associations are tested for and executed as required.
;      acess also handles the special cases of pseudo-vaRIAbles.
;
;      (XL)		     vaRIAble name base
;      (wa)		     vaRIAble name offset
;      jsr  acess	     call to access value
;      ppm  loc		     transfer loc if access failure
;      (XR)		     vaRIAble value
;      (wa,WB,WC)	     destroyed
;      (XL,ra)		     destroyed
;
;      failure can occur if an input association causes an end
;      of file condition or if the evaluation of an expression
;      associated with an expression vaRIAble fails.
;
acess	PRC	r,1			; entry point (recursive)
	MOV	XR,XL			; copy name base
	ADD	XR,WA			; point to vaRIAble location
	MOV	XR,(XR)			; load vaRIAble value
;
;      loop here to check for successive trblks
;
acs02	BNE	(XR),=b_trt,acs18	; jump if not trapped
;
;      here if trapped
;
	BEQ	XR,=trbkv,acs12		; jump if keyword vaRIAble
	BNE	XR,=trbev,acs05		; jump if not expression vaRIAble
;
;      here for expression vaRIAble, evaluate vaRIAble
;
	MOV	XR,evexp(XL)		; load expression pointer
	ZER	WB			; evaluate by value
	JSR	evalx			; evaluate expression
	PPM	acs04			; jump if evaluation failure
	BRN	acs02			; check value for more trblks
	EJC
;
;      acess (continued)
;
;      here on reading end of file
;
acs03	ADD	XS,*num03		; pop trblk ptr, name base and offset
	MOV	dnamp,XR		; pop unused scblk
;
;      merge here when evaluation of expression fails
;
acs04	EXI	1			; take alternate (failure) return
;
;      here if not keyword or expression vaRIAble
;
acs05	MOV	WB,trtyp(XR)		; load trap type code
	BNZ	WB,acs10		; jump if not input association
	BZE	kvinp,acs09		; ignore input assoc if input is off
;
;      here for input association
;
	MOV	-(XS),XL		; stack name base
	MOV	-(XS),WA		; stack name offset
	MOV	-(XS),XR		; stack trblk pointer
	MOV	actrm,kvtrm		; temp to hold trim keyword
	MOV	XL,trfpt(XR)		; get file ctrl blk ptr or zero
	BNZ	XL,acs06		; jump if not standard input file
	BEQ	trter(XR),=v_ter,acs21	; jump if terminal
;
;      here to read from standard input file
;
	MOV	WA,cswin		; length for read buffer
	JSR	alocs			; build string of appropriate length
	JSR	sysrd			; read next standard input image
	PPM	acs03			; jump to fail exit if end of file
	BRN	acs07			; else merge with other file case
;
;      here for input from other than standard input file
;
acs06	MOV	WA,XL			; fcblk ptr
	JSR	sysil			; get input record max length (to wa)
	BNZ	WC,acs6a		; jump if not binary file
	MOV	actrm,WC		; disable trim for binary file
acs6a	JSR	alocs			; allocate string of correct size
	MOV	WA,XL			; fcblk ptr
	JSR	sysin			; call system input routine
	PPM	acs03			; jump to fail exit if end of file
	PPM	acs22			; error
	PPM	acs23			; error
	EJC
;
;      acess (continued)
;
;      merge here after obtaining input record
;
acs07	MOV	WB,actrm		; load trim indicator
	JSR	trimr			; trim record as required
	MOV	WB,XR			; copy result pointer
	MOV	XR,(XS)			; reload pointer to trblk
;
;      loop to chase to end of trblk chain and store value
;
acs08	MOV	XL,XR			; save pointer to this trblk
	MOV	XR,trnxt(XR)		; load forward pointer
	BEQ	(XR),=b_trt,acs08	; loop if this is another trblk
	MOV	trnxt(XL),WB		; else store result at end of chain
	MOV	XR,(XS)+		; restore initial trblk pointer
	MOV	WA,(XS)+		; restore name offset
	MOV	XL,(XS)+		; restore name base pointer
;
;      come here to move to next trblk
;
acs09	MOV	XR,trnxt(XR)		; load forward ptr to next value
	BRN	acs02			; back to check if trapped
;
;      here to check for access trace trblk
;
acs10	BNE	WB,=trtac,acs09		; loop back if not access trace
	BZE	kvtra,acs09		; ignore access trace if trace off
	DCV	kvtra			; else decrement trace count
	BZE	trfnc(XR),acs11		; jump if print trace
	EJC
;
;      acess (continued)
;
;      here for full function trace
;
	JSR	trxeq			; call routine to execute trace
	BRN	acs09			; jump for next trblk
;
;      here for case of print trace
;
acs11	JSR	prtsn			; print statement number
	JSR	prtnv			; print name = value
	BRN	acs09			; jump back for next trblk
;
;      here for keyword vaRIAble
;
acs12	MOV	XR,kvnum(XL)		; load keyword number
	BGE	XR,=k_v__,acs14		; jump if not one word value
	MTI	kvabe(XR)		; else load value as integer
;
;      common exit with keyword value as integer in (ia)
;
acs13	JSR	icbld			; build icblk
	BRN	acs18			; jump to exit
;
;      here if not one word keyword value
;
acs14	BGE	XR,=k_s__,acs15		; jump if special case
	SUB	XR,=k_v__		; else get offset
	WTB	XR			; convert to byte offset
	ADD	XR,=ndabo		; point to pattern value
	BRN	acs18			; jump to exit
;
;      here if special keyword case
;
acs15	MOV	XL,kvrtn		; load rtntype in case
	LDI	kvstl			; load stlimit in case
	SUB	XR,=k_s__		; get case number
	BSW	XR,k__n_		; switch on keyword number
.IF    .csfn
	IFF	k__fl,acs26		; file
	IFF	k__lf,acs27		; lastfile
.FI
.IF    .culk
	IFF	k__lc,acs24		; lcase
	IFF	k__uc,acs25		; ucase
.FI
	IFF	k__al,acs16		; jump if alphabet
	IFF	k__rt,acs17		; rtntype
	IFF	k__sc,acs19		; stcount
	IFF	k__sl,acs13		; stlimit
	IFF	k__et,acs20		; errteXT
	ESW				; end switch on keyword number
	EJC
;
;      acess (continued)
;
.IF    .culk
;      lcase
;
acs24	MOV	XR,=lcase		; load pointer to lcase string
	BRN	acs18			; common return
;
;      ucase
;
acs25	MOV	XR,=ucase		; load pointer to ucase string
	BRN	acs18			; common return
;
.FI
.IF    .csfn
;      file
;
acs26	MOV	WC,kvstn		; load current stmt number
	BRN	acs28			; merge to obtain file name
;
;      lastfile
;
acs27	MOV	WC,kvlst		; load last stmt number
;
;      merge here to map statement number in WC to file name
;
acs28	JSR	filnm			; obtain file name for this stmt
	BRN	acs17			; merge to return string in XL
.FI
;      alphabet
;
acs16	MOV	XL,kvalp		; load pointer to alphabet string
;
;      rtntype merges here
;
acs17	MOV	XR,XL			; copy string ptr to proper reg
;
;      common return point
;
acs18	EXI				; return to acess caller
;
;      here for stcount (ia has stlimit)
;
acs19	ILT	acs29			; if counting suppressed
	MOV	WA,stmcs		; refine with counter start value
	SUB	WA,stmct		; minus current counter
	MTI	WA			; convert to integer
	ADI	kvstl			; add stlimit
acs29	SBI	kvstc			; stcount = limit - left
	BRN	acs13			; merge back with integer result
;
;      errteXT
;
acs20	MOV	XR,r_etx		; get errteXT string
	BRN	acs18			; merge with result
;
;      here to read a record from terminal
;
acs21	MOV	WA,=rilen		; buffer length
	JSR	alocs			; allocate buffer
	JSR	sysri			; read record
	PPM	acs03			; endfile
	BRN	acs07			; merge with record read
;
;      error returns
;
acs22	MOV	dnamp,XR		; pop unused scblk
	ERB	202,input from file caused non-recoverable error
;
acs23	MOV	dnamp,XR		; pop unused scblk
	ERB	203,input file record has incorrect format
	ENP				; end procedure acess
	EJC
;
;      acomp -- compare two arithmetic values
;
;      1(XS)		     first argument
;      0(XS)		     second argument
;      jsr  acomp	     call to compare values
;      ppm  loc		     transfer loc if arg1 is non-numeric
;      ppm  loc		     transfer loc if arg2 is non-numeric
;      ppm  loc		     transfer loc for arg1 lt arg2
;      ppm  loc		     transfer loc for arg1 eq arg2
;      ppm  loc		     transfer loc for arg1 gt arg2
;      (normal return is never given)
;      (wa,WB,WC,ia,ra)	     destroyed
;      (XL,XR)		     destroyed
;
acomp	PRC	n,5			; entry point
	JSR	arith			; load arithmetic operands
	PPM	acmp7			; jump if first arg non-numeric
	PPM	acmp8			; jump if second arg non-numeric
.IF    .cnra
.ELSE
	PPM	acmp4			; jump if real arguments
.FI
;
;      here for integer arguments
;
	SBI	icval(XL)		; subtract to compare
	IOV	acmp3			; jump if overflow
	ILT	acmp5			; else jump if arg1 lt arg2
	IEQ	acmp2			; jump if arg1 eq arg2
;
;      here if arg1 gt arg2
;
acmp1	EXI	5			; take gt exit
;
;      here if arg1 eq arg2
;
acmp2	EXI	4			; take eq exit
	EJC
;
;      acomp (continued)
;
;      here for integer overflow on subtract
;
acmp3	LDI	icval(XL)		; load second argument
	ILT	acmp1			; gt if negative
	BRN	acmp5			; else lt
.IF    .cnra
.ELSE
;
;      here for real operands
;
acmp4	SBR	rcval(XL)		; subtract to compare
	ROV	acmp6			; jump if overflow
	RGT	acmp1			; else jump if arg1 gt
	REQ	acmp2			; jump if arg1 eq arg2
.FI
;
;      here if arg1 lt arg2
;
acmp5	EXI	3			; take lt exit
.IF    .cnra
.ELSE
;
;      here if overflow on real subtraction
;
acmp6	LDR	rcval(XL)		; reload arg2
	RLT	acmp1			; gt if negative
	BRN	acmp5			; else lt
.FI
;
;      here if arg1 non-numeric
;
acmp7	EXI	1			; take error exit
;
;      here if arg2 non-numeric
;
acmp8	EXI	2			; take error exit
	ENP				; end procedure acomp
	EJC
;
;      alloc		     allocate block of dynamic storage
;
;      (wa)		     length required in bytes
;      jsr  alloc	     call to allocate block
;      (XR)		     pointer to allocated block
;
;      a possible alternative to aov ... and following stmt is -
;      mov  dname,XR .	sub  wa,XR .  blo XR,dnamp,aloc2 .
;      mov  dnamp,XR .	add  wa,XR
;
alloc	PRC	e,0			; entry point
;
;      common exit point
;
aloc1	MOV	XR,dnamp		; point to next available loc
	AOV	WA,XR,aloc2		; point past allocated block
	BGT	XR,dname,aloc2		; jump if not enough room
	MOV	dnamp,XR		; store new pointer
	SUB	XR,WA			; point back to start of allocated bk
	EXI				; return to caller
;
;      here if insufficient room, try a garbage collection
;
aloc2	MOV	allsv,WB		; save WB
alc2a	ZER	WB			; set no upward move for gbcol
	JSR	gbcol			; garbage collect
.IF    .csed
	MOV	WB,XR			; remember new sediment size
.FI
;
;      see if room after gbcol or sysmm call
;
aloc3	MOV	XR,dnamp		; point to first available loc
	AOV	WA,XR,alc3a		; point past new block
	BLO	XR,dname,aloc4		; jump if there is room now
;
;      failed again, see if we can get more core
;
alc3a	JSR	sysmm			; try to get more memory
	WTB	XR			; convert to baus (sgd05)
	ADD	dname,XR		; bump ptr by amount obtained
	BNZ	XR,aloc3		; jump if got more core
.IF    .csed
	BZE	dnams,alc3b		; jump if there was no sediment
	ZER	dnams			; try collecting the sediment
	BRN	alc2a			;
;
;      sysmm failed and there was no sediment to collect
;
alc3b	ADD	dname,rsmem		; get the reserve memory
.ELSE
	ADD	dname,rsmem		; get the reserve memory
.FI
	ZER	rsmem			; only permissible once
	ICV	errft			; fatal error
	ERB	204,memory overflow
	EJC
;
;      here after successful garbage collection
;
aloc4	STI	allia			; save IA
.IF    .csed
	MOV	dnams,WB		; record new sediment size
.FI
	MOV	WB,dname		; get dynamic end adrs
	SUB	WB,dnamp		; compute free store
	BTW	WB			; convert bytes to words
	MTI	WB			; put free store in IA
	MLI	alfsf			; multiply by free store factor
	IOV	aloc5			; jump if overflowed
	MOV	WB,dname		; dynamic end adrs
	SUB	WB,dnamb		; compute total amount of dynamic
	BTW	WB			; convert to words
	MOV	aldyn,WB		; store it
	SBI	aldyn			; subtract from scaled up free store
	IGT	aloc5			; jump if sufficient free store
	JSR	sysmm			; try to get more store
	WTB	XR			; convert to baus (sgd05)
	ADD	dname,XR		; adjust dynamic end adrs
;
;      merge to restore IA and WB
;
aloc5	LDI	allia			; recover IA
	MOV	WB,allsv		; restore WB
	BRN	aloc1			; jump back to exit
	ENP				; end procedure alloc
	EJC
.IF    .cnbf
.ELSE
;
;      alobf -- allocate buffer
;
;      this routines allocates a new buffer.  as the bfblk
;      and bcblk come in pairs, both are allocated here,
;      and XR points to the bcblk on return.  the bfblk
;      and bcblk are set to the null buffer, and the idval
;      is zero on return.
;
;      (wa)		     buffer size in characters
;      jsr  alobf	     call to create buffer
;      (XR)		     bcblk ptr
;      (wa,WB)		     destroyed
;
alobf	PRC	e,0			; entry point
	BGT	WA,kvmxl,alb01		; check for maXLngth exceeded
	MOV	WB,WA			; hang onto allocation size
	CTB	WA,bfsi_		; get total block size
	ADD	WA,*bcsi_		; add in allocation for bcblk
	JSR	alloc			; allocate frame
	MOV	(XR),=b_bct		; set type
	ZER	idval(XR)		; no id yet
	ZER	bclen(XR)		; no defined length
	MOV	WA,XL			; save XL
	MOV	XL,XR			; copy bcblk ptr
	ADD	XL,*bcsi_		; bias past partially built bcblk
	MOV	(XL),=b_bft		; set bfblk type word
	MOV	bfalc(XL),WB		; set allocated size
	MOV	bcbuf(XR),XL		; set pointer in bcblk
	ZER	bfchr(XL)		; clear first word (null pad)
	MOV	XL,WA			; restore entry XL
	EXI				; return to caller
;
;      here for mxlen exceeded
;
alb01	ERB	273,buffer size exceeds value of maXLngth keyword
	ENP				; end procedure alobf
	EJC
.FI
;
;      alocs -- allocate string block
;
;      alocs is used to build a frame for a string block into
;      which the actual characters are placed by the caller.
;      all strings are created with a call to alocs (the
;      exceptions occur in trimr and s_rpl procedures).
;
;      (wa)		     length of string to be allocated
;      jsr  alocs	     call to allocate scblk
;      (XR)		     pointer to resulting scblk
;      (wa)		     destroyed
;      (WC)		     character count (entry value of wa)
;
;      the resulting scblk has the type word and the length
;      filled in and the last word is cleared to zero characters
;      to ensure correct right padding of the final word.
;
alocs	PRC	e,0			; entry point
	BGT	WA,kvmxl,alcs2		; jump if length exceeds maXLength
	MOV	WC,WA			; else copy length
	CTB	WA,scsi_		; compute length of scblk in bytes
	MOV	XR,dnamp		; point to next available location
	AOV	WA,XR,alcs0		; point past block
	BLO	XR,dname,alcs1		; jump if there is room
;
;      insufficient memory
;
alcs0	ZER	XR			; else clear garbage XR value
	JSR	alloc			; and use standard allocator
	ADD	XR,WA			; point past end of block to merge
;
;      merge here with XR pointing beyond new block
;
alcs1	MOV	dnamp,XR		; set updated storage pointer
	ZER	-(XR)			; store zero chars in last word
	DCA	WA			; decrement length
	SUB	XR,WA			; point back to start of block
	MOV	(XR),=b_scl		; set type word
	MOV	sclen(XR),WC		; store length in chars
	EXI				; return to alocs caller
;
;      come here if string is too long
;
alcs2	ERB	205,string length exceeds value of maXLngth keyword
	ENP				; end procedure alocs
	EJC
;
;      alost -- allocate space in static region
;
;      (wa)		     length required in bytes
;      jsr  alost	     call to allocate space
;      (XR)		     pointer to allocated block
;      (WB)		     destroyed
;
;      note that the coding ensures that the resulting value
;      of state is always less than dnamb. this fact is used
;      in testing a vaRIAble name for being in the static region
;
alost	PRC	e,0			; entry point
;
;      merge back here after allocating new chunk
;
alst1	MOV	XR,state		; point to current end of area
	AOV	WA,XR,alst2		; point beyond proposed block
	BGE	XR,dnamb,alst2		; jump if overlap with dynamic area
	MOV	state,XR		; else store new pointer
	SUB	XR,WA			; point back to start of block
	EXI				; return to alost caller
;
;      here if no room, prepare to move dynamic storage up
;
alst2	MOV	alsta,WA		; save wa
	BGE	WA,*e_sts,alst3		; skip if requested chunk is large
	MOV	WA,*e_sts		; else set to get large enough chunk
;
;      here with amount to move up in wa
;
alst3	JSR	alloc			; allocate block to ensure room
	MOV	dnamp,XR		; and delete it
	MOV	WB,WA			; copy move up amount
	JSR	gbcol			; call gbcol to move dynamic area up
.IF    .csed
	MOV	dnams,XR		; remember new sediment size
.FI
	MOV	WA,alsta		; restore wa
	BRN	alst1			; loop back to try again
	ENP				; end procedure alost
	EJC
.IF    .cnbf
.ELSE
;
;      apndb -- append string to buffer
;
;      this routine is used by buffer handling routines to
;      append data to an existing bfblk.
;
;      (XR)		     existing bcblk to be appended
;      (XL)		     convertable to string
;      jsr  apndb	     call to append to buffer
;      ppm  loc		     thread if (XL) cant be converted
;      ppm  loc		     if not enough room
;      (wa,WB)		     destroyed
;
;      if more characters are specified than can be inserted,
;      then no action is taken and the second return is taken.
;
apndb	PRC	e,2			; entry point
	MOV	WA,bclen(XR)		; load offset to insert
	ZER	WB			; replace section is null
	JSR	insbf			; call to insert at end
	PPM	apn01			; convert error
	PPM	apn02			; no room
	EXI				; return to caller
;
;      here to take convert failure exit
;
apn01	EXI	1			; return to caller alternate
;
;      here for no fit exit
;
apn02	EXI	2			; alternate exit to caller
	ENP				; end procedure apndb
	EJC
.FI
;
;      arith -- fetch arithmetic operands
;
;      arith is used by functions and operators which expect
;      two numeric arguments (operands) which must both be
;      integer or both be real. arith fetches two arguments from
;      the stack and performs any necessary conversions.
;
;      1(XS)		     first argument (left operand)
;      0(XS)		     second argument (right operand)
;      jsr  arith	     call to fetch numeric arguments
;      ppm  loc		     transfer loc for opnd 1 non-numeric
;      ppm  loc		     transfer loc for opnd 2 non-numeric
.IF    .cnra
.ELSE
;      ppm  loc		     transfer loc for real operands
.FI
;
;      for integer args, control returns past the parameters
;
;      (ia)		     left operand value
;      (XR)		     ptr to icblk for left operand
;      (XL)		     ptr to icblk for right operand
;      (XS)		     popped twice
;      (wa,WB,ra)	     destroyed
.IF    .cnra
.ELSE
;
;      for real arguments, control returns to the location
;      specified by the third parameter.
;
;      (RA)		     left operand value
;      (XR)		     ptr to rcblk for left operand
;      (XL)		     ptr to rcblk for right operand
;      (wa,WB,WC)	     destroyed
;      (XS)		     popped twice
.FI
	EJC
;
;      arith (continued)
;
;      entry point
;
.IF    .cnra
arith	PRC	n,2			; entry point
.ELSE
arith	PRC	n,3			; entry point
.FI
	MOV	XL,(XS)+		; load right operand
	MOV	XR,(XS)+		; load left operand
	MOV	WA,(XL)			; get right operand type word
	BEQ	WA,=b_icl,arth1		; jump if integer
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,arth4		; jump if real
.FI
	MOV	-(XS),XR		; else replace left arg on stack
	MOV	XR,XL			; copy left arg pointer
	JSR	gtnum			; convert to numeric
	PPM	arth6			; jump if unconvertible
	MOV	XL,XR			; else copy converted result
	MOV	WA,(XL)			; get right operand type word
	MOV	XR,(XS)+		; reload left argument
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,arth4		; jump if right arg is real
.FI
;
;      here if right arg is an integer
;
arth1	BNE	(XR),=b_icl,arth3	; jump if left arg not integer
;
;      exit for integer case
;
arth2	LDI	icval(XR)		; load left operand value
	EXI				; return to arith caller
;
;      here for right operand integer, left operand not
;
arth3	JSR	gtnum			; convert left arg to numeric
	PPM	arth7			; jump if not convertible
	BEQ	WA,=b_icl,arth2		; jump back if integer-integer
.IF    .cnra
.ELSE
;
;      here we must convert real-integer to real-real
;
	MOV	-(XS),XR		; put left arg back on stack
	LDI	icval(XL)		; load right argument value
	ITR				; convert to real
	JSR	rcbld			; get real block for right arg, merge
	MOV	XL,XR			; copy right arg ptr
	MOV	XR,(XS)+		; load left argument
	BRN	arth5			; merge for real-real case
	EJC
;
;      arith (continued)
;
;      here if right argument is real
;
arth4	BEQ	(XR),=b_rcl,arth5	; jump if left arg real
	JSR	gtrea			; else convert to real
	PPM	arth7			; error if unconvertible
;
;      here for real-real
;
arth5	LDR	rcval(XR)		; load left operand value
	EXI	3			; take real-real exit
.FI
;
;      here for error converting right argument
;
arth6	ICA	XS			; pop unwanted left arg
	EXI	2			; take appropriate error exit
;
;      here for error converting left operand
;
arth7	EXI	1			; take appropriate error return
	ENP				; end procedure arith
	EJC
;
;      asign -- perform assignment
;
;      asign performs the assignment of a value to a vaRIAble
;      with appropriate checks for output associations and
;      value trace associations which are executed as required.
;      asign also handles the special cases of assignment to
;      pattern and expression vaRIAbles.
;
;      (WB)		     value to be assigned
;      (XL)		     base pointer for vaRIAble
;      (wa)		     offset for vaRIAble
;      jsr  asign	     call to assign value to vaRIAble
;      ppm  loc		     transfer loc for failure
;      (XR,XL,WA,WB,WC)	     destroyed
;      (RA)		     destroyed
;
;      failure occurs if the evaluation of an expression
;      associated with an expression vaRIAble fails.
;
asign	PRC	r,1			; entry point (recursive)
;
;      merge back here to assign result to expression vaRIAble.
;
asg01	ADD	XL,WA			; point to vaRIAble value
	MOV	XR,(XL)			; load vaRIAble value
	BEQ	(XR),=b_trt,asg02	; jump if trapped
	MOV	(XL),WB			; else perform assignment
	ZER	XL			; clear garbage value in XL
	EXI				; and return to asign caller
;
;      here if value is trapped
;
asg02	SUB	XL,WA			; restore name base
	BEQ	XR,=trbkv,asg14		; jump if keyword vaRIAble
	BNE	XR,=trbev,asg04		; jump if not expression vaRIAble
;
;      here for assignment to expression vaRIAble
;
	MOV	XR,evexp(XL)		; point to expression
	MOV	-(XS),WB		; store value to assign on stack
	MOV	WB,=num01		; set for evaluation by name
	JSR	evalx			; evaluate expression by name
	PPM	asg03			; jump if evaluation fails
	MOV	WB,(XS)+		; else reload value to assign
	BRN	asg01			; loop back to perform assignment
	EJC
;
;      asign (continued)
;
;      here for failure during expression evaluation
;
asg03	ICA	XS			; remove stacked value entry
	EXI	1			; take failure exit
;
;      here if not keyword or expression vaRIAble
;
asg04	MOV	-(XS),XR		; save ptr to first trblk
;
;      loop to chase down trblk chain and assign value at end
;
asg05	MOV	WC,XR			; save ptr to this trblk
	MOV	XR,trnxt(XR)		; point to next trblk
	BEQ	(XR),=b_trt,asg05	; loop back if another trblk
	MOV	XR,WC			; else point back to last trblk
	MOV	trval(XR),WB		; store value at end of chain
	MOV	XR,(XS)+		; restore ptr to first trblk
;
;      loop to process trblk entries on chain
;
asg06	MOV	WB,trtyp(XR)		; load type code of trblk
	BEQ	WB,=trtvl,asg08		; jump if value trace
	BEQ	WB,=trtou,asg10		; jump if output association
;
;      here to move to next trblk on chain
;
asg07	MOV	XR,trnxt(XR)		; point to next trblk on chain
	BEQ	(XR),=b_trt,asg06	; loop back if another trblk
	EXI				; else end of chain, return to caller
;
;      here to process value trace
;
asg08	BZE	kvtra,asg07		; ignore value trace if trace off
	DCV	kvtra			; else decrement trace count
	BZE	trfnc(XR),asg09		; jump if print trace
	JSR	trxeq			; else execute function trace
	BRN	asg07			; and loop back
	EJC
;
;      asign (continued)
;
;      here for print trace
;
asg09	JSR	prtsn			; print statement number
	JSR	prtnv			; print name = value
	BRN	asg07			; loop back for next trblk
;
;      here for output association
;
asg10	BZE	kvoup,asg07		; ignore output assoc if output off
asg1b	MOV	XL,XR			; copy trblk pointer
	MOV	XR,trnxt(XR)		; point to next trblk
	BEQ	(XR),=b_trt,asg1b	; loop back if another trblk
	MOV	XR,XL			; else point back to last trblk
.IF    .cnbf
	MOV	-(XS),trval(XR)		; stack value to output
.ELSE
	MOV	XR,trval(XR)		; get value to output
	BEQ	(XR),=b_bct,asg11	; branch if buffer
	MOV	-(XS),XR		; stack value to output
.FI
	JSR	gtstg			; convert to string
	PPM	asg12			; get datatype name if unconvertible
;
;      merge with string or buffer to output in XR
;
asg11	MOV	WA,trfpt(XL)		; fcblk ptr
	BZE	WA,asg13		; jump if standard output file
;
;      here for output to file
;
asg1a	JSR	sysou			; call system output routine
	ERR	206,output caused file overflow
	ERR	207,output caused non-recoverable error
	EXI				; else all done, return to caller
;
;      if not printable, get datatype name instead
;
asg12	JSR	dtype			; call datatype routine
	BRN	asg11			; merge
;
;      here to print a string to standard output or terminal
;
.IF    .csou
asg13	BEQ	trter(XL),=v_ter,asg1a	; jump if terminal output
	ICV	WA			; signal standard output
	BRN	asg1a			; use sysou to perform output
.ELSE
.IF    .cnbf
asg13	JSR	prtst			; print string value
.ELSE
asg13	BNE	(XR),=b_bct,asg1c	; branch if not buffer
	MOV	-(XS),XR		; stack buffer
	JSR	gtstg			; convert to string
	PPM				; always succeeds
asg1c	JSR	prtst			; print string value
.FI
	BEQ	trter(XL),=v_ter,asg20	; jump if terminal output
	JSR	prtnl			; end of line
	EXI				; return to caller
.FI
	EJC
;
;      asign (continued)
;
;      here for keyword assignment
;
asg14	MOV	XL,kvnum(XL)		; load keyword number
	BEQ	XL,=k_etx,asg19		; jump if errteXT
	MOV	XR,WB			; copy value to be assigned
	JSR	gtint			; convert to integer
	ERR	208,keyword value assigned is not integer
	LDI	icval(XR)		; else load value
	BEQ	XL,=k_stl,asg16		; jump if special case of stlimit
	MFI	WA,asg18		; else get addr integer, test ovflow
	BGT	WA,mxlen,asg18		; fail if too large
	BEQ	XL,=k_ert,asg17		; jump if special case of errtype
.IF    .cnpf
.ELSE
	BEQ	XL,=k_pfl,asg21		; jump if special case of profile
.FI
	BEQ	XL,=k_mxl,asg24		; jump if special case of maXLngth
	BEQ	XL,=k_fls,asg26		; jump if special case of fullscan
	BLT	XL,=k_p__,asg15		; jump unless protected
	ERB	209,keyword in assignment is protected
;
;      here to do assignment if not protected
;
asg15	MOV	kvabe(XL),WA		; store new value
	EXI				; return to asign caller
;
;      here for special case of stlimit
;
;      since stcount is maintained as (stlimit-stcount)
;      it is also necessary to modify stcount appropriately.
;
asg16	SBI	kvstl			; subtract old limit
	ADI	kvstc			; add old counter
	STI	kvstc			; store course counter value
	LDI	kvstl			; check if counting suppressed
	ILT	asg25			; do not refine if so
	MOV	WA,stmcs		; refine with counter breakout
	SUB	WA,stmct		; values
	MTI	WA			; convert to integer
	NGI				; current-start value
	ADI	kvstc			; add in course counter value
	STI	kvstc			; save refined value
asg25	LDI	icval(XR)		; reload new limit value
	STI	kvstl			; store new limit value
	JSR	stgcc			; recompute countdown counters
	EXI				; return to asign caller
;
;      here for special case of errtype
;
asg17	BLE	WA,=nini9,error		; ok to signal if in range
;
;      here if value assigned is out of range
;
asg18	ERB	210,keyword value assigned is negative or too large
;
;      here for special case of errteXT
;
asg19	MOV	-(XS),WB		; stack value
	JSR	gtstg			; convert to string
	ERR	211,value assigned to keyword errteXT not a string
	MOV	r_etx,XR		; make assignment
	EXI				; return to caller
.IF    .csou
.ELSE
;
;      print string to terminal
;
asg20	JSR	prttr			; print
	EXI				; return
.FI
;
.IF    .cnpf
.ELSE
;      here for keyword profile
;
asg21	BGT	WA,=num02,asg18		; moan if not 0,1, or 2
	BZE	WA,asg15		; just assign if zero
	BZE	pfdmp,asg22		; branch if first assignment
	BEQ	WA,pfdmp,asg23		; also if same value as before
	ERB	268,inconsistent value assigned to keyword profile
;
asg22	MOV	pfdmp,WA		; note value on first assignment
asg23	MOV	kvpfl,WA		; store new value
	JSR	stgcc			; recompute countdown counts
	JSR	systm			; get the time
	STI	pfstm			; fudge some kind of start time
	EXI				; return to asign caller
.FI
;
;      here for keyword maXLngth
;
asg24	BGE	WA,=mnlen,asg15		; if acceptable value
	ERB	287,value assigned to keyword maXLngth is too small
;
;      here for keyword fullscan
;
asg26	BNZ	WA,asg15		; if acceptable value
	ERB	274,value assigned to keyword fullscan is zero
;
	ENP				; end procedure asign
	EJC
;
;      asinp -- assign during pattern match
;
;      asinp is like asign and has a similar calling sequence
;      and effect. the difference is that the global pattern
;      vaRIAbles are saved and restored if required.
;
;      (XL)		     base pointer for vaRIAble
;      (wa)		     offset for vaRIAble
;      (WB)		     value to be assigned
;      jsr  asinp	     call to assign value to vaRIAble
;      ppm  loc		     transfer loc if failure
;      (XR,XL)		     destroyed
;      (wa,WB,WC,ra)	     destroyed
;
asinp	PRC	r,1			; entry point, recursive
	ADD	XL,WA			; point to vaRIAble
	MOV	XR,(XL)			; load current contents
	BEQ	(XR),=b_trt,asnp1	; jump if trapped
	MOV	(XL),WB			; else perform assignment
	ZER	XL			; clear garbage value in XL
	EXI				; return to asinp caller
;
;      here if vaRIAble is trapped
;
asnp1	SUB	XL,WA			; restore base pointer
	MOV	-(XS),pmssl		; stack subject string length
	MOV	-(XS),pmhbs		; stack history stack base ptr
	MOV	-(XS),r_pms		; stack subject string pointer
	MOV	-(XS),pmdfl		; stack dot flag
	JSR	asign			; call full-blown assignment routine
	PPM	asnp2			; jump if failure
	MOV	pmdfl,(XS)+		; restore dot flag
	MOV	r_pms,(XS)+		; restore subject string pointer
	MOV	pmhbs,(XS)+		; restore history stack base pointer
	MOV	pmssl,(XS)+		; restore subject string length
	EXI				; return to asinp caller
;
;      here if failure in asign call
;
asnp2	MOV	pmdfl,(XS)+		; restore dot flag
	MOV	r_pms,(XS)+		; restore subject string pointer
	MOV	pmhbs,(XS)+		; restore history stack base pointer
	MOV	pmssl,(XS)+		; restore subject string length
	EXI	1			; take failure exit
	ENP				; end procedure asinp
	EJC
;
;      blkln -- determine length of block
;
;      blkln determines the length of a block in dynamic store.
;
;      (wa)		     first word of block
;      (XR)		     pointer to block
;      jsr  blkln	     call to get block length
;      (wa)		     length of block in bytes
;      (XL)		     destroyed
;
;      blkln is used by the garbage collector and is not
;      permitted to call gbcol directly or indirectly.
;
;      the first word stored in the block (i.e. at XR) may
;      be anything, but the contents of wa must be correct.
;
blkln	PRC	e,0			; entry point
	MOV	XL,WA			; copy first word
	LEI	XL			; get entry id (bl_xx)
	BSW	XL,bl___,bln00		; switch on block type
	IFF	bl_ar,bln01		; arblk
.IF    .cnbf
.ELSE
	IFF	bl_bc,bln04		; bcblk
	IFF	bl_bf,bln11		; bfblk
.FI
.IF    .csln
	IFF	bl_cd,bln12		; cdblk
.ELSE
	IFF	bl_cd,bln01		; cdblk
.FI
	IFF	bl_df,bln01		; dfblk
	IFF	bl_ef,bln01		; efblk
.IF    .csln
	IFF	bl_ex,bln12		; exblk
.ELSE
	IFF	bl_ex,bln01		; exblk
.FI
	IFF	bl_pf,bln01		; pfblk
	IFF	bl_tb,bln01		; tbblk
	IFF	bl_vc,bln01		; vcblk
	IFF	bl_ev,bln03		; evblk
	IFF	bl_kv,bln03		; kvblk
	IFF	bl_p0,bln02		; p0blk
	IFF	bl_se,bln02		; seblk
	IFF	bl_nm,bln03		; nmblk
	IFF	bl_p1,bln03		; p1blk
	IFF	bl_p2,bln04		; p2blk
	IFF	bl_te,bln04		; teblk
	IFF	bl_ff,bln05		; ffblk
	IFF	bl_tr,bln05		; trblk
	IFF	bl_ct,bln06		; ctblk
	IFF	bl_ic,bln07		; icblk
	IFF	bl_pd,bln08		; pdblk
.IF    .cnra
.ELSE
	IFF	bl_rc,bln09		; rcblk
.FI
	IFF	bl_sc,bln10		; scblk
	ESW				; end of jump table on block type
	EJC
;
;      blkln (continued)
;
;      here for blocks with length in second word
;
bln00	MOV	WA,num01(XR)		; load length
	EXI				; return to blkln caller
;
;      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
;
bln01	MOV	WA,num02(XR)		; load length from third word
	EXI				; return to blkln caller
;
;      here for two word blocks (p0,se)
;
bln02	MOV	WA,*num02		; load length (two words)
	EXI				; return to blkln caller
;
;      here for three word blocks (nm,p1,ev,kv)
;
bln03	MOV	WA,*num03		; load length (three words)
	EXI				; return to blkln caller
;
;      here for four word blocks (p2,te,bc)
;
bln04	MOV	WA,*num04		; load length (four words)
	EXI				; return to blkln caller
;
;      here for five word blocks (ff,tr)
;
bln05	MOV	WA,*num05		; load length
	EXI				; return to blkln caller
	EJC
;
;      blkln (continued)
;
;      here for ctblk
;
bln06	MOV	WA,*ctsi_		; set size of ctblk
	EXI				; return to blkln caller
;
;      here for icblk
;
bln07	MOV	WA,*icsi_		; set size of icblk
	EXI				; return to blkln caller
;
;      here for pdblk
;
bln08	MOV	XL,pddfp(XR)		; point to dfblk
	MOV	WA,dfpdl(XL)		; load pdblk length from dfblk
	EXI				; return to blkln caller
.IF    .cnra
.ELSE
;
;      here for rcblk
;
bln09	MOV	WA,*rcsi_		; set size of rcblk
	EXI				; return to blkln caller
.FI
;
;      here for scblk
;
bln10	MOV	WA,sclen(XR)		; load length in characters
	CTB	WA,scsi_		; calculate length in bytes
	EXI				; return to blkln caller
.IF    .cnbf
.ELSE
;
;      here for bfblk
;
bln11	MOV	WA,bfalc(XR)		; get allocation in bytes
	CTB	WA,bfsi_		; calculate length in bytes
	EXI				; return to blkln caller
.FI
.IF    .csln
;
;      here for length in fourth word (cd,ex)
;
bln12	MOV	WA,num03(XR)		; load length from cdlen/exlen
	EXI				; return to blkln caller
.FI
	ENP				; end procedure blkln
	EJC
;
;      copyb -- copy a block
;
;      (XS)		     block to be copied
;      jsr  copyb	     call to copy block
;      ppm  loc		     return if block has no idval field
;			     normal return if idval field
;      (XR)		     copy of block
;      (XS)		     popped
;      (XL,WA,WB,WC)	     destroyed
;
copyb	PRC	n,1			; entry point
	MOV	XR,(XS)			; load argument
	BEQ	XR,=nulls,cop10		; return argument if it is null
	MOV	WA,(XR)			; else load type word
	MOV	WB,WA			; copy type word
	JSR	blkln			; get length of argument block
	MOV	XL,XR			; copy pointer
	JSR	alloc			; allocate block of same size
	MOV	(XS),XR			; store pointer to copy
	MVW				; copy contents of old block to new
	ZER	XL			; clear garbage XL
	MOV	XR,(XS)			; reload pointer to start of copy
	BEQ	WB,=b_tbt,cop05		; jump if table
	BEQ	WB,=b_vct,cop01		; jump if vector
	BEQ	WB,=b_pdt,cop01		; jump if program defined
.IF    .cnbf
.ELSE
	BEQ	WB,=b_bct,cop11		; jump if buffer
.FI
	BNE	WB,=b_art,cop10		; return copy if not array
;
;      here for array (arblk)
;
	ADD	XR,arofs(XR)		; point to prototype field
	BRN	cop02			; jump to merge
;
;      here for vector, program defined
;
cop01	ADD	XR,*pdfld		; point to pdfld = vcvls
;
;      merge here for arblk, vcblk, pdblk to delete trap
;      blocks from all value fields (the copy is untrapped)
;
cop02	MOV	XL,(XR)			; load next pointer
;
;      loop to get value at end of trblk chain
;
cop03	BNE	(XL),=b_trt,cop04	; jump if not trapped
	MOV	XL,trval(XL)		; else point to next value
	BRN	cop03			; and loop back
	EJC
;
;      copyb (continued)
;
;      here with untrapped value in XL
;
cop04	MOV	(XR)+,XL		; store real value, bump pointer
	BNE	XR,dnamp,cop02		; loop back if more to go
	BRN	cop09			; else jump to exit
;
;      here to copy a table
;
cop05	ZER	idval(XR)		; zero id to stop dump blowing up
	MOV	WA,*tesi_		; set size of teblk
	MOV	WC,*tbbuk		; set initial offset
;
;      loop through buckets in table
;
cop06	MOV	XR,(XS)			; load table pointer
	BEQ	WC,tblen(XR),cop09	; jump to exit if all done
	MOV	WB,WC			; else copy offset
	SUB	WB,*tenxt		; subtract link offset to merge
	ADD	XR,WB			; next bucket header less link offset
	ICA	WC			; bump offset
;
;      loop through teblks on one chain
;
cop07	MOV	XL,tenxt(XR)		; load pointer to next teblk
	MOV	tenxt(XR),(XS)		; set end of chain pointer in case
	BEQ	(XL),=b_tbt,cop06	; back for next bucket if chain end
	SUB	XR,WB			; point to head of previous block
	MOV	-(XS),XR		; stack ptr to previous block
	MOV	WA,*tesi_		; set size of teblk
	JSR	alloc			; allocate new teblk
	MOV	-(XS),XR		; stack ptr to new teblk
	MVW				; copy old teblk to new teblk
	MOV	XR,(XS)+		; restore pointer to new teblk
	MOV	XL,(XS)+		; restore pointer to previous block
	ADD	XL,WB			; add offset back in
	MOV	tenxt(XL),XR		; link new block to previous
	MOV	XL,XR			; copy pointer to new block
;
;      loop to set real value after removing trap chain
;
cop08	MOV	XL,teval(XL)		; load value
	BEQ	(XL),=b_trt,cop08	; loop back if trapped
	MOV	teval(XR),XL		; store untrapped value in teblk
	ZER	WB			; zero offset within teblk
	BRN	cop07			; back for next teblk
;
;      common exit point
;
cop09	MOV	XR,(XS)+		; load pointer to block
	EXI				; return
;
;      alternative return
;
cop10	EXI	1			; return
	EJC
.IF    .cnbf
.ELSE
;
;      here to copy buffer
;
cop11	MOV	XL,bcbuf(XR)		; get bfblk ptr
	MOV	WA,bfalc(XL)		; get allocation
	CTB	WA,bfsi_		; set total size
	MOV	XL,XR			; save bcblk ptr
	JSR	alloc			; allocate bfblk
	MOV	WB,bcbuf(XL)		; get old bfblk
	MOV	bcbuf(XL),XR		; set pointer to new bfblk
	MOV	XL,WB			; point to old bfblk
	MVW				; copy bfblk too
	ZER	XL			; clear rubbish ptr
	BRN	cop09			; branch to exit
.FI
	ENP				; end procedure copyb
;
;      cdgcg -- generate code for complex goto
;
;      used by cmpil to process complex goto tree
;
;      (WB)		     must be collectable
;      (XR)		     expression pointer
;      jsr  cdgcg	     call to generate complex goto
;      (XL,XR,WA)	     destroyed
;
cdgcg	PRC	e,0			; entry point
	MOV	XL,cmopn(XR)		; get unary goto operator
	MOV	XR,cmrop(XR)		; point to goto operand
	BEQ	XL,=opdvd,cdgc2		; jump if direct goto
	JSR	cdgnm			; generate opnd by name if not direct
;
;      return point
;
cdgc1	MOV	WA,XL			; goto operator
	JSR	cdwrd			; generate it
	EXI				; return to caller
;
;      direct goto
;
cdgc2	JSR	cdgvl			; generate operand by value
	BRN	cdgc1			; merge to return
	ENP				; end procedure cdgcg
	EJC
;
;      cdgex -- build expression block
;
;      cdgex is passed a pointer to an expression tree (see
;      expan) and returns an expression (seblk or exblk).
;
.IF    .cevb
;      (wa)		     0 if by value, 1 if by name
.FI
;      (WC)		     some collectable value
;      (WB)		     integer in range 0 le x le mxlen
;      (XL)		     ptr to expression tree
;      jsr  cdgex	     call to build expression
;      (XR)		     ptr to seblk or exblk
;      (XL,WA,WB)	     destroyed
;
cdgex	PRC	r,0			; entry point, recursive
	BLO	(XL),=b_vr_,cdgx1	; jump if not vaRIAble
;
;      here for natural vaRIAble, build seblk
;
	MOV	WA,*sesi_		; set size of seblk
	JSR	alloc			; allocate space for seblk
	MOV	(XR),=b_sel		; set type word
	MOV	sevar(XR),XL		; store vrblk pointer
	EXI				; return to cdgex caller
;
;      here if not vaRIAble, build exblk
;
cdgx1	MOV	XR,XL			; copy tree pointer
	MOV	-(XS),WC		; save WC
	MOV	XL,cwcof		; save current offset
.IF    .cevb
	BZE	WA,cdgx2		; jump if by value
.FI
	MOV	WA,(XR)			; get type word
	BNE	WA,=b_cmt,cdgx2		; call by value if not cmblk
	BGE	cmtyp(XR),=c__nm,cdgx2	; jump if cmblk only by value
	EJC
;
;      cdgex (continued)
;
;      here if expression can be evaluated by name
;
	JSR	cdgnm			; generate code by name
	MOV	WA,=ornm_		; load return by name word
	BRN	cdgx3			; merge with value case
;
;      here if expression can only be evaluated by value
;
cdgx2	JSR	cdgvl			; generate code by value
	MOV	WA,=orvl_		; load return by value word
;
;      merge here to construct exblk
;
cdgx3	JSR	cdwrd			; generate return word
	JSR	exbld			; build exblk
	MOV	WC,(XS)+		; restore WC
	EXI				; return to cdgex caller
	ENP				; end procedure cdgex
	EJC
;
;      cdgnm -- generate code by name
;
;      cdgnm is called during the compilation process to
;      generate code by name for an expression. see cdblk
;      description for details of code generated. the input
;      to cdgnm is an expression tree as generated by expan.
;
;      cdgnm is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (WB)		     integer in range 0 le n le dnamb
;      (XR)		     ptr to tree generated by expan
;      (WC)		     constant flag (see below)
;      jsr  cdgnm	     call to generate code by name
;      (XR,WA)		     destroyed
;      (WC)		     set non-zero if non-constant
;
;      WC is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise WC is unchanged.
;
;      the code is generated in the current ccblk (see cdwrd).
;
cdgnm	PRC	r,0			; entry point, recursive
	MOV	-(XS),XL		; save entry XL
	MOV	-(XS),WB		; save entry WB
	CHK				; check for stack overflow
	MOV	WA,(XR)			; load type word
	BEQ	WA,=b_cmt,cgn04		; jump if cmblk
	BHI	WA,=b_vr_,cgn02		; jump if simple vaRIAble
;
;      merge here for operand yielding value (e.g. constant)
;
cgn01	ERB	212,syntax error: value used where name is required
;
;      here for natural vaRIAble reference
;
cgn02	MOV	WA,=olvn_		; load vaRIAble load call
	JSR	cdwrd			; generate it
	MOV	WA,XR			; copy vrblk pointer
	JSR	cdwrd			; generate vrblk pointer
	EJC
;
;      cdgnm (continued)
;
;      here to exit with WC set correctly
;
cgn03	MOV	WB,(XS)+		; restore entry WB
	MOV	XL,(XS)+		; restore entry XL
	EXI				; return to cdgnm caller
;
;      here for cmblk
;
cgn04	MOV	XL,XR			; copy cmblk pointer
	MOV	XR,cmtyp(XR)		; load cmblk type
	BGE	XR,=c__nm,cgn01		; error if not name operand
	BSW	XR,c__nm		; else switch on type
	IFF	c_arr,cgn05		; array reference
	IFF	c_fnc,cgn08		; function call
	IFF	c_def,cgn09		; deferred expression
	IFF	c_ind,cgn10		; indirect reference
	IFF	c_key,cgn11		; keyword reference
	IFF	c_ubo,cgn08		; undefined binary op
	IFF	c_uuo,cgn08		; undefined unary op
	ESW				; end switch on cmblk type
;
;      here to generate code for array reference
;
cgn05	MOV	WB,*cmopn		; point to array operand
;
;      loop to generate code for array operand and subscripts
;
cgn06	JSR	cmgen			; generate code for next operand
	MOV	WC,cmlen(XL)		; load length of cmblk
	BLT	WB,WC,cgn06		; loop till all generated
;
;      generate appropriate array call
;
	MOV	WA,=oaon_		; load one-subscript case call
	BEQ	WC,*cmar1,cgn07		; jump to exit if one subscript case
	MOV	WA,=oamn_		; else load multi-subscript case call
	JSR	cdwrd			; generate call
	MOV	WA,WC			; copy cmblk length
	BTW	WA			; convert to words
	SUB	WA,=cmvls		; calculate number of subscripts
	EJC
;
;      cdgnm (continued)
;
;      here to exit generating word (non-constant)
;
cgn07	MNZ	WC			; set result non-constant
	JSR	cdwrd			; generate word
	BRN	cgn03			; back to exit
;
;      here to generate code for functions and undefined oprs
;
cgn08	MOV	XR,XL			; copy cmblk pointer
	JSR	cdgvl			; gen code by value for call
	MOV	WA,=ofne_		; get eXTra call for by name
	BRN	cgn07			; back to generate and exit
;
;      here to generate code for defered expression
;
cgn09	MOV	XR,cmrop(XL)		; check if vaRIAble
	BHI	(XR),=b_vr_,cgn02	; treat *vaRIAble as simple var
	MOV	XL,XR			; copy ptr to expression tree
.IF    .cevb
	MOV	WA,=num01		; return name
.FI
	JSR	cdgex			; else build exblk
	MOV	WA,=olex_		; set call to load expr by name
	JSR	cdwrd			; generate it
	MOV	WA,XR			; copy exblk pointer
	JSR	cdwrd			; generate exblk pointer
	BRN	cgn03			; back to exit
;
;      here to generate code for indirect reference
;
cgn10	MOV	XR,cmrop(XL)		; get operand
	JSR	cdgvl			; generate code by value for it
	MOV	WA,=oinn_		; load call for indirect by name
	BRN	cgn12			; merge
;
;      here to generate code for keyword reference
;
cgn11	MOV	XR,cmrop(XL)		; get operand
	JSR	cdgnm			; generate code by name for it
	MOV	WA,=okwn_		; load call for keyword by name
;
;      keyword, indirect merge here
;
cgn12	JSR	cdwrd			; generate code for operator
	BRN	cgn03			; exit
	ENP				; end procedure cdgnm
	EJC
;
;      cdgvl -- generate code by value
;
;      cdgvl is called during the compilation process to
;      generate code by value for an expression. see cdblk
;      description for details of the code generated. the input
;      to cdgvl is an expression tree as generated by expan.
;
;      cdgvl is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (WB)		     integer in range 0 le n le dnamb
;      (XR)		     ptr to tree generated by expan
;      (WC)		     constant flag (see below)
;      jsr  cdgvl	     call to generate code by value
;      (XR,WA)		     destroyed
;      (WC)		     set non-zero if non-constant
;
;      WC is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise WC is unchanged.
;
;      if WC is non-zero on entry, then preevaluation is not
;      allowed regardless of the nature of the operand.
;
;      the code is generated in the current ccblk (see cdwrd).
;
cdgvl	PRC	r,0			; entry point, recursive
	MOV	WA,(XR)			; load type word
	BEQ	WA,=b_cmt,cgv01		; jump if cmblk
	BLT	WA,=b_vra,cgv00		; jump if icblk, rcblk, scblk
	BNZ	vrlen(XR),cgvl0		; jump if not system vaRIAble
	MOV	-(XS),XR		; stack XR
	MOV	XR,vrsvp(XR)		; point to svblk
	MOV	WA,svbit(XR)		; get svblk property bits
	MOV	XR,(XS)+		; recover XR
	ANB	WA,btkwv		; check if constant keyword value
	BEQ	WA,btkwv,cgv00		; jump if constant keyword value
;
;      here for vaRIAble value reference
;
cgvl0	MNZ	WC			; indicate non-constant value
;
;      merge here for simple constant (icblk,rcblk,scblk)
;      and for vaRIAbles corresponding to constant keywords.
;
cgv00	MOV	WA,XR			; copy ptr to var or constant
	JSR	cdwrd			; generate as code word
	EXI				; return to caller
	EJC
;
;      cdgvl (continued)
;
;      here for tree node (cmblk)
;
cgv01	MOV	-(XS),WB		; save entry WB
	MOV	-(XS),XL		; save entry XL
	MOV	-(XS),WC		; save entry constant flag
	MOV	-(XS),cwcof		; save initial code offset
	CHK				; check for stack overflow
;
;      prepare to generate code for cmblk. WC is set to the
;      value of cswno (zero if -optimise, 1 if -noopt) to
;      start with and is reset non-zero for any non-constant
;      code generated. if it is still zero after generating all
;      the cmblk code, then its value is computed as the result.
;
	MOV	XL,XR			; copy cmblk pointer
	MOV	XR,cmtyp(XR)		; load cmblk type
	MOV	WC,cswno		; reset constant flag
	BLE	XR,=c_pr_,cgv02		; jump if not predicate value
	MNZ	WC			; else force non-constant case
;
;      here with WC set appropriately
;
cgv02	BSW	XR,c__nv		; switch to appropriate generator
	IFF	c_arr,cgv03		; array reference
	IFF	c_fnc,cgv05		; function call
	IFF	c_def,cgv14		; deferred expression
	IFF	c_sel,cgv15		; selection
	IFF	c_ind,cgv31		; indirect reference
	IFF	c_key,cgv27		; keyword reference
	IFF	c_ubo,cgv29		; undefined binop
	IFF	c_uuo,cgv30		; undefined unop
	IFF	c_bvl,cgv18		; binops with val opds
	IFF	c_alt,cgv18		; alternation
	IFF	c_uvl,cgv19		; unops with valu opnd
	IFF	c_ass,cgv21		; assignment
	IFF	c_cnc,cgv24		; concatenation
	IFF	c_cnp,cgv24		; concatenation (not pattern match)
	IFF	c_unm,cgv27		; unops with name opnd
	IFF	c_bvn,cgv26		; binary _ and .
	IFF	c_int,cgv31		; interrogation
	IFF	c_neg,cgv28		; negation
	IFF	c_pmt,cgv18		; pattern match
	ESW				; end switch on cmblk type
	EJC
;
;      cdgvl (continued)
;
;      here to generate code for array reference
;
cgv03	MOV	WB,*cmopn		; set offset to array operand
;
;      loop to generate code for array operand and subscripts
;
cgv04	JSR	cmgen			; gen value code for next operand
	MOV	WC,cmlen(XL)		; load cmblk length
	BLT	WB,WC,cgv04		; loop back if more to go
;
;      generate call to appropriate array reference routine
;
	MOV	WA,=oaov_		; set one subscript call in case
	BEQ	WC,*cmar1,cgv32		; jump to exit if 1-sub case
	MOV	WA,=oamv_		; else set call for multi-subscripts
	JSR	cdwrd			; generate call
	MOV	WA,WC			; copy length of cmblk
	SUB	WA,*cmvls		; subtract standard length
	BTW	WA			; get number of words
	BRN	cgv32			; jump to generate subscript count
;
;      here to generate code for function call
;
cgv05	MOV	WB,*cmvls		; set offset to first argument
;
;      loop to generate code for arguments
;
cgv06	BEQ	WB,cmlen(XL),cgv07	; jump if all generated
	JSR	cmgen			; else gen value code for next arg
	BRN	cgv06			; back to generate next argument
;
;      here to generate actual function call
;
cgv07	SUB	WB,*cmvls		; get number of arg ptrs (bytes)
	BTW	WB			; convert bytes to words
	MOV	XR,cmopn(XL)		; load function vrblk pointer
	BNZ	vrlen(XR),cgv12		; jump if not system function
	MOV	XL,vrsvp(XR)		; load svblk ptr if system var
	MOV	WA,svbit(XL)		; load bit mask
	ANB	WA,btffc		; test for fast function call allowed
	ZRB	WA,cgv12		; jump if not
	EJC
;
;      cdgvl (continued)
;
;      here if fast function call is allowed
;
	MOV	WA,svbit(XL)		; reload bit indicators
	ANB	WA,btpre		; test for preevaluation ok
	NZB	WA,cgv08		; jump if preevaluation permitted
	MNZ	WC			; else set result non-constant
;
;      test for correct number of args for fast call
;
cgv08	MOV	XL,vrfnc(XR)		; load ptr to svfnc field
	MOV	WA,fargs(XL)		; load svnar field value
	BEQ	WA,WB,cgv11		; jump if argument count is correct
	BHI	WA,WB,cgv09		; jump if too few arguments given
;
;      here if too many arguments, prepare to generate o_pops
;
	SUB	WB,WA			; get number of eXTra args
	LCT	WB,WB			; set as count to control loop
	MOV	WA,=opop_		; set pop call
	BRN	cgv10			; jump to common loop
;
;      here if too few arguments, prepare to generate nulls
;
cgv09	SUB	WA,WB			; get number of missing arguments
	LCT	WB,WA			; load as count to control loop
	MOV	WA,=nulls		; load ptr to null constant
;
;      loop to generate calls to fix argument count
;
cgv10	JSR	cdwrd			; generate one call
	BCT	WB,cgv10		; loop till all generated
;
;      here after adjusting arg count as required
;
cgv11	MOV	WA,XL			; copy pointer to svfnc field
	BRN	cgv36			; jump to generate call
	EJC
;
;      cdgvl (continued)
;
;      come here if fast call is not permitted
;
cgv12	MOV	WA,=ofns_		; set one arg call in case
	BEQ	WB,=num01,cgv13		; jump if one arg case
	MOV	WA,=ofnc_		; else load call for more than 1 arg
	JSR	cdwrd			; generate it
	MOV	WA,WB			; copy argument count
;
;      one arg case merges here
;
cgv13	JSR	cdwrd			; generate =o_fns or arg count
	MOV	WA,XR			; copy vrblk pointer
	BRN	cgv32			; jump to generate vrblk ptr
;
;      here for deferred expression
;
cgv14	MOV	XL,cmrop(XL)		; point to expression tree
.IF    .cevb
	ZER	WA			; return value
.FI
	JSR	cdgex			; build exblk or seblk
	MOV	WA,XR			; copy block ptr
	JSR	cdwrd			; generate ptr to exblk or seblk
	BRN	cgv34			; jump to exit, constant test
;
;      here to generate code for selection
;
cgv15	ZER	-(XS)			; zero ptr to chain of forward jumps
	ZER	-(XS)			; zero ptr to prev o_slc forward ptr
	MOV	WB,*cmvls		; point to first alternative
	MOV	WA,=osla_		; set initial code word
;
;      0(XS)		     is the offset to the previous word
;			     which requires filling in with an
;			     offset to the following o_slc,o_sld
;
;      1(XS)		     is the head of a chain of offset
;			     pointers indicating those locations
;			     to be filled with offsets past
;			     the end of all the alternatives
;
cgv16	JSR	cdwrd			; generate o_slc (o_sla first time)
	MOV	(XS),cwcof		; set current loc as ptr to fill in
	JSR	cdwrd			; generate garbage word there for now
	JSR	cmgen			; gen value code for alternative
	MOV	WA,=oslb_		; load o_slb pointer
	JSR	cdwrd			; generate o_slb call
	MOV	WA,num01(XS)		; load old chain ptr
	MOV	num01(XS),cwcof		; set current loc as new chain head
	JSR	cdwrd			; generate forward chain link
	EJC
;
;      cdgvl (continued)
;
;      now to fill in the skip offset to o_slc,o_sld
;
	MOV	XR,(XS)			; load offset to word to plug
	ADD	XR,r_ccb		; point to actual location to plug
	MOV	(XR),cwcof		; plug proper offset in
	MOV	WA,=oslc_		; load o_slc ptr for next alternative
	MOV	XR,WB			; copy offset (destroy garbage XR)
	ICA	XR			; bump eXTra time for test
	BLT	XR,cmlen(XL),cgv16	; loop back if not last alternative
;
;      here to generate code for last alternative
;
	MOV	WA,=osld_		; get header call
	JSR	cdwrd			; generate o_sld call
	JSR	cmgen			; generate code for last alternative
	ICA	XS			; pop offset ptr
	MOV	XR,(XS)+		; load chain ptr
;
;      loop to plug offsets past structure
;
cgv17	ADD	XR,r_ccb		; make next ptr absolute
	MOV	WA,(XR)			; load forward ptr
	MOV	(XR),cwcof		; plug required offset
	MOV	XR,WA			; copy forward ptr
	BNZ	WA,cgv17		; loop back if more to go
	BRN	cgv33			; else jump to exit (not constant)
;
;      here for binary ops with value operands
;
cgv18	MOV	XR,cmlop(XL)		; load left operand pointer
	JSR	cdgvl			; gen value code for left operand
;
;      here for unary ops with value operand (binops merge)
;
cgv19	MOV	XR,cmrop(XL)		; load right (only) operand ptr
	JSR	cdgvl			; gen code by value
	EJC
;
;      cdgvl (continued)
;
;      merge here to generate operator call from cmopn field
;
cgv20	MOV	WA,cmopn(XL)		; load operator call pointer
	BRN	cgv36			; jump to generate it with cons test
;
;      here for assignment
;
cgv21	MOV	XR,cmlop(XL)		; load left operand pointer
	BLO	(XR),=b_vr_,cgv22	; jump if not vaRIAble
;
;      here for assignment to simple vaRIAble
;
	MOV	XR,cmrop(XL)		; load right operand ptr
	JSR	cdgvl			; generate code by value
	MOV	WA,cmlop(XL)		; reload left operand vrblk ptr
	ADD	WA,*vrsto		; point to vrsto field
	BRN	cgv32			; jump to generate store ptr
;
;      here if not simple vaRIAble assignment
;
cgv22	JSR	expap			; test for pattern match on left side
	PPM	cgv23			; jump if not pattern match
;
;      here for pattern replacement
;
	MOV	cmlop(XL),cmrop(XR)	; save pattern ptr in safe place
	MOV	XR,cmlop(XR)		; load subject ptr
	JSR	cdgnm			; gen code by name for subject
	MOV	XR,cmlop(XL)		; load pattern ptr
	JSR	cdgvl			; gen code by value for pattern
	MOV	WA,=opmn_		; load match by name call
	JSR	cdwrd			; generate it
	MOV	XR,cmrop(XL)		; load replacement value ptr
	JSR	cdgvl			; gen code by value
	MOV	WA,=orpl_		; load replace call
	BRN	cgv32			; jump to gen and exit (not constant)
;
;      here for assignment to complex vaRIAble
;
cgv23	MNZ	WC			; inhibit pre-evaluation
	JSR	cdgnm			; gen code by name for left side
	BRN	cgv31			; merge with unop circuit
	EJC
;
;      cdgvl (continued)
;
;      here for concatenation
;
cgv24	MOV	XR,cmlop(XL)		; load left operand ptr
	BNE	(XR),=b_cmt,cgv18	; ordinary binop if not cmblk
	MOV	WB,cmtyp(XR)		; load cmblk type code
	BEQ	WB,=c_int,cgv25		; special case if interrogation
	BEQ	WB,=c_neg,cgv25		; or negation
	BNE	WB,=c_fnc,cgv18		; else ordinary binop if not function
	MOV	XR,cmopn(XR)		; else load function vrblk ptr
	BNZ	vrlen(XR),cgv18		; ordinary binop if not system var
	MOV	XR,vrsvp(XR)		; else point to svblk
	MOV	WA,svbit(XR)		; load bit indicators
	ANB	WA,btprd		; test for predicate function
	ZRB	WA,cgv18		; ordinary binop if not
;
;      here if left arg of concatenation is predicate function
;
cgv25	MOV	XR,cmlop(XL)		; reload left arg
	JSR	cdgvl			; gen code by value
	MOV	WA,=opop_		; load pop call
	JSR	cdwrd			; generate it
	MOV	XR,cmrop(XL)		; load right operand
	JSR	cdgvl			; gen code by value as result code
	BRN	cgv33			; exit (not constant)
;
;      here to generate code for pattern, immediate assignment
;
cgv26	MOV	XR,cmlop(XL)		; load left operand
	JSR	cdgvl			; gen code by value, merge
;
;      here for unops with arg by name (binary _ . merge)
;
cgv27	MOV	XR,cmrop(XL)		; load right operand ptr
	JSR	cdgnm			; gen code by name for right arg
	MOV	XR,cmopn(XL)		; get operator code word
	BNE	(XR),=o_kwv,cgv20	; gen call unless keyword value
	EJC
;
;      cdgvl (continued)
;
;      here for keyword by value. this is constant only if
;      the operand is one of the special system vaRIAbles with
;      the svckw bit set to indicate a constant keyword value.
;      note that the only constant operand by name is a vaRIAble
;
	BNZ	WC,cgv20		; gen call if non-constant (not var)
	MNZ	WC			; else set non-constant in case
	MOV	XR,cmrop(XL)		; load ptr to operand vrblk
	BNZ	vrlen(XR),cgv20		; gen (non-constant) if not sys var
	MOV	XR,vrsvp(XR)		; else load ptr to svblk
	MOV	WA,svbit(XR)		; load bit mask
	ANB	WA,btckw		; test for constant keyword
	ZRB	WA,cgv20		; go gen if not constant
	ZER	WC			; else set result constant
	BRN	cgv20			; and jump back to generate call
;
;      here to generate code for negation
;
cgv28	MOV	WA,=onta_		; get initial word
	JSR	cdwrd			; generate it
	MOV	WB,cwcof		; save next offset
	JSR	cdwrd			; generate gunk word for now
	MOV	XR,cmrop(XL)		; load right operand ptr
	JSR	cdgvl			; gen code by value
	MOV	WA,=ontb_		; load end of evaluation call
	JSR	cdwrd			; generate it
	MOV	XR,WB			; copy offset to word to plug
	ADD	XR,r_ccb		; point to actual word to plug
	MOV	(XR),cwcof		; plug word with current offset
	MOV	WA,=ontc_		; load final call
	BRN	cgv32			; jump to generate it (not constant)
;
;      here to generate code for undefined binary operator
;
cgv29	MOV	XR,cmlop(XL)		; load left operand ptr
	JSR	cdgvl			; generate code by value
	EJC
;
;      cdgvl (continued)
;
;      here to generate code for undefined unary operator
;
cgv30	MOV	WB,=c_uo_		; set unop code + 1
	SUB	WB,cmtyp(XL)		; set number of args (1 or 2)
;
;      merge here for undefined operators
;
	MOV	XR,cmrop(XL)		; load right (only) operand pointer
	JSR	cdgvl			; gen value code for right operand
	MOV	XR,cmopn(XL)		; load pointer to operator dv
	MOV	XR,dvopn(XR)		; load pointer offset
	WTB	XR			; convert word offset to bytes
	ADD	XR,=r_uba		; point to proper function ptr
	SUB	XR,*vrfnc		; set standard function offset
	BRN	cgv12			; merge with function call circuit
;
;      here to generate code for interrogation, indirection
;
cgv31	MNZ	WC			; set non constant
	BRN	cgv19			; merge
;
;      here to exit generating a word, result not constant
;
cgv32	JSR	cdwrd			; generate word, merge
;
;      here to exit with no word generated, not constant
;
cgv33	MNZ	WC			; indicate result is not constant
;
;      common exit point
;
cgv34	ICA	XS			; pop initial code offset
	MOV	WA,(XS)+		; restore old constant flag
	MOV	XL,(XS)+		; restore entry XL
	MOV	WB,(XS)+		; restore entry WB
	BNZ	WC,cgv35		; jump if not constant
	MOV	WC,WA			; else restore entry constant flag
;
;      here to return after dealing with WC setting
;
cgv35	EXI				; return to cdgvl caller
;
;      exit here to generate word and test for constant
;
cgv36	JSR	cdwrd			; generate word
	BNZ	WC,cgv34		; jump to exit if not constant
	EJC
;
;      cdgvl (continued)
;
;      here to preevaluate constant sub-expression
;
	MOV	WA,=orvl_		; load call to return value
	JSR	cdwrd			; generate it
	MOV	XL,(XS)			; load initial code offset
	JSR	exbld			; build exblk for expression
	ZER	WB			; set to evaluate by value
	JSR	evalx			; evaluate expression
	PPM				; should not fail
	MOV	WA,(XR)			; load type word of result
	BLO	WA,=p_aaa,cgv37		; jump if not pattern
	MOV	WA,=olpt_		; else load special pattern load call
	JSR	cdwrd			; generate it
;
;      merge here to generate pointer to resulting constant
;
cgv37	MOV	WA,XR			; copy constant pointer
	JSR	cdwrd			; generate ptr
	ZER	WC			; set result constant
	BRN	cgv34			; jump back to exit
	ENP				; end procedure cdgvl
	EJC
;
;      cdwrd -- generate one word of code
;
;      cdwrd writes one word into the current code block under
;      construction. a new, larger, block is allocated if there
;      is insufficient room in the current block. cdwrd ensures
.IF    .csln
;      that there are at least four words left in the block
.ELSE
;      that there are at least three words left in the block
.FI
;      after entering the new word. this guarantees that any
;      eXTra space at the end can be split off as a ccblk.
;
;      (wa)		     word to be generated
;      jsr  cdwrd	     call to generate word
;
cdwrd	PRC	e,0			; entry point
	MOV	-(XS),XR		; save entry XR
	MOV	-(XS),WA		; save code word to be generated
;
;      merge back here after allocating larger block
;
cdwd1	MOV	XR,r_ccb		; load ptr to ccblk being built
	BNZ	XR,cdwd2		; jump if block allocated
;
;      here we allocate an entirely fresh block
;
	MOV	WA,*e_cbs		; load initial length
	JSR	alloc			; allocate ccblk
	MOV	(XR),=b_cct		; store type word
	MOV	cwcof,*cccod		; set initial offset
	MOV	cclen(XR),WA		; store block length
.IF    .csln
	ZER	ccsln(XR)		; zero line number
.FI
	MOV	r_ccb,XR		; store ptr to new block
;
;      here we have a block we can use
;
cdwd2	MOV	WA,cwcof		; load current offset
.IF    .csln
	ADD	WA,*num05		; adjust for test (five words)
.ELSE
	ADD	WA,*num04		; adjust for test (four words)
.FI
	BLO	WA,cclen(XR),cdwd4	; jump if room in this block
;
;      here if no room in current block
;
	BGE	WA,mxlen,cdwd5		; jump if already at max size
	ADD	WA,*e_cbs		; else get new size
	MOV	-(XS),XL		; save entry XL
	MOV	XL,XR			; copy pointer
	BLT	WA,mxlen,cdwd3		; jump if not too large
	MOV	WA,mxlen		; else reset to max allowed size
	EJC
;
;      cdwrd (continued)
;
;      here with new block size in wa
;
cdwd3	JSR	alloc			; allocate new block
	MOV	r_ccb,XR		; store pointer to new block
	MOV	(XR)+,=b_cct		; store type word in new block
	MOV	(XR)+,WA		; store block length
.IF    .csln
	MOV	(XR)+,ccsln(XL)		; copy source line number word
.FI
	ADD	XL,*ccuse		; point to ccuse,cccod fields in old
	MOV	WA,(XL)			; load ccuse value
	MVW				; copy useful words from old block
	MOV	XL,(XS)+		; restore XL
	BRN	cdwd1			; merge back to try again
;
;      here with room in current block
;
cdwd4	MOV	WA,cwcof		; load current offset
	ICA	WA			; get new offset
	MOV	cwcof,WA		; store new offset
	MOV	ccuse(XR),WA		; store in ccblk for gbcol
	DCA	WA			; restore ptr to this word
	ADD	XR,WA			; point to current entry
	MOV	WA,(XS)+		; reload word to generate
	MOV	(XR),WA			; store word in block
	MOV	XR,(XS)+		; restore entry XR
	EXI				; return to caller
;
;      here if compiled code is too long for cdblk
;
cdwd5	ERB	213,syntax error: statement is too complicated.
	ENP				; end procedure cdwrd
	EJC
;
;      cmgen -- generate code for cmblk ptr
;
;      cmgen is a subsidiary procedure used to generate value
;      code for a cmblk ptr from the main code generators.
;
;      (XL)		     cmblk pointer
;      (WB)		     offset to pointer in cmblk
;      jsr  cmgen	     call to generate code
;      (XR,WA)		     destroyed
;      (WB)		     bumped by one word
;
cmgen	PRC	r,0			; entry point, recursive
	MOV	XR,XL			; copy cmblk pointer
	ADD	XR,WB			; point to cmblk pointer
	MOV	XR,(XR)			; load cmblk pointer
	JSR	cdgvl			; generate code by value
	ICA	WB			; bump offset
	EXI				; return to caller
	ENP				; end procedure cmgen
	EJC
;
;      cmpil (compile source code)
;
;      cmpil is used to convert snobol4 source code to internal
;      form (see cdblk format). it is used both for the initial
;      compile and at run time by the code and convert functions
;      this procedure has control for the entire duration of
;      initial compilation. an error in any procedure called
;      during compilation will lead first to the error section
;      and ultimately back here for resumed compilation. the
;      re-entry points after an error are specially labelled -
;
;      cmpce		     resume after control card error
;      cmple		     resume after label error
;      cmpse		     resume after statement error
;
;      jsr  cmpil	     call to compile code
;      (XR)		     ptr to cdblk for entry statement
;      (XL,WA,WB,WC,ra)	     destroyed
;
;      the following global vaRIAbles are referenced
;
;      cmpln		     line number of first line of
;			     statement to be compiled
;
;      cmpsn		     number of next statement
;			     to be compiled.
;
;      cswxx		     control card switch values are
;			     changed when relevant control
;			     cards are met.
;
;      cwcof		     offset to next word in code block
;			     being built (see cdwrd).
;
;      lstsn		     number of statement most recently
;			     compiled (initially set to zero).
;
;      r_cim		     current (initial) compiler image
;			     (zero for initial compile call)
;
;      r_cni		     used to point to following image.
;			     (see readr procedure).
;
;      scngo		     goto switch for scane procedure
;
;      scnil		     length of current image excluding
;			     characters removed by -input.
;
;      scnpt		     current scan offset, see scane.
;
;      scnrs		     rescan switch for scane procedure.
;
;      scnse		     offset (in r_cim) of most recently
;			     scanned element. set zero if not
;			     currently scanning items
	EJC
;
;      cmpil (continued)
;
;      stage		   stgic  initial compile in progress
;			   stgxc  code/convert compile
;			   stgev  building exblk for eval
;			   stgxt  execute time (outside compile)
;			   stgce  initial compile after end line
;			   stgxe  execute compile after end line
;
;      cmpil also uses a fixed number of locations on the
;      main stack as follows. (the definitions of the actual
;      offsets are in the definitions section).
;
;      cmstm(XS)	     pointer to expan tree for body of
;			     statement (see expan procedure).
;
;      cmsgo(XS)	     pointer to tree representation of
;			     success goto (see procedure scngo)
;			     zero if no success goto is given
;
;      cmfgo(XS)	     like cmsgo for failure goto.
;
;      cmcgo(XS)	     set non-zero only if there is a
;			     conditional goto. used for -fail,
;			     -nofail code generation.
;
;      cmpcd(XS)	     pointer to cdblk for previous
;			     statement. zero for 1st statement.
;
;      cmffp(XS)	     set non-zero if cdfal in previous
;			     cdblk needs filling with forward
;			     pointer, else set to zero.
;
;      cmffc(XS)	     same as cmffp for current cdblk
;
;      cmsop(XS)	     offset to word in previous cdblk
;			     to be filled in with forward ptr
;			     to next cdblk for success goto.
;			     zero if no fill in is required.
;
;      cmsoc(XS)	     same as cmsop for current cdblk.
;
;      cmlbl(XS)	     pointer to vrblk for label of
;			     current statement. zero if no label
;
;      cmtra(XS)	     pointer to cdblk for entry stmnt.
	EJC
;
;      cmpil (continued)
;
;      entry point
;
cmpil	PRC	e,0			; entry point
	LCT	WB,=cmnen		; set number of stack work locations
;
;      loop to initialize stack working locations
;
cmp00	ZER	-(XS)			; store a zero, make one entry
	BCT	WB,cmp00		; loop back until all set
	MOV	cmpxs,XS		; save stack pointer for error sec
	SSS	cmpss			; save s-r stack pointer if any
;
;      loop through statements
;
cmp01	MOV	WB,scnpt		; set scan pointer offset
	MOV	scnse,WB		; set start of element location
	MOV	WA,=ocer_		; point to compile error call
	JSR	cdwrd			; generate as temporary cdfal
	BLT	WB,scnil,cmp04		; jump if chars left on this image
;
;      loop here after comment or control card
;      also special entry after control card error
;
cmpce	ZER	XR			; clear possible garbage XR value
.IF    .cinc
	BNZ	cnind,cmpc2		; if within include file
.FI
	BNE	stage,=stgic,cmp02	; skip unless initial compile
cmpc2	JSR	readr			; read next input image
	BZE	XR,cmp09		; jump if no input available
	JSR	nexts			; acquire next source image
	MOV	lstsn,cmpsn		; store stmt no for use by listr
	MOV	cmpln,rdcln		; store line number at start of stmt
	ZER	scnpt			; reset scan pointer
	BRN	cmp04			; go process image
;
;      for execute time compile, permit embedded control cards
;      and comments (by skipping to next semi-colon)
;
cmp02	MOV	XR,r_cim		; get current image
	MOV	WB,scnpt		; get current offset
	PLC	XR,WB			; prepare to get chars
;
;      skip to semi-colon
;
cmp03	BGE	scnpt,scnil,cmp09	; end loop if end of image
	LCH	WC,(XR)+		; get char
	ICV	scnpt			; advance offset
	BNE	WC,=ch_sm,cmp03		; loop if not semi-colon
	EJC
;
;      cmpil (continued)
;
;      here with image available to scan. note that if the input
;      string is null, then everything is ok since null is
;      actually assembled as a word of blanks.
;
cmp04	MOV	XR,r_cim		; point to current image
	MOV	WB,scnpt		; load current offset
	MOV	WA,WB			; copy for label scan
	PLC	XR,WB			; point to first character
	LCH	WC,(XR)+		; load first character
	BEQ	WC,=ch_sm,cmp12		; no label if semicolon
	BEQ	WC,=ch_as,cmpce		; loop back if comment card
	BEQ	WC,=ch_mn,cmp32		; jump if control card
	MOV	r_cmp,r_cim		; about to destroy r_cim
	MOV	XL,=cmlab		; point to label work string
	MOV	r_cim,XL		; scane is to scan work string
	PSC	XL			; point to first character position
	SCH	WC,(XL)+		; store char just loaded
	MOV	WC,=ch_sm		; get a semicolon
	SCH	WC,(XL)			; store after first char
	CSC	XL			; finished character storing
	ZER	XL			; clear pointer
	ZER	scnpt			; start at first character
	MOV	-(XS),scnil		; preserve image length
	MOV	scnil,=num02		; read 2 chars at most
	JSR	scane			; scan first char for type
	MOV	scnil,(XS)+		; restore image length
	MOV	WC,XL			; note return code
	MOV	XL,r_cmp		; get old r_cim
	MOV	r_cim,XL		; put it back
	MOV	scnpt,WB		; reinstate offset
	BNZ	scnbl,cmp12		; blank seen - cant be label
	MOV	XR,XL			; point to current image
	PLC	XR,WB			; point to first char again
	BEQ	WC,=t_var,cmp06		; ok if letter
	BEQ	WC,=t_con,cmp06		; ok if digit
;
;      drop in or jump from error section if scane failed
;
cmple	MOV	r_cim,r_cmp		; point to bad line
	ERB	214,bad label or misplaced continuation line
;
;      loop to scan label
;
cmp05	BEQ	WC,=ch_sm,cmp07		; skip if semicolon
	ICV	WA			; bump offset
	BEQ	WA,scnil,cmp07		; jump if end of image (label end)
	EJC
;
;      cmpil (continued)
;
;      enter loop at this point
;
cmp06	LCH	WC,(XR)+		; else load next character
.IF    .caht
	BEQ	WC,=ch_ht,cmp07		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WC,=ch_vt,cmp07		; jump if vertical tab
.FI
	BNE	WC,=ch_bl,cmp05		; loop back if non-blank
;
;      here after scanning out label
;
cmp07	MOV	scnpt,WA		; save updated scan offset
	SUB	WA,WB			; get length of label
	BZE	WA,cmp12		; skip if label length zero
	ZER	XR			; clear garbage XR value
	JSR	sbstr			; build scblk for label name
	JSR	gtnvr			; locate/contruct vrblk
	PPM				; dummy (impossible) error return
	MOV	cmlbl(XS),XR		; store label pointer
	BNZ	vrlen(XR),cmp11		; jump if not system label
	BNE	vrsvp(XR),=v_end,cmp11	; jump if not end label
;
;      here for end label scanned out
;
	ADD	stage,=stgnd		; adjust stage appropriately
	JSR	scane			; scan out next element
	BEQ	XL,=t_smc,cmp10		; jump if end of image
	BNE	XL,=t_var,cmp08		; else error if not vaRIAble
;
;      here check for valid initial transfer
;
	BEQ	vrlbl(XR),=stndl,cmp08	; jump if not defined (error)
	MOV	cmtra(XS),vrlbl(XR)	; else set initial entry pointer
	JSR	scane			; scan next element
	BEQ	XL,=t_smc,cmp10		; jump if ok (end of image)
;
;      here for bad transfer label
;
cmp08	ERB	215,syntax error: undefined or erroneous entry label
;
;      here for end of input (no end label detected)
;
cmp09	ZER	XR			; clear garbage XR value
	ADD	stage,=stgnd		; adjust stage appropriately
	BEQ	stage,=stgxe,cmp10	; jump if code call (ok)
	ERB	216,syntax error: missing end line
;
;      here after processing end line (merge here on end error)
;
cmp10	MOV	WA,=ostp_		; set stop call pointer
	JSR	cdwrd			; generate as statement call
	BRN	cmpse			; jump to generate as failure
	EJC
;
;      cmpil (continued)
;
;      here after processing label other than end
;
cmp11	BNE	stage,=stgic,cmp12	; jump if code call - redef. ok
	BEQ	vrlbl(XR),=stndl,cmp12	; else check for redefinition
	ZER	cmlbl(XS)		; leave first label decln undisturbed
	ERB	217,syntax error: duplicate label
;
;      here after dealing with label
;      null statements and statements just containing a
;      constant subject are optimized out by resetting the
;      current ccblk to empty.
;
cmp12	ZER	WB			; set flag for statement body
	JSR	expan			; get tree for statement body
	MOV	cmstm(XS),XR		; store for later use
	ZER	cmsgo(XS)		; clear success goto pointer
	ZER	cmfgo(XS)		; clear failure goto pointer
	ZER	cmcgo(XS)		; clear conditional goto flag
	JSR	scane			; scan next element
	BEQ	XL,=t_col,cmp13		; jump if colon (goto)
	BNZ	cswno,cmp18		; jump if not optimizing
	BNZ	cmlbl(XS),cmp18		; jump if label present
	MOV	XR,cmstm(XS)		; load tree ptr for statement body
	MOV	WA,(XR)			; load type word
	BEQ	WA,=b_cmt,cmp18		; jump if cmblk
	BGE	WA,=b_vra,cmp18		; jump if not icblk, scblk, or rcblk
	MOV	XL,r_ccb		; load ptr to ccblk
	MOV	ccuse(XL),*cccod	; reset use offset in ccblk
	MOV	cwcof,*cccod		; and in global
	ICV	cmpsn			; bump statement number
	BRN	cmp01			; generate no code for statement
;
;      loop to process goto fields
;
cmp13	MNZ	scngo			; set goto flag
	JSR	scane			; scan next element
	BEQ	XL,=t_smc,cmp31		; jump if no fields left
	BEQ	XL,=t_sgo,cmp14		; jump if s for success goto
	BEQ	XL,=t_fgo,cmp16		; jump if f for failure goto
;
;      here for unconditional goto (i.e. not f or s)
;
	MNZ	scnrs			; set to rescan element not f,s
	JSR	scngf			; scan out goto field
	BNZ	cmfgo(XS),cmp17		; error if fgoto already
	MOV	cmfgo(XS),XR		; else set as fgoto
	BRN	cmp15			; merge with sgoto circuit
;
;      here for success goto
;
cmp14	JSR	scngf			; scan success goto field
	MOV	cmcgo(XS),=num01	; set conditional goto flag
;
;      uncontional goto merges here
;
cmp15	BNZ	cmsgo(XS),cmp17		; error if sgoto already given
	MOV	cmsgo(XS),XR		; else set sgoto
	BRN	cmp13			; loop back for next goto field
;
;      here for failure goto
;
cmp16	JSR	scngf			; scan goto field
	MOV	cmcgo(XS),=num01	; set conditonal goto flag
	BNZ	cmfgo(XS),cmp17		; error if fgoto already given
	MOV	cmfgo(XS),XR		; else store fgoto pointer
	BRN	cmp13			; loop back for next field
	EJC
;
;      cmpil (continued)
;
;      here for duplicated goto field
;
cmp17	ERB	218,syntax error: duplicated goto field
;
;      here to generate code
;
cmp18	ZER	scnse			; stop positional error flags
	MOV	XR,cmstm(XS)		; load tree ptr for statement body
	ZER	WB			; collectable value for WB for cdgvl
	ZER	WC			; reset constant flag for cdgvl
	JSR	expap			; test for pattern match
	PPM	cmp19			; jump if not pattern match
	MOV	cmopn(XR),=opms_	; else set pattern match pointer
	MOV	cmtyp(XR),=c_pmt	;
;
;      here after dealing with special pattern match case
;
cmp19	JSR	cdgvl			; generate code for body of statement
	MOV	XR,cmsgo(XS)		; load sgoto pointer
	MOV	WA,XR			; copy it
	BZE	XR,cmp21		; jump if no success goto
	ZER	cmsoc(XS)		; clear success offset fillin ptr
	BHI	XR,state,cmp20		; jump if complex goto
;
;      here for simple success goto (label)
;
	ADD	WA,*vrtra		; point to vrtra field as required
	JSR	cdwrd			; generate success goto
	BRN	cmp22			; jump to deal with fgoto
;
;      here for complex success goto
;
cmp20	BEQ	XR,cmfgo(XS),cmp22	; no code if same as fgoto
	ZER	WB			; else set ok value for cdgvl in WB
	JSR	cdgcg			; generate code for success goto
	BRN	cmp22			; jump to deal with fgoto
;
;      here for no success goto
;
cmp21	MOV	cmsoc(XS),cwcof		; set success fill in offset
	MOV	WA,=ocer_		; point to compile error call
	JSR	cdwrd			; generate as temporary value
	EJC
;
;      cmpil (continued)
;
;      here to deal with failure goto
;
cmp22	MOV	XR,cmfgo(XS)		; load failure goto pointer
	MOV	WA,XR			; copy it
	ZER	cmffc(XS)		; set no fill in required yet
	BZE	XR,cmp23		; jump if no failure goto given
	ADD	WA,*vrtra		; point to vrtra field in case
	BLO	XR,state,cmpse		; jump to gen if simple fgoto
;
;      here for complex failure goto
;
	MOV	WB,cwcof		; save offset to o_gof call
	MOV	WA,=ogof_		; point to failure goto call
	JSR	cdwrd			; generate
	MOV	WA,=ofif_		; point to fail in fail word
	JSR	cdwrd			; generate
	JSR	cdgcg			; generate code for failure goto
	MOV	WA,WB			; copy offset to o_gof for cdfal
	MOV	WB,=b_cdc		; set complex case cdtyp
	BRN	cmp25			; jump to build cdblk
;
;      here if no failure goto given
;
cmp23	MOV	WA,=ounf_		; load unexpected failure call in cas
	MOV	WC,cswfl		; get -nofail flag
	ORB	WC,cmcgo(XS)		; check if conditional goto
	ZRB	WC,cmpse		; jump if -nofail and no cond. goto
	MNZ	cmffc(XS)		; else set fill in flag
	MOV	WA,=ocer_		; and set compile error for temporary
;
;      merge here with cdfal value in wa, simple cdblk
;      also special entry after statement error
;
cmpse	MOV	WB,=b_cds		; set cdtyp for simple case
	EJC
;
;      cmpil (continued)
;
;      merge here to build cdblk
;
;      (wa)		     cdfal value to be generated
;      (WB)		     cdtyp value to be generated
;
;      at this stage, we chop off an appropriate chunk of the
;      current ccblk and convert it into a cdblk. the remainder
;      of the ccblk is reformatted to be the new ccblk.
;
cmp25	MOV	XR,r_ccb		; point to ccblk
	MOV	XL,cmlbl(XS)		; get possible label pointer
	BZE	XL,cmp26		; skip if no label
	ZER	cmlbl(XS)		; clear flag for next statement
	MOV	vrlbl(XL),XR		; put cdblk ptr in vrblk label field
;
;      merge after doing label
;
cmp26	MOV	(XR),WB			; set type word for new cdblk
	MOV	cdfal(XR),WA		; set failure word
	MOV	XL,XR			; copy pointer to ccblk
	MOV	WB,ccuse(XR)		; load length gen (= new cdlen)
	MOV	WC,cclen(XR)		; load total ccblk length
	ADD	XL,WB			; point past cdblk
	SUB	WC,WB			; get length left for chop off
	MOV	(XL),=b_cct		; set type code for new ccblk at end
	MOV	ccuse(XL),*cccod	; set initial code offset
	MOV	cwcof,*cccod		; reinitialise cwcof
	MOV	cclen(XL),WC		; set new length
	MOV	r_ccb,XL		; set new ccblk pointer
.IF    .csln
	ZER	ccsln(XL)		; initialize new line number
	MOV	cdsln(XR),cmpln		; set line number in old block
.FI
	MOV	cdstm(XR),cmpsn		; set statement number
	ICV	cmpsn			; bump statement number
;
;      set pointers in previous code block as required
;
	MOV	XL,cmpcd(XS)		; load ptr to previous cdblk
	BZE	cmffp(XS),cmp27		; jump if no failure fill in required
	MOV	cdfal(XL),XR		; else set failure ptr in previous
;
;      here to deal with success forward pointer
;
cmp27	MOV	WA,cmsop(XS)		; load success offset
	BZE	WA,cmp28		; jump if no fill in required
	ADD	XL,WA			; else point to fill in location
	MOV	(XL),XR			; store forward pointer
	ZER	XL			; clear garbage XL value
	EJC
;
;      cmpil (continued)
;
;      now set fill in pointers for this statement
;
cmp28	MOV	cmffp(XS),cmffc(XS)	; copy failure fill in flag
	MOV	cmsop(XS),cmsoc(XS)	; copy success fill in offset
	MOV	cmpcd(XS),XR		; save ptr to this cdblk
	BNZ	cmtra(XS),cmp29		; jump if initial entry already set
	MOV	cmtra(XS),XR		; else set ptr here as default
;
;      here after compiling one statement
;
cmp29	BLT	stage,=stgce,cmp01	; jump if not end line just done
	BZE	cswls,cmp30		; skip if -nolist
	JSR	listr			; list last line
;
;      return
;
cmp30	MOV	XR,cmtra(XS)		; load initial entry cdblk pointer
	ADD	XS,*cmnen		; pop work locations off stack
	EXI				; and return to cmpil caller
;
;      here at end of goto field
;
cmp31	MOV	WB,cmfgo(XS)		; get fail goto
	ORB	WB,cmsgo(XS)		; or in success goto
	BNZ	WB,cmp18		; ok if non-null field
	ERB	219,syntax error: empty goto field
;
;      control card found
;
cmp32	ICV	WB			; point past ch_mn
	JSR	cncrd			; process control card
	ZER	scnse			; clear start of element loc.
	BRN	cmpce			; loop for next statement
	ENP				; end procedure cmpil
	EJC
;
;      cncrd -- control card processor
;
;      called to deal with control cards
;
;      r_cim		     points to current image
;      (WB)		     offset to 1st char of control card
;      jsr  cncrd	     call to process control cards
;      (XL,XR,WA,WB,WC,ia)   destroyed
;
cncrd	PRC	e,0			; entry point
	MOV	scnpt,WB		; offset for control card scan
	MOV	WA,=ccnoc		; number of chars for comparison
	CTW	WA,0			; convert to word count
	MOV	cnswc,WA		; save word count
;
;      loop here if more than one control card
;
cnc01	BGE	scnpt,scnil,cnc09	; return if end of image
	MOV	XR,r_cim		; point to image
	PLC	XR,scnpt		; char ptr for first char
	LCH	WA,(XR)+		; get first char
.IF    .culc
	FLC	WA			; fold to lower case
.FI
	BEQ	WA,=ch_li,cnc07		; special case of -inxxx
cnc0a	MNZ	scncc			; set flag for scane
	JSR	scane			; scan card name
	ZER	scncc			; clear scane flag
	BNZ	XL,cnc06		; fail unless control card name
	MOV	WA,=ccnoc		; no. of chars to be compared
.IF    .cicc
	BLT	sclen(XR),WA,cnc08	; fail if too few chars
.ELSE
	BLT	sclen(XR),WA,cnc06	; fail if too few chars
.FI
	MOV	XL,XR			; point to control card name
	ZER	WB			; zero offset for substring
	JSR	sbstr			; eXTract substring for comparison
.IF    .culc
	MOV	WA,sclen(XR)		; reload length
	JSR	flstg			; fold to upper case
.FI
	MOV	cnscc,XR		; keep control card substring ptr
	MOV	XR,=ccnms		; point to list of standard names
	ZER	WB			; initialise name offset
	LCT	WC,=cc_nc		; number of standard names
;
;      try to match name
;
cnc02	MOV	XL,cnscc		; point to name
	LCT	WA,cnswc		; counter for inner loop
	BRN	cnc04			; jump into loop
;
;      inner loop to match card name chars
;
cnc03	ICA	XR			; bump standard names ptr
	ICA	XL			; bump name pointer
;
;      here to initiate the loop
;
cnc04	CNE	schar(XL),(XR),cnc05	; comp. up to cfp_c chars at once
	BCT	WA,cnc03		; loop if more words to compare
	EJC
;
;      cncrd (continued)
;
;      matched - branch on card offset
;
	MOV	XL,WB			; get name offset
.IF    .cicc
	BSW	XL,cc_nc,cnc08		; switch
.ELSE
	BSW	XL,cc_nc,cnc06		; switch
.FI
.IF    .culc
	IFF	cc_ca,cnc37		; -case
.FI
.IF    .ccmc
	IFF	cc_co,cnc39		; -compare
.FI
	IFF	cc_do,cnc10		; -double
	IFF	cc_du,cnc11		; -dump
.IF    .cinc
	IFF	cc_cp,cnc41		; -copy
.FI
	IFF	cc_ej,cnc12		; -eject
	IFF	cc_er,cnc13		; -errors
	IFF	cc_ex,cnc14		; -execute
	IFF	cc_fa,cnc15		; -fail
.IF    .cinc
	IFF	cc_in,cnc41		; -include
.FI
.IF    .csln
	IFF	cc_ln,cnc44		; -line
.FI
	IFF	cc_li,cnc16		; -list
	IFF	cc_nr,cnc17		; -noerrors
	IFF	cc_nx,cnc18		; -noexecute
	IFF	cc_nf,cnc19		; -nofail
	IFF	cc_nl,cnc20		; -nolist
	IFF	cc_no,cnc21		; -noopt
	IFF	cc_np,cnc22		; -noprint
	IFF	cc_op,cnc24		; -optimise
	IFF	cc_pr,cnc25		; -print
	IFF	cc_si,cnc27		; -single
	IFF	cc_sp,cnc28		; -space
	IFF	cc_st,cnc31		; -stitle
	IFF	cc_ti,cnc32		; -title
	IFF	cc_tr,cnc36		; -trace
	ESW				; end switch
;
;      not matched yet. align std names ptr and try again
;
cnc05	ICA	XR			; bump standard names ptr
	BCT	WA,cnc05		; loop
	ICV	WB			; bump names offset
	BCT	WC,cnc02		; continue if more names
.IF    .cicc
	BRN	cnc08			; ignore unrecognized control card
.FI
;
;      invalid control card name
;
cnc06	ERB	247,invalid control statement
;
;      special processing for -inxxx
;
cnc07	LCH	WA,(XR)+		; get next char
.IF    .culc
	FLC	WA			; fold to lower case
.FI
	BNE	WA,=ch_ln,cnc0a		; if not letter n
	LCH	WA,(XR)			; get third char
	BLT	WA,=ch_d0,cnc0a		; if not digit
	BGT	WA,=ch_d9,cnc0a		; if not digit
	ADD	scnpt,=num02		; bump offset past -in
	JSR	scane			; scan integer after -in
	MOV	-(XS),XR		; stack scanned item
	JSR	gtsmi			; check if integer
	PPM	cnc06			; fail if not integer
	PPM	cnc06			; fail if negative or large
	MOV	cswin,XR		; keep integer
	EJC
;
;      cncrd (continued)
;
;      check for more control cards before returning
;
cnc08	MOV	WA,scnpt		; preserve in case xeq time compile
	JSR	scane			; look for comma
	BEQ	XL,=t_cma,cnc01		; loop if comma found
	MOV	scnpt,WA		; restore scnpt in case xeq time
;
;      return point
;
cnc09	EXI				; return
;
;      -double
;
cnc10	MNZ	cswdb			; set switch
	BRN	cnc08			; merge
;
;      -dump
;      this is used for system debugging . it has the effect of
;      producing a core dump at compilation time
;
cnc11	JSR	sysdm			; call dumper
	BRN	cnc09			; finished
;
;      -eject
;
cnc12	BZE	cswls,cnc09		; return if -nolist
	JSR	prtps			; eject
	JSR	listt			; list title
	BRN	cnc09			; finished
;
;      -errors
;
cnc13	ZER	cswer			; clear switch
	BRN	cnc08			; merge
;
;      -execute
;
cnc14	ZER	cswex			; clear switch
	BRN	cnc08			; merge
;
;      -fail
;
cnc15	MNZ	cswfl			; set switch
	BRN	cnc08			; merge
;
;      -list
;
cnc16	MNZ	cswls			; set switch
	BEQ	stage,=stgic,cnc08	; done if compile time
;
;      list code line if execute time compile
;
	ZER	lstpf			; permit listing
	JSR	listr			; list line
	BRN	cnc08			; merge
	EJC
;
;      cncrd (continued)
;
;      -noerrors
;
cnc17	MNZ	cswer			; set switch
	BRN	cnc08			; merge
;
;      -noexecute
;
cnc18	MNZ	cswex			; set switch
	BRN	cnc08			; merge
;
;      -nofail
;
cnc19	ZER	cswfl			; clear switch
	BRN	cnc08			; merge
;
;      -nolist
;
cnc20	ZER	cswls			; clear switch
	BRN	cnc08			; merge
;
;      -nooptimise
;
cnc21	MNZ	cswno			; set switch
	BRN	cnc08			; merge
;
;      -noprint
;
cnc22	ZER	cswpr			; clear switch
	BRN	cnc08			; merge
;
;      -optimise
;
cnc24	ZER	cswno			; clear switch
	BRN	cnc08			; merge
;
;      -print
;
cnc25	MNZ	cswpr			; set switch
	BRN	cnc08			; merge
	EJC
;
;      cncrd (continued)
;
;      -single
;
cnc27	ZER	cswdb			; clear switch
	BRN	cnc08			; merge
;
;      -space
;
cnc28	BZE	cswls,cnc09		; return if -nolist
	JSR	scane			; scan integer after -space
	MOV	WC,=num01		; 1 space in case
	BEQ	XR,=t_smc,cnc29		; jump if no integer
	MOV	-(XS),XR		; stack it
	JSR	gtsmi			; check integer
	PPM	cnc06			; fail if not integer
	PPM	cnc06			; fail if negative or large
	BNZ	WC,cnc29		; jump if non zero
	MOV	WC,=num01		; else 1 space
;
;      merge with count of lines to skip
;
cnc29	ADD	lstlc,WC		; bump line count
	LCT	WC,WC			; convert to loop counter
	BLT	lstlc,lstnp,cnc30	; jump if fits on page
	JSR	prtps			; eject
	JSR	listt			; list title
	BRN	cnc09			; merge
;
;      skip lines
;
cnc30	JSR	prtnl			; print a blank
	BCT	WC,cnc30		; loop
	BRN	cnc09			; merge
	EJC
;
;      cncrd (continued)
;
;      -stitl
;
cnc31	MOV	cnr_t,=r_stl		; ptr to r_stl
	BRN	cnc33			; merge
;
;      -title
;
cnc32	MOV	r_stl,=nulls		; clear subtitle
	MOV	cnr_t,=r_ttl		; ptr to r_ttl
;
;      common processing for -title, -stitl
;
cnc33	MOV	XR,=nulls		; null in case needed
	MNZ	cnttl			; set flag for next listr call
	MOV	WB,=ccofs		; offset to title/subtitle
	MOV	WA,scnil		; input image length
	BLO	WA,WB,cnc34		; jump if no chars left
	SUB	WA,WB			; no of chars to eXTract
	MOV	XL,r_cim		; point to image
	JSR	sbstr			; get title/subtitle
;
;      store title/subtitle
;
cnc34	MOV	XL,cnr_t		; point to storage location
	MOV	(XL),XR			; store title/subtitle
	BEQ	XL,=r_stl,cnc09		; return if stitl
	BNZ	precl,cnc09		; return if eXTended listing
	BZE	prich,cnc09		; return if regular printer
	MOV	XL,sclen(XR)		; get length of title
	MOV	WA,XL			; copy it
	BZE	XL,cnc35		; jump if null
	ADD	XL,=num10		; increment
	BHI	XL,prlen,cnc09		; use default lstp0 val if too long
	ADD	WA,=num04		; point just past title
;
;      store offset to page nn message for short title
;
cnc35	MOV	lstpo,WA		; store offset
	BRN	cnc09			; return
;
;      -trace
;      provided for system debugging.  toggles the system label
;      trace switch at compile time
;
cnc36	JSR	systt			; toggle switch
	BRN	cnc08			; merge
.IF    .culc
;
;      -case
;      sets value of kvcas so that names are folded or not
;      during compilation.
;
cnc37	JSR	scane			; scan integer after -case
	ZER	WC			; get 0 in case none there
	BEQ	XL,=t_smc,cnc38		; skip if no integer
	MOV	-(XS),XR		; stack it
	JSR	gtsmi			; check integer
	PPM	cnc06			; fail if not integer
	PPM	cnc06			; fail if negative or too large
cnc38	MOV	kvcas,WC		; store new case value
	BRN	cnc09			; merge
.FI
.IF    .ccmc
;
;      -compare
;
;      sets value of kvcom so that string comparisons may
;      follow collation sequence determined by the interface.
;
cnc39	JSR	scane			; scan integer after -compare
	ZER	WC			; get 0 in case none there
	BEQ	XL,=t_smc,cnc40		; skip if no integer
	MOV	-(XS),XR		; stack it
	JSR	gtsmi			; check integer
	PPM	cnc06			; fail if not integer
	PPM	cnc06			; fail if negative or too large
cnc40	MOV	kvcom,WC		; store new compare value
	BRN	cnc09			; merge
.FI
.IF    .cinc
;
;      -include
;
cnc41	MNZ	scncc			; set flag for scane
	JSR	scane			; scan quoted file name
	ZER	scncc			; clear scane flag
	BNE	XL,=t_con,cnc06		; if not constant
	BNE	(XR),=b_scl,cnc06	; if not string constant
	MOV	r_ifn,XR		; save file name
	MOV	XL,r_inc		; examine include file name table
	ZER	WB			; lookup by value
	JSR	tfind			; do lookup
	PPM				; never fails
	BEQ	XR,=inton,cnc09		; ignore if already in table
	MNZ	WB			; set for trim
	MOV	XR,r_ifn		; file name
	JSR	trimr			; remove trailing blanks
	MOV	XL,r_inc		; include file name table
	MNZ	WB			; lookup by name this time
	JSR	tfind			; do lookup
	PPM				; never fails
	MOV	teval(XL),=inton	; make table value integer 1
	ICV	cnind			; increase nesting level
	MOV	WA,cnind		; load new nest level
	BGT	WA,=ccinm,cnc42		; fail if excessive nesting
.IF    .csfn
;
;      record the name and line number of the current input file
;
	MOV	XL,r_ifa		; array of nested file names
	ADD	WA,=vcvlb		; compute offset in words
	WTB	WA			; convert to bytes
	ADD	XL,WA			; point to element
	MOV	(XL),r_sfc		; record current file name
	MOV	XL,WA			; preserve nesting byte offset
	MTI	rdnln			; fetch source line number as integer
	JSR	icbld			; convert to icblk
	ADD	XL,r_ifl		; entry in nested line number array
	MOV	(XL),XR			; record in array
.FI
;
;      here to switch to include file named in r_ifn
;
	MOV	WA,cswin		; max read length
	MOV	XL,r_ifn		; include file name
	JSR	alocs			; get buffer for complete file name
	JSR	sysif			; open include file
	PPM	cnc43			; could not open
.IF    .csfn
;
;      make note of the complete file name for error messages
;
	ZER	WB			; do not trim trailing blanks
	JSR	trimr			; adjust scblk for actual length
	MOV	r_sfc,XR		; save ptr to file name
	MTI	cmpsn			; current statement as integer
	JSR	icbld			; build icblk for stmt number
	MOV	XL,r_sfn		; file name table
	MNZ	WB			; lookup statement number by name
	JSR	tfind			; allocate new teblk
	PPM				; always possible to allocate block
	MOV	teval(XL),r_sfc		; record file name as entry value
.ELSE
	MOV	dnamp,XR		; release allocated scblk
.FI
	ZER	rdnln			; restart line counter for new file
	BEQ	stage,=stgic,cnc09	; if initial compile
	BNE	cnind,=num01,cnc09	; if not first execute-time nesting
;
;      here for -include during execute-time compile
;
	MOV	r_ici,r_cim		; remember code argument string
	MOV	cnspt,scnpt		; save position in string
	MOV	cnsil,scnil		; and length of string
	BRN	cnc09			; all done, merge
;
;      here for excessive include file nesting
;
cnc42	ERB	284,excessively nested include files
;
;      here if include file could not be opened
;
cnc43	MOV	dnamp,XR		; release allocated scblk
	ERB	285,include file cannot be opened
;
.FI
.IF    .csln
;
;      -line n filename
;
cnc44	JSR	scane			; scan integer after -line
	BNE	XL,=t_con,cnc06		; jump if no line number
	BNE	(XR),=b_icl,cnc06	; jump if not integer
	LDI	icval(XR)		; fetch integer line number
	ILE	cnc06			; error if negative or zero
	BEQ	stage,=stgic,cnc45	; skip if initial compile
	MFI	cmpln			; set directly for other compiles
	BRN	cnc46			; no need to set rdnln
cnc45	SBI	intv1			; adjust number by one
	MFI	rdnln			; save line number
.IF    .csfn
cnc46	MNZ	scncc			; set flag for scane
	JSR	scane			; scan quoted file name
	ZER	scncc			; clear scane flag
	BEQ	XL,=t_smc,cnc47		; done if no file name
	BNE	XL,=t_con,cnc06		; error if not constant
	BNE	(XR),=b_scl,cnc06	; if not string constant
	JSR	newfn			; record new file name
	BRN	cnc09			; merge
;
;      here if file name not present
;
cnc47	DCV	scnpt			; set to rescan the terminator
	BRN	cnc09			; merge
.ELSE
cnc46	BRN	cnc09			; merge
.FI
.FI
	ENP				; end procedure cncrd
	EJC
.IF    .ceng
;
;      enevs -- evaluate string expression for engine
;
;      enevs is used by the eXTernal interface to evaluate a
;      string expression, typically for an engine wishing to
;      obtain the value of a vaRIAble or expression.
;
.IF    .cevb
;      (WB)		     0 if by value, 1 if by name
.FI
;      (XR)		     scblk for string to evaluate
;      jsr  enevs	     call to convert and evaluate
;      (XR)		     pointer to result
;			     = 0 if expression evaluation failed
;			     = 1 if conversion to expression failed
;
enevs	PRC	r,0			; entry point (recursive)
.IF    .cevb
	MOV	-(XS),WB		; save value/name flag
.FI
	JSR	gtexp			; convert to expression
	PPM	enev2			; conversion fails
.IF    .cevb
	MOV	WB,(XS)+		; recover value/name flag
.FI
	JSR	evalx			; evaluate expression by value
	PPM	enev1			; evaluation fails
	EXI
;
;      here if expression evaluation failed
;
enev1	ZER	XR			; return zero result
	EXI
;
;      here if conversion to expression failed
;
.IF    .cevb
enev2	ICA	XS			; discard value/name flag
	MOV	XR,=num01		; return integer one result
.ELSE
enev2	MOV	XR,=num01		; return integer one result
.FI
	EXI
	ENP
	EJC
;
;      engts -- get string for engine
;
;      engts is passed an object and returns a string with
;      any necessary conversions performed.
;
;      (XR)		     input argument
;      jsr  engts	     call to convert to string
;      (XR)		     pointer to resulting string
;			     =0 if conversion not possible
;
engts	PRC	e,0			; entry point
	MOV	-(XS),XR		; stack argument to convert
	JSR	gtstg			; convert to string
	PPM	engt1			; convert impossible
	EXI
;
;      here if unable to convert to string
;
engt1	ZER	XR			; return zero
	EXI
	ENP
	EJC
.FI
;
;      dffnc -- define function
;
;      dffnc is called whenever a new function is assigned to
;      a vaRIAble. it deals with eXTernal function use counts.
;
;      (XR)		     pointer to vrblk
;      (XL)		     pointer to new function block
;      jsr  dffnc	     call to define function
;      (wa,WB)		     destroyed
;
dffnc	PRC	e,0			; entry point
.IF    .cnld
.ELSE
	BNE	(XL),=b_efc,dffn1	; skip if new function not eXTernal
	ICV	efuse(XL)		; else increment its use count
;
;      here after dealing with new function use count
;
dffn1	MOV	WA,XR			; save vrblk pointer
	MOV	XR,vrfnc(XR)		; load old function pointer
	BNE	(XR),=b_efc,dffn2	; jump if old function not eXTernal
	MOV	WB,efuse(XR)		; else get use count
	DCV	WB			; decrement
	MOV	efuse(XR),WB		; store decremented value
	BNZ	WB,dffn2		; jump if use count still non-zero
	JSR	sysul			; else call system unload function
;
;      here after dealing with old function use count
;
dffn2	MOV	XR,WA			; restore vrblk pointer
.FI
	MOV	WA,XL			; copy function block ptr
	BLT	XR,=r_yyy,dffn3		; skip checks if opsyn op definition
	BNZ	vrlen(XR),dffn3		; jump if not system vaRIAble
;
;      for system vaRIAble, check for illegal redefinition
;
	MOV	XL,vrsvp(XR)		; point to svblk
	MOV	WB,svbit(XL)		; load bit indicators
	ANB	WB,btfnc		; is it a system function
	ZRB	WB,dffn3		; redef ok if not
	ERB	248,attempted redefinition of system function
;
;      here if redefinition is permitted
;
dffn3	MOV	vrfnc(XR),WA		; store new function pointer
	MOV	XL,WA			; restore function block pointer
	EXI				; return to dffnc caller
	ENP				; end procedure dffnc
	EJC
;
;      dtach -- detach i/o associated names
;
;      detaches trblks from i/o associated vaRIAbles, removes
;      entry from iochn chain attached to filearg1 vrblk and may
;      remove vrblk access and store traps.
;      input, output, terminal are handled specially.
;
;      (XL)		     i/o assoc. vbl name base ptr
;      (wa)		     offset to name
;      jsr  dtach	     call for detach operation
;      (XL,XR,WA,WB,WC)	     destroyed
;
dtach	PRC	e,0			; entry point
	MOV	dtcnb,XL		; store name base (gbcol not called)
	ADD	XL,WA			; point to name location
	MOV	dtcnm,XL		; store it
;
;      loop to search for i/o trblk
;
dtch1	MOV	XR,XL			; copy name pointer
;
;      continue after block deletion
;
dtch2	MOV	XL,(XL)			; point to next value
	BNE	(XL),=b_trt,dtch6	; jump at chain end
	MOV	WA,trtyp(XL)		; get trap block type
	BEQ	WA,=trtin,dtch3		; jump if input
	BEQ	WA,=trtou,dtch3		; jump if output
	ADD	XL,*trnxt		; point to next link
	BRN	dtch1			; loop
;
;      delete an old association
;
dtch3	MOV	(XR),trval(XL)		; delete trblk
	MOV	WA,XL			; dump XL ...
	MOV	WB,XR			; ... and XR
	MOV	XL,trtrf(XL)		; point to trtrf trap block
	BZE	XL,dtch5		; jump if no iochn
	BNE	(XL),=b_trt,dtch5	; jump if input, output, terminal
;
;      loop to search iochn chain for name ptr
;
dtch4	MOV	XR,XL			; remember link ptr
	MOV	XL,trtrf(XL)		; point to next link
	BZE	XL,dtch5		; jump if end of chain
	MOV	WC,ionmb(XL)		; get name base
	ADD	WC,ionmo(XL)		; add offset
	BNE	WC,dtcnm,dtch4		; loop if no match
	MOV	trtrf(XR),trtrf(XL)	; remove name from chain
	EJC
;
;      dtach (continued)
;
;      prepare to resume i/o trblk scan
;
dtch5	MOV	XL,WA			; recover XL ...
	MOV	XR,WB			; ... and XR
	ADD	XL,*trval		; point to value field
	BRN	dtch2			; continue
;
;      exit point
;
dtch6	MOV	XR,dtcnb		; possible vrblk ptr
	JSR	setvr			; reset vrblk if necessary
	EXI				; return
	ENP				; end procedure dtach
	EJC
;
;      dtype -- get datatype name
;
;      (XR)		     object whose datatype is required
;      jsr  dtype	     call to get datatype
;      (XR)		     result datatype
;
dtype	PRC	e,0			; entry point
	BEQ	(XR),=b_pdt,dtyp1	; jump if prog.defined
	MOV	XR,(XR)			; load type word
	LEI	XR			; get entry point id (block code)
	WTB	XR			; convert to byte offset
	MOV	XR,scnmt(XR)		; load table entry
	EXI				; exit to dtype caller
;
;      here if program defined
;
dtyp1	MOV	XR,pddfp(XR)		; point to dfblk
	MOV	XR,dfnam(XR)		; get datatype name from dfblk
	EXI				; return to dtype caller
	ENP				; end procedure dtype
	EJC
;
;      dumpr -- print dump of storage
;
;      (XR)		     dump argument (see below)
;      jsr  dumpr	     call to print dump
;      (XR,XL)		     destroyed
;      (wa,WB,WC,ra)	     destroyed
;
;      the dump argument has the following significance
;
;      dmarg = 0	     no dump printed
;      dmarg = 1	     partial dump (nat vars, keywords)
;      dmarg = 2	     full dump (arrays, tables, etc.)
;      dmarg = 3	     full dump + null vaRIAbles
;      dmarg ge 4	     core dump
;
;      since dumpr scrambles store, it is not permissible to
;      collect in mid-dump. hence a collect is done initially
;      and then if store runs out an error message is produced.
;
dumpr	PRC	e,0			; entry point
	BZE	XR,dmp28		; skip dump if argument is zero
	BGT	XR,=num03,dmp29		; jump if core dump required
	ZER	XL			; clear XL
	ZER	WB			; zero move offset
	MOV	dmarg,XR		; save dump argument
.IF    .csed
	ZER	dnams			; collect sediment too
.FI
	JSR	gbcol			; collect garbage
	JSR	prtpg			; eject printer
	MOV	XR,=dmhdv		; point to heading for vaRIAbles
	JSR	prtst			; print it
	JSR	prtnl			; terminate print line
	JSR	prtnl			; and print a blank line
;
;      first all natural vaRIAble blocks (vrblk) whose values
;      are non-null are linked in lexical order using dmvch as
;      the chain head and chaining through the vrget fields.
;      note that this scrambles store if the process is
;      interrupted before completion e.g. by exceeding time  or
;      print limits. since the subsequent core dumps and
;      failures if execution is resumed are very confusing, the
;      execution time error routine checks for this event and
;      attempts an unscramble. similar precautions should be
;      observed if translate time dumping is implemented.
;
	ZER	dmvch			; set null chain to start
	MOV	WA,hshtb		; point to hash table
;
;      loop through headers in hash table
;
dmp00	MOV	XR,WA			; copy hash bucket pointer
	ICA	WA			; bump pointer
	SUB	XR,*vrnxt		; set offset to merge
;
;      loop through vrblks on one chain
;
dmp01	MOV	XR,vrnxt(XR)		; point to next vrblk on chain
	BZE	XR,dmp09		; jump if end of this hash chain
	MOV	XL,XR			; else copy vrblk pointer
	EJC
;
;      dumpr (continued)
;
;      loop to find value and skip if null
;
dmp02	MOV	XL,vrval(XL)		; load value
	BEQ	dmarg,=num03,dmp2a	; skip null value check if dump(3)
	BEQ	XL,=nulls,dmp01		; loop for next vrblk if null value
dmp2a	BEQ	(XL),=b_trt,dmp02	; loop back if value is trapped
;
;      non-null value, prepare to search chain
;
	MOV	WC,XR			; save vrblk pointer
	ADD	XR,*vrsof		; adjust ptr to be like scblk ptr
	BNZ	sclen(XR),dmp03		; jump if non-system vaRIAble
	MOV	XR,vrsvo(XR)		; else load ptr to name in svblk
;
;      here with name pointer for new block in XR
;
dmp03	MOV	WB,XR			; save pointer to chars
	MOV	dmpsv,WA		; save hash bucket pointer
	MOV	WA,=dmvch		; point to chain head
;
;      loop to search chain for correct insertion point
;
dmp04	MOV	dmpch,WA		; save chain pointer
	MOV	XL,WA			; copy it
	MOV	XR,(XL)			; load pointer to next entry
	BZE	XR,dmp08		; jump if end of chain to insert
	ADD	XR,*vrsof		; else get name ptr for chained vrblk
	BNZ	sclen(XR),dmp05		; jump if not system vaRIAble
	MOV	XR,vrsvo(XR)		; else point to name in svblk
;
;      here prepare to compare the names
;
;      (wa)		     scratch
;      (WB)		     pointer to string of entering vrblk
;      (WC)		     pointer to entering vrblk
;      (XR)		     pointer to string of current block
;      (XL)		     scratch
;
dmp05	MOV	XL,WB			; point to entering vrblk string
	MOV	WA,sclen(XL)		; load its length
	PLC	XL			; point to chars of entering string
.IF    .ccmc
	MOV	dmpsb,WB		; save WB
	MOV	WB,sclen(XR)		; length of old string
	PLC	XR			; point to chars of old string
	JSR	syscm			; generalized lexical compare
	PPM	dmp06			; string too long, treat like eq
	PPM	dmp06			; entering string lt old string
	PPM	dmp07			; entering string gt old string
;
;      here when entering string le old string
;
dmp06	MOV	WB,dmpsb		; restore WB
	BRN	dmp08			; found insertion point
	EJC
;
;      dumpr (continued)
;
;      here we move out on the chain
;
dmp07	MOV	WB,dmpsb		; restore WB
	MOV	XL,dmpch		; copy chain pointer
.ELSE
	BHI	WA,sclen(XR),dmp06	; jump if entering length high
	PLC	XR			; else point to chars of old string
	CMC	dmp08,dmp07		; compare, insert if new is llt old
	BRN	dmp08			; or if leq (we had shorter length)
;
;      here when new length is longer than old length
;
dmp06	MOV	WA,sclen(XR)		; load shorter length
	PLC	XR			; point to chars of old string
	CMC	dmp08,dmp07		; compare, insert if new one low
	EJC
;
;      dumpr (continued)
;
;      here we move out on the chain
;
dmp07	MOV	XL,dmpch		; copy chain pointer
.FI
	MOV	WA,(XL)			; move to next entry on chain
	BRN	dmp04			; loop back
;
;      here after locating the proper insertion point
;
dmp08	MOV	XL,dmpch		; copy chain pointer
	MOV	WA,dmpsv		; restore hash bucket pointer
	MOV	XR,WC			; restore vrblk pointer
	MOV	vrget(XR),(XL)		; link vrblk to rest of chain
	MOV	(XL),XR			; link vrblk into current chain loc
	BRN	dmp01			; loop back for next vrblk
;
;      here after processing all vrblks on one chain
;
dmp09	BNE	WA,hshte,dmp00		; loop back if more buckets to go
;
;      loop to generate dump of natural vaRIAble values
;
dmp10	MOV	XR,dmvch		; load pointer to next entry on chain
	BZE	XR,dmp11		; jump if end of chain
	MOV	dmvch,(XR)		; else update chain ptr to next entry
	JSR	setvr			; restore vrget field
	MOV	XL,XR			; copy vrblk pointer (name base)
	MOV	WA,*vrval		; set offset for vrblk name
	JSR	prtnv			; print name = value
	BRN	dmp10			; loop back till all printed
;
;      prepare to print keywords
;
dmp11	JSR	prtnl			; print blank line
	JSR	prtnl			; and another
	MOV	XR,=dmhdk		; point to keyword heading
	JSR	prtst			; print heading
	JSR	prtnl			; end line
	JSR	prtnl			; print one blank line
	MOV	XL,=vdmkw		; point to list of keyword svblk ptrs
	EJC
;
;      dumpr (continued)
;
;      loop to dump keyword values
;
dmp12	MOV	XR,(XL)+		; load next svblk ptr from table
	BZE	XR,dmp13		; jump if end of list
.IF    .ccmk
	BEQ	XR,=num01,dmp12		; &compare ignored if not implemented
.FI
	MOV	WA,=ch_am		; load ampersand
	JSR	prtch			; print ampersand
	JSR	prtst			; print keyword name
	MOV	WA,svlen(XR)		; load name length from svblk
	CTB	WA,svchs		; get length of name
	ADD	XR,WA			; point to svknm field
	MOV	dmpkn,(XR)		; store in dummy kvblk
	MOV	XR,=tmbeb		; point to blank-equal-blank
	JSR	prtst			; print it
	MOV	dmpsv,XL		; save table pointer
	MOV	XL,=dmpkb		; point to dummy kvblk
	MOV	(XL),=b_kvt		; build type word
	MOV	kvvar(XL),=trbkv	; build ptr to dummy trace block
	MOV	WA,*kvvar		; set zero offset
	JSR	acess			; get keyword value
	PPM				; failure is impossible
	JSR	prtvl			; print keyword value
	JSR	prtnl			; terminate print line
	MOV	XL,dmpsv		; restore table pointer
	BRN	dmp12			; loop back till all printed
;
;      here after completing partial dump
;
dmp13	BEQ	dmarg,=num01,dmp27	; exit if partial dump complete
	MOV	XR,dnamb		; else point to first dynamic block
;
;      loop through blocks in dynamic storage
;
dmp14	BEQ	XR,dnamp,dmp27		; jump if end of used region
	MOV	WA,(XR)			; else load first word of block
	BEQ	WA,=b_vct,dmp16		; jump if vector
	BEQ	WA,=b_art,dmp17		; jump if array
	BEQ	WA,=b_pdt,dmp18		; jump if program defined
	BEQ	WA,=b_tbt,dmp19		; jump if table
.IF    .cnbf
.ELSE
	BEQ	WA,=b_bct,dmp30		; jump if buffer
.FI
;
;      merge here to move to next block
;
dmp15	JSR	blkln			; get length of block
	ADD	XR,WA			; point past this block
	BRN	dmp14			; loop back for next block
	EJC
;
;      dumpr (continued)
;
;      here for vector
;
dmp16	MOV	WB,*vcvls		; set offset to first value
	BRN	dmp19			; jump to merge
;
;      here for array
;
dmp17	MOV	WB,arofs(XR)		; set offset to arpro field
	ICA	WB			; bump to get offset to values
	BRN	dmp19			; jump to merge
;
;      here for program defined
;
dmp18	MOV	WB,*pdfld		; point to values, merge
;
;      here for table (others merge)
;
dmp19	BZE	idval(XR),dmp15		; ignore block if zero id value
	JSR	blkln			; else get block length
	MOV	XL,XR			; copy block pointer
	MOV	dmpsv,WA		; save length
	MOV	WA,WB			; copy offset to first value
	JSR	prtnl			; print blank line
	MOV	dmpsa,WA		; preserve offset
	JSR	prtvl			; print block value (for title)
	MOV	WA,dmpsa		; recover offset
	JSR	prtnl			; end print line
	BEQ	(XR),=b_tbt,dmp22	; jump if table
	DCA	WA			; point before first word
;
;      loop to print contents of array, vector, or program def
;
dmp20	MOV	XR,XL			; copy block pointer
	ICA	WA			; bump offset
	ADD	XR,WA			; point to next value
	BEQ	WA,dmpsv,dmp14		; exit if end (XR past block)
	SUB	XR,*vrval		; subtract offset to merge into loop
;
;      loop to find value and ignore nulls
;
dmp21	MOV	XR,vrval(XR)		; load next value
	BEQ	dmarg,=num03,dmp2b	; skip null value check if dump(3)
	BEQ	XR,=nulls,dmp20		; loop back if null value
dmp2b	BEQ	(XR),=b_trt,dmp21	; loop back if trapped
	JSR	prtnv			; else print name = value
	BRN	dmp20			; loop back for next field
	EJC
;
;      dumpr (continued)
;
;      here to dump a table
;
dmp22	MOV	WC,*tbbuk		; set offset to first bucket
	MOV	WA,*teval		; set name offset for all teblks
;
;      loop through table buckets
;
dmp23	MOV	-(XS),XL		; save tbblk pointer
	ADD	XL,WC			; point to next bucket header
	ICA	WC			; bump bucket offset
	SUB	XL,*tenxt		; subtract offset to merge into loop
;
;      loop to process teblks on one chain
;
dmp24	MOV	XL,tenxt(XL)		; point to next teblk
	BEQ	XL,(XS),dmp26		; jump if end of chain
	MOV	XR,XL			; else copy teblk pointer
;
;      loop to find value and ignore if null
;
dmp25	MOV	XR,teval(XR)		; load next value
	BEQ	XR,=nulls,dmp24		; ignore if null value
	BEQ	(XR),=b_trt,dmp25	; loop back if trapped
	MOV	dmpsv,WC		; else save offset pointer
	JSR	prtnv			; print name = value
	MOV	WC,dmpsv		; reload offset
	BRN	dmp24			; loop back for next teblk
;
;      here to move to next hash chain
;
dmp26	MOV	XL,(XS)+		; restore tbblk pointer
	BNE	WC,tblen(XL),dmp23	; loop back if more buckets to go
	MOV	XR,XL			; else copy table pointer
	ADD	XR,WC			; point to following block
	BRN	dmp14			; loop back to process next block
;
;      here after completing dump
;
dmp27	JSR	prtpg			; eject printer
;
;      merge here if no dump given (dmarg=0)
;
dmp28	EXI				; return to dump caller
;
;      call system core dump routine
;
dmp29	JSR	sysdm			; call it
	BRN	dmp28			; return
.IF    .cnbf
.ELSE
	EJC
;
;      dumpr (continued)
;
;      here to dump buffer block
;
dmp30	JSR	prtnl			; print blank line
	JSR	prtvl			; print value id for title
	JSR	prtnl			; force new line
	MOV	WA,=ch_dq		; load double quote
	JSR	prtch			; print it
	MOV	WC,bclen(XR)		; load defined length
	BZE	WC,dmp32		; skip characters if none
	LCT	WC,WC			; load count for loop
	MOV	WB,XR			; save bcblk ptr
	MOV	XR,bcbuf(XR)		; point to bfblk
	PLC	XR			; get set to load characters
;
;      loop here stuffing characters in output stream
;
dmp31	LCH	WA,(XR)+		; get next character
	JSR	prtch			; stuff it
	BCT	WC,dmp31		; branch for next one
	MOV	XR,WB			; restore bcblk pointer
;
;      merge to stuff closing quote mark
;
dmp32	MOV	WA,=ch_dq		; stuff quote
	JSR	prtch			; print it
	JSR	prtnl			; print new line
	MOV	WA,(XR)			; get first wd for blkln
	BRN	dmp15			; merge to get next block
.FI
	ENP				; end procedure dumpr
	EJC
;
;      ermsg -- print error code and error message
;
;      kvert		     error code
;      jsr  ermsg	     call to print message
;      (XR,XL,WA,WB,WC,ia)   destroyed
;
ermsg	PRC	e,0			; entry point
	MOV	WA,kvert		; load error code
	MOV	XR,=ermms		; point to error message /error/
	JSR	prtst			; print it
	JSR	ertex			; get error message teXT
	ADD	WA,=thsnd		; bump error code for print
	MTI	WA			; fail code in int acc
	MOV	WB,profs		; save current buffer position
	JSR	prtin			; print code (now have error1xxx)
	MOV	XL,prbuf		; point to print buffer
	PSC	XL,WB			; point to the 1
	MOV	WA,=ch_bl		; load a blank
	SCH	WA,(XL)			; store blank over 1 (error xxx)
	CSC	XL			; complete store characters
	ZER	XL			; clear garbage pointer in XL
	MOV	WA,XR			; keep error teXT
	MOV	XR,=ermns		; point to / -- /
	JSR	prtst			; print it
	MOV	XR,WA			; get error teXT again
	JSR	prtst			; print error message teXT
	JSR	prtis			; print line
	JSR	prtis			; print blank line
	EXI				; return to ermsg caller
	ENP				; end procedure ermsg
	EJC
;
;      ertex -- get error message teXT
;
;      (wa)		     error code
;      jsr  ertex	     call to get error teXT
;      (XR)		     ptr to error teXT in dynamic
;      (r_etx)		     copy of ptr to error teXT
;      (XL,WC,ia)	     destroyed
;
ertex	PRC	e,0			; entry point
	MOV	ertwa,WA		; save wa
	MOV	ertwb,WB		; save WB
	JSR	sysem			; get failure message teXT
	MOV	XL,XR			; copy pointer to it
	MOV	WA,sclen(XR)		; get length of string
	BZE	WA,ert02		; jump if null
	ZER	WB			; offset of zero
	JSR	sbstr			; copy into dynamic store
	MOV	r_etx,XR		; store for relocation
;
;      return
;
ert01	MOV	WB,ertwb		; restore WB
	MOV	WA,ertwa		; restore wa
	EXI				; return to caller
;
;      return errteXT contents instead of null
;
ert02	MOV	XR,r_etx		; get errteXT
	BRN	ert01			; return
	ENP
	EJC
;
;      evali -- evaluate integer argument
;
;      evali is used by pattern primitives len,tab,rtab,pos,rpos
;      when their argument is an expression value.
;
;      (XR)		     node pointer
;      (WB)		     cursor
;      jsr  evali	     call to evaluate integer
;      ppm  loc		     transfer loc for non-integer arg
;      ppm  loc		     transfer loc for out of range arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (XR)		     ptr to node with integer argument
;      (WC,XL,ra)	     destroyed
;
;      on return, the node pointed to has the integer argument
;      in parm1 and the proper successor pointer in pthen.
;      this allows merging with the normal (integer arg) case.
;
evali	PRC	r,4			; entry point (recursive)
	JSR	evalp			; evaluate expression
	PPM	evli1			; jump on failure
	MOV	-(XS),XL		; stack result for gtsmi
	MOV	XL,pthen(XR)		; load successor pointer
	MOV	evlio,XR		; save original node pointer
	MOV	evlif,WC		; zero if simple argument
	JSR	gtsmi			; convert arg to small integer
	PPM	evli2			; jump if not integer
	PPM	evli3			; jump if out of range
	MOV	evliv,XR		; store result in special dummy node
	MOV	XR,=evlin		; point to dummy node with result
	MOV	(XR),=p_len		; dummy pattern block pcode
	MOV	pthen(XR),XL		; store successor pointer
	EXI	4			; take successful exit
;
;      here if evaluation fails
;
evli1	EXI	3			; take failure return
;
;      here if argument is not integer
;
evli2	EXI	1			; take non-integer error exit
;
;      here if argument is out of range
;
evli3	EXI	2			; take out-of-range error exit
	ENP				; end procedure evali
	EJC
;
;      evalp -- evaluate expression during pattern match
;
;      evalp is used to evaluate an expression (by value) during
;      a pattern match. the effect is like evalx, but pattern
;      vaRIAbles are stacked and restored if necessary.
;
;      evalp also differs from evalx in that if the result is
;      an expression it is reevaluated. this occurs repeatedly.
;
;      to support optimization of pos and rpos, evalp uses WC
;      to signal the caller for the case of a simple vrblk
;      that is not an expression and is not trapped.  because
;      this case cannot have any side effects, optimization is
;      possible.
;
;      (XR)		     node pointer
;      (WB)		     pattern match cursor
;      jsr  evalp	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (XL)		     result
;      (wa)		     first word of result block
;      (WC)		     zero if simple vrblk, else non-zero
;      (XR,WB)		     destroyed (failure case only)
;      (RA)		     destroyed
;
;      the expression pointer is stored in parm1 of the node
;
;      control returns to failp on failure of evaluation
;
evalp	PRC	r,1			; entry point (recursive)
	MOV	XL,parm1(XR)		; load expression pointer
	BEQ	(XL),=b_exl,evlp1	; jump if exblk case
;
;      here for case of seblk
;
;      we can give a fast return if the value of the vrblk is
;      not an expression and is not trapped.
;
	MOV	XL,sevar(XL)		; load vrblk pointer
	MOV	XL,vrval(XL)		; load value of vrblk
	MOV	WA,(XL)			; load first word of value
	BHI	WA,=b_t__,evlp3		; jump if not seblk, trblk or exblk
;
;      here for exblk or seblk with expr value or trapped value
;
evlp1	CHK				; check for stack space
	MOV	-(XS),XR		; stack node pointer
	MOV	-(XS),WB		; stack cursor
	MOV	-(XS),r_pms		; stack subject string pointer
	MOV	-(XS),pmssl		; stack subject string length
	MOV	-(XS),pmdfl		; stack dot flag
	MOV	-(XS),pmhbs		; stack history stack base pointer
	MOV	XR,parm1(XR)		; load expression pointer
	EJC
;
;      evalp (continued)
;
;      loop back here to reevaluate expression result
;
evlp2	ZER	WB			; set flag for by value
	JSR	evalx			; evaluate expression
	PPM	evlp4			; jump on failure
	MOV	WA,(XR)			; else load first word of value
	BLO	WA,=b_e__,evlp2		; loop back to reevaluate expression
;
;      here to restore pattern values after successful eval
;
	MOV	XL,XR			; copy result pointer
	MOV	pmhbs,(XS)+		; restore history stack base pointer
	MOV	pmdfl,(XS)+		; restore dot flag
	MOV	pmssl,(XS)+		; restore subject string length
	MOV	r_pms,(XS)+		; restore subject string pointer
	MOV	WB,(XS)+		; restore cursor
	MOV	XR,(XS)+		; restore node pointer
	MOV	WC,XR			; non-zero for simple vrblk
	EXI				; return to evalp caller
;
;      here to return after simple vrblk case
;
evlp3	ZER	WC			; simple vrblk, no side effects
	EXI				; return to evalp caller
;
;      here for failure during evaluation
;
evlp4	MOV	pmhbs,(XS)+		; restore history stack base pointer
	MOV	pmdfl,(XS)+		; restore dot flag
	MOV	pmssl,(XS)+		; restore subject string length
	MOV	r_pms,(XS)+		; restore subject string pointer
	ADD	XS,*num02		; remove node ptr, cursor
	EXI	1			; take failure exit
	ENP				; end procedure evalp
	EJC
;
;      evals -- evaluate string argument
;
;      evals is used by span, any, notany, break, breakx when
;      they are passed an expression argument.
;
;      (XR)		     node pointer
;      (WB)		     cursor
;      jsr  evals	     call to evaluate string
;      ppm  loc		     transfer loc for non-string arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (XR)		     ptr to node with parms set
;      (XL,WC,ra)	     destroyed
;
;      on return, the node pointed to has a character table
;      pointer in parm1 and a bit mask in parm2. the proper
;      successor is stored in pthen of this node. thus it is
;      ok for merging with the normal (multi-char string) case.
;
evals	PRC	r,3			; entry point (recursive)
	JSR	evalp			; evaluate expression
	PPM	evls1			; jump if evaluation fails
	MOV	-(XS),pthen(XR)		; save successor pointer
	MOV	-(XS),WB		; save cursor
	MOV	-(XS),XL		; stack result ptr for patst
	ZER	WB			; dummy pcode for one char string
	ZER	WC			; dummy pcode for expression arg
	MOV	XL,=p_brk		; appropriate pcode for our use
	JSR	patst			; call routine to build node
	PPM	evls2			; jump if not string
	MOV	WB,(XS)+		; restore cursor
	MOV	pthen(XR),(XS)+		; store successor pointer
	EXI	3			; take success return
;
;      here if evaluation fails
;
evls1	EXI	2			; take failure return
;
;      here if argument is not string
;
evls2	ADD	XS,*num02		; pop successor and cursor
	EXI	1			; take non-string error exit
	ENP				; end procedure evals
	EJC
;
;      evalx -- evaluate expression
;
;      evalx is called to evaluate an expression
;
;      (XR)		     pointer to exblk or seblk
;      (WB)		     0 if by value, 1 if by name
;      jsr  evalx	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (XR)		     result if called by value
;      (XL,WA)		     result name base,offset if by name
;      (XR)		     destroyed (name case only)
;      (XL,WA)		     destroyed (value case only)
;      (WB,WC,ra)	     destroyed
;
evalx	PRC	r,1			; entry point, recursive
	BEQ	(XR),=b_exl,evlx2	; jump if exblk case
;
;      here for seblk
;
	MOV	XL,sevar(XR)		; load vrblk pointer (name base)
	MOV	WA,*vrval		; set name offset
	BNZ	WB,evlx1		; jump if called by name
	JSR	acess			; call routine to access value
	PPM	evlx9			; jump if failure on access
;
;      merge here to exit for seblk case
;
evlx1	EXI				; return to evalx caller
	EJC
;
;      evalx (continued)
;
;      here for full expression (exblk) case
;
;      if an error occurs in the expression code at execution
;      time, control is passed via error section to exfal
;      without returning to this routine.
;      the following entries are made on the stack before
;      giving control to the expression code
;
;			     evalx return point
;			     saved value of r_cod
;			     code pointer (-r_cod)
;			     saved value of flptr
;			     0 if by value, 1 if by name
;      flptr --------------- *exflc, fail offset in exblk
;
evlx2	SCP	WC			; get code pointer
	MOV	WA,r_cod		; load code block pointer
	SUB	WC,WA			; get code pointer as offset
	MOV	-(XS),WA		; stack old code block pointer
	MOV	-(XS),WC		; stack relative code offset
	MOV	-(XS),flptr		; stack old failure pointer
	MOV	-(XS),WB		; stack name/value indicator
	MOV	-(XS),*exflc		; stack new fail offset
	MOV	gtcef,flptr		; keep in case of error
	MOV	r_gtc,r_cod		; keep code block pointer similarly
	MOV	flptr,XS		; set new failure pointer
	MOV	r_cod,XR		; set new code block pointer
	MOV	eXStm(XR),kvstn		; remember stmnt number
	ADD	XR,*excod		; point to first code word
	LCP	XR			; set code pointer
	BNE	stage,=stgxt,evlx0	; jump if not execution time
	MOV	stage,=stgee		; evaluating expression
;
;      here to execute first code word of expression
;
evlx0	ZER	XL			; clear garbage XL
	LCW	XR			; load first code word
	BRI	(XR)			; execute it
	EJC
;
;      evalx (continued)
;
;      come here if successful return by value (see o_rvl)
;
evlx3	MOV	XR,(XS)+		; load value
	BZE	num01(XS),evlx5		; jump if called by value
	ERB	249,expression evaluated by name returned value
;
;      here for expression returning by name (see o_rnm)
;
evlx4	MOV	WA,(XS)+		; load name offset
	MOV	XL,(XS)+		; load name base
	BNZ	num01(XS),evlx5		; jump if called by name
	JSR	acess			; else access value first
	PPM	evlx6			; jump if failure during access
;
;      here after loading correct result into XR or XL,WA
;
evlx5	ZER	WB			; note successful
	BRN	evlx7			; merge
;
;      here for failure in expression evaluation (see o_fex)
;
evlx6	MNZ	WB			; note unsuccessful
;
;      restore environment
;
evlx7	BNE	stage,=stgee,evlx8	; skip if was not previously XT
	MOV	stage,=stgxt		; execute time
;
;      merge with stage set up
;
evlx8	ADD	XS,*num02		; pop name/value indicator, *exfal
	MOV	flptr,(XS)+		; restore old failure pointer
	MOV	WC,(XS)+		; load code offset
	ADD	WC,(XS)			; make code pointer absolute
	MOV	r_cod,(XS)+		; restore old code block pointer
	LCP	WC			; restore old code pointer
	BZE	WB,evlx1		; jump for successful return
;
;      merge here for failure in seblk case
;
evlx9	EXI	1			; take failure exit
	ENP				; end of procedure evalx
	EJC
;
;      exbld -- build exblk
;
;      exbld is used to build an expression block from the
;      code compiled most recently in the current ccblk.
;
;      (XL)		     offset in ccblk to start of code
;      (WB)		     integer in range 0 le n le mxlen
;      jsr  exbld	     call to build exblk
;      (XR)		     ptr to constructed exblk
;      (wa,WB,XL)	     destroyed
;
exbld	PRC	e,0			; entry point
	MOV	WA,XL			; copy offset to start of code
	SUB	WA,*excod		; calc reduction in offset in exblk
	MOV	-(XS),WA		; stack for later
	MOV	WA,cwcof		; load final offset
	SUB	WA,XL			; compute length of code
	ADD	WA,*exsi_		; add space for standard fields
	JSR	alloc			; allocate space for exblk
	MOV	-(XS),XR		; save pointer to exblk
	MOV	extyp(XR),=b_exl	; store type word
	ZER	eXStm(XR)		; zeroise stmnt number field
.IF    .csln
	MOV	eXSln(XR),cmpln		; set line number field
.FI
	MOV	exlen(XR),WA		; store length
	MOV	exflc(XR),=ofex_	; store failure word
	ADD	XR,*exsi_		; set XR for mvw
	MOV	cwcof,XL		; reset offset to start of code
	ADD	XL,r_ccb		; point to start of code
	SUB	WA,*exsi_		; length of code to move
	MOV	-(XS),WA		; stack length of code
	MVW				; move code to exblk
	MOV	WA,(XS)+		; get length of code
	BTW	WA			; convert byte count to word count
	LCT	WA,WA			; prepare counter for loop
	MOV	XL,(XS)			; copy exblk ptr, dont unstack
	ADD	XL,*excod		; point to code itself
	MOV	WB,num01(XS)		; get reduction in offset
;
;      this loop searches for negation and selection code so
;      that the offsets computed whilst code was in code block
;      can be transformed to reduced values applicable in an
;      exblk.
;
exbl1	MOV	XR,(XL)+		; get next code word
	BEQ	XR,=osla_,exbl3		; jump if selection found
	BEQ	XR,=onta_,exbl3		; jump if negation found
	BCT	WA,exbl1		; loop to end of code
;
;      no selection found or merge to exit on termination
;
exbl2	MOV	XR,(XS)+		; pop exblk ptr into XR
	MOV	XL,(XS)+		; pop reduction constant
	EXI				; return to caller
	EJC
;
;      exbld (continued)
;
;      selection or negation found
;      reduce the offsets as needed. offsets occur in words
;      following code words -
;	    =onta_, =osla_, =oslb_, =oslc_
;
exbl3	SUB	(XL)+,WB		; adjust offset
	BCT	WA,exbl4		; decrement count
;
exbl4	BCT	WA,exbl5		; decrement count
;
;      continue search for more offsets
;
exbl5	MOV	XR,(XL)+		; get next code word
	BEQ	XR,=osla_,exbl3		; jump if offset found
	BEQ	XR,=oslb_,exbl3		; jump if offset found
	BEQ	XR,=oslc_,exbl3		; jump if offset found
	BEQ	XR,=onta_,exbl3		; jump if offset found
	BCT	WA,exbl5		; loop
	BRN	exbl2			; merge to return
	ENP				; end procedure exbld
	EJC
;
;      expan -- analyze expression
;
;      the expression analyzer (expan) procedure is used to scan
;      an expression and convert it into a tree representation.
;      see the description of cmblk in the structures section
;      for detailed format of tree blocks.
;
;      the analyzer uses a simple precedence scheme in which
;      operands and operators are placed on a single stack
;      and condensations are made when low precedence operators
;      are stacked after a higher precedence operator. a global
;      vaRIAble (in WB) keeps track of the level as follows.
;
;      0    scanning outer level of statement or expression
;      1    scanning outer level of normal goto
;      2    scanning outer level of direct goto
;      3    scanning inside array brackets
;      4    scanning inside grouping parentheses
;      5    scanning inside function parentheses
;
;      this vaRIAble is saved on the stack on encountering a
;      grouping and restored at the end of the grouping.
;
;      another global vaRIAble (in WC) counts the number of
;      items at one grouping level and is incremented for each
;      comma encountered. it is stacked with the level indicator
;
;      the scan is controlled by a three state finite machine.
;      a global vaRIAble stored in wa is the current state.
;
;      wa=0		     nothing scanned at this level
;      wa=1		     operand expected
;      wa=2		     operator expected
;
;      (WB)		     call type (see below)
;      jsr  expan	     call to analyze expression
;      (XR)		     pointer to resulting tree
;      (XL,WA,WB,WC,ra)	     destroyed
;
;      the entry value of WB indicates the call type as follows.
;
;      0    scanning either the main body of a statement or the
;	    teXT of an expression (from eval call). valid
;	    terminators are colon, semicolon. the rescan flag is
;	    set to return the terminator on the next scane call.
;
;      1    scanning a normal goto. the only valid
;	    terminator is a right paren.
;
;      2    scanning a direct goto. the only valid
;	    terminator is a right bracket.
	EJC
;
;      expan (continued)
;
;      entry point
;
expan	PRC	e,0			; entry point
	ZER	-(XS)			; set top of stack indicator
	ZER	WA			; set initial state to zero
	ZER	WC			; zero counter value
;
;      loop here for successive entries
;
exp01	JSR	scane			; scan next element
	ADD	XL,WA			; add state to syntax code
	BSW	XL,t_nes		; switch on element type/state
	IFF	t_va0,exp03		; vaRIAble, s=0
	IFF	t_va1,exp03		; vaRIAble, state one
	IFF	t_va2,exp04		; vaRIAble, s=2
	IFF	t_co0,exp03		; constant, s=0
	IFF	t_co1,exp03		; constant, s=1
	IFF	t_co2,exp04		; constant, s=2
	IFF	t_lp0,exp06		; left paren, s=0
	IFF	t_lp1,exp06		; left paren, s=1
	IFF	t_lp2,exp04		; left paren, s=2
	IFF	t_fn0,exp10		; function, s=0
	IFF	t_fn1,exp10		; function, s=1
	IFF	t_fn2,exp04		; function, s=2
	IFF	t_rp0,exp02		; right paren, s=0
	IFF	t_rp1,exp05		; right paren, s=1
	IFF	t_rp2,exp12		; right paren, s=2
	IFF	t_lb0,exp08		; left brkt, s=0
	IFF	t_lb1,exp08		; left brkt, s=1
	IFF	t_lb2,exp09		; left brkt, s=2
	IFF	t_rb0,exp02		; right brkt, s=0
	IFF	t_rb1,exp05		; right brkt, s=1
	IFF	t_rb2,exp18		; right brkt, s=2
	IFF	t_uo0,exp27		; unop, s=0
	IFF	t_uo1,exp27		; unop, s=1
	IFF	t_uo2,exp04		; unop, s=2
	IFF	t_bo0,exp05		; binop, s=0
	IFF	t_bo1,exp05		; binop, s=1
	IFF	t_bo2,exp26		; binop, s=2
	IFF	t_cm0,exp02		; comma, s=0
	IFF	t_cm1,exp05		; comma, s=1
	IFF	t_cm2,exp11		; comma, s=2
	IFF	t_cl0,exp02		; colon, s=0
	IFF	t_cl1,exp05		; colon, s=1
	IFF	t_cl2,exp19		; colon, s=2
	IFF	t_sm0,exp02		; semicolon, s=0
	IFF	t_sm1,exp05		; semicolon, s=1
	IFF	t_sm2,exp19		; semicolon, s=2
	ESW				; end switch on element type/state
	EJC
;
;      expan (continued)
;
;      here for rbr,rpr,col,smc,cma in state 0
;
;      set to rescan the terminator encountered and create
;      a null constant (case of omitted null)
;
exp02	MNZ	scnrs			; set to rescan element
	MOV	XR,=nulls		; point to null, merge
;
;      here for var or con in states 0,1
;
;      stack the vaRIAble/constant and set state=2
;
exp03	MOV	-(XS),XR		; stack pointer to operand
	MOV	WA,=num02		; set state 2
	BRN	exp01			; jump for next element
;
;      here for var,con,lpr,fnc,uop in state 2
;
;      we rescan the element and create a concatenation operator
;      this is the case of the blank concatenation operator.
;
exp04	MNZ	scnrs			; set to rescan element
	MOV	XR,=opdvc		; point to concat operator dv
	BZE	WB,exp4a		; ok if at top level
	MOV	XR,=opdvp		; else point to unmistakable concat.
;
;      merge here when XR set up with proper concatenation dvblk
;
exp4a	BNZ	scnbl,exp26		; merge bop if blanks, else error
;      dcv  scnse	     adjust start of element location
	ERB	220,syntax error: missing operator
;
;      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
;
;      this is an erronous contruction
;

;exp05 dcv  scnse	     adjust start of element location
exp05	ERB	221,syntax error: missing operand
;
;      here for lpr (s=0,1)
;
exp06	MOV	XL,=num04		; set new level indicator
	ZER	XR			; set zero value for cmopn
	EJC
;
;      expan (continued)
;
;      merge here to store old level on stack and start new one
;
exp07	MOV	-(XS),XR		; stack cmopn value
	MOV	-(XS),WC		; stack old counter
	MOV	-(XS),WB		; stack old level indicator
	CHK				; check for stack overflow
	ZER	WA			; set new state to zero
	MOV	WB,XL			; set new level indicator
	MOV	WC,=num01		; initialize new counter
	BRN	exp01			; jump to scan next element
;
;      here for lbr (s=0,1)
;
;      this is an illegal use of left bracket
;
exp08	ERB	222,syntax error: invalid use of left bracket
;
;      here for lbr (s=2)
;
;      set new level and start to scan subscripts
;
exp09	MOV	XR,(XS)+		; load array ptr for cmopn
	MOV	XL,=num03		; set new level indicator
	BRN	exp07			; jump to stack old and start new
;
;      here for fnc (s=0,1)
;
;      stack old level and start to scan arguments
;
exp10	MOV	XL,=num05		; set new lev indic (XR=vrblk=cmopn)
	BRN	exp07			; jump to stack old and start new
;
;      here for cma (s=2)
;
;      increment argument count and continue
;
exp11	ICV	WC			; increment counter
	JSR	expdm			; dump operators at this level
	ZER	-(XS)			; set new level for parameter
	ZER	WA			; set new state
	BGT	WB,=num02,exp01		; loop back unless outer level
	ERB	223,syntax error: invalid use of comma
	EJC
;
;      expan (continued)
;
;      here for rpr (s=2)
;
;      at outer level in a normal goto this is a terminator
;      otherwise it must terminate a function or grouping
;
exp12	BEQ	WB,=num01,exp20		; end of normal goto
	BEQ	WB,=num05,exp13		; end of function arguments
	BEQ	WB,=num04,exp14		; end of grouping / selection
	ERB	224,syntax error: unbalanced right parenthesis
;
;      here at end of function arguments
;
exp13	MOV	XL,=c_fnc		; set cmtyp value for function
	BRN	exp15			; jump to build cmblk
;
;      here for end of grouping
;
exp14	BEQ	WC,=num01,exp17		; jump if end of grouping
	MOV	XL,=c_sel		; else set cmtyp for selection
;
;      merge here to build cmblk for level just scanned and
;      to pop up to the previous scan level before continuing.
;
exp15	JSR	expdm			; dump operators at this level
	MOV	WA,WC			; copy count
	ADD	WA,=cmvls		; add for standard fields at start
	WTB	WA			; convert length to bytes
	JSR	alloc			; allocate space for cmblk
	MOV	(XR),=b_cmt		; store type code for cmblk
	MOV	cmtyp(XR),XL		; store cmblk node type indicator
	MOV	cmlen(XR),WA		; store length
	ADD	XR,WA			; point past end of block
	LCT	WC,WC			; set loop counter
;
;      loop to move remaining words to cmblk
;
exp16	MOV	-(XR),(XS)+		; move one operand ptr from stack
	MOV	WB,(XS)+		; pop to old level indicator
	BCT	WC,exp16		; loop till all moved
	EJC
;
;      expan (continued)
;
;      complete cmblk and stack pointer to it on stack
;
	SUB	XR,*cmvls		; point back to start of block
	MOV	WC,(XS)+		; restore old counter
	MOV	cmopn(XR),(XS)		; store operand ptr in cmblk
	MOV	(XS),XR			; stack cmblk pointer
	MOV	WA,=num02		; set new state
	BRN	exp01			; back for next element
;
;      here at end of a parenthesized expression
;
exp17	JSR	expdm			; dump operators at this level
	MOV	XR,(XS)+		; restore XR
	MOV	WB,(XS)+		; restore outer level
	MOV	WC,(XS)+		; restore outer count
	MOV	(XS),XR			; store opnd over unused cmopn val
	MOV	WA,=num02		; set new state
	BRN	exp01			; back for next ele8ent
;
;      here for rbr (s=2)
;
;      at outer level in a direct goto, this is a terminator.
;      otherwise it must terminate a subscript list.
;
exp18	MOV	XL,=c_arr		; set cmtyp for array reference
	BEQ	WB,=num03,exp15		; jump to build cmblk if end arrayref
	BEQ	WB,=num02,exp20		; jump if end of direct goto
	ERB	225,syntax error: unbalanced right bracket
	EJC
;
;      expan (continued)
;
;      here for col,smc (s=2)
;
;      error unless terminating statement body at outer level
;
exp19	MNZ	scnrs			; rescan terminator
	MOV	XL,WB			; copy level indicator
	BSW	XL,6			; switch on level indicator
	IFF	0,exp20			; normal outer level
	IFF	1,exp22			; fail if normal goto
	IFF	2,exp23			; fail if direct goto
	IFF	3,exp24			; fail array brackets
	IFF	4,exp21			; fail if in grouping
	IFF	5,exp21			; fail function args
	ESW				; end switch on level
;
;      here at normal end of expression
;
exp20	JSR	expdm			; dump remaining operators
	MOV	XR,(XS)+		; load tree pointer
	ICA	XS			; pop off bottom of stack marker
	EXI				; return to expan caller
;
;      missing right paren
;
exp21	ERB	226,syntax error: missing right paren
;
;      missing right paren in goto field
;
exp22	ERB	227,syntax error: right paren missing from goto
;
;      missing bracket in goto
;
exp23	ERB	228,syntax error: right bracket missing from goto
;
;      missing array bracket
;
exp24	ERB	229,syntax error: missing right array bracket
	EJC
;
;      expan (continued)
;
;      loop here when an operator causes an operator dump
;
exp25	MOV	expsv,XR		;
	JSR	expop			; pop one operator
	MOV	XR,expsv		; restore op dv pointer and merge
;
;      here for bop (s=2)
;
;      remove operators (condense) from stack until no more
;      left at this level or top one has lower precedence.
;      loop here till this condition is met.
;
exp26	MOV	XL,num01(XS)		; load operator dvptr from stack
	BLE	XL,=num05,exp27		; jump if bottom of stack level
	BLT	dvrpr(XR),dvlpr(XL),exp25; else pop if new prec is lo
;
;      here for uop (s=0,1)
;
;      binary operator merges after precedence check
;
;      the operator dv is stored on the stack and the scan
;      continues after setting the scan state to one.
;
exp27	MOV	-(XS),XR		; stack operator dvptr on stack
	CHK				; check for stack overflow
	MOV	WA,=num01		; set new state
	BNE	XR,=opdvs,exp01		; back for next element unless =
;
;      here for special case of binary =. the syntax allows a
;      null right argument for this operator to be left
;      out. accordingly we reset to state zero to get proper
;      action on a terminator (supply a null constant).
;
	ZER	WA			; set state zero
	BRN	exp01			; jump for next element
	ENP				; end procedure expan
	EJC
;
;      expap -- test for pattern match tree
;
;      expap is passed an expression tree to determine if it
;      is a pattern match. the following are recogized as
;      matches in the conteXT of this call.
;
;      1)   an explicit use of binary question mark
;      2)   a concatenation
;      3)   an alternation whose left operand is a concatenation
;
;      (XR)		     ptr to expan tree
;      jsr  expap	     call to test for pattern match
;      ppm  loc		     transfer loc if not a pattern match
;      (wa)		     destroyed
;      (XR)		     unchanged (if not match)
;      (XR)		     ptr to binary operator blk if match
;
expap	PRC	e,1			; entry point
	MOV	-(XS),XL		; save XL
	BNE	(XR),=b_cmt,expp2	; no match if not complex
	MOV	WA,cmtyp(XR)		; else load type code
	BEQ	WA,=c_cnc,expp1		; concatenation is a match
	BEQ	WA,=c_pmt,expp1		; binary question mark is a match
	BNE	WA,=c_alt,expp2		; else not match unless alternation
;
;      here for alternation. change (a b) / c to a qm (b / c)
;
	MOV	XL,cmlop(XR)		; load left operand pointer
	BNE	(XL),=b_cmt,expp2	; not match if left opnd not complex
	BNE	cmtyp(XL),=c_cnc,expp2	; not match if left op not conc
	MOV	cmlop(XR),cmrop(XL)	; XR points to (b / c)
	MOV	cmrop(XL),XR		; set XL opnds to a, (b / c)
	MOV	XR,XL			; point to this altered node
;
;      exit here for pattern match
;
expp1	MOV	XL,(XS)+		; restore entry XL
	EXI				; give pattern match return
;
;      exit here if not pattern match
;
expp2	MOV	XL,(XS)+		; restore entry XL
	EXI	1			; give non-match return
	ENP				; end procedure expap
	EJC
;
;      expdm -- dump operators at current level (for expan)
;
;      expdm uses expop to condense all operators at this syntax
;      level. the stack bottom is recognized from the level
;      value which is saved on the top of the stack.
;
;      jsr  expdm	     call to dump operators
;      (XS)		     popped as required
;      (XR,WA)		     destroyed
;
expdm	PRC	n,0			; entry point
	MOV	r_exs,XL		; save XL value
;
;      loop to dump operators
;
exdm1	BLE	num01(XS),=num05,exdm2	; jump if stack bottom (saved level
	JSR	expop			; else pop one operator
	BRN	exdm1			; and loop back
;
;      here after popping all operators
;
exdm2	MOV	XL,r_exs		; restore XL
	ZER	r_exs			; release save location
	EXI				; return to expdm caller
	ENP				; end procedure expdm
	EJC
;
;      expop-- pop operator (for expan)
;
;      expop is used by the expan routine to condense one
;      operator from the top of the syntax stack. an appropriate
;      cmblk is built for the operator (unary or binary) and a
;      pointer to this cmblk is stacked.
;
;      expop is also used by scngf (goto field scan) procedure
;
;      jsr  expop	     call to pop operator
;      (XS)		     popped appropriately
;      (XR,XL,WA)	     destroyed
;
expop	PRC	n,0			; entry point
	MOV	XR,num01(XS)		; load operator dv pointer
	BEQ	dvlpr(XR),=lluno,expo2	; jump if unary
;
;      here for binary operator
;
	MOV	WA,*cmbs_		; set size of binary operator cmblk
	JSR	alloc			; allocate space for cmblk
	MOV	cmrop(XR),(XS)+		; pop and store right operand ptr
	MOV	XL,(XS)+		; pop and load operator dv ptr
	MOV	cmlop(XR),(XS)		; store left operand pointer
;
;      common exit point
;
expo1	MOV	(XR),=b_cmt		; store type code for cmblk
	MOV	cmtyp(XR),dvtyp(XL)	; store cmblk node type code
	MOV	cmopn(XR),XL		; store dvptr (=ptr to dac o_xxx)
	MOV	cmlen(XR),WA		; store cmblk length
	MOV	(XS),XR			; store resulting node ptr on stack
	EXI				; return to expop caller
;
;      here for unary operator
;
expo2	MOV	WA,*cmus_		; set size of unary operator cmblk
	JSR	alloc			; allocate space for cmblk
	MOV	cmrop(XR),(XS)+		; pop and store operand pointer
	MOV	XL,(XS)			; load operator dv pointer
	BRN	expo1			; merge back to exit
	ENP				; end procedure expop
	EJC
.IF    .csfn
;
;      filnm -- obtain file name from statement number
;
;      filnm takes a statement number and examines the file name
;      table pointed to by r_sfn to find the name of the file
;      containing the given statement.	table entries are
;      arranged in order of ascending statement number (there
;      is only one hash bucket in this table).	elements are
;      added to the table each time there is a change in
;      file name, recording the then current statement number.
;
;      to find the file name, the linked list of teblks is
;      scanned for an element containing a subscript (statement
;      number) greater than the argument statement number, or
;      the end of chain.  when this condition is met, the
;      previous teblk contains the desired file name as its
;      value entry.
;
;      (WC)		     statement number
;      jsr  filnm	     call to obtain file name
;      (XL)		     file name (scblk)
;      (ia)		     destroyed
;
filnm	PRC	e,0			; entry point
	MOV	-(XS),WB		; preserve WB
	BZE	WC,filn3		; return nulls if stno is zero
	MOV	XL,r_sfn		; file name table
	BZE	XL,filn3		; if no table
	MOV	WB,tbbuk(XL)		; get bucket entry
	BEQ	WB,r_sfn,filn3		; jump if no teblks on chain
	MOV	-(XS),XR		; preserve XR
	MOV	XR,WB			; previous block pointer
	MOV	-(XS),WC		; preserve stmt number
;
;      loop through teblks on hash chain
;
filn1	MOV	XL,XR			; next element to examine
	MOV	XR,tesub(XL)		; load subscript value (an icblk)
	LDI	icval(XR)		; load the statement number
	MFI	WC			; convert to address constant
	BLT	(XS),WC,filn2		; compare arg with teblk stmt number
;
;      here if desired stmt number is ge teblk stmt number
;
	MOV	WB,XL			; save previous entry pointer
	MOV	XR,tenxt(XL)		; point to next teblk on chain
	BNE	XR,r_sfn,filn1		; jump if there is one
;
;      here if chain exhausted or desired block found.
;
filn2	MOV	XL,WB			; previous teblk
	MOV	XL,teval(XL)		; get ptr to file name scblk
	MOV	WC,(XS)+		; restore stmt number
	MOV	XR,(XS)+		; restore XR
	MOV	WB,(XS)+		; restore WB
	EXI
;
;      no table or no table entries
;
filn3	MOV	WB,(XS)+		; restore WB
	MOV	XL,=nulls		; return null string
	EXI
	ENP
	EJC
.FI
;
.IF    .culc
;
;      flstg -- fold string to lower case
;
;      flstg folds a character string containing upper case
;      characcters to one containing lower case characters.
;      folding is only done if &case (kvcas) is not zero.
;
;      (XR)		     string argument
;      (wa)		     length of string
;      jsr  flstg	     call to fold string
;      (XR)		     result string (possibly original)
;      (WC)		     destroyed
;
flstg	PRC	e,0			; entry point
	BZE	kvcas,fst99		; skip if &case is 0
	MOV	-(XS),XL		; save XL across call
	MOV	-(XS),XR		; save original scblk ptr
	JSR	alocs			; allocate new string block
	MOV	XL,(XS)			; point to original scblk
	MOV	-(XS),XR		; save pointer to new scblk
	PLC	XL			; point to original chars
	PSC	XR			; point to new chars
	ZER	-(XS)			; init did fold flag
	LCT	WC,WC			; load loop counter
fst01	LCH	WA,(XL)+		; load character
	BLT	WA,=ch_ua,fst02		; skip if less than uc a
	BGT	WA,=ch_uz,fst02		; skip if greater than uc z
	FLC	WA			; fold character to lower case
	MNZ	(XS)			; set did fold character flag
fst02	SCH	WA,(XR)+		; store (possibly folded) character
	BCT	WC,fst01		; loop thru entire string
	CSC	XR			; complete store characters
	MOV	XR,(XS)+		; see if any change
	BNZ	XR,fst10		; skip if folding done (no change)
	MOV	dnamp,(XS)+		; do not need new scblk
	MOV	XR,(XS)+		; return original scblk
	BRN	fst20			; merge below
fst10	MOV	XR,(XS)+		; return new scblk
	ICA	XS			; throw away original scblk pointer
fst20	MOV	WA,sclen(XR)		; reload string length
	MOV	XL,(XS)+		; restore XL
fst99	EXI				; return
	ENP
	EJC
.FI
;
;      gbcol -- perform garbage collection
;
;      gbcol performs a garbage collection on the dynamic region
;      all blocks which are no longer in use are eliminated
;      by moving blocks which are in use down and resetting
;      dnamp, the pointer to the next available location.
;
;      (WB)		     move offset (see below)
;      jsr  gbcol	     call to collect garbage
.IF    .csed
;      (XR)		     sediment size after collection
.ELSE
;      (XR)		     destroyed
.FI
;
;      the following conditions must be met at the time when
;      gbcol is called.
;
;      1)   all pointers to blocks in the dynamic area must be
;	    accessible to the garbage collector. this means
;	    that they must occur in one of the following.
;
;	    a)		     main stack, with current top
;			     element being indicated by XS
;
;	    b)		     in relocatable fields of vrblks.
;
;	    c)		     in register XL at the time of call
;
;	    e)		     in the special region of working
;			     storage where names begin with r_.
;
;      2)   all pointers must point to the start of blocks with
;	    the sole exception of the contents of the code
;	    pointer register which points into the r_cod block.
;
;      3)   no location which appears to contain a pointer
;	    into the dynamic region may occur unless it is in
;	    fact a pointer to the start of the block. however
;	    pointers outside this area may occur and will
;	    not be changed by the garbage collector.
;	    it is especially important to make sure that XL
;	    does not contain a garbage value from some process
;	    carried out before the call to the collector.
;
;      gbcol has the capability of moving the final compacted
;      result up in memory (with addresses adjusted accordingly)
;      this is used to add space to the static region. the
;      entry value of WB is the number of bytes to move up.
;      the caller must guarantee that there is enough room.
;      furthermore the value in WB if it is non-zero, must be at
;      least 256 so that the mWB instruction conditions are met.
	EJC
;
;      gbcol (continued)
;
;      the algorithm, which is a modification of the lisp-2
;      garbage collector devised by r.dewar and k.belcher
;      takes three passes as follows.
;
;      1)   all pointers in memory are scanned and blocks in use
;	    determined from this scan. note that this procedure
;	    is recursive and uses the main stack for linkage.
;	    the marking process is thus similar to that used in
;	    a standard lisp collector. however the method of
;	    actually marking the blocks is different.
;
;	    the first field of a block normally contains a
;	    code entry point pointer. such an entry pointer
;	    can be distinguished from the address of any pointer
;	    to be processed by the collector. during garbage
;	    collection, this word is used to build a back chain
;	    of pointers through fields which point to the block.
;	    the end of the chain is marked by the occurence
;	    of the word which used to be in the first word of
;	    the block. this backchain serves both as a mark
;	    indicating that the block is in use and as a list of
;	    references for the relocation phase.
;
;      2)   storage is scanned sequentially to discover which
;	    blocks are currently in use as indicated by the
;	    presence of a backchain. two pointers are maintained
;	    one scans through looking at each block. the other
;	    is incremented only for blocks found to be in use.
;	    in this way, the eventual location of each block can
;	    be determined without actually moving any blocks.
;	    as each block which is in use is processed, the back
;	    chain is used to reset all pointers which point to
;	    this block to contain its new address, i.e. the
;	    address it will occupy after the blocks are moved.
;	    the first word of the block, taken from the end of
;	    the chain is restored at this point.
;
;	    during pass 2, the collector builds blocks which
;	    describe the regions of storage which are to be
;	    moved in the third pass. there is one descriptor for
;	    each contiguous set of good blocks. the descriptor
;	    is built just behind the block to be moved and
;	    contains a pointer to the next block and the number
;	    of words to be moved.
;
;      3)   in the third and final pass, the move descriptor
;	    blocks built in pass two are used to actually move
;	    the blocks down to the bottom of the dynamic region.
;	    the collection is then complete and the next
;	    available location pointer is reset.
	EJC
;
;      gbcol (continued)
;
.IF    .csed
;      the garbage collector also recognizes the concept of
;      sediment.  sediment is defined as long-lived objects
;      which percipitate to the bottom of dynamic storage.
;      moving these objects during repeated collections is
;      inefficient.  it also contributes to thrashing on
;      systems with virtual memory.  in a typical worst-case
;      situation, there may be several megabytes of live objects
;      in the sediment, and only a few dead objects in need of
;      collection.  without recognising sediment, the standard
;      collector would move those megabytes of objects downward
;      to squeeze out the dead objects.	 this type of move
;      would result in excessive thrasing for very little memory
;      gain.
;
;      scanning of blocks in the sediment cannot be avoided
;      entirely, because these blocks may contain pointers to
;      live objects above the sediment.	 however, sediment
;      blocks need not be linked to a back chain as described
;      in pass one above.  since these blocks will not be moved,
;      pointers to them do not need to be adjusted.  eliminating
;      unnecessary back chain links increases locality of
;      reference, improving virtual memory performance.
;
;      because back chains are used to mark blocks whose con-
;      tents have been processed, a different marking system
.IF    .cepp
;      is needed for blocks in the sediment.  since block type
;      words point to odd-parity entry addresses, merely incre-
;      menting the type word serves to mark the block as pro-
;      cessed.	during pass three, the type words are decre-
;      mented to restore them to their original value.
.ELSE
;      is needed for blocks in the sediment.  all block type
;      words normally lie in the range b_aaa to p_yyy.	blocks
;      can be marked by adding an offset (created in gbcmk) to
;      move type words out of this range.  during pass three the
;      offset is subtracted to restore them to their original
;      value.
.FI
	EJC
;
;      gbcol (continued)
;
;
;      the vaRIAble dnams contains the number of bytes of memory
;      currently in the sediment.  setting dnams to zero will
;      eliminate the sediment and force it to be included in a
;      full garbage collection.	 gbcol returns a suggested new
;      value for dnams (usually dnamp-dnamb) in XR which the
;      caller can store in dnams if it wishes to maintain the
;      sediment.  that is, data remaining after a garbage
;      collection is considered to be sediment.	 if one accepts
;      the common lore that most objects are either very short-
;      or very long-lived, then this naive setting of dnams
;      probably includes some short-lived objects toward the end
;      of the sediment.
;
;      knowing when to reset dnams to zero to collect the sedi-
;      ment is not precisely known.  we force it to zero prior
;      to producing a dump, when gbcol is invoked by collect()
;      (so that the sediment is invisible to the user), when
;      sysmm is unable to obtain additional memory, and when
;      gbcol is called to relocate the dynamic area up in memory
;      (to make room for enlarging the static area).  if there
;      are no other reset situations, this leads to the inexo-
;      rable growth of the sediment, possible forcing a modest
;      program to begin to use virtual memory that it otherwise
;      would not.
;
;      as we scan sediment blocks in pass three, we maintain
;      aggregate counts of the amount of dead and live storage,
;      which is used to decide when to reset dnams.  when the
;      ratio of free storage found in the sediment to total
;      sediment size exceeds a threshold, the sediment is marked
;      for collection on the next gbcol call.
;
.FI
	EJC
;
;      gbcol (continued)
;
gbcol	PRC	e,0			; entry point
;z-
	BNZ	dmvch,gbc14		; fail if in mid-dump
	MNZ	gbcfl			; note gbcol entered
	MOV	gbsva,WA		; save entry wa
	MOV	gbsvb,WB		; save entry WB
	MOV	gbsvc,WC		; save entry WC
	MOV	-(XS),XL		; save entry XL
	SCP	WA			; get code pointer value
	SUB	WA,r_cod		; make relative
	LCP	WA			; and restore
.IF    .csed
	BZE	WB,gbc0a		; check there is no move offset
	ZER	dnams			; collect sediment if must move it
gbc0a	MOV	WA,dnamb		; start of dynamic area
	ADD	WA,dnams		; size of sediment
	MOV	gbcsd,WA		; first location past sediment
.IF    .cepp
.ELSE
	MOV	WA,=p_yyy		; last entry point
	ICV	WA			; address past last entry point
	SUB	WA,=b_aaa		; size of entry point area
	MOV	gbcmk,WA		; use to mark processed sed. blocks
.FI
.FI
.IF    .cgbc
;
;      inform sysgc that collection to commence
;
	MNZ	XR			; non-zero flags start of collection
	MOV	WA,dnamb		; start of dynamic area
	MOV	WB,dnamp		; next available location
	MOV	WC,dname		; last available location + 1
	JSR	sysgc			; inform of collection
.FI
;
;      process stack entries
;
	MOV	XR,XS			; point to stack front
	MOV	XL,stbas		; point past end of stack
	BGE	XL,XR,gbc00		; ok if d-stack
	MOV	XR,XL			; reverse if ...
	MOV	XL,XS			; ... u-stack
;
;      process the stack
;
gbc00	JSR	gbcpf			; process pointers on stack
;
;      process special work locations
;
	MOV	XR,=r_aaa		; point to start of relocatable locs
	MOV	XL,=r_yyy		; point past end of relocatable locs
	JSR	gbcpf			; process work fields
;
;      prepare to process vaRIAble blocks
;
	MOV	WA,hshtb		; point to first hash slot pointer
;
;      loop through hash slots
;
gbc01	MOV	XL,WA			; point to next slot
	ICA	WA			; bump bucket pointer
	MOV	gbcnm,WA		; save bucket pointer
	EJC
;
;      gbcol (continued)
;
;      loop through vaRIAbles on one hash chain
;
gbc02	MOV	XR,(XL)			; load ptr to next vrblk
	BZE	XR,gbc03		; jump if end of chain
	MOV	XL,XR			; else copy vrblk pointer
	ADD	XR,*vrval		; point to first reloc fld
	ADD	XL,*vrnxt		; point past last (and to link ptr)
	JSR	gbcpf			; process reloc fields in vrblk
	BRN	gbc02			; loop back for next block
;
;      here at end of one hash chain
;
gbc03	MOV	WA,gbcnm		; restore bucket pointer
	BNE	WA,hshte,gbc01		; loop back if more buckets to go
	EJC
;
;      gbcol (continued)
;
;      now we are ready to start pass two. registers are used
;      as follows in pass two.
;
;      (XR)		     scans through all blocks
;      (WC)		     pointer to eventual location
;
;      the move description blocks built in this pass have
;      the following format.
;
;      word 1		     pointer to next move block,
;			     zero if end of chain of blocks
;
;      word 2		     length of blocks to be moved in
;			     bytes. set to the address of the
;			     first byte while actually scanning
;			     the blocks.
;
;      the first entry on this chain is a special entry
;      consisting of the two words gbcnm and gbcns. after
;      building the chain of move descriptors, gbcnm points to
;      the first real move block, and gbcns is the length of
;      blocks in use at the start of storage which need not
;      be moved since they are in the correct position.
;
.IF    .csed
	MOV	XR,dnamb		; point to first block
	ZER	WB			; accumulate size of dead blocks
gbc04	BEQ	XR,gbcsd,gbc4c		; jump if end of sediment
	MOV	WA,(XR)			; else get first word
.IF    .cepp
	BOD	WA,gbc4b		; jump if entry pointer (unused)
	DCV	WA			; restore entry pointer
.ELSE
	BHI	WA,=p_yyy,gbc4a		; skip if not entry ptr (in use)
	BHI	WA,=b_aaa,gbc4b		; jump if entry pointer (unused)
gbc4a	SUB	WA,gbcmk		; restore entry pointer
.FI
	MOV	(XR),WA			; restore first word
	JSR	blkln			; get length of this block
	ADD	XR,WA			; bump actual pointer
	BRN	gbc04			; continue scan through sediment
;
;      here for unused sediment block
;
gbc4b	JSR	blkln			; get length of this block
	ADD	XR,WA			; bump actual pointer
	ADD	WB,WA			; count size of unused blocks
	BRN	gbc04			; continue scan through sediment
;
;      here at end of sediment.	 remember size of free blocks
;      within the sediment.  this will be used later to decide
;      how to set the sediment size returned to caller.
;
;      then scan rest of dynamic area above sediment.
;
;      (WB) = aggregate size of free blocks in sediment
;      (XR) = first location past sediment
;
gbc4c	MOV	gbcsf,WB		; size of sediment free space
.ELSE
	MOV	XR,dnamb		; point to first block
.FI
	MOV	WC,XR			; set as first eventual location
	ADD	WC,gbsvb		; add offset for eventual move up
	ZER	gbcnm			; clear initial forward pointer
	MOV	gbclm,=gbcnm		; initialize ptr to last move block
	MOV	gbcns,XR		; initialize first address
;
;      loop through a series of blocks in use
;
gbc05	BEQ	XR,dnamp,gbc07		; jump if end of used region
	MOV	WA,(XR)			; else get first word
.IF    .cepp
	BOD	WA,gbc07		; jump if entry pointer (unused)
.ELSE
	BHI	WA,=p_yyy,gbc06		; skip if not entry ptr (in use)
	BHI	WA,=b_aaa,gbc07		; jump if entry pointer (unused)
.FI
;
;      here for block in use, loop to relocate references
;
gbc06	MOV	XL,WA			; copy pointer
	MOV	WA,(XL)			; load forward pointer
	MOV	(XL),WC			; relocate reference
.IF    .cepp
	BEV	WA,gbc06		; loop back if not end of chain
.ELSE
	BHI	WA,=p_yyy,gbc06		; loop back if not end of chain
	BLO	WA,=b_aaa,gbc06		; loop back if not end of chain
.FI
	EJC
;
;      gbcol (continued)
;
;      at end of chain, restore first word and bump past
;
	MOV	(XR),WA			; restore first word
	JSR	blkln			; get length of this block
	ADD	XR,WA			; bump actual pointer
	ADD	WC,WA			; bump eventual pointer
	BRN	gbc05			; loop back for next block
;
;      here at end of a series of blocks in use
;
gbc07	MOV	WA,XR			; copy pointer past last block
	MOV	XL,gbclm		; point to previous move block
	SUB	WA,num01(XL)		; subtract starting address
	MOV	num01(XL),WA		; store length of block to be moved
;
;      loop through a series of blocks not in use
;
gbc08	BEQ	XR,dnamp,gbc10		; jump if end of used region
	MOV	WA,(XR)			; else load first word of next block
.IF    .cepp
	BEV	WA,gbc09		; jump if in use
.ELSE
	BHI	WA,=p_yyy,gbc09		; jump if in use
	BLO	WA,=b_aaa,gbc09		; jump if in use
.FI
	JSR	blkln			; else get length of next block
	ADD	XR,WA			; push pointer
	BRN	gbc08			; and loop back
;
;      here for a block in use after processing a series of
;      blocks which were not in use, build new move block.
;
gbc09	SUB	XR,*num02		; point 2 words behind for move block
	MOV	XL,gbclm		; point to previous move block
	MOV	(XL),XR			; set forward ptr in previous block
	ZER	(XR)			; zero forward ptr of new block
	MOV	gbclm,XR		; remember address of this block
	MOV	XL,XR			; copy ptr to move block
	ADD	XR,*num02		; point back to block in use
	MOV	num01(XL),XR		; store starting address
	BRN	gbc06			; jump to process block in use
	EJC
;
;      gbcol (continued)
;
;      here for pass three -- actually move the blocks down
;
;      (XL)		     pointer to old location
;      (XR)		     pointer to new location
;
.IF    .csed
gbc10	MOV	XR,gbcsd		; point to storage above sediment
.ELSE
gbc10	MOV	XR,dnamb		; point to start of storage
.FI
	ADD	XR,gbcns		; bump past unmoved blocks at start
;
;      loop through move descriptors
;
gbc11	MOV	XL,gbcnm		; point to next move block
	BZE	XL,gbc12		; jump if end of chain
	MOV	gbcnm,(XL)+		; move pointer down chain
	MOV	WA,(XL)+		; get length to move
	MVW				; perform move
	BRN	gbc11			; loop back
;
;      now test for move up
;
gbc12	MOV	dnamp,XR		; set next available loc ptr
	MOV	WB,gbsvb		; reload move offset
	BZE	WB,gbc13		; jump if no move required
	MOV	XL,XR			; else copy old top of core
	ADD	XR,WB			; point to new top of core
	MOV	dnamp,XR		; save new top of core pointer
	MOV	WA,XL			; copy old top
	SUB	WA,dnamb		; minus old bottom = length
	ADD	dnamb,WB		; bump bottom to get new value
	MWB				; perform move (backwards)
;
;      merge here to exit
;
gbc13	ZER	XR			; clear garbage value in XR
	MOV	gbcfl,XR		; note exit from gbcol
.IF    .cgbc
	MOV	WA,dnamb		; start of dynamic area
	MOV	WB,dnamp		; next available location
	MOV	WC,dname		; last available location + 1
	JSR	sysgc			; inform sysgc of completion
.FI
.IF    .csed
;
;      decide whether to mark sediment for collection next time.
;      this is done by examining the ratio of previous sediment
;      free space to the new sediment size.
;
	STI	gbcia			; save IA
	ZER	XR			; presume no sediment will remain
	MOV	WB,gbcsf		; free space in sediment
	BTW	WB			; convert bytes to words
	MTI	WB			; put sediment free store in IA
	MLI	gbsed			; multiply by sediment factor
	IOV	gb13a			; jump if overflowed
	MOV	WB,dnamp		; end of dynamic area in use
	SUB	WB,dnamb		; minus start is sediment remaining
	BTW	WB			; convert to words
	MOV	gbcsf,WB		; store it
	SBI	gbcsf			; subtract from scaled up free store
	IGT	gb13a			; jump if large free store in sedimnt
	MOV	XR,dnamp		; below threshold, return sediment
	SUB	XR,dnamb		; for use by caller
gb13a	LDI	gbcia			; restore IA
.FI
	MOV	WA,gbsva		; restore wa
	MOV	WB,gbsvb		; restore WB
	SCP	WC			; get code pointer
	ADD	WC,r_cod		; make absolute again
	LCP	WC			; and replace absolute value
	MOV	WC,gbsvc		; restore WC
	MOV	XL,(XS)+		; restore entry XL
	ICV	gbcnt			; increment count of collections
	EXI				; exit to gbcol caller
;
;      garbage collection not allowed whilst dumping
;
gbc14	ICV	errft			; fatal error
	ERB	250,insufficient memory to complete dump
	ENP				; end procedure gbcol
	EJC
;
;      gbcpf -- process fields for garbage collector
;
;      this procedure is used by the garbage collector to
;      process fields in pass one. see gbcol for full details.
;
;      (XR)		     ptr to first location to process
;      (XL)		     ptr past last location to process
;      jsr  gbcpf	     call to process fields
;      (XR,WA,WB,WC,ia)	     destroyed
;
;      note that although this procedure uses a recursive
;      approach, it controls its own stack and is not recursive.
;
gbcpf	PRC	e,0			; entry point
	ZER	-(XS)			; set zero to mark bottom of stack
	MOV	-(XS),XL		; save end pointer
;
;      merge here to go down a level and start a new loop
;
;      1(XS)		     next lvl field ptr (0 at outer lvl)
;      0(XS)		     ptr past last field to process
;      (XR)		     ptr to first field to process
;
;      loop to process successive fields
;
gpf01	MOV	XL,(XR)			; load field contents
	MOV	WC,XR			; save field pointer
.IF    .crpp
	BOD	XL,gpf2a		; jump if not ptr into dynamic area
.FI
	BLT	XL,dnamb,gpf2a		; jump if not ptr into dynamic area
	BGE	XL,dnamp,gpf2a		; jump if not ptr into dynamic area
;
;      here we have a ptr to a block in the dynamic area.
;      link this field onto the reference backchain.
;
	MOV	WA,(XL)			; load ptr to chain (or entry ptr)
.IF    .csed
	BLT	XL,gbcsd,gpf1a		; do not chain if within sediment
.FI
	MOV	(XL),XR			; set this field as new head of chain
	MOV	(XR),WA			; set forward pointer
;
;      now see if this block has been processed before
;
.IF    .cepp
gpf1a	BOD	WA,gpf03		; jump if not already processed
.ELSE
gpf1a	BHI	WA,=p_yyy,gpf2a		; jump if already processed
	BHI	WA,=b_aaa,gpf03		; jump if not already processed
.FI
;
;      here to restore pointer in XR to field just processed
;
gpf02	MOV	XR,WC			; restore field pointer
;
;      here to move to next field
;
gpf2a	ICA	XR			; bump to next field
	BNE	XR,(XS),gpf01		; loop back if more to go
	EJC
;
;      gbcpf (continued)
;
;      here we pop up a level after finishing a block
;
	MOV	XL,(XS)+		; restore pointer past end
	MOV	XR,(XS)+		; restore block pointer
	BNZ	XR,gpf2a		; continue loop unless outer levl
	EXI				; return to caller if outer level
;
;      here to process an active block which has not been done
;
.IF    .csed
;
;      since sediment blocks are not marked by putting them on
;      the back chain, they must be explicitly marked in another
;      manner.	if odd parity entry points are present, mark by
;      temporarily converting to even parity.  if odd parity not
;      available, the entry point is adjusted by the value in
;      gbcmk.
;
gpf03	BGE	XL,gbcsd,gpf3a		; if not within sediment
.IF    .cepp
	ICV	(XL)			; mark by making entry point even
.ELSE
	ADD	(XL),gbcmk		; mark by biasing entry point
.FI
gpf3a	MOV	XR,XL			; copy block pointer
.ELSE
gpf03	MOV	XR,XL			; copy block pointer
.FI
	MOV	XL,WA			; copy first word of block
	LEI	XL			; load entry point id (bl_xx)
;
;      block type switch. note that blocks with no relocatable
;      fields just return to gpf02 here to continue to next fld.
;
	BSW	XL,bl___		; switch on block type
	IFF	bl_ar,gpf06		; arblk
.IF    .cnbf
	IFF	bl_bc,gpf02		; bcblk - dummy to fill out iffs
.ELSE
	IFF	bl_bc,gpf18		; bcblk
.FI
	IFF	bl_bf,gpf02		; bfblk
	IFF	bl_cc,gpf07		; ccblk
.IF    .csln
	IFF	bl_cd,gpf19		; cdblk
.ELSE
	IFF	bl_cd,gpf08		; cdblk
.FI
	IFF	bl_cm,gpf04		; cmblk
	IFF	bl_df,gpf02		; dfblk
	IFF	bl_ev,gpf10		; evblk
	IFF	bl_ex,gpf17		; exblk
	IFF	bl_ff,gpf11		; ffblk
	IFF	bl_nm,gpf10		; nmblk
	IFF	bl_p0,gpf10		; p0blk
	IFF	bl_p1,gpf12		; p1blk
	IFF	bl_p2,gpf12		; p2blk
	IFF	bl_pd,gpf13		; pdblk
	IFF	bl_pf,gpf14		; pfblk
	IFF	bl_tb,gpf08		; tbblk
	IFF	bl_te,gpf15		; teblk
	IFF	bl_tr,gpf16		; trblk
	IFF	bl_vc,gpf08		; vcblk
	IFF	bl_xr,gpf09		; XRblk
	IFF	bl_ct,gpf02		; ctblk
	IFF	bl_ef,gpf02		; efblk
	IFF	bl_ic,gpf02		; icblk
	IFF	bl_kv,gpf02		; kvblk
	IFF	bl_rc,gpf02		; rcblk
	IFF	bl_sc,gpf02		; scblk
	IFF	bl_se,gpf02		; seblk
	IFF	bl_xn,gpf02		; xnblk
	ESW				; end of jump table
	EJC
;
;      gbcpf (continued)
;
;      cmblk
;
gpf04	MOV	WA,cmlen(XR)		; load length
	MOV	WB,*cmtyp		; set offset
;
;      here to push down to new level
;
;      (WC)		     field ptr at previous level
;      (XR)		     ptr to new block
;      (wa)		     length (reloc flds + flds at start)
;      (WB)		     offset to first reloc field
;
gpf05	ADD	WA,XR			; point past last reloc field
	ADD	XR,WB			; point to first reloc field
	MOV	-(XS),WC		; stack old field pointer
	MOV	-(XS),WA		; stack new limit pointer
	CHK				; check for stack overflow
	BRN	gpf01			; if ok, back to process
;
;      arblk
;
gpf06	MOV	WA,arlen(XR)		; load length
	MOV	WB,arofs(XR)		; set offset to 1st reloc fld (arpro)
	BRN	gpf05			; all set
;
;      ccblk
;
gpf07	MOV	WA,ccuse(XR)		; set length in use
	MOV	WB,*ccuse		; 1st word (make sure at least one)
	BRN	gpf05			; all set
	EJC
;
;      gbcpf (continued)
;
.IF    .csln
;      cdblk
;
gpf19	MOV	WA,cdlen(XR)		; load length
	MOV	WB,*cdfal		; set offset
	BRN	gpf05			; jump back
;
;      tbblk, vcblk
.ELSE
;      cdblk, tbblk, vcblk
.FI
;
gpf08	MOV	WA,offs2(XR)		; load length
	MOV	WB,*offs3		; set offset
	BRN	gpf05			; jump back
;
;      XRblk
;
gpf09	MOV	WA,xrlen(XR)		; load length
	MOV	WB,*xrptr		; set offset
	BRN	gpf05			; jump back
;
;      evblk, nmblk, p0blk
;
gpf10	MOV	WA,*offs2		; point past second field
	MOV	WB,*offs1		; offset is one (only reloc fld is 2)
	BRN	gpf05			; all set
;
;      ffblk
;
gpf11	MOV	WA,*ffofs		; set length
	MOV	WB,*ffnxt		; set offset
	BRN	gpf05			; all set
;
;      p1blk, p2blk
;
gpf12	MOV	WA,*parm2		; length (parm2 is non-relocatable)
	MOV	WB,*pthen		; set offset
	BRN	gpf05			; all set
	EJC
;
;      gbcpf (continued)
;
;      pdblk
;
gpf13	MOV	XL,pddfp(XR)		; load ptr to dfblk
	MOV	WA,dfpdl(XL)		; get pdblk length
	MOV	WB,*pdfld		; set offset
	BRN	gpf05			; all set
;
;      pfblk
;
gpf14	MOV	WA,*pfarg		; length past last reloc
	MOV	WB,*pfcod		; offset to first reloc
	BRN	gpf05			; all set
;
;      teblk
;
gpf15	MOV	WA,*tesi_		; set length
	MOV	WB,*tesub		; and offset
	BRN	gpf05			; all set
;
;      trblk
;
gpf16	MOV	WA,*trsi_		; set length
	MOV	WB,*trval		; and offset
	BRN	gpf05			; all set
;
;      exblk
;
gpf17	MOV	WA,exlen(XR)		; load length
	MOV	WB,*exflc		; set offset
	BRN	gpf05			; jump back
.IF    .cnbf
.ELSE
;
;      bcblk
;
gpf18	MOV	WA,*bcsi_		; set length
	MOV	WB,*bcbuf		; and offset
	BRN	gpf05			; all set
.FI
	ENP				; end procedure gbcpf
	EJC
;z+
;
;      gtarr -- get array
;
;      gtarr is passed an object and returns an array if possibl
;
;      (XR)		     value to be converted
;      (wa)		     0 to place table addresses in array
;			     non-zero for keys/values in array
;      jsr  gtarr	     call to get array
;      ppm  loc		     transfer loc for all null table
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     resulting array
;      (XL,WA,WB,WC)	     destroyed
;
gtarr	PRC	e,2			; entry point
	MOV	gtawa,WA		; save wa indicator
	MOV	WA,(XR)			; load type word
	BEQ	WA,=b_art,gtar8		; exit if already an array
	BEQ	WA,=b_vct,gtar8		; exit if already an array
	BNE	WA,=b_tbt,gta9a		; else fail if not a table (sgd02)
;
;      here we convert a table to an array
;
	MOV	-(XS),XR		; replace tbblk pointer on stack
	ZER	XR			; signal first pass
	ZER	WB			; zero non-null element count
;
;      the following code is executed twice. on the first pass,
;      signalled by XR=0, the number of non-null elements in
;      the table is counted in WB. in the second pass, where
;      XR is a pointer into the arblk, the name and value are
;      entered into the current arblk location provided gtawa
;      is non-zero.  if gtawa is zero, the address of the teblk
;      is entered into the arblk twice (c3.762).
;
gtar1	MOV	XL,(XS)			; point to table
	ADD	XL,tblen(XL)		; point past last bucket
	SUB	XL,*tbbuk		; set first bucket offset
	MOV	WA,XL			; copy adjusted pointer
;
;      loop through buckets in table block
;      next three lines of code rely on tenxt having a value
;      1 less than tbbuk.
;
gtar2	MOV	XL,WA			; copy bucket pointer
	DCA	WA			; decrement bucket pointer
;
;      loop through teblks on one bucket chain
;
gtar3	MOV	XL,tenxt(XL)		; point to next teblk
	BEQ	XL,(XS),gtar6		; jump if chain end (tbblk ptr)
	MOV	cnvtp,XL		; else save teblk pointer
;
;      loop to find value down trblk chain
;
gtar4	MOV	XL,teval(XL)		; load value
	BEQ	(XL),=b_trt,gtar4	; loop till value found
	MOV	WC,XL			; copy value
	MOV	XL,cnvtp		; restore teblk pointer
	EJC
;
;      gtarr (continued)
;
;      now check for null and test cases
;
	BEQ	WC,=nulls,gtar3		; loop back to ignore null value
	BNZ	XR,gtar5		; jump if second pass
	ICV	WB			; for the first pass, bump count
	BRN	gtar3			; and loop back for next teblk
;
;      here in second pass
;
gtar5	BZE	gtawa,gta5a		; jump if address wanted
	MOV	(XR)+,tesub(XL)		; store subscript name
	MOV	(XR)+,WC		; store value in arblk
	BRN	gtar3			; loop back for next teblk
;
;      here to record teblk address in arblk.  this allows
;      a sort routine to sort by ascending address.
;
gta5a	MOV	(XR)+,XL		; store teblk address in name
	MOV	(XR)+,XL		; and value slots
	BRN	gtar3			; loop back for next teblk
;
;      here after scanning teblks on one chain
;
gtar6	BNE	WA,(XS),gtar2		; loop back if more buckets to go
	BNZ	XR,gtar7		; else jump if second pass
;
;      here after counting non-null elements
;
	BZE	WB,gtar9		; fail if no non-null elements
	MOV	WA,WB			; else copy count
	ADD	WA,WB			; double (two words/element)
	ADD	WA,=arvl2		; add space for standard fields
	WTB	WA			; convert length to bytes
	BGT	WA,mxlen,gta9b		; error if too long for array
	JSR	alloc			; else allocate space for arblk
	MOV	(XR),=b_art		; store type word
	ZER	idval(XR)		; zero id for the moment
	MOV	arlen(XR),WA		; store length
	MOV	arndm(XR),=num02	; set dimensions = 2
	LDI	intv1			; get integer one
	STI	arlbd(XR)		; store as lbd 1
	STI	arlb2(XR)		; store as lbd 2
	LDI	intv2			; load integer two
	STI	ardm2(XR)		; store as dim 2
	MTI	WB			; get element count as integer
	STI	ardim(XR)		; store as dim 1
	ZER	arpr2(XR)		; zero prototype field for now
	MOV	arofs(XR),*arpr2	; set offset field (signal pass 2)
	MOV	WB,XR			; save arblk pointer
	ADD	XR,*arvl2		; point to first element location
	BRN	gtar1			; jump back to fill in elements
	EJC
;
;      gtarr (continued)
;
;      here after filling in element values
;
gtar7	MOV	XR,WB			; restore arblk pointer
	MOV	(XS),WB			; store as result
;
;      now we need the array prototype which is of the form nn,2
;      this is obtained by building the string for nn02 and
;      changing the zero to a comma before storing it.
;
	LDI	ardim(XR)		; get number of elements (nn)
	MLI	intvh			; multiply by 100
	ADI	intv2			; add 2 (nn02)
	JSR	icbld			; build integer
	MOV	-(XS),XR		; store ptr for gtstg
	JSR	gtstg			; convert to string
	PPM				; convert fail is impossible
	MOV	XL,XR			; copy string pointer
	MOV	XR,(XS)+		; reload arblk pointer
	MOV	arpr2(XR),XL		; store prototype ptr (nn02)
	SUB	WA,=num02		; adjust length to point to zero
	PSC	XL,WA			; point to zero
	MOV	WB,=ch_cm		; load a comma
	SCH	WB,(XL)			; store a comma over the zero
	CSC	XL			; complete store characters
;
;      normal return
;
gtar8	EXI				; return to caller
;
;      null table non-conversion return
;
gtar9	MOV	XR,(XS)+		; restore stack for conv err (sgd02)
	EXI	1			; return
;
;      impossible conversion return
;
gta9a	EXI	2			; return
;
;      array size too large
;
gta9b	ERB	260,conversion array size exceeds maximum permitted
	ENP				; procedure gtarr
	EJC
;
;      gtcod -- convert to code
;
;      (XR)		     object to be converted
;      jsr  gtcod	     call to convert to code
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to resulting cdblk
;      (XL,WA,WB,WC,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
gtcod	PRC	e,1			; entry point
	BEQ	(XR),=b_cds,gtcd1	; jump if already code
	BEQ	(XR),=b_cdc,gtcd1	; jump if already code
;
;      here we must generate a cdblk by compilation
;
	MOV	-(XS),XR		; stack argument for gtstg
	JSR	gtstg			; convert argument to string
	PPM	gtcd2			; jump if non-convertible
	MOV	gtcef,flptr		; save fail ptr in case of error
	MOV	r_gtc,r_cod		; also save code ptr
	MOV	r_cim,XR		; else set image pointer
	MOV	scnil,WA		; set image length
	ZER	scnpt			; set scan pointer
	MOV	stage,=stgxc		; set stage for execute compile
	MOV	lstsn,cmpsn		; in case listr called
.IF    .csln
	ICV	cmpln			; bump line number
.FI
	JSR	cmpil			; compile string
	MOV	stage,=stgxt		; reset stage for execute time
	ZER	r_cim			; clear image
;
;      merge here if no convert required
;
gtcd1	EXI				; give normal gtcod return
;
;      here if unconvertible
;
gtcd2	EXI	1			; give error return
	ENP				; end procedure gtcod
	EJC
;
;      gtexp -- convert to expression
;
.IF    .cevb
;      (WB)		     0 if by value, 1 if by name
.FI
;      (XR)		     input value to be converted
;      jsr  gtexp	     call to convert to expression
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to result exblk or seblk
;      (XL,WA,WB,WC,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
gtexp	PRC	e,1			; entry point
	BLO	(XR),=b_e__,gtex1	; jump if already an expression
	MOV	-(XS),XR		; store argument for gtstg
	JSR	gtstg			; convert argument to string
	PPM	gtex2			; jump if unconvertible
;
;      check the last character of the string for colon or
;      semicolon.  these characters can legitimately end an
;      expression in open code, so expan will not detect them
;      as errors, but they are invalid as terminators for a
;      string that is being converted to expression form.
;
	MOV	XL,XR			; copy input string pointer
	PLC	XL,WA			; point one past the string end
	LCH	XL,-(XL)		; fetch the last character
	BEQ	XL,=ch_cl,gtex2		; error if it is a semicolon
	BEQ	XL,=ch_sm,gtex2		; or if it is a colon
;
;      here we convert a string by compilation
;
	MOV	r_cim,XR		; set input image pointer
	ZER	scnpt			; set scan pointer
	MOV	scnil,WA		; set input image length
.IF    .cevb
	MOV	-(XS),WB		; save value/name flag
.FI
	ZER	WB			; set code for normal scan
	MOV	gtcef,flptr		; save fail ptr in case of error
	MOV	r_gtc,r_cod		; also save code ptr
	MOV	stage,=stgev		; adjust stage for compile
	MOV	scntp,=t_uok		; indicate unary operator acceptable
	JSR	expan			; build tree for expression
	ZER	scnrs			; reset rescan flag
.IF    .cevb
	MOV	WA,(XS)+		; restore value/name flag
.FI
	BNE	scnpt,scnil,gtex2	; error if not end of image
	ZER	WB			; set ok value for cdgex call
	MOV	XL,XR			; copy tree pointer
	JSR	cdgex			; build expression block
	ZER	r_cim			; clear pointer
	MOV	stage,=stgxt		; restore stage for execute time
;
;      merge here if no conversion required
;
gtex1	EXI				; return to gtexp caller
;
;      here if unconvertible
;
gtex2	EXI	1			; take error exit
	ENP				; end procedure gtexp
	EJC
;
;      gtint -- get integer value
;
;      gtint is passed an object and returns an integer after
;      performing any necessary conversions.
;
;      (XR)		     value to be converted
;      jsr  gtint	     call to convert to integer
;      ppm  loc		     transfer loc for convert impossible
;      (XR)		     resulting integer
;      (WC,ra)		     destroyed
;      (wa,WB)		     destroyed (only on conversion err)
;      (XR)		     unchanged (on convert error)
;
gtint	PRC	e,1			; entry point
	BEQ	(XR),=b_icl,gtin2	; jump if already an integer
	MOV	gtina,WA		; else save wa
	MOV	gtinb,WB		; save WB
	JSR	gtnum			; convert to numeric
	PPM	gtin3			; jump if unconvertible
.IF    .cnra
.ELSE
	BEQ	WA,=b_icl,gtin1		; jump if integer
;
;      here we convert a real to integer
;
	LDR	rcval(XR)		; load real value
	RTI	gtin3			; convert to integer (err if ovflow)
	JSR	icbld			; if ok build icblk
.FI
;
;      here after successful conversion to integer
;
gtin1	MOV	WA,gtina		; restore wa
	MOV	WB,gtinb		; restore WB
;
;      common exit point
;
gtin2	EXI				; return to gtint caller
;
;      here on conversion error
;
gtin3	EXI	1			; take convert error exit
	ENP				; end procedure gtint
	EJC
;
;      gtnum -- get numeric value
;
;      gtnum is given an object and returns either an integer
;      or a real, performing any necessary conversions.
;
;      (XR)		     object to be converted
;      jsr  gtnum	     call to convert to numeric
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to result (int or real)
;      (wa)		     first word of result block
;      (WB,WC,ra)	     destroyed
;      (XR)		     unchanged (on convert error)
;
gtnum	PRC	e,1			; entry point
	MOV	WA,(XR)			; load first word of block
	BEQ	WA,=b_icl,gtn34		; jump if integer (no conversion)
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,gtn34		; jump if real (no conversion)
.FI
;
;      at this point the only possibility is to convert a string
;      to an integer or real as appropriate.
;
	MOV	-(XS),XR		; stack argument in case convert err
	MOV	-(XS),XR		; stack argument for gtstg
.IF    .cnbf
	JSR	gtstg			; convert argument to string
.ELSE
	JSR	gtstb			; get argument as string or buffer
.FI
	PPM	gtn36			; jump if unconvertible
;
;      initialize numeric conversion
;
	LDI	intv0			; initialize integer result to zero
	BZE	WA,gtn32		; jump to exit with zero if null
	LCT	WA,WA			; set bct counter for following loops
	ZER	gtnnf			; tentatively indicate result +
.IF    .cnra
.ELSE
	STI	gtnex			; initialise exponent to zero
	ZER	gtnsc			; zero scale in case real
	ZER	gtndf			; reset flag for dec point found
	ZER	gtnrd			; reset flag for digits found
	LDR	reav0			; zero real accum in case real
.FI
	PLC	XR			; point to argument characters
;
;      merge back here after ignoring leading blank
;
gtn01	LCH	WB,(XR)+		; load first character
	BLT	WB,=ch_d0,gtn02		; jump if not digit
	BLE	WB,=ch_d9,gtn06		; jump if first char is a digit
	EJC
;
;      gtnum (continued)
;
;      here if first digit is non-digit
;
gtn02	BNE	WB,=ch_bl,gtn03		; jump if non-blank
gtna2	BCT	WA,gtn01		; else decr count and loop back
	BRN	gtn07			; jump to return zero if all blanks
;
;      here for first character non-blank, non-digit
;
gtn03	BEQ	WB,=ch_pl,gtn04		; jump if plus sign
.IF    .caht
	BEQ	WB,=ch_ht,gtna2		; horizontal tab equiv to blank
.FI
.IF    .cavt
	BEQ	WB,=ch_vt,gtna2		; vertical tab equiv to blank
.FI
.IF    .cnra
	BNE	WB,=ch_mn,gtn36		; else fail
.ELSE
	BNE	WB,=ch_mn,gtn12		; jump if not minus (may be real)
.FI
	MNZ	gtnnf			; if minus sign, set negative flag
;
;      merge here after processing sign
;
gtn04	BCT	WA,gtn05		; jump if chars left
	BRN	gtn36			; else error
;
;      loop to fetch characters of an integer
;
gtn05	LCH	WB,(XR)+		; load next character
	BLT	WB,=ch_d0,gtn08		; jump if not a digit
	BGT	WB,=ch_d9,gtn08		; jump if not a digit
;
;      merge here for first digit
;
gtn06	STI	gtnsi			; save current value
.IF    .cnra
	CVM	gtn36			; current*10-(new dig) jump if ovflow
.ELSE
	CVM	gtn35			; current*10-(new dig) jump if ovflow
	MNZ	gtnrd			; set digit read flag
.FI
	BCT	WA,gtn05		; else loop back if more chars
;
;      here to exit with converted integer value
;
gtn07	BNZ	gtnnf,gtn32		; jump if negative (all set)
	NGI				; else negate
	INO	gtn32			; jump if no overflow
	BRN	gtn36			; else signal error
	EJC
;
;      gtnum (continued)
;
;      here for a non-digit character while attempting to
;      convert an integer, check for trailing blanks or real.
;
gtn08	BEQ	WB,=ch_bl,gtna9		; jump if a blank
.IF    .caht
	BEQ	WB,=ch_ht,gtna9		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WB,=ch_vt,gtna9		; jump if vertical tab
.FI
.IF    .cnra
	BRN	gtn36			; error
.ELSE
	ITR				; else convert integer to real
	NGR				; negate to get positive value
	BRN	gtn12			; jump to try for real
.FI
;
;      here we scan out blanks to end of string
;
gtn09	LCH	WB,(XR)+		; get next char
.IF    .caht
	BEQ	WB,=ch_ht,gtna9		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WB,=ch_vt,gtna9		; jump if vertical tab
.FI
	BNE	WB,=ch_bl,gtn36		; error if non-blank
gtna9	BCT	WA,gtn09		; loop back if more chars to check
	BRN	gtn07			; return integer if all blanks
.IF    .cnra
.ELSE
;
;      loop to collect mantissa of real
;
gtn10	LCH	WB,(XR)+		; load next character
	BLT	WB,=ch_d0,gtn12		; jump if non-numeric
	BGT	WB,=ch_d9,gtn12		; jump if non-numeric
;
;      merge here to collect first real digit
;
gtn11	SUB	WB,=ch_d0		; convert digit to number
	MLR	reavt			; multiply real by 10.0
	ROV	gtn36			; convert error if overflow
	STR	gtnsr			; save result
	MTI	WB			; get new digit as integer
	ITR				; convert new digit to real
	ADR	gtnsr			; add to get new total
	ADD	gtnsc,gtndf		; increment scale if after dec point
	MNZ	gtnrd			; set digit found flag
	BCT	WA,gtn10		; loop back if more chars
	BRN	gtn22			; else jump to scale
	EJC
;
;      gtnum (continued)
;
;      here if non-digit found while collecting a real
;
gtn12	BNE	WB,=ch_dt,gtn13		; jump if not dec point
	BNZ	gtndf,gtn36		; if dec point, error if one already
	MOV	gtndf,=num01		; else set flag for dec point
	BCT	WA,gtn10		; loop back if more chars
	BRN	gtn22			; else jump to scale
;
;      here if not decimal point
;
gtn13	BEQ	WB,=ch_le,gtn15		; jump if e for exponent
	BEQ	WB,=ch_ld,gtn15		; jump if d for exponent
.IF    .culc
	BEQ	WB,=ch_ue,gtn15		; jump if e for exponent
	BEQ	WB,=ch_ud,gtn15		; jump if d for exponent
.FI
;
;      here check for trailing blanks
;
gtn14	BEQ	WB,=ch_bl,gtnb4		; jump if blank
.IF    .caht
	BEQ	WB,=ch_ht,gtnb4		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WB,=ch_vt,gtnb4		; jump if vertical tab
.FI
	BRN	gtn36			; error if non-blank
;
gtnb4	LCH	WB,(XR)+		; get next character
	BCT	WA,gtn14		; loop back to check if more
	BRN	gtn22			; else jump to scale
;
;      here to read and process an exponent
;
gtn15	ZER	gtnes			; set exponent sign positive
	LDI	intv0			; initialize exponent to zero
	MNZ	gtndf			; reset no dec point indication
	BCT	WA,gtn16		; jump skipping past e or d
	BRN	gtn36			; error if null exponent
;
;      check for exponent sign
;
gtn16	LCH	WB,(XR)+		; load first exponent character
	BEQ	WB,=ch_pl,gtn17		; jump if plus sign
	BNE	WB,=ch_mn,gtn19		; else jump if not minus sign
	MNZ	gtnes			; set sign negative if minus sign
;
;      merge here after processing exponent sign
;
gtn17	BCT	WA,gtn18		; jump if chars left
	BRN	gtn36			; else error
;
;      loop to convert exponent digits
;
gtn18	LCH	WB,(XR)+		; load next character
	EJC
;
;      gtnum (continued)
;
;      merge here for first exponent digit
;
gtn19	BLT	WB,=ch_d0,gtn20		; jump if not digit
	BGT	WB,=ch_d9,gtn20		; jump if not digit
	CVM	gtn36			; else current*10, subtract new digit
	BCT	WA,gtn18		; loop back if more chars
	BRN	gtn21			; jump if exponent field is exhausted
;
;      here to check for trailing blanks after exponent
;
gtn20	BEQ	WB,=ch_bl,gtnc0		; jump if blank
.IF    .caht
	BEQ	WB,=ch_ht,gtnc0		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WC,=ch_vt,gtnc0		; jump if vertical tab
.FI
	BRN	gtn36			; error if non-blank
;
gtnc0	LCH	WB,(XR)+		; get next character
	BCT	WA,gtn20		; loop back till all blanks scanned
;
;      merge here after collecting exponent
;
gtn21	STI	gtnex			; save collected exponent
	BNZ	gtnes,gtn22		; jump if it was negative
	NGI				; else complement
	IOV	gtn36			; error if overflow
	STI	gtnex			; and store positive exponent
;
;      merge here with exponent (0 if none given)
;
gtn22	BZE	gtnrd,gtn36		; error if not digits collected
	BZE	gtndf,gtn36		; error if no exponent or dec point
	MTI	gtnsc			; else load scale as integer
	SBI	gtnex			; subtract exponent
	IOV	gtn36			; error if overflow
	ILT	gtn26			; jump if we must scale up
;
;      here we have a negative exponent, so scale down
;
	MFI	WA,gtn36		; load scale factor, err if ovflow
;
;      loop to scale down in steps of 10**10
;
gtn23	BLE	WA,=num10,gtn24		; jump if 10 or less to go
	DVR	reatt			; else divide by 10**10
	SUB	WA,=num10		; decrement scale
	BRN	gtn23			; and loop back
	EJC
;
;      gtnum (continued)
;
;      here scale rest of way from powers of ten table
;
gtn24	BZE	WA,gtn30		; jump if scaled
	LCT	WB,=cfp_r		; else get indexing factor
	MOV	XR,=reav1		; point to powers of ten table
	WTB	WA			; convert remaining scale to byte ofs
;
;      loop to point to powers of ten table entry
;
gtn25	ADD	XR,WA			; bump pointer
	BCT	WB,gtn25		; once for each value word
	DVR	(XR)			; scale down as required
	BRN	gtn30			; and jump
;
;      come here to scale result up (positive exponent)
;
gtn26	NGI				; get absolute value of exponent
	IOV	gtn36			; error if overflow
	MFI	WA,gtn36		; acquire scale, error if ovflow
;
;      loop to scale up in steps of 10**10
;
gtn27	BLE	WA,=num10,gtn28		; jump if 10 or less to go
	MLR	reatt			; else multiply by 10**10
	ROV	gtn36			; error if overflow
	SUB	WA,=num10		; else decrement scale
	BRN	gtn27			; and loop back
;
;      here to scale up rest of way with table
;
gtn28	BZE	WA,gtn30		; jump if scaled
	LCT	WB,=cfp_r		; else get indexing factor
	MOV	XR,=reav1		; point to powers of ten table
	WTB	WA			; convert remaining scale to byte ofs
;
;      loop to point to proper entry in powers of ten table
;
gtn29	ADD	XR,WA			; bump pointer
	BCT	WB,gtn29		; once for each word in value
	MLR	(XR)			; scale up
	ROV	gtn36			; error if overflow
	EJC
;
;      gtnum (continued)
;
;      here with real value scaled and ready except for sign
;
gtn30	BZE	gtnnf,gtn31		; jump if positive
	NGR				; else negate
;
;      here with properly signed real value in (RA)
;
gtn31	JSR	rcbld			; build real block
	BRN	gtn33			; merge to exit
.FI
;
;      here with properly signed integer value in (ia)
;
gtn32	JSR	icbld			; build icblk
;
;      real merges here
;
gtn33	MOV	WA,(XR)			; load first word of result block
	ICA	XS			; pop argument off stack
;
;      common exit point
;
gtn34	EXI				; return to gtnum caller
.IF    .cnra
.ELSE
;
;      come here if overflow occurs during collection of integer
;      have to restore WB which cvm may have destroyed.
;
gtn35	LCH	WB,-(XR)		; reload current character
	LCH	WB,(XR)+		; bump character pointer
	LDI	gtnsi			; reload integer so far
	ITR				; convert to real
	NGR				; make value positive
	BRN	gtn11			; merge with real circuit
.FI
;
;      here for unconvertible to string or conversion error
;
gtn36	MOV	XR,(XS)+		; reload original argument
	EXI	1			; take convert-error exit
	ENP				; end procedure gtnum
	EJC
;
;      gtnvr -- convert to natural vaRIAble
;
;      gtnvr locates a vaRIAble block (vrblk) given either an
;      appropriate name (nmblk) or a non-null string (scblk).
;
;      (XR)		     argument
;      jsr  gtnvr	     call to convert to natural vaRIAble
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to vrblk
;      (wa,WB)		     destroyed (conversion error only)
;      (WC)		     destroyed
;
gtnvr	PRC	e,1			; entry point
;z-
	BNE	(XR),=b_nml,gnv02	; jump if not name
	MOV	XR,nmbas(XR)		; else load name base if name
	BLO	XR,state,gnv07		; skip if vrblk (in static region)
;
;      common error exit
;
gnv01	EXI	1			; take convert-error exit
;
;      here if not name
;
gnv02	MOV	gnvsa,WA		; save wa
	MOV	gnvsb,WB		; save WB
	MOV	-(XS),XR		; stack argument for gtstg
	JSR	gtstg			; convert argument to string
	PPM	gnv01			; jump if conversion error
	BZE	WA,gnv01		; null string is an error
.IF    .culc
	JSR	flstg			; fold upper case to lower case
.FI
	MOV	-(XS),XL		; save XL
	MOV	-(XS),XR		; stack string ptr for later
	MOV	WB,XR			; copy string pointer
	ADD	WB,*schar		; point to characters of string
	MOV	gnvst,WB		; save pointer to characters
	MOV	WB,WA			; copy length
	CTW	WB,0			; get number of words in name
	MOV	gnvnw,WB		; save for later
	JSR	hashs			; compute hash index for string
	RMI	hshnb			; compute hash offset by taking mod
	MFI	WC			; get as offset
	WTB	WC			; convert offset to bytes
	ADD	WC,hshtb		; point to proper hash chain
	SUB	WC,*vrnxt		; subtract offset to merge into loop
	EJC
;
;      gtnvr (continued)
;
;      loop to search hash chain
;
gnv03	MOV	XL,WC			; copy hash chain pointer
	MOV	XL,vrnxt(XL)		; point to next vrblk on chain
	BZE	XL,gnv08		; jump if end of chain
	MOV	WC,XL			; save pointer to this vrblk
	BNZ	vrlen(XL),gnv04		; jump if not system vaRIAble
	MOV	XL,vrsvp(XL)		; else point to svblk
	SUB	XL,*vrsof		; adjust offset for merge
;
;      merge here with string ptr (like vrblk) in XL
;
gnv04	BNE	WA,vrlen(XL),gnv03	; back for next vrblk if lengths ne
	ADD	XL,*vrchs		; else point to chars of chain entry
	LCT	WB,gnvnw		; get word counter to control loop
	MOV	XR,gnvst		; point to chars of new name
;
;      loop to compare characters of the two names
;
gnv05	CNE	(XR),(XL),gnv03		; jump if no match for next vrblk
	ICA	XR			; bump new name pointer
	ICA	XL			; bump vrblk in chain name pointer
	BCT	WB,gnv05		; else loop till all compared
	MOV	XR,WC			; we have found a match, get vrblk
;
;      exit point after finding vrblk or building new one
;
gnv06	MOV	WA,gnvsa		; restore wa
	MOV	WB,gnvsb		; restore WB
	ICA	XS			; pop string pointer
	MOV	XL,(XS)+		; restore XL
;
;      common exit point
;
gnv07	EXI				; return to gtnvr caller
;
;      not found, prepare to search system vaRIAble table
;
gnv08	ZER	XR			; clear garbage XR pointer
	MOV	gnvhe,WC		; save ptr to end of hash chain
	BGT	WA,=num09,gnv14		; cannot be system var if length gt 9
	MOV	XL,WA			; else copy length
	WTB	XL			; convert to byte offset
	MOV	XL,vsrch(XL)		; point to first svblk of this length
	EJC
;
;      gtnvr (continued)
;
;      loop to search entries in standard vaRIAble table
;
gnv09	MOV	gnvsp,XL		; save table pointer
	MOV	WC,(XL)+		; load svbit bit string
	MOV	WB,(XL)+		; load length from table entry
	BNE	WA,WB,gnv14		; jump if end of right length entries
	LCT	WB,gnvnw		; get word counter to control loop
	MOV	XR,gnvst		; point to chars of new name
;
;      loop to check for matching names
;
gnv10	CNE	(XR),(XL),gnv11		; jump if name mismatch
	ICA	XR			; else bump new name pointer
	ICA	XL			; bump svblk pointer
	BCT	WB,gnv10		; else loop until all checked
;
;      here we have a match in the standard vaRIAble table
;
	ZER	WC			; set vrlen value zero
	MOV	WA,*vrsi_		; set standard size
	BRN	gnv15			; jump to build vrblk
;
;      here if no match with table entry in svblks table
;
gnv11	ICA	XL			; bump past word of chars
	BCT	WB,gnv11		; loop back if more to go
	RSH	WC,svnbt		; remove uninteresting bits
;
;      loop to bump table ptr for each flagged word
;
gnv12	MOV	WB,bits1		; load bit to test
	ANB	WB,WC			; test for word present
	ZRB	WB,gnv13		; jump if not present
	ICA	XL			; else bump table pointer
;
;      here after dealing with one word (one bit)
;
gnv13	RSH	WC,1			; remove bit already processed
	NZB	WC,gnv12		; loop back if more bits to test
	BRN	gnv09			; else loop back for next svblk
;
;      here if not system vaRIAble
;
gnv14	MOV	WC,WA			; copy vrlen value
	MOV	WA,=vrchs		; load standard size -chars
	ADD	WA,gnvnw		; adjust for chars of name
	WTB	WA			; convert length to bytes
	EJC
;
;      gtnvr (continued)
;
;      merge here to build vrblk
;
gnv15	JSR	alost			; allocate space for vrblk (static)
	MOV	WB,XR			; save vrblk pointer
	MOV	XL,=stnvr		; point to model vaRIAble block
	MOV	WA,*vrlen		; set length of standard fields
	MVW				; set initial fields of new block
	MOV	XL,gnvhe		; load pointer to end of hash chain
	MOV	vrnxt(XL),WB		; add new block to end of chain
	MOV	(XR)+,WC		; set vrlen field, bump ptr
	MOV	WA,gnvnw		; get length in words
	WTB	WA			; convert to length in bytes
	BZE	WC,gnv16		; jump if system vaRIAble
;
;      here for non-system vaRIAble -- set chars of name
;
	MOV	XL,(XS)			; point back to string name
	ADD	XL,*schar		; point to chars of name
	MVW				; move characters into place
	MOV	XR,WB			; restore vrblk pointer
	BRN	gnv06			; jump back to exit
;
;      here for system vaRIAble case to fill in fields where
;      necessary from the fields present in the svblk.
;
gnv16	MOV	XL,gnvsp		; load pointer to svblk
	MOV	(XR),XL			; set svblk ptr in vrblk
	MOV	XR,WB			; restore vrblk pointer
	MOV	WB,svbit(XL)		; load bit indicators
	ADD	XL,*svchs		; point to characters of name
	ADD	XL,WA			; point past characters
;
;      skip past keyword number (svknm) if present
;
	MOV	WC,btknm		; load test bit
	ANB	WC,WB			; and to test
	ZRB	WC,gnv17		; jump if no keyword number
	ICA	XL			; else bump pointer
	EJC
;
;      gtnvr (continued)
;
;      here test for function (svfnc and svnar)
;
gnv17	MOV	WC,btfnc		; get test bit
	ANB	WC,WB			; and to test
	ZRB	WC,gnv18		; skip if no system function
	MOV	vrfnc(XR),XL		; else point vrfnc to svfnc field
	ADD	XL,*num02		; and bump past svfnc, svnar fields
;
;      now test for label (svlbl)
;
gnv18	MOV	WC,btlbl		; get test bit
	ANB	WC,WB			; and to test
	ZRB	WC,gnv19		; jump if bit is off (no system labl)
	MOV	vrlbl(XR),XL		; else point vrlbl to svlbl field
	ICA	XL			; bump past svlbl field
;
;      now test for value (svval)
;
gnv19	MOV	WC,btval		; load test bit
	ANB	WC,WB			; and to test
	ZRB	WC,gnv06		; all done if no value
	MOV	vrval(XR),(XL)		; else set initial value
	MOV	vrsto(XR),=b_vre	; set error store access
	BRN	gnv06			; merge back to exit to caller
	ENP				; end procedure gtnvr
	EJC
;
;      gtpat -- get pattern
;
;      gtpat is passed an object in (XR) and returns a
;      pattern after performing any necessary conversions
;
;      (XR)		     input argument
;      jsr  gtpat	     call to convert to pattern
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     resulting pattern
;      (wa)		     destroyed
;      (WB)		     destroyed (only on convert error)
;      (XR)		     unchanged (only on convert error)
;
gtpat	PRC	e,1			; entry point
;z+
	BHI	(XR),=p_aaa,gtpt5	; jump if pattern already
;
;      here if not pattern, try for string
;
	MOV	gtpsb,WB		; save WB
	MOV	-(XS),XR		; stack argument for gtstg
	JSR	gtstg			; convert argument to string
	PPM	gtpt2			; jump if impossible
;
;      here we have a string
;
	BNZ	WA,gtpt1		; jump if non-null
;
;      here for null string. generate pointer to null pattern.
;
	MOV	XR,=ndnth		; point to nothen node
	BRN	gtpt4			; jump to exit
	EJC
;
;      gtpat (continued)
;
;      here for non-null string
;
gtpt1	MOV	WB,=p_str		; load pcode for multi-char string
	BNE	WA,=num01,gtpt3		; jump if multi-char string
;
;      here for one character string, share one character any
;
	PLC	XR			; point to character
	LCH	WA,(XR)			; load character
	MOV	XR,WA			; set as parm1
	MOV	WB,=p_ans		; point to pcode for 1-char any
	BRN	gtpt3			; jump to build node
;
;      here if argument is not convertible to string
;
gtpt2	MOV	WB,=p_exa		; set pcode for expression in case
	BLO	(XR),=b_e__,gtpt3	; jump to build node if expression
;
;      here we have an error (conversion impossible)
;
	EXI	1			; take convert error exit
;
;      merge here to build node for string or expression
;
gtpt3	JSR	pbild			; call routine to build pattern node
;
;      common exit after successful conversion
;
gtpt4	MOV	WB,gtpsb		; restore WB
;
;      merge here to exit if no conversion required
;
gtpt5	EXI				; return to gtpat caller
	ENP				; end procedure gtpat
.IF    .cnra
.ELSE
	EJC
;
;      gtrea -- get real value
;
;      gtrea is passed an object and returns a real value
;      performing any necessary conversions.
;
;      (XR)		     object to be converted
;      jsr  gtrea	     call to convert object to real
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to resulting real
;      (wa,WB,WC,ra)	     destroyed
;      (XR)		     unchanged (convert error only)
;
gtrea	PRC	e,1			; entry point
	MOV	WA,(XR)			; get first word of block
	BEQ	WA,=b_rcl,gtre2		; jump if real
	JSR	gtnum			; else convert argument to numeric
	PPM	gtre3			; jump if unconvertible
	BEQ	WA,=b_rcl,gtre2		; jump if real was returned
;
;      here for case of an integer to convert to real
;
gtre1	LDI	icval(XR)		; load integer
	ITR				; convert to real
	JSR	rcbld			; build rcblk
;
;      exit with real
;
gtre2	EXI				; return to gtrea caller
;
;      here on conversion error
;
gtre3	EXI	1			; take convert error exit
	ENP				; end procedure gtrea
.FI
	EJC
;
;      gtsmi -- get small integer
;
;      gtsmi is passed a snobol object and returns an address
;      integer in the range (0 le n le dnamb). such a value can
;      only be derived from an integer in the appropriate range.
;      small integers never appear as snobol values. however,
;      they are used internally for a variety of purposes.
;
;      -(XS)		     argument to convert (on stack)
;      jsr  gtsmi	     call to convert to small integer
;      ppm  loc		     transfer loc for not integer
;      ppm  loc		     transfer loc for lt 0, gt dnamb
;      (XR,WC)		     resulting small int (two copies)
;      (XS)		     popped
;      (RA)		     destroyed
;      (wa,WB)		     destroyed (on convert error only)
;      (XR)		     input arg (convert error only)
;
gtsmi	PRC	n,2			; entry point
	MOV	XR,(XS)+		; load argument
	BEQ	(XR),=b_icl,gtsm1	; skip if already an integer
;
;      here if not an integer
;
	JSR	gtint			; convert argument to integer
	PPM	gtsm2			; jump if convert is impossible
;
;      merge here with integer
;
gtsm1	LDI	icval(XR)		; load integer value
	MFI	WC,gtsm3		; move as one word, jump if ovflow
	BGT	WC,mxlen,gtsm3		; or if too large
	MOV	XR,WC			; copy result to XR
	EXI				; return to gtsmi caller
;
;      here if unconvertible to integer
;
gtsm2	EXI	1			; take non-integer error exit
;
;      here if out of range
;
gtsm3	EXI	2			; take out-of-range error exit
	ENP				; end procedure gtsmi
	EJC
.IF    .cnbf
.ELSE
;
;      gtstb -- get string or buffer
;
;      gtstb is passed an object and returns it unchanged if
;      it is a buffer block, else it returns it as a string with
;      any necessary conversions performed.
;
;      -(XS)		     input argument (on stack)
;      jsr  gtstb	     call to get buffer or cnvrt to stg
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to resulting scblk or bfblk
;      (wa)		     length of string in characters
;      (WB)		     zero/bcblk if string/buffer
;      (XS)		     popped
;      (RA)		     destroyed
;      (XR)		     input arg (convert error only)
;
gtstb	PRC	n,1			; entry point
	MOV	XR,(XS)			; load argument, leave on stack
	MOV	WA,(XR)			; load block type
	BEQ	WA,=b_scl,gtsb2		; jump if already a string
	BEQ	WA,=b_bct,gtsb3		; jump if already a buffer
	JSR	gtstg			; convert to string
	PPM	gtsb1			; conversion failed
	ZER	WB			; signal string result
	EXI				; convert with string result
;
;      here if conversion failed
;
gtsb1	EXI	1			; take convert error exit
;
;      here if a string already
;
gtsb2	ICA	XS			; pop argument
	MOV	WA,sclen(XR)		; load string length
	ZER	WB			; signal string result
	EXI				; return with string result
;
;      here if it is already a buffer
;
gtsb3	ICA	XS			; pop argument
	MOV	WA,bclen(XR)		; load length of string in buffer
	MOV	WB,XR			; return bcblk pointer in WB
	MOV	XR,bcbuf(XR)		; return bfblk pointer in XR
	EXI				; return with buffer result
	ENP				; end procedure gtstg
	EJC
.FI
;
;      gtstg -- get string
;
;      gtstg is passed an object and returns a string with
;      any necessary conversions performed.
;
;      -(XS)		     input argument (on stack)
;      jsr  gtstg	     call to convert to string
;      ppm  loc		     transfer loc if convert impossible
;      (XR)		     pointer to resulting string
;      (wa)		     length of string in characters
;      (XS)		     popped
;      (RA)		     destroyed
;      (XR)		     input arg (convert error only)
;
gtstg	PRC	n,1			; entry point
	MOV	XR,(XS)+		; load argument, pop stack
	BEQ	(XR),=b_scl,gts30	; jump if already a string
;
;      here if not a string already
;
gts01	MOV	-(XS),XR		; restack argument in case error
	MOV	-(XS),XL		; save XL
	MOV	gtsvb,WB		; save WB
	MOV	gtsvc,WC		; save WC
	MOV	WA,(XR)			; load first word of block
	BEQ	WA,=b_icl,gts05		; jump to convert integer
.IF    .cnra
.ELSE
	BEQ	WA,=b_rcl,gts10		; jump to convert real
.FI
	BEQ	WA,=b_nml,gts03		; jump to convert name
.IF    .cnbf
.ELSE
	BEQ	WA,=b_bct,gts32		; jump to convert buffer
.FI
;
;      here on conversion error
;
gts02	MOV	XL,(XS)+		; restore XL
	MOV	XR,(XS)+		; reload input argument
	EXI	1			; take convert error exit
	EJC
;
;      gtstg (continued)
;
;      here to convert a name (only possible if natural var)
;
gts03	MOV	XL,nmbas(XR)		; load name base
	BHI	XL,state,gts02		; error if not natural var (static)
	ADD	XL,*vrsof		; else point to possible string name
	MOV	WA,sclen(XL)		; load length
	BNZ	WA,gts04		; jump if not system vaRIAble
	MOV	XL,vrsvo(XL)		; else point to svblk
	MOV	WA,svlen(XL)		; and load name length
;
;      merge here with string in XR, length in wa
;
gts04	ZER	WB			; set offset to zero
	JSR	sbstr			; use sbstr to copy string
	BRN	gts29			; jump to exit
;
;      come here to convert an integer
;
gts05	LDI	icval(XR)		; load integer value
.IF    .cnci
	JSR	sysci			; convert integer
	MOV	WA,sclen(XL)		; get length
	ZER	WB			; zero offset for sbstr
	JSR	sbstr			; copy in result from sysci
	BRN	gts29			; exit
.ELSE
	MOV	gtssf,=num01		; set sign flag negative
	ILT	gts06			; skip if integer is negative
	NGI				; else negate integer
	ZER	gtssf			; and reset negative flag
	EJC
;
;      gtstg (continued)
;
;      here with sign flag set and sign forced negative as
;      required by the cvd instruction.
;
gts06	MOV	XR,gtswk		; point to result work area
	MOV	WB,=nstmx		; initialize counter to max length
	PSC	XR,WB			; prepare to store (right-left)
;
;      loop to convert digits into work area
;
gts07	CVD				; convert one digit into wa
	SCH	WA,-(XR)		; store in work area
	DCV	WB			; decrement counter
	INE	gts07			; loop if more digits to go
	CSC	XR			; complete store characters
.FI
;
;      merge here after converting integer or real into work
;      area. WB is set to nstmx - (number of chars in result).
;
gts08	MOV	WA,=nstmx		; get max number of characters
	SUB	WA,WB			; compute length of result
	MOV	XL,WA			; remember length for move later on
	ADD	WA,gtssf		; add one for negative sign if needed
	JSR	alocs			; allocate string for result
	MOV	WC,XR			; save result pointer for the moment
	PSC	XR			; point to chars of result block
	BZE	gtssf,gts09		; skip if positive
	MOV	WA,=ch_mn		; else load negative sign
	SCH	WA,(XR)+		; and store it
	CSC	XR			; complete store characters
;
;      here after dealing with sign
;
gts09	MOV	WA,XL			; recall length to move
	MOV	XL,gtswk		; point to result work area
	PLC	XL,WB			; point to first result character
	MVC				; move chars to result string
	MOV	XR,WC			; restore result pointer
.IF    .cnra
.ELSE
	BRN	gts29			; jump to exit
	EJC
;
;      gtstg (continued)
;
;      here to convert a real
;
gts10	LDR	rcval(XR)		; load real
.IF    .cncr
	MOV	WA,=nstmr		; max number of result chars
	ZER	XL			; clear dud value
	JSR	alocs			; allocate result area
	MOV	WA,=cfp_s		; significant digits to produce
	ZER	WB			; conversion type
	JSR	syscr			; convert real to string
	MOV	sclen(XR),WA		; store result size
	ZER	WB			; no trailing blanks to remove
	JSR	trimr			; discard excess memory
.ELSE
	ZER	gtssf			; reset negative flag
	REQ	gts31			; skip if zero
	RGE	gts11			; jump if real is positive
	MOV	gtssf,=num01		; else set negative flag
	NGR				; and get absolute value of real
;
;      now scale the real to the range (0.1 le x lt 1.0)
;
gts11	LDI	intv0			; initialize exponent to zero
;
;      loop to scale up in steps of 10**10
;
gts12	STR	gtsrs			; save real value
	SBR	reap1			; subtract 0.1 to compare
	RGE	gts13			; jump if scale up not required
	LDR	gtsrs			; else reload value
	MLR	reatt			; multiply by 10**10
	SBI	intvt			; decrement exponent by 10
	BRN	gts12			; loop back to test again
;
;      test for scale down required
;
gts13	LDR	gtsrs			; reload value
	SBR	reav1			; subtract 1.0
	RLT	gts17			; jump if no scale down required
	LDR	gtsrs			; else reload value
;
;      loop to scale down in steps of 10**10
;
gts14	SBR	reatt			; subtract 10**10 to compare
	RLT	gts15			; jump if large step not required
	LDR	gtsrs			; else restore value
	DVR	reatt			; divide by 10**10
	STR	gtsrs			; store new value
	ADI	intvt			; increment exponent by 10
	BRN	gts14			; loop back
	EJC
;
;      gtstg (continued)
;
;      at this point we have (1.0 le x lt 10**10)
;      complete scaling with powers of ten table
;
gts15	MOV	XR,=reav1		; point to powers of ten table
;
;      loop to locate correct entry in table
;
gts16	LDR	gtsrs			; reload value
	ADI	intv1			; increment exponent
	ADD	XR,*cfp_r		; point to next entry in table
	SBR	(XR)			; subtract it to compare
	RGE	gts16			; loop till we find a larger entry
	LDR	gtsrs			; then reload the value
	DVR	(XR)			; and complete scaling
	STR	gtsrs			; store value
;
;      we are now scaled, so round by adding 0.5 * 10**(-cfp_s)
;
gts17	LDR	gtsrs			; get value again
	ADR	gtsrn			; add rounding factor
	STR	gtsrs			; store result
;
;      the rounding operation may have pushed us up past
;      1.0 again, so check one more time.
;
	SBR	reav1			; subtract 1.0 to compare
	RLT	gts18			; skip if ok
	ADI	intv1			; else increment exponent
	LDR	gtsrs			; reload value
	DVR	reavt			; divide by 10.0 to rescale
	BRN	gts19			; jump to merge
;
;      here if rounding did not muck up scaling
;
gts18	LDR	gtsrs			; reload rounded value
	EJC
;
;      gtstg (continued)
;
;      now we have completed the scaling as follows
;
;      (ia)		     signed exponent
;      (RA)		     scaled real (absolute value)
;
;      if the exponent is negative or greater than cfp_s, then
;      we convert the number in the form.
;
;      (neg sign) 0 . (cpf_s digits) e (exp sign) (exp digits)
;
;      if the exponent is positive and less than or equal to
;      cfp_s, the number is converted in the form.
;
;      (neg sign) (exponent digits) . (cfp_s-exponent digits)
;
;      in both cases, the formats obtained from the above
;      rules are modified by deleting trailing zeros after the
;      decimal point. there are no leading zeros in the exponent
;      and the exponent sign is always present.
;
gts19	MOV	XL,=cfp_s		; set num dec digits = cfp_s
	MOV	gtses,=ch_mn		; set exponent sign negative
	ILT	gts21			; all set if exponent is negative
	MFI	WA			; else fetch exponent
	BLE	WA,=cfp_s,gts20		; skip if we can use special format
	MTI	WA			; else restore exponent
	NGI				; set negative for cvd
	MOV	gtses,=ch_pl		; set plus sign for exponent sign
	BRN	gts21			; jump to generate exponent
;
;      here if we can use the format without an exponent
;
gts20	SUB	XL,WA			; compute digits after decimal point
	LDI	intv0			; reset exponent to zero
	EJC
;
;      gtstg (continued)
;
;      merge here as follows
;
;      (ia)		     exponent absolute value
;      gtses		     character for exponent sign
;      (RA)		     positive fraction
;      (XL)		     number of digits after dec point
;
gts21	MOV	XR,gtswk		; point to work area
	MOV	WB,=nstmx		; set character ctr to max length
	PSC	XR,WB			; prepare to store (right to left)
	IEQ	gts23			; skip exponent if it is zero
;
;      loop to generate digits of exponent
;
gts22	CVD				; convert a digit into wa
	SCH	WA,-(XR)		; store in work area
	DCV	WB			; decrement counter
	INE	gts22			; loop back if more digits to go
;
;      here generate exponent sign and e
;
	MOV	WA,gtses		; load exponent sign
	SCH	WA,-(XR)		; store in work area
	MOV	WA,=ch_le		; get character letter e
	SCH	WA,-(XR)		; store in work area
	SUB	WB,=num02		; decrement counter for sign and e
;
;      here to generate the fraction
;
gts23	MLR	gtssc			; convert real to integer (10**cfp_s)
	RTI				; get integer (overflow impossible)
	NGI				; negate as required by cvd
;
;      loop to suppress trailing zeros
;
gts24	BZE	XL,gts27		; jump if no digits left to do
	CVD				; else convert one digit
	BNE	WA,=ch_d0,gts26		; jump if not a zero
	DCV	XL			; decrement counter
	BRN	gts24			; loop back for next digit
	EJC
;
;      gtstg (continued)
;
;      loop to generate digits after decimal point
;
gts25	CVD				; convert a digit into wa
;
;      merge here first time
;
gts26	SCH	WA,-(XR)		; store digit
	DCV	WB			; decrement counter
	DCV	XL			; decrement counter
	BNZ	XL,gts25		; loop back if more to go
;
;      here generate the decimal point
;
gts27	MOV	WA,=ch_dt		; load decimal point
	SCH	WA,-(XR)		; store in work area
	DCV	WB			; decrement counter
;
;      here generate the digits before the decimal point
;
gts28	CVD				; convert a digit into wa
	SCH	WA,-(XR)		; store in work area
	DCV	WB			; decrement counter
	INE	gts28			; loop back if more to go
	CSC	XR			; complete store characters
	BRN	gts08			; else jump back to exit
.FI
.FI
;
;      exit point after successful conversion
;
gts29	MOV	XL,(XS)+		; restore XL
	ICA	XS			; pop argument
	MOV	WB,gtsvb		; restore WB
	MOV	WC,gtsvc		; restore WC
;
;      merge here if no conversion required
;
gts30	MOV	WA,sclen(XR)		; load string length
	EXI				; return to caller
.IF    .cnra
.ELSE
;
;      here to return string for real zero
;
gts31	MOV	XL,=scre0		; point to string
	MOV	WA,=num02		; 2 chars
	ZER	WB			; zero offset
	JSR	sbstr			; copy string
	BRN	gts29			; return
.FI
.IF    .cnbf
.ELSE
	EJC
;
;      here to convert a buffer block
;
gts32	MOV	XL,XR			; copy arg ptr
	MOV	WA,bclen(XL)		; get size to allocate
	BZE	WA,gts33		; if null then return null
	JSR	alocs			; allocate string frame
	MOV	WB,XR			; save string ptr
	MOV	WA,sclen(XR)		; get length to move
	CTB	WA,0			; get as multiple of word size
	MOV	XL,bcbuf(XL)		; point to bfblk
	ADD	XR,*scsi_		; point to start of character area
	ADD	XL,*bfsi_		; point to start of buffer chars
	MVW				; copy words
	MOV	XR,WB			; restore scblk ptr
	BRN	gts29			; exit with scblk
;
;      here when null buffer is being converted
;
gts33	MOV	XR,=nulls		; point to null
	BRN	gts29			; exit with null
.FI
	ENP				; end procedure gtstg
	EJC
;
;      gtvar -- get vaRIAble for i/o/trace association
;
;      gtvar is used to point to an actual vaRIAble location
;      for the detach,input,output,trace,stoptr system functions
;
;      (XR)		     argument to function
;      jsr  gtvar	     call to locate vaRIAble pointer
;      ppm  loc		     transfer loc if not ok vaRIAble
;      (XL,WA)		     name base,offset of vaRIAble
;      (XR,ra)		     destroyed
;      (WB,WC)		     destroyed (convert error only)
;      (XR)		     input arg (convert error only)
;
gtvar	PRC	e,1			; entry point
	BNE	(XR),=b_nml,gtvr2	; jump if not a name
	MOV	WA,nmofs(XR)		; else load name offset
	MOV	XL,nmbas(XR)		; load name base
	BEQ	(XL),=b_evt,gtvr1	; error if expression vaRIAble
	BNE	(XL),=b_kvt,gtvr3	; all ok if not keyword vaRIAble
;
;      here on conversion error
;
gtvr1	EXI	1			; take convert error exit
;
;      here if not a name, try convert to natural vaRIAble
;
gtvr2	MOV	gtvrc,WC		; save WC
	JSR	gtnvr			; locate vrblk if possible
	PPM	gtvr1			; jump if convert error
	MOV	XL,XR			; else copy vrblk name base
	MOV	WA,*vrval		; and set offset
	MOV	WC,gtvrc		; restore WC
;
;      here for name obtained
;
gtvr3	BHI	XL,state,gtvr4		; all ok if not natural vaRIAble
	BEQ	vrsto(XL),=b_vre,gtvr1	; error if protected vaRIAble
;
;      common exit point
;
gtvr4	EXI				; return to caller
	ENP				; end procedure gtvar
	EJC
	EJC
;
;      hashs -- compute hash index for string
;
;      hashs is used to convert a string to a unique integer
;      value. the resulting hash value is a positive integer
;      in the range 0 to cfp_m
;
;      (XR)		     string to be hashed
;      jsr  hashs	     call to hash string
;      (ia)		     hash value
;      (XR,WB,WC)	     destroyed
;
;      the hash function used is as follows.
;
;      start with the length of the string.
;
;      if there is more than one character in a word,
;      take the first e_hnw words of the characters from
;      the string or all the words if fewer than e_hnw.
;
;      compute the exclusive or of all these words treating
;      them as one word bit string values.
;
;      if there is just one character in a word,
;      then mimic the word by word hash by shifting
;      successive characters to get a similar effect.
;
;      e_hnw is set to zero in case only one character per word.
;
;      move the result as an integer with the mti instruction.
;
;      the test on e_hnw is done dynamically. this should be done
;      eventually using conditional assembly, but that would require
;      changes to the build process (ds 8 may 2013).
;
hashs	PRC	e,0			; entry point
;z-
	MOV	WC,=e_hnw		; get number of words to use
	BZE	WC,hshsa		; branch if one character per word
	MOV	WC,sclen(XR)		; load string length in characters
	MOV	WB,WC			; initialize with length
	BZE	WC,hshs3		; jump if null string
	ZGB	WB			; correct byte ordering if necessary
	CTW	WC,0			; get number of words of chars
	ADD	XR,*schar		; point to characters of string
	BLO	WC,=e_hnw,hshs1		; use whole string if short
	MOV	WC,=e_hnw		; else set to involve first e_hnw wds
;
;      here with count of words to check in WC
;
hshs1	LCT	WC,WC			; set counter to control loop
;
;      loop to compute exclusive or
;
hshs2	XOB	WB,(XR)+		; exclusive or next word of chars
	BCT	WC,hshs2		; loop till all processed
;
;      merge here with exclusive or in WB
;
hshs3	ZGB	WB			; zeroise undefined bits
	ANB	WB,bitsm		; ensure in range 0 to cfp_m
	MTI	WB			; move result as integer
	ZER	XR			; clear garbage value in XR
	EXI				; return to hashs caller
;
;      here if just one character per word
;
hshsa	MOV	WC,sclen(XR)		; load string length in characters
	MOV	WB,WC			; initialize with length
	BZE	WC,hshs3		; jump if null string
	ZGB	WB			; correct byte ordering if necessary
	CTW	WC,0			; get number of words of chars
	PLC	XR			;
	MOV	-(XS),XL		; save XL
	MOV	XL,WC			; load length for branch
	BGE	XL,=num25,hsh24		; use first characters if longer
	BSW	XL,25			; merge to compute hash
	IFF	0,hsh00			;
	IFF	1,hsh01			;
	IFF	2,hsh02			;
	IFF	3,hsh03			;
	IFF	4,hsh04			;
	IFF	5,hsh05			;
	IFF	6,hsh06			;
	IFF	7,hsh07			;
	IFF	8,hsh08			;
	IFF	9,hsh09			;
	IFF	10,hsh10		;
	IFF	11,hsh11		;
	IFF	12,hsh12		;
	IFF	13,hsh13		;
	IFF	14,hsh14		;
	IFF	15,hsh15		;
	IFF	16,hsh16		;
	IFF	17,hsh17		;
	IFF	18,hsh18		;
	IFF	19,hsh19		;
	IFF	20,hsh20		;
	IFF	21,hsh21		;
	IFF	22,hsh22		;
	IFF	23,hsh23		;
	IFF	24,hsh24		;
	ESW
hsh24	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh23	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh22	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh21	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh20	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh19	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh18	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh17	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh16	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh15	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh14	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh13	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh12	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh11	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh10	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh09	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh08	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh07	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh06	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh05	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh04	LCH	WC,(XR)+		; load next character
	LSH	WC,24			; shift for hash
	XOB	WB,WC			; hash character
hsh03	LCH	WC,(XR)+		; load next character
	LSH	WC,16			; shift for hash
	XOB	WB,WC			; hash character
hsh02	LCH	WC,(XR)+		; load next character
	LSH	WC,8			; shift for hash
	XOB	WB,WC			; hash character
hsh01	LCH	WC,(XR)+		; load next character
	XOB	WB,WC			; hash character
hsh00	MOV	XL,(XS)+		; restore XL
	BRN	hshs3			; merge to complete hash
	ENP				; end procedure hashs
;
;      icbld -- build integer block
;
;      (ia)		     integer value for icblk
;      jsr  icbld	     call to build integer block
;      (XR)		     pointer to result icblk
;      (wa)		     destroyed
;
icbld	PRC	e,0			; entry point
;z+
	MFI	XR,icbl1		; copy small integers
	BLE	XR,=num02,icbl3		; jump if 0,1 or 2
;
;      construct icblk
;
icbl1	MOV	XR,dnamp		; load pointer to next available loc
	ADD	XR,*icsi_		; point past new icblk
	BLO	XR,dname,icbl2		; jump if there is room
	MOV	WA,*icsi_		; else load length of icblk
	JSR	alloc			; use standard allocator to get block
	ADD	XR,WA			; point past block to merge
;
;      merge here with XR pointing past the block obtained
;
icbl2	MOV	dnamp,XR		; set new pointer
	SUB	XR,*icsi_		; point back to start of block
	MOV	(XR),=b_icl		; store type word
	STI	icval(XR)		; store integer value in icblk
	EXI				; return to icbld caller
;
;      optimise by not building icblks for small integers
;
icbl3	WTB	XR			; convert integer to offset
	MOV	XR,intab(XR)		; point to pre-built icblk
	EXI				; return
	ENP				; end procedure icbld
	EJC
;
;      ident -- compare two values
;
;      ident compares two values in the sense of the ident
;      differ functions available at the snobol level.
;
;      (XR)		     first argument
;      (XL)		     second argument
;      jsr  ident	     call to compare arguments
;      ppm  loc		     transfer loc if ident
;      (normal return if differ)
;      (XR,XL,WC,ra)	     destroyed
;
ident	PRC	e,1			; entry point
	BEQ	XR,XL,iden7		; jump if same pointer (ident)
	MOV	WC,(XR)			; else load arg 1 type word
.IF    .cnbf
	BNE	WC,(XL),iden1		; differ if arg 2 type word differ
.ELSE
	BNE	WC,(XL),iden0		; differ if arg 2 type word differ
.FI
	BEQ	WC,=b_scl,iden2		; jump if strings
	BEQ	WC,=b_icl,iden4		; jump if integers
.IF    .cnra
.ELSE
	BEQ	WC,=b_rcl,iden5		; jump if reals
.FI
	BEQ	WC,=b_nml,iden6		; jump if names
.IF    .cnbf
.ELSE
	BNE	WC,=b_bct,iden1		; jump if not buffers
;
;      here for buffers, ident only if lengths and chars same
;
	MOV	WC,bclen(XR)		; load arg 1 length
	BNE	WC,bclen(XL),iden1	; differ if lengths differ
	BZE	WC,iden7		; identical if length 0
	MOV	XR,bcbuf(XR)		; arg 1 buffer block
	MOV	XL,bcbuf(XL)		; arg 2 buffer block
	BRN	idn2a			; compare characters
;
;      here if the type words differ.
;      check if string/buffer comparison
;
iden0	BEQ	WC,=b_scl,idn0a		; jump if arg 1 is a string
	BNE	WC,=b_bct,iden1		; jump if arg 1 not string or buffer
;
;      here if arg 1 is a buffer
;
	BNE	(XL),=b_scl,iden1	; jump if arg 2 is not string
	MOV	WC,bclen(XR)		; load arg 1 length
	BNE	WC,sclen(XL),iden1	; differ if lengths differ
	BZE	WC,iden7		; identical if length 0
	MOV	XR,bcbuf(XR)		; arg 1 buffer block
	BRN	idn2a			; compare characters
;
;      here if arg 1 is a string
;
idn0a	BNE	(XL),=b_bct,iden1	; jump if arg 2 is not buffer
	MOV	WC,sclen(XR)		; load arg 1 length
	BNE	WC,bclen(XL),iden1	; differ if lengths differ
	BZE	WC,iden7		; identical if length 0
	MOV	XL,bcbuf(XL)		; arg 2 buffer block
	BRN	idn2a			; compare characters
.FI
;
;      for all other datatypes, must be differ if XR ne XL
;
;      merge here for differ
;
iden1	EXI				; take differ exit
;
;      here for strings, ident only if lengths and chars same
;
iden2	MOV	WC,sclen(XR)		; load arg 1 length
	BNE	WC,sclen(XL),iden1	; differ if lengths differ
;
;      buffer and string comparisons merge here
;
idn2a	ADD	XR,*schar		; point to chars of arg 1
	ADD	XL,*schar		; point to chars of arg 2
	CTW	WC,0			; get number of words in strings
	LCT	WC,WC			; set loop counter
;
;      loop to compare characters. note that WC cannot be zero
;      since all null strings point to nulls and give XL=XR.
;
iden3	CNE	(XR),(XL),iden8		; differ if chars do not match
	ICA	XR			; else bump arg one pointer
	ICA	XL			; bump arg two pointer
	BCT	WC,iden3		; loop back till all checked
	EJC
;
;      ident (continued)
;
;      here to exit for case of two ident strings
;
	ZER	XL			; clear garbage value in XL
	ZER	XR			; clear garbage value in XR
	EXI	1			; take ident exit
;
;      here for integers, ident if same values
;
iden4	LDI	icval(XR)		; load arg 1
	SBI	icval(XL)		; subtract arg 2 to compare
	IOV	iden1			; differ if overflow
	INE	iden1			; differ if result is not zero
	EXI	1			; take ident exit
.IF    .cnra
.ELSE
;
;      here for reals, ident if same values
;
iden5	LDR	rcval(XR)		; load arg 1
	SBR	rcval(XL)		; subtract arg 2 to compare
	ROV	iden1			; differ if overflow
	RNE	iden1			; differ if result is not zero
	EXI	1			; take ident exit
.FI
;
;      here for names, ident if bases and offsets same
;
iden6	BNE	nmofs(XR),nmofs(XL),iden1; differ if different offset
	BNE	nmbas(XR),nmbas(XL),iden1; differ if different base
;
;      merge here to signal ident for identical pointers
;
iden7	EXI	1			; take ident exit
;
;      here for differ strings
;
iden8	ZER	XR			; clear garbage ptr in XR
	ZER	XL			; clear garbage ptr in XL
	EXI				; return to caller (differ)
	ENP				; end procedure ident
	EJC
;
;      inout - used to initialise input and output vaRIAbles
;
;      (XL)		     pointer to vbl name string
;      (WB)		     trblk type
;      jsr  inout	     call to perform initialisation
;      (XL)		     vrblk ptr
;      (XR)		     trblk ptr
;      (wa,WC)		     destroyed
;
;      note that trter (= trtrf) field of standard i/o vaRIAbles
;      points to corresponding svblk not to a trblk as is the
;      case for ordinary vaRIAbles.
;
inout	PRC	e,0			; entry point
	MOV	-(XS),WB		; stack trblk type
	MOV	WA,sclen(XL)		; get name length
	ZER	WB			; point to start of name
	JSR	sbstr			; build a proper scblk
	JSR	gtnvr			; build vrblk
	PPM				; no error return
	MOV	WC,XR			; save vrblk pointer
	MOV	WB,(XS)+		; get trter field
	ZER	XL			; zero trfpt
	JSR	trbld			; build trblk
	MOV	XL,WC			; recall vrblk pointer
	MOV	trter(XR),vrsvp(XL)	; store svblk pointer
	MOV	vrval(XL),XR		; store trblk ptr in vrblk
	MOV	vrget(XL),=b_vra	; set trapped access
	MOV	vrsto(XL),=b_vrv	; set trapped store
	EXI				; return to caller
	ENP				; end procedure inout
	EJC
.IF    .cnbf
.ELSE
;
;      insbf -- insert string in buffer
;
;      this routine will replace a section of a buffer with the
;      contents of a given string.  if the length of the
;      section to be replaced is different than the length of
;      the given string, and the replacement is not an append,
;      then the upper section of the buffer is shifted up or
;      down to create the proper space for the insert.
;
;      (XR)		     pointer to bcblk
;      (XL)		     object which is string convertable
;      (wa)		     offset of start of insert in buffer
;      (WB)		     length of section to replace
;      jsr  insbf	     call to insert characters in buffer
;      ppm  loc		     thread if (XL) not convertable
;      ppm  loc		     thread if insert not possible
;
;      the second alternate exit is taken if the insert would
;      overflow the buffer, or if the insert is out past the
;      defined end of the buffer as given.
;
insbf	PRC	e,2			; entry point
	MOV	inssa,WA		; save entry wa
	MOV	inssb,WB		; save entry WB
	MOV	inssc,WC		; save entry WC
	ADD	WA,WB			; add to get offset past replace part
	MOV	insab,WA		; save wa+WB
	MOV	WC,bclen(XR)		; get current defined length
	BGT	inssa,WC,ins07		; fail if start offset too big
	BGT	WA,WC,ins07		; fail if final offset too big
	MOV	-(XS),XL		; save entry XL
	MOV	-(XS),XR		; save bcblk ptr
	MOV	-(XS),XL		; stack again for gtstg or gtstb
	BEQ	XR,XL,ins08		; b if inserting same buffer
	JSR	gtstb			; call to get string or buffer
	PPM	ins05			; take string convert err exit
;
;      merge here with XR pointing to the scblk or bfblk of
;      the object being inserted, and wa containing the
;      number of characters in that object.
;
ins09	MOV	XL,XR			; save string ptr
	MOV	insln,WA		; save its length
	MOV	XR,(XS)			; restore bcblk ptr
	ADD	WA,WC			; add buffer len to string len
	SUB	WA,inssb		; bias out component being replaced
	MOV	XR,bcbuf(XR)		; point to bfblk
	BGT	WA,bfalc(XR),ins06	; fail if result exceeds allocation
	MOV	XR,(XS)			; restore bcblk ptr
	MOV	WA,WC			; get buffer length
	SUB	WA,insab		; subtract to get shift length
	ADD	WC,insln		; add length of new
	SUB	WC,inssb		; subtract old to get total new len
	MOV	WB,bclen(XR)		; get old bclen
	MOV	bclen(XR),WC		; stuff new length
	BZE	WA,ins04		; skip shift if nothing to do
	BEQ	inssb,insln,ins04	; skip shift if lengths match
	MOV	XR,bcbuf(XR)		; point to bfblk
	MOV	-(XS),XL		; save scblk ptr
	BLO	inssb,insln,ins01	; brn if shift is for more room
	EJC
;
;      insbf (continued)
;
;      we are shifting the upper segment down to compact
;      the buffer.  (the string length is smaller than the
;      segment being replaced.)	 registers are set as
;
;      (wa)		     move (shift down) length
;      (WB)		     old bclen
;      (WC)		     new bclen
;      (XR)		     bfblk ptr
;      (XL),(XS)	     scblk or bfblk ptr
;
	MOV	WB,inssa		; get offset to insert
	ADD	WB,insln		; add insert length to get dest off
	MOV	XL,XR			; make copy
	PLC	XL,insab		; prepare source for move
	PSC	XR,WB			; prepare destination reg for move
	MVC				; move em out
	BRN	ins02			; branch to pad
;
;      we are shifting the upper segment up to expand
;      the buffer.  (the string length is larger than the
;      segment being replaced.)
;
ins01	MOV	XL,XR			; copy bfblk ptr
	PLC	XL,WB			; set source reg for move backwards
	PSC	XR,WC			; set destination ptr for move
	MCB				; move backwards (possible overlap)
;
;      merge here after move to adjust padding at new buffer end
;
ins02	MOV	XL,(XS)+		; restore scblk or bfblk ptr
	MOV	WA,WC			; copy new buffer end
	CTB	WA,0			; round out
	SUB	WA,WC			; subtract to get remainder
	BZE	WA,ins04		; no pad if already even boundary
	MOV	XR,(XS)			; get bcblk ptr
	MOV	XR,bcbuf(XR)		; get bfblk ptr
	PSC	XR,WC			; prepare to pad
	ZER	WB			; clear WB
	LCT	WA,WA			; load loop count
;
;      loop here to stuff pad characters
;
ins03	SCH	WB,(XR)+		; stuff zero pad
	BCT	WA,ins03		; branch for more
	CSC	XR			; complete store character
	EJC
;
;      insbf (continued)
;
;      merge here when padding ok.  now copy in the insert
;      string to the hole.
;
ins04	MOV	WA,insln		; get insert length
	BZE	WA,ins4b		; if nothing to insert
	MOV	XR,(XS)			; get bcblk ptr
	MOV	XR,bcbuf(XR)		; get bfblk ptr
	PLC	XL			; prepare to copy from first char
	PSC	XR,inssa		; prepare to store in hole
	MVC				; copy the characters
;
;      continue here after possible insertion copy
;
ins4b	MOV	XR,(XS)+		; restore entry XR
	MOV	XL,(XS)+		; restore entry XL
	MOV	WA,inssa		; restore entry wa
	MOV	WB,inssb		; restore entry WB
	MOV	WC,inssc		; restore entry WC
	EXI				; return to caller
;
;      here to take string convert error exit
;
ins05	MOV	XR,(XS)+		; restore entry XR
	MOV	XL,(XS)+		; restore entry XL
	MOV	WA,inssa		; restore entry wa
	MOV	WB,inssb		; restore entry WB
	MOV	WC,inssc		; restore entry WC
	EXI	1			; alternate exit
;
;      here for invalid offset or length
;
ins06	MOV	XR,(XS)+		; restore entry XR
	MOV	XL,(XS)+		; restore entry XL
;
;      merge for length failure exit with stack set
;
ins07	MOV	WA,inssa		; restore entry wa
	MOV	WB,inssb		; restore entry WB
	MOV	WC,inssc		; restore entry WC
	EXI	2			; alternate exit
;
;      here if inserting the same buffer into itself.  have
;      to convert the inserted buffer to an intermediate
;      string to prevent garbled data.
;
ins08	JSR	gtstg			; call to get string
	PPM	ins05			; take string convert err exit
	BRN	ins09			; merge back to perform insertion
	ENP				; end procedure insbf
	EJC
.FI
;
;      insta - used to initialize structures in static region
;
;      (XR)		     pointer to starting static location
;      jsr  insta	     call to initialize static structure
;      (XR)		     ptr to next free static location
;      (wa,WB,WC)	     destroyed
;
;      note that this procedure establishes the pointers
;      prbuf, gtswk, and kvalp.
;
insta	PRC	e,0			; entry point
;
;      initialize print buffer with blank words
;
;z-
	MOV	WC,prlen		; no. of chars in print bfr
	MOV	prbuf,XR		; print bfr is put at static start
	MOV	(XR)+,=b_scl		; store string type code
	MOV	(XR)+,WC		; and string length
	CTW	WC,0			; get number of words in buffer
	MOV	prlnw,WC		; store for buffer clear
	LCT	WC,WC			; words to clear
;
;      loop to clear buffer
;
inst1	MOV	(XR)+,nullw		; store blank
	BCT	WC,inst1		; loop
;
;      allocate work area for gtstg conversion procedure
;
	MOV	WA,=nstmx		; get max num chars in output number
	CTB	WA,scsi_		; no of bytes needed
	MOV	gtswk,XR		; store bfr adrs
	ADD	XR,WA			; bump for work bfr
;
;      build alphabet string for alphabet keyword and replace
;
	MOV	kvalp,XR		; save alphabet pointer
	MOV	(XR),=b_scl		; string blk type
	MOV	WC,=cfp_a		; no of chars in alphabet
	MOV	sclen(XR),WC		; store as string length
	MOV	WB,WC			; copy char count
	CTB	WB,scsi_		; no. of bytes needed
	ADD	WB,XR			; current end address for static
	MOV	WA,WB			; save adrs past alphabet string
	LCT	WC,WC			; loop counter
	PSC	XR			; point to chars of string
	ZER	WB			; set initial character value
;
;      loop to enter character codes in order
;
inst2	SCH	WB,(XR)+		; store next code
	ICV	WB			; bump code value
	BCT	WC,inst2		; loop till all stored
	CSC	XR			; complete store characters
	MOV	XR,WA			; return current static ptr
	EXI				; return to caller
	ENP				; end procedure insta
	EJC
;
;      iofcb -- get input/output fcblk pointer
;
;      used by endfile, eject and rewind to find the fcblk
;      (if any) corresponding to their argument.
;
;      -(XS)		     argument
;      jsr  iofcb	     call to find fcblk
;      ppm  loc		     arg is an unsuitable name
;      ppm  loc		     arg is null string
;      ppm  loc		     arg file not found
;      (XS)		     popped
;      (XL)		     ptr to filearg1 vrblk
;      (XR)		     argument
;      (wa)		     fcblk ptr or 0
;      (WB,WC)		     destroyed
;
iofcb	PRC	n,3			; entry point
;z+
	JSR	gtstg			; get arg as string
	PPM	iofc2			; fail
	MOV	XL,XR			; copy string ptr
	JSR	gtnvr			; get as natural vaRIAble
	PPM	iofc3			; fail if null
	MOV	WB,XL			; copy string pointer again
	MOV	XL,XR			; copy vrblk ptr for return
	ZER	WA			; in case no trblk found
;
;      loop to find file arg1 trblk
;
iofc1	MOV	XR,vrval(XR)		; get possible trblk ptr
	BNE	(XR),=b_trt,iofc4	; fail if end of chain
	BNE	trtyp(XR),=trtfc,iofc1	; loop if not file arg trblk
	MOV	WA,trfpt(XR)		; get fcblk ptr
	MOV	XR,WB			; copy arg
	EXI				; return
;
;      fail return
;
iofc2	EXI	1			; fail
;
;      null arg
;
iofc3	EXI	2			; null arg return
;
;      file not found
;
iofc4	EXI	3			; file not found return
	ENP				; end procedure iofcb
	EJC
;
;      ioppf -- process filearg2 for ioput
;
;      (r_xsc)		     filearg2 ptr
;      jsr  ioppf	     call to process filearg2
;      (XL)		     filearg1 ptr
;      (XR)		     file arg2 ptr
;      -(XS)...-(XS)	     fields eXTracted from filearg2
;      (WC)		     no. of fields eXTracted
;      (WB)		     input/output flag
;      (wa)		     fcblk ptr or 0
;
ioppf	PRC	n,0			; entry point
	ZER	WB			; to count fields eXTracted
;
;      loop to eXTract fields
;
iopp1	MOV	XL,=iodel		; get delimiter
	MOV	WC,XL			; copy it
	ZER	WA			; retain leading blanks in filearg2
	JSR	XScan			; get next field
	MOV	-(XS),XR		; stack it
	ICV	WB			; increment count
	BNZ	WA,iopp1		; loop
	MOV	WC,WB			; count of fields
	MOV	WB,ioptt		; i/o marker
	MOV	WA,r_iof		; fcblk ptr or 0
	MOV	XR,r_io2		; file arg2 ptr
	MOV	XL,r_io1		; filearg1
	EXI				; return
	ENP				; end procedure ioppf
	EJC
;
;      ioput -- routine used by input and output
;
;      ioput sets up input/output  associations. it builds
;      such trace and file control blocks as are necessary and
;      calls sysfc,sysio to perform checks on the
;      arguments and to open the files.
;
;	  +-----------+	  +---------------+	  +-----------+
;      +-.i	      i	  i		  i------.i   =b_xrt  i
;      i  +-----------+	  +---------------+	  +-----------+
;      i  /	      /	       (r_fcb)		  i    *4     i
;      i  /	      /				  +-----------+
;      i  +-----------+	  +---------------+	  i	      i-
;      i  i   name    +--.i    =b_trt	  i	  +-----------+
;      i  /	      /	  +---------------+	  i	      i
;      i   (first arg)	  i =trtin/=trtou i	  +-----------+
;      i		  +---------------+		i
;      i		  i	value	  i		i
;      i		  +---------------+		i
;      i		  i(trtrf) 0   or i--+		i
;      i		  +---------------+  i		i
;      i		  i(trfpt) 0   or i----+	i
;      i		  +---------------+  i i	i
;      i		     (i/o trblk)     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+	  +---------------+  i i	i
;      i  i	      +--.i    =b_trt	  i.-+ i	i
;      i  +-----------+	  +---------------+    i	i
;      i  /	      /	  i    =trtfc	  i    i	i
;      i  /	      /	  +---------------+    i	i
;      i    (filearg1	  i	value	  i    i	i
;      i	 vrblk)	  +---------------+    i	i
;      i		  i(trtrf) 0   or i--+ i	.
;      i		  +---------------+  i .  +-----------+
;      i		  i(trfpt) 0   or i------./   fcblk   /
;      i		  +---------------+  i	  +-----------+
;      i		       (trtrf)	     i
;      i				     i
;      i				     i
;      i		  +---------------+  i
;      i		  i    =b_xrt	  i.-+
;      i		  +---------------+
;      i		  i	 *5	  i
;      i		  +---------------+
;      +------------------i		  i
;			  +---------------+	  +-----------+
;			  i(trtrf) o   or i------.i  =b_xrt   i
;			  +---------------+	  +-----------+
;			  i  name offset  i	  i    etc    i
;			  +---------------+
;			    (iochn - chain of name pointers)
	EJC
;
;      ioput (continued)
;
;      no additional trap blocks are used for standard input/out
;      files. otherwise an i/o trap block is attached to second
;      arg (filearg1) vrblk. see diagram above for details of
;      the structure built.
;
;      -(XS)		     1st arg (vbl to be associated)
;      -(XS)		     2nd arg (file arg1)
;      -(XS)		     3rd arg (file arg2)
;      (WB)		     0 for input, 3 for output assoc.
;      jsr  ioput	     call for input/output association
;      ppm  loc		     3rd arg not a string
;      ppm  loc		     2nd arg not a suitable name
;      ppm  loc		     1st arg not a suitable name
;      ppm  loc		     inappropriate file spec for i/o
;      ppm  loc		     i/o file does not exist
;      ppm  loc		     i/o file cannot be read/written
;      ppm  loc		     i/o fcblk currently in use
;      (XS)		     popped
;      (XL,XR,WA,WB,WC)	     destroyed
;
ioput	PRC	n,7			; entry point
	ZER	r_iot			; in case no trtrf block used
	ZER	r_iof			; in case no fcblk alocated
	ZER	r_iop			; in case sysio fails
	MOV	ioptt,WB		; store i/o trace type
	JSR	XScni			; prepare to scan filearg2
	PPM	iop13			; fail
	PPM	iopa0			; null file arg2
;
iopa0	MOV	r_io2,XR		; keep file arg2
	MOV	XL,WA			; copy length
	JSR	gtstg			; convert filearg1 to string
	PPM	iop14			; fail
	MOV	r_io1,XR		; keep filearg1 ptr
	JSR	gtnvr			; convert to natural vaRIAble
	PPM	iop00			; jump if null
	BRN	iop04			; jump to process non-null args
;
;      null filearg1
;
iop00	BZE	XL,iop01		; skip if both args null
	JSR	ioppf			; process filearg2
	JSR	sysfc			; call for filearg2 check
	PPM	iop16			; fail
	PPM	iop26			; fail
	BRN	iop11			; complete file association
	EJC
;
;      ioput (continued)
;
;      here with 0 or fcblk ptr in (XL)
;
iop01	MOV	WB,ioptt		; get trace type
	MOV	XR,r_iot		; get 0 or trtrf ptr
	JSR	trbld			; build trblk
	MOV	WC,XR			; copy trblk pointer
	MOV	XR,(XS)+		; get vaRIAble from stack
	MOV	-(XS),WC		; make trblk collectable
	JSR	gtvar			; point to vaRIAble
	PPM	iop15			; fail
	MOV	WC,(XS)+		; recover trblk pointer
	MOV	r_ion,XL		; save name pointer
	MOV	XR,XL			; copy name pointer
	ADD	XR,WA			; point to vaRIAble
	SUB	XR,*vrval		; subtract offset,merge into loop
;
;      loop to end of trblk chain if any
;
iop02	MOV	XL,XR			; copy blk ptr
	MOV	XR,vrval(XR)		; load ptr to next trblk
	BNE	(XR),=b_trt,iop03	; jump if not trapped
	BNE	trtyp(XR),ioptt,iop02	; loop if not same assocn
	MOV	XR,trnxt(XR)		; get value and delete old trblk
;
;      ioput (continued)
;
;      store new association
;
iop03	MOV	vrval(XL),WC		; link to this trblk
	MOV	XL,WC			; copy pointer
	MOV	trnxt(XL),XR		; store value in trblk
	MOV	XR,r_ion		; restore possible vrblk pointer
	MOV	WB,WA			; keep offset to name
	JSR	setvr			; if vrblk, set vrget,vrsto
	MOV	XR,r_iot		; get 0 or trtrf ptr
	BNZ	XR,iop19		; jump if trtrf block exists
	EXI				; return to caller
;
;      non standard file
;      see if an fcblk has already been allocated.
;
iop04	ZER	WA			; in case no fcblk found
	EJC
;
;      ioput (continued)
;
;      search possible trblk chain to pick up the fcblk
;
iop05	MOV	WB,XR			; remember blk ptr
	MOV	XR,vrval(XR)		; chain along
	BNE	(XR),=b_trt,iop06	; jump if end of trblk chain
	BNE	trtyp(XR),=trtfc,iop05	; loop if more to go
	MOV	r_iot,XR		; point to file arg1 trblk
	MOV	WA,trfpt(XR)		; get fcblk ptr from trblk
;
;      wa = 0 or fcblk ptr
;      WB = ptr to preceding blk to which any trtrf block
;	    for file arg1 must be chained.
;
iop06	MOV	r_iof,WA		; keep possible fcblk ptr
	MOV	r_iop,WB		; keep preceding blk ptr
	JSR	ioppf			; process filearg2
	JSR	sysfc			; see if fcblk required
	PPM	iop16			; fail
	PPM	iop26			; fail
	BZE	WA,iop12		; skip if no new fcblk wanted
	BLT	WC,=num02,iop6a		; jump if fcblk in dynamic
	JSR	alost			; get it in static
	BRN	iop6b			; skip
;
;      obtain fcblk in dynamic
;
iop6a	JSR	alloc			; get space for fcblk
;
;      merge
;
iop6b	MOV	XL,XR			; point to fcblk
	MOV	WB,WA			; copy its length
	BTW	WB			; get count as words (sgd apr80)
	LCT	WB,WB			; loop counter
;
;      clear fcblk
;
iop07	ZER	(XR)+			; clear a word
	BCT	WB,iop07		; loop
	BEQ	WC,=num02,iop09		; skip if in static - dont set fields
	MOV	(XL),=b_xnt		; store xnblk code in case
	MOV	num01(XL),WA		; store length
	BNZ	WC,iop09		; jump if xnblk wanted
	MOV	(XL),=b_xrt		; XRblk code requested
;
	EJC
;      ioput (continued)
;
;      complete fcblk initialisation
;
iop09	MOV	XR,r_iot		; get possible trblk ptr
	MOV	r_iof,XL		; store fcblk ptr
	BNZ	XR,iop10		; jump if trblk already found
;
;      a new trblk is needed
;
	MOV	WB,=trtfc		; trtyp for fcblk trap blk
	JSR	trbld			; make the block
	MOV	r_iot,XR		; copy trtrf ptr
	MOV	XL,r_iop		; point to preceding blk
	MOV	vrval(XR),vrval(XL)	; copy value field to trblk
	MOV	vrval(XL),XR		; link new trblk into chain
	MOV	XR,XL			; point to predecessor blk
	JSR	setvr			; set trace intercepts
	MOV	XR,vrval(XR)		; recover trblk ptr
	BRN	iop1a			; store fcblk ptr
;
;      here if existing trblk
;
iop10	ZER	r_iop			; do not release if sysio fails
;
;      XR is ptr to trblk, XL is fcblk ptr or 0
;
iop1a	MOV	trfpt(XR),r_iof		; store fcblk ptr
;
;      call sysio to complete file accessing
;
iop11	MOV	WA,r_iof		; copy fcblk ptr or 0
	MOV	WB,ioptt		; get input/output flag
	MOV	XR,r_io2		; get file arg2
	MOV	XL,r_io1		; get file arg1
	JSR	sysio			; associate to the file
	PPM	iop17			; fail
	PPM	iop18			; fail
	BNZ	r_iot,iop01		; not std input if non-null trtrf blk
	BNZ	ioptt,iop01		; jump if output
	BZE	WC,iop01		; no change to standard read length
	MOV	cswin,WC		; store new read length for std file
	BRN	iop01			; merge to finish the task
;
;      sysfc may have returned a pointer to a private fcblk
;
iop12	BNZ	XL,iop09		; jump if private fcblk
	BRN	iop11			; finish the association
;
;      failure returns
;
iop13	EXI	1			; 3rd arg not a string
iop14	EXI	2			; 2nd arg unsuitable
iop15	ICA	XS			; discard trblk pointer
	EXI	3			; 1st arg unsuitable
iop16	EXI	4			; file spec wrong
iop26	EXI	7			; fcblk in use
;
;      i/o file does not exist
;
iop17	MOV	XR,r_iop		; is there a trblk to release
	BZE	XR,iopa7		; if not
	MOV	XL,vrval(XR)		; point to trblk
	MOV	vrval(XR),vrval(XL)	; unsplice it
	JSR	setvr			; adjust trace intercepts
iopa7	EXI	5			; i/o file does not exist
;
;      i/o file cannot be read/written
;
iop18	MOV	XR,r_iop		; is there a trblk to release
	BZE	XR,iopa7		; if not
	MOV	XL,vrval(XR)		; point to trblk
	MOV	vrval(XR),vrval(XL)	; unsplice it
	JSR	setvr			; adjust trace intercepts
iopa8	EXI	6			; i/o file cannot be read/written
	EJC
;
;      ioput (continued)
;
;      add to iochn chain of associated vaRIAbles unless
;      already present.
;
iop19	MOV	WC,r_ion		; WC = name base, WB = name offset
;
;      search loop
;
iop20	MOV	XR,trtrf(XR)		; next link of chain
	BZE	XR,iop21		; not found
	BNE	WC,ionmb(XR),iop20	; no match
	BEQ	WB,ionmo(XR),iop22	; exit if matched
	BRN	iop20			; loop
;
;      not found
;
iop21	MOV	WA,*num05		; space needed
	JSR	alloc			; get it
	MOV	(XR),=b_xrt		; store XRblk code
	MOV	num01(XR),WA		; store length
	MOV	ionmb(XR),WC		; store name base
	MOV	ionmo(XR),WB		; store name offset
	MOV	XL,r_iot		; point to trtrf blk
	MOV	WA,trtrf(XL)		; get ptr field contents
	MOV	trtrf(XL),XR		; store ptr to new block
	MOV	trtrf(XR),WA		; complete the linking
;
;      insert fcblk on fcblk chain for sysej, sysxi
;
iop22	BZE	r_iof,iop25		; skip if no fcblk
	MOV	XL,r_fcb		; ptr to head of existing chain
;
;      see if fcblk already on chain
;
iop23	BZE	XL,iop24		; not on if end of chain
	BEQ	num03(XL),r_iof,iop25	; dont duplicate if find it
	MOV	XL,num02(XL)		; get next link
	BRN	iop23			; loop
;
;      not found so add an entry for this fcblk
;
iop24	MOV	WA,*num04		; space needed
	JSR	alloc			; get it
	MOV	(XR),=b_xrt		; store block code
	MOV	num01(XR),WA		; store length
	MOV	num02(XR),r_fcb		; store previous link in this node
	MOV	num03(XR),r_iof		; store fcblk ptr
	MOV	r_fcb,XR		; insert node into fcblk chain
;
;      return
;
iop25	EXI				; return to caller
	ENP				; end procedure ioput
	EJC
;
;      ktrex -- execute keyword trace
;
;      ktrex is used to execute a possible keyword trace. it
;      includes the test on trace and tests for trace active.
;
;      (XL)		     ptr to trblk (or 0 if untraced)
;      jsr  ktrex	     call to execute keyword trace
;      (XL,WA,WB,WC)	     destroyed
;      (RA)		     destroyed
;
ktrex	PRC	r,0			; entry point (recursive)
	BZE	XL,ktrx3		; immediate exit if keyword untraced
	BZE	kvtra,ktrx3		; immediate exit if trace = 0
	DCV	kvtra			; else decrement trace
	MOV	-(XS),XR		; save XR
	MOV	XR,XL			; copy trblk pointer
	MOV	XL,trkvr(XR)		; load vrblk pointer (nmbas)
	MOV	WA,*vrval		; set name offset
	BZE	trfnc(XR),ktrx1		; jump if print trace
	JSR	trxeq			; else execute full trace
	BRN	ktrx2			; and jump to exit
;
;      here for print trace
;
ktrx1	MOV	-(XS),XL		; stack vrblk ptr for kwnam
	MOV	-(XS),WA		; stack offset for kwnam
	JSR	prtsn			; print statement number
	MOV	WA,=ch_am		; load ampersand
	JSR	prtch			; print ampersand
	JSR	prtnm			; print keyword name
	MOV	XR,=tmbeb		; point to blank-equal-blank
	JSR	prtst			; print blank-equal-blank
	JSR	kwnam			; get keyword pseudo-vaRIAble name
	MOV	dnamp,XR		; reset ptr to delete kvblk
	JSR	acess			; get keyword value
	PPM				; failure is impossible
	JSR	prtvl			; print keyword value
	JSR	prtnl			; terminate print line
;
;      here to exit after completing trace
;
ktrx2	MOV	XR,(XS)+		; restore entry XR
;
;      merge here to exit if no trace required
;
ktrx3	EXI				; return to ktrex caller
	ENP				; end procedure ktrex
	EJC
;
;      kwnam -- get pseudo-vaRIAble name for keyword
;
;      1(XS)		     name base for vrblk
;      0(XS)		     offset (should be *vrval)
;      jsr  kwnam	     call to get pseudo-vaRIAble name
;      (XS)		     popped twice
;      (XL,WA)		     resulting pseudo-vaRIAble name
;      (XR,WA,WB)	     destroyed
;
kwnam	PRC	n,0			; entry point
	ICA	XS			; ignore name offset
	MOV	XR,(XS)+		; load name base
	BGE	XR,state,kwnm1		; jump if not natural vaRIAble name
	BNZ	vrlen(XR),kwnm1		; error if not system vaRIAble
	MOV	XR,vrsvp(XR)		; else point to svblk
	MOV	WA,svbit(XR)		; load bit mask
	ANB	WA,btknm		; and with keyword bit
	ZRB	WA,kwnm1		; error if no keyword association
	MOV	WA,svlen(XR)		; else load name length in characters
	CTB	WA,svchs		; compute offset to field we want
	ADD	XR,WA			; point to svknm field
	MOV	WB,(XR)			; load svknm value
	MOV	WA,*kvsi_		; set size of kvblk
	JSR	alloc			; allocate kvblk
	MOV	(XR),=b_kvt		; store type word
	MOV	kvnum(XR),WB		; store keyword number
	MOV	kvvar(XR),=trbkv	; set dummy trblk pointer
	MOV	XL,XR			; copy kvblk pointer
	MOV	WA,*kvvar		; set proper offset
	EXI				; return to kvnam caller
;
;      here if not keyword name
;
kwnm1	ERB	251,keyword operand is not name of defined keyword
	ENP				; end procedure kwnam
	EJC
;
;      lcomp-- compare two strings lexically
;
;      1(XS)		     first argument
;      0(XS)		     second argument
;      jsr  lcomp	     call to compare aruments
;      ppm  loc		     transfer loc for arg1 not string
;      ppm  loc		     transfer loc for arg2 not string
;      ppm  loc		     transfer loc if arg1 llt arg2
;      ppm  loc		     transfer loc if arg1 leq arg2
;      ppm  loc		     transfer loc if arg1 lgt arg2
;      (the normal return is never taken)
;      (XS)		     popped twice
;      (XR,XL)		     destroyed
;      (wa,WB,WC,ra)	     destroyed
;
lcomp	PRC	n,5			; entry point
.IF    .cnbf
	JSR	gtstg			; convert second arg to string
.ELSE
	JSR	gtstb			; get second arg as string or buffer
.FI
	PPM	lcmp6			; jump if second arg not string
	MOV	XL,XR			; else save pointer
	MOV	WC,WA			; and length
.IF    .cnbf
	JSR	gtstg			; convert first argument to string
.ELSE
	JSR	gtstb			; get first arg as string or buffer
.FI
	PPM	lcmp5			; jump if not string
	MOV	WB,WA			; save arg 1 length
	PLC	XR			; point to chars of arg 1
	PLC	XL			; point to chars of arg 2
.IF    .ccmc
	MOV	WA,WC			; arg 2 length to wa
	JSR	syscm			; compare (XL,WA=arg2  XR,WB=arg1)
	ERR	283,string length exceeded for generalized lexical comparison
	PPM	lcmp4			; arg 2 lt arg 1, lgt exit
	PPM	lcmp3			; arg 2 gt arg 1, llt exit
	EXI	4			; else identical strings, leq exit
	EJC
;
;      lcomp (continued)
.ELSE
	BLO	WA,WC,lcmp1		; jump if arg 1 length is smaller
	MOV	WA,WC			; else set arg 2 length as smaller
;
;      here with smaller length in (wa)
;
lcmp1	BZE	WA,lcmp7		; if null string, compare lengths
	CMC	lcmp4,lcmp3		; compare strings, jump if unequal
lcmp7	BNE	WB,WC,lcmp2		; if equal, jump if lengths unequal
	EXI	4			; else identical strings, leq exit
	EJC
;
;      lcomp (continued)
;
;      here if initial strings identical, but lengths unequal
;
lcmp2	BHI	WB,WC,lcmp4		; jump if arg 1 length gt arg 2 leng
.FI
;
;      here if first arg llt second arg
;
lcmp3	EXI	3			; take llt exit
;
;      here if first arg lgt second arg
;
lcmp4	EXI	5			; take lgt exit
;
;      here if first arg is not a string
;
lcmp5	EXI	1			; take bad first arg exit
;
;      here for second arg not a string
;
lcmp6	EXI	2			; take bad second arg error exit
	ENP				; end procedure lcomp
	EJC
;
;      listr -- list source line
;
;      listr is used to list a source line during the initial
;      compilation. it is called from scane and scanl.
;
;      jsr  listr	     call to list line
;      (XR,XL,WA,WB,WC)	     destroyed
;
;      global locations used by listr
;
;      cnttl		     flag for -title, -stitl
;
;      erlst		     if listing on account of an error
;
.IF    .cinc
;      lstid		     include depth of current image
;
.FI
;      lstlc		     count lines on current page
;
;      lstnp		     max number of lines/page
;
;      lstpf		     set non-zero if the current source
;			     line has been listed, else zero.
;
;      lstpg		     compiler listing page number
;
;      lstsn		     set if stmnt num to be listed
;
;      r_cim		     pointer to current input line.
;
;      r_ttl		     title for source listing
;
;      r_stl		     ptr to sub-title string
;
;      entry point
;
listr	PRC	e,0			; entry point
	BNZ	cnttl,list5		; jump if -title or -stitl
	BNZ	lstpf,list4		; immediate exit if already listed
	BGE	lstlc,lstnp,list6	; jump if no room
;
;      here after printing title (if needed)
;
list0	MOV	XR,r_cim		; load pointer to current image
	BZE	XR,list4		; jump if no image to print
	PLC	XR			; point to characters
	LCH	WA,(XR)			; load first character
	MOV	XR,lstsn		; load statement number
	BZE	XR,list2		; jump if no statement number
	MTI	XR			; else get stmnt number as integer
	BNE	stage,=stgic,list1	; skip if execute time
	BEQ	WA,=ch_as,list2		; no stmnt number list if comment
	BEQ	WA,=ch_mn,list2		; no stmnt no. if control card
;
;      print statement number
;
list1	JSR	prtin			; else print statement number
	ZER	lstsn			; and clear for next time in
.IF    .cinc
;
;      here to test for printing include depth
;
list2	MOV	XR,lstid		; include depth of image
	BZE	XR,list8		; if not from an include file
	MOV	WA,=stnpd		; position for start of statement
	SUB	WA,=num03		; position to place include depth
	MOV	profs,WA		; set as starting position
	MTI	XR			; include depth as integer
	JSR	prtin			; print include depth
	EJC
;
;      listr (continued)
;
;      here after printing statement number and include depth
;
list8	MOV	profs,=stnpd		; point past statement number
.ELSE
	EJC
;
;      listr (continued)
;
;      merge here after printing statement number (if required)
;
list2	MOV	profs,=stnpd		; point past statement number
.FI
	MOV	XR,r_cim		; load pointer to current image
	JSR	prtst			; print it
	ICV	lstlc			; bump line counter
	BNZ	erlst,list3		; jump if error copy to int.ch.
	JSR	prtnl			; terminate line
	BZE	cswdb,list3		; jump if -single mode
	JSR	prtnl			; else add a blank line
	ICV	lstlc			; and bump line counter
;
;      here after printing source image
;
list3	MNZ	lstpf			; set flag for line printed
;
;      merge here to exit
;
list4	EXI				; return to listr caller
;
;      print title after -title or -stitl card
;
list5	ZER	cnttl			; clear flag
;
;      eject to new page and list title
;
list6	JSR	prtps			; eject
	BZE	prich,list7		; skip if listing to regular printer
	BEQ	r_ttl,=nulls,list0	; terminal listing omits null title
;
;      list title
;
list7	JSR	listt			; list title
	BRN	list0			; merge
	ENP				; end procedure listr
	EJC
;
;      listt -- list title and subtitle
;
;      used during compilation to print page heading
;
;      jsr  listt	     call to list title
;      (XR,WA)		     destroyed
;
listt	PRC	e,0			; entry point
	MOV	XR,r_ttl		; point to source listing title
	JSR	prtst			; print title
	MOV	profs,lstpo		; set offset
	MOV	XR,=lstms		; set page message
	JSR	prtst			; print page message
	ICV	lstpg			; bump page number
	MTI	lstpg			; load page number as integer
	JSR	prtin			; print page number
	JSR	prtnl			; terminate title line
	ADD	lstlc,=num02		; count title line and blank line
;
;      print sub-title (if any)
;
	MOV	XR,r_stl		; load pointer to sub-title
	BZE	XR,lstt1		; jump if no sub-title
	JSR	prtst			; else print sub-title
	JSR	prtnl			; terminate line
	ICV	lstlc			; bump line count
;
;      return point
;
lstt1	JSR	prtnl			; print a blank line
	EXI				; return to caller
	ENP				; end procedure listt
	EJC
.IF    .csfn
;
;      newfn -- record new source file name
;
;      newfn is used after switching to a new include file, or
;      after a -line statement which contains a file name.
;
;      (XR)		     file name scblk
;      jsr  newfn
;      (wa,WB,WC,XL,XR,ra)   destroyed
;
;      on return, the table that maps statement numbers to file
;      names has been updated to include this new file name and
;      the current statement number.  the entry is made only if
;      the file name had changed from its previous value.
;
newfn	PRC	e,0			; entry point
	MOV	-(XS),XR		; save new name
	MOV	XL,r_sfc		; load previous name
	JSR	ident			; check for equality
	PPM	nwfn1			; jump if identical
	MOV	XR,(XS)+		; different, restore name
	MOV	r_sfc,XR		; record current file name
	MOV	WB,cmpsn		; get current statement
	MTI	WB			; convert to integer
	JSR	icbld			; build icblk for stmt number
	MOV	XL,r_sfn		; file name table
	MNZ	WB			; lookup statement number by name
	JSR	tfind			; allocate new teblk
	PPM				; always possible to allocate block
	MOV	teval(XL),r_sfc		; record file name as entry value
	EXI
;
;     here if new name and old name identical
;
nwfn1	ICA	XS			; pop stack
	EXI
	EJC
.FI
;
;      nexts -- acquire next source image
;
;      nexts is used to acquire the next source image at compile
;      time. it assumes that a prior call to readr has input
;      a line image (see procedure readr). before the current
;      image is finally lost it may be listed here.
;
;      jsr  nexts	     call to acquire next input line
;      (XR,XL,WA,WB,WC)	     destroyed
;
;      global values affected
;
.IF    .cinc
;      lstid		     include depth of next image
;
.FI
;      r_cni		     on input, next image. on
;			     exit reset to zero
;
;      r_cim		     on exit, set to point to image
;
;      rdcln		     current ln set from next line num
;
;      scnil		     input image length on exit
;
;      scnse		     reset to zero on exit
;
;      lstpf		     set on exit if line is listed
;
nexts	PRC	e,0			; entry point
	BZE	cswls,nXTs2		; jump if -nolist
	MOV	XR,r_cim		; point to image
	BZE	XR,nXTs2		; jump if no image
	PLC	XR			; get char ptr
	LCH	WA,(XR)			; get first char
	BNE	WA,=ch_mn,nXTs1		; jump if not ctrl card
	BZE	cswpr,nXTs2		; jump if -noprint
;
;      here to call lister
;
nXTs1	JSR	listr			; list line
;
;      here after possible listing
;
nXTs2	MOV	XR,r_cni		; point to next image
	MOV	r_cim,XR		; set as next image
	MOV	rdcln,rdnln		; set as current line number
.IF    .cinc
	MOV	lstid,cnind		; set as current include depth
.FI
	ZER	r_cni			; clear next image pointer
	MOV	WA,sclen(XR)		; get input image length
	MOV	WB,cswin		; get max allowable length
	BLO	WA,WB,nXTs3		; skip if not too long
	MOV	WA,WB			; else truncate
;
;      here with length in (wa)
;
nXTs3	MOV	scnil,WA		; use as record length
	ZER	scnse			; reset scnse
	ZER	lstpf			; set line not listed yet
	EXI				; return to nexts caller
	ENP				; end procedure nexts
	EJC
;
;      patin -- pattern construction for len,pos,rpos,tab,rtab
;
;      these pattern types all generate a similar node type. so
;      the construction code is shared. see functions section
;      for actual entry points for these five functions.
;
;      (wa)		     pcode for expression arg case
;      (WB)		     pcode for integer arg case
;      jsr  patin	     call to build pattern node
;      ppm  loc		     transfer loc for not integer or exp
;      ppm  loc		     transfer loc for int out of range
;      (XR)		     pointer to constructed node
;      (XL,WA,WB,WC,ia)	     destroyed
;
patin	PRC	n,2			; entry point
	MOV	XL,WA			; preserve expression arg pcode
	JSR	gtsmi			; try to convert arg as small integer
	PPM	ptin2			; jump if not integer
	PPM	ptin3			; jump if out of range
;
;      common successful exit point
;
ptin1	JSR	pbild			; build pattern node
	EXI				; return to caller
;
;      here if argument is not an integer
;
ptin2	MOV	WB,XL			; copy expr arg case pcode
	BLO	(XR),=b_e__,ptin1	; all ok if expression arg
	EXI	1			; else take error exit for wrong type
;
;      here for error of out of range integer argument
;
ptin3	EXI	2			; take out-of-range error exit
	ENP				; end procedure patin
	EJC
;
;      patst -- pattern construction for any,notany,
;		break,span and breakx pattern functions.
;
;      these pattern functions build similar types of nodes and
;      the construction code is shared. see functions section
;      for actual entry points for these five pattern functions.
;
;      0(XS)		     string argument
;      (WB)		     pcode for one char argument
;      (XL)		     pcode for multi-char argument
;      (WC)		     pcode for expression argument
;      jsr  patst	     call to build node
;      ppm  loc		     if not string or expr (or null)
;      (XS)		     popped past string argument
;      (XR)		     pointer to constructed node
;      (XL)		     destroyed
;      (wa,WB,WC,ra)	     destroyed
;
;      note that there is a special call to patst in the evals
;      procedure with a slightly different form. see evals
;      for details of the form of this call.
;
patst	PRC	n,1			; entry point
	JSR	gtstg			; convert argument as string
	PPM	pats7			; jump if not string
	BZE	WA,pats7		; jump if null string (catspaw)
	BNE	WA,=num01,pats2		; jump if not one char string
;
;      here for one char string case
;
	BZE	WB,pats2		; treat as multi-char if evals call
	PLC	XR			; point to character
	LCH	XR,(XR)			; load character
;
;      common exit point after successful construction
;
pats1	JSR	pbild			; call routine to build node
	EXI				; return to patst caller
	EJC
;
;      patst (continued)
;
;      here for multi-character string case
;
pats2	MOV	-(XS),XL		; save multi-char pcode
	MOV	WC,ctmsk		; load current mask bit
	BEQ	XR,r_cts,pats6		; jump if same as last string c3.738
	MOV	-(XS),XR		; save string pointer
	LSH	WC,1			; shift to next position
	NZB	WC,pats4		; skip if position left in this tbl
;
;      here we must allocate a new character table
;
	MOV	WA,*ctsi_		; set size of ctblk
	JSR	alloc			; allocate ctblk
	MOV	r_ctp,XR		; store ptr to new ctblk
	MOV	(XR)+,=b_ctt		; store type code, bump ptr
	LCT	WB,=cfp_a		; set number of words to clear
	MOV	WC,bits0		; load all zero bits
;
;      loop to clear all bits in table to zeros
;
pats3	MOV	(XR)+,WC		; move word of zero bits
	BCT	WB,pats3		; loop till all cleared
	MOV	WC,bits1		; set initial bit position
;
;      merge here with bit position available
;
pats4	MOV	ctmsk,WC		; save parm2 (new bit position)
	MOV	XL,(XS)+		; restore pointer to argument string
	MOV	r_cts,XL		; save for next time   c3.738
	MOV	WB,sclen(XL)		; load string length
	BZE	WB,pats6		; jump if null string case
	LCT	WB,WB			; else set loop counter
	PLC	XL			; point to characters in argument
	EJC
;
;      patst (continued)
;
;      loop to set bits in column of table
;
pats5	LCH	WA,(XL)+		; load next character
	WTB	WA			; convert to byte offset
	MOV	XR,r_ctp		; point to ctblk
	ADD	XR,WA			; point to ctblk entry
	MOV	WA,WC			; copy bit mask
	ORB	WA,ctchs(XR)		; or in bits already set
	MOV	ctchs(XR),WA		; store resulting bit string
	BCT	WB,pats5		; loop till all bits set
;
;      complete processing for multi-char string case
;
pats6	MOV	XR,r_ctp		; load ctblk ptr as parm1 for pbild
	ZER	XL			; clear garbage ptr in XL
	MOV	WB,(XS)+		; load pcode for multi-char str case
	BRN	pats1			; back to exit (WC=bitstring=parm2)
;
;      here if argument is not a string
;
;      note that the call from evals cannot pass an expression
;      since evalp always reevaluates expressions.
;
pats7	MOV	WB,WC			; set pcode for expression argument
	BLO	(XR),=b_e__,pats1	; jump to exit if expression arg
	EXI	1			; else take wrong type error exit
	ENP				; end procedure patst
	EJC
;
;      pbild -- build pattern node
;
;      (XR)		     parm1 (only if required)
;      (WB)		     pcode for node
;      (WC)		     parm2 (only if required)
;      jsr  pbild	     call to build node
;      (XR)		     pointer to constructed node
;      (wa)		     destroyed
;
pbild	PRC	e,0			; entry point
	MOV	-(XS),XR		; stack possible parm1
	MOV	XR,WB			; copy pcode
	LEI	XR			; load entry point id (bl_px)
	BEQ	XR,=bl_p1,pbld1		; jump if one parameter
	BEQ	XR,=bl_p0,pbld3		; jump if no parameters
;
;      here for two parameter case
;
	MOV	WA,*pcsi_		; set size of p2blk
	JSR	alloc			; allocate block
	MOV	parm2(XR),WC		; store second parameter
	BRN	pbld2			; merge with one parm case
;
;      here for one parameter case
;
pbld1	MOV	WA,*pbsi_		; set size of p1blk
	JSR	alloc			; allocate node
;
;      merge here from two parm case
;
pbld2	MOV	parm1(XR),(XS)		; store first parameter
	BRN	pbld4			; merge with no parameter case
;
;      here for case of no parameters
;
pbld3	MOV	WA,*pasi_		; set size of p0blk
	JSR	alloc			; allocate node
;
;      merge here from other cases
;
pbld4	MOV	(XR),WB			; store pcode
	ICA	XS			; pop first parameter
	MOV	pthen(XR),=ndnth	; set nothen successor pointer
	EXI				; return to pbild caller
	ENP				; end procedure pbild
	EJC
;
;      pconc -- concatenate two patterns
;
;      (XL)		     ptr to right pattern
;      (XR)		     ptr to left pattern
;      jsr  pconc	     call to concatenate patterns
;      (XR)		     ptr to concatenated pattern
;      (XL,WA,WB,WC)	     destroyed
;
;
;      to concatenate two patterns, all successors in the left
;      pattern which point to the nothen node must be changed to
;      point to the right pattern. however, this modification
;      must be performed on a copy of the left argument rather
;      than the left argument itself, since the left argument
;      may be pointed to by some other vaRIAble value.
;
;      accordingly, it is necessary to copy the left argument.
;      this is not a trivial process since we must avoid copying
;      nodes more than once and the pattern is a graph structure
;      the following algorithm is employed.
;
;      the stack is used to store a list of nodes which
;      have already been copied. the format of the entries on
;      this list consists of a two word block. the first word
;      is the old address and the second word is the address
;      of the copy. this list is searched by the pcopy
;      routine to avoid making duplicate copies. a trick is
;      used to accomplish the concatenation at the same time.
;      a special entry is made to start with on the stack. this
;      entry records that the nothen node has been copied
;      already and the address of its copy is the right pattern.
;      this automatically performs the correct replacements.
;
pconc	PRC	e,0			; entry point
	ZER	-(XS)			; make room for one entry at bottom
	MOV	WC,XS			; store pointer to start of list
	MOV	-(XS),=ndnth		; stack nothen node as old node
	MOV	-(XS),XL		; store right arg as copy of nothen
	MOV	XT,XS			; initialize pointer to stack entries
	JSR	pcopy			; copy first node of left arg
	MOV	num02(XT),WA		; store as result under list
	EJC
;
;      pconc (continued)
;
;      the following loop scans entries in the list and makes
;      sure that their successors have been copied.
;
pcnc1	BEQ	XT,XS,pcnc2		; jump if all entries processed
	MOV	XR,-(XT)		; else load next old address
	MOV	XR,pthen(XR)		; load pointer to successor
	JSR	pcopy			; copy successor node
	MOV	XR,-(XT)		; load pointer to new node (copy)
	MOV	pthen(XR),WA		; store ptr to new successor
;
;      now check for special case of alternation node where
;      parm1 points to a node and must be copied like pthen.
;
	BNE	(XR),=p_alt,pcnc1	; loop back if not
	MOV	XR,parm1(XR)		; else load pointer to alternative
	JSR	pcopy			; copy it
	MOV	XR,(XT)			; restore ptr to new node
	MOV	parm1(XR),WA		; store ptr to copied alternative
	BRN	pcnc1			; loop back for next entry
;
;      here at end of copy process
;
pcnc2	MOV	XS,WC			; restore stack pointer
	MOV	XR,(XS)+		; load pointer to copy
	EXI				; return to pconc caller
	ENP				; end procedure pconc
	EJC
;
;      pcopy -- copy a pattern node
;
;      pcopy is called from the pconc procedure to copy a single
;      pattern node. the copy is only carried out if the node
;      has not been copied already.
;
;      (XR)		     pointer to node to be copied
;      (XT)		     ptr to current loc in copy list
;      (WC)		     pointer to list of copied nodes
;      jsr  pcopy	     call to copy a node
;      (wa)		     pointer to copy
;      (WB,XR)		     destroyed
;
pcopy	PRC	n,0			; entry point
	MOV	WB,XT			; save XT
	MOV	XT,WC			; point to start of list
;
;      loop to search list of nodes copied already
;
pcop1	DCA	XT			; point to next entry on list
	BEQ	XR,(XT),pcop2		; jump if match
	DCA	XT			; else skip over copied address
	BNE	XT,XS,pcop1		; loop back if more to test
;
;      here if not in list, perform copy
;
	MOV	WA,(XR)			; load first word of block
	JSR	blkln			; get length of block
	MOV	XL,XR			; save pointer to old node
	JSR	alloc			; allocate space for copy
	MOV	-(XS),XL		; store old address on list
	MOV	-(XS),XR		; store new address on list
	CHK				; check for stack overflow
	MVW				; move words from old block to copy
	MOV	WA,(XS)			; load pointer to copy
	BRN	pcop3			; jump to exit
;
;      here if we find entry in list
;
pcop2	MOV	WA,-(XT)		; load address of copy from list
;
;      common exit point
;
pcop3	MOV	XT,WB			; restore XT
	EXI				; return to pcopy caller
	ENP				; end procedure pcopy
	EJC
.IF    .cnpf
.ELSE
;
;      prflr -- print profile
;      prflr is called to print the contents of the profile
;      table in a fairly readable tabular format.
;
;      jsr  prflr	     call to print profile
;      (wa,ia)		     destroyed
;
prflr	PRC	e,0			;
	BZE	pfdmp,prfl4		; no printing if no profiling done
	MOV	-(XS),XR		; preserve entry XR
	MOV	pfsvw,WB		; and also WB
	JSR	prtpg			; eject
	MOV	XR,=pfms1		; load msg /program profile/
	JSR	prtst			; and print it
	JSR	prtnl			; followed by newline
	JSR	prtnl			; and another
	MOV	XR,=pfms2		; point to first hdr
	JSR	prtst			; print it
	JSR	prtnl			; new line
	MOV	XR,=pfms3		; second hdr
	JSR	prtst			; print it
	JSR	prtnl			; new line
	JSR	prtnl			; and another blank line
	ZER	WB			; initial stmt count
	MOV	XR,pftbl		; point to table origin
	ADD	XR,*xndta		; bias past xnblk header (sgd07)
;
;      loop here to print successive entries
;
prfl1	ICV	WB			; bump stmt nr
	LDI	(XR)			; load nr of executions
	IEQ	prfl3			; no printing if zero
	MOV	profs,=pfpd1		; point where to print
	JSR	prtin			; and print it
	ZER	profs			; back to start of line
	MTI	WB			; load stmt nr
	JSR	prtin			; print it there
	MOV	profs,=pfpd2		; and pad past count
	LDI	cfp_i(XR)		; load total exec time
	JSR	prtin			; print that too
	LDI	cfp_i(XR)		; reload time
	MLI	intth			; convert to microsec
	IOV	prfl2			; omit next bit if overflow
	DVI	(XR)			; divide by executions
	MOV	profs,=pfpd3		; pad last print
	JSR	prtin			; and print mcsec/execn
;
;      merge after printing time
;
prfl2	JSR	prtnl			; thats another line
;
;      here to go to next entry
;
prfl3	ADD	XR,*pf_i2		; bump index ptr (sgd07)
	BLT	WB,pfnte,prfl1		; loop if more stmts
	MOV	XR,(XS)+		; restore callers XR
	MOV	WB,pfsvw		; and WB too
;
;      here to exit
;
prfl4	EXI				; return
	ENP				; end of prflr
	EJC
;
;      prflu -- update an entry in the profile table
;
;      on entry, kvstn contains nr of stmt to profile
;
;      jsr  prflu	     call to update entry
;      (ia)		     destroyed
;
prflu	PRC	e,0			;
	BNZ	pffnc,pflu4		; skip if just entered function
	MOV	-(XS),XR		; preserve entry XR
	MOV	pfsvw,WA		; save wa (sgd07)
	BNZ	pftbl,pflu2		; branch if table allocated
;
;      here if space for profile table not yet allocated.
;      calculate size needed, allocate a static xnblk, and
;      initialize it all to zero.
;      the time taken for this will be attributed to the current
;      statement (assignment to keywd profile), but since the
;      timing for this statement is up the pole anyway, this
;      doesnt really matter...
;
	SUB	pfnte,=num01		; adjust for eXTra count (sgd07)
	MTI	pfi2a			; convrt entry size to int
	STI	pfste			; and store safely for later
	MTI	pfnte			; load table length as integer
	MLI	pfste			; multiply by entry size
	MFI	WA			; get back address-style
	ADD	WA,=num02		; add on 2 word overhead
	WTB	WA			; convert the whole lot to bytes
	JSR	alost			; gimme the space
	MOV	pftbl,XR		; save block pointer
	MOV	(XR)+,=b_xnt		; put block type and ...
	MOV	(XR)+,WA		; ... length into header
	MFI	WA			; get back nr of wds in data area
	LCT	WA,WA			; load the counter
;
;      loop here to zero the block data
;
pflu1	ZER	(XR)+			; blank a word
	BCT	WA,pflu1		; and alllllll the rest
;
;      end of allocation. merge back into routine
;
pflu2	MTI	kvstn			; load nr of stmt just ended
	SBI	intv1			; make into index offset
	MLI	pfste			; make offset of table entry
	MFI	WA			; convert to address
	WTB	WA			; get as baus
	ADD	WA,*num02		; offset includes table header
	MOV	XR,pftbl		; get table start
	BGE	WA,num01(XR),pflu3	; if out of table, skip it
	ADD	XR,WA			; else point to entry
	LDI	(XR)			; get nr of executions so far
	ADI	intv1			; nudge up one
	STI	(XR)			; and put back
	JSR	systm			; get time now
	STI	pfetm			; stash ending time
	SBI	pfstm			; subtract start time
	ADI	cfp_i(XR)		; add cumulative time so far
	STI	cfp_i(XR)		; and put back new total
	LDI	pfetm			; load end time of this stmt ...
	STI	pfstm			; ... which is start time of next
;
;      merge here to exit
;
pflu3	MOV	XR,(XS)+		; restore callers XR
	MOV	WA,pfsvw		; restore saved reg
	EXI				; and return
;
;      here if profile is suppressed because a program defined
;      function is about to be entered, and so the current stmt
;      has not yet finished
;
pflu4	ZER	pffnc			; reset the condition flag
	EXI				; and immediate return
	ENP				; end of procedure prflu
	EJC
.FI
;
;      prpar - process print parameters
;
;      (WC)		     if nonzero associate terminal only
;      jsr  prpar	     call to process print parameters
;      (XL,XR,WA,WB,WC)	     destroyed
;
;      since memory allocation is undecided on initial call,
;      terminal cannot be associated. the entry with WC non-zero
;      is provided so a later call can be made to complete this.
;
prpar	PRC	e,0			; entry point
	BNZ	WC,prpa8		; jump to associate terminal
	JSR	syspp			; get print parameters
	BNZ	WB,prpa1		; jump if lines/page specified
	MOV	WB,mxint		; else use a large value
	RSH	WB,1			; but not too large
;
;      store line count/page
;
prpa1	MOV	lstnp,WB		; store number of lines/page
	MOV	lstlc,WB		; pretend page is full initially
	ZER	lstpg			; clear page number
	MOV	WB,prlen		; get prior length if any
	BZE	WB,prpa2		; skip if no length
	BGT	WA,WB,prpa3		; skip storing if too big
;
;      store print buffer length
;
prpa2	MOV	prlen,WA		; store value
;
;      process bits options
;
prpa3	MOV	WB,bits3		; bit 3 mask
	ANB	WB,WC			; get -nolist bit
	ZRB	WB,prpa4		; skip if clear
	ZER	cswls			; set -nolist
;
;      check if fail reports goto interactive channel
;
prpa4	MOV	WB,bits1		; bit 1 mask
	ANB	WB,WC			; get bit
	MOV	erich,WB		; store int. chan. error flag
	MOV	WB,bits2		; bit 2 mask
	ANB	WB,WC			; get bit
	MOV	prich,WB		; flag for std printer on int. chan.
	MOV	WB,bits4		; bit 4 mask
	ANB	WB,WC			; get bit
	MOV	cpsts,WB		; flag for compile stats suppressn.
	MOV	WB,bits5		; bit 5 mask
	ANB	WB,WC			; get bit
	MOV	exsts,WB		; flag for exec stats suppression
	EJC
;
;      prpar (continued)
;
	MOV	WB,bits6		; bit 6 mask
	ANB	WB,WC			; get bit
	MOV	precl,WB		; eXTended/compact listing flag
	SUB	WA,=num08		; point 8 chars from line end
	ZRB	WB,prpa5		; jump if not eXTended
	MOV	lstpo,WA		; store for listing page headings
;
;	continue option processing
;
prpa5	MOV	WB,bits7		; bit 7 mask
	ANB	WB,WC			; get bit 7
	MOV	cswex,WB		; set -noexecute if non-zero
	MOV	WB,bit10		; bit 10 mask
	ANB	WB,WC			; get bit 10
	MOV	headp,WB		; pretend printed to omit headers
	MOV	WB,bits9		; bit 9 mask
	ANB	WB,WC			; get bit 9
	MOV	prsto,WB		; keep it as std listing option
.IF    .culc
	MOV	WB,WC			; copy flags
	RSH	WB,12			; right justify bit 13
	ANB	WB,bits1		; get bit
	MOV	kvcas,WB		; set -case
.FI
	MOV	WB,bit12		; bit 12 mask
	ANB	WB,WC			; get bit 12
	MOV	cswer,WB		; keep it as errors/noerrors option
	ZRB	WB,prpa6		; skip if clear
	MOV	WA,prlen		; get print buffer length
	SUB	WA,=num08		; point 8 chars from line end
	MOV	lstpo,WA		; store page offset
;
;      check for -print/-noprint
;
prpa6	MOV	WB,bit11		; bit 11 mask
	ANB	WB,WC			; get bit 11
	MOV	cswpr,WB		; set -print if non-zero
;
;      check for terminal
;
	ANB	WC,bits8		; see if terminal to be activated
	BNZ	WC,prpa8		; jump if terminal required
	BZE	initr,prpa9		; jump if no terminal to detach
	MOV	XL,=v_ter		; ptr to /terminal/
	JSR	gtnvr			; get vrblk pointer
	PPM				; cant fail
	MOV	vrval(XR),=nulls	; clear value of terminal
	JSR	setvr			; remove association
	BRN	prpa9			; return
;
;      associate terminal
;
prpa8	MNZ	initr			; note terminal associated
	BZE	dnamb,prpa9		; cant if memory not organised
	MOV	XL,=v_ter		; point to terminal string
	MOV	WB,=trtou		; output trace type
	JSR	inout			; attach output trblk to vrblk
	MOV	-(XS),XR		; stack trblk ptr
	MOV	XL,=v_ter		; point to terminal string
	MOV	WB,=trtin		; input trace type
	JSR	inout			; attach input trace blk
	MOV	vrval(XR),(XS)+		; add output trblk to chain
;
;      return point
;
prpa9	EXI				; return
	ENP				; end procedure prpar
	EJC
;
;      prtch -- print a character
;
;      prtch is used to print a single character
;
;      (wa)		     character to be printed
;      jsr  prtch	     call to print character
;
prtch	PRC	e,0			; entry point
	MOV	-(XS),XR		; save XR
	BNE	profs,prlen,prch1	; jump if room in buffer
	JSR	prtnl			; else print this line
;
;      here after making sure we have room
;
prch1	MOV	XR,prbuf		; point to print buffer
	PSC	XR,profs		; point to next character location
	SCH	WA,(XR)			; store new character
	CSC	XR			; complete store characters
	ICV	profs			; bump pointer
	MOV	XR,(XS)+		; restore entry XR
	EXI				; return to prtch caller
	ENP				; end procedure prtch
	EJC
;
;      prtic -- print to interactive channel
;
;      prtic is called to print the contents of the standard
;      print buffer to the interactive channel. it is only
;      called after prtst has set up the string for printing.
;      it does not clear the buffer.
;
;      jsr  prtic	     call for print
;      (wa,WB)		     destroyed
;
prtic	PRC	e,0			; entry point
	MOV	-(XS),XR		; save XR
	MOV	XR,prbuf		; point to buffer
	MOV	WA,profs		; no of chars
	JSR	syspi			; print
	PPM	prtc2			; fail return
;
;      return
;
prtc1	MOV	XR,(XS)+		; restore XR
	EXI				; return
;
;      error occured
;
prtc2	ZER	erich			; prevent looping
	ERB	252,error on printing to interactive channel
	BRN	prtc1			; return
	ENP				; procedure prtic
	EJC
;
;      prtis -- print to interactive and standard printer
;
;      prtis puts a line from the print buffer onto the
;      interactive channel (if any) and the standard printer.
;      it always prints to the standard printer but does
;      not duplicate lines if the standard printer is
;      interactive.  it clears down the print buffer.
;
;      jsr  prtis	     call for printing
;      (wa,WB)		     destroyed
;
prtis	PRC	e,0			; entry point
	BNZ	prich,prts1		; jump if standard printer is int.ch.
	BZE	erich,prts1		; skip if not doing int. error reps.
	JSR	prtic			; print to interactive channel
;
;      merge and exit
;
prts1	JSR	prtnl			; print to standard printer
	EXI				; return
	ENP				; end procedure prtis
	EJC
;
;      prtin -- print an integer
;
;      prtin prints the integer value which is in the integer
;      accumulator. blocks built in dynamic storage
;      during this process are immediately deleted.
;
;      (ia)		     integer value to be printed
;      jsr  prtin	     call to print integer
;      (ia,ra)		     destroyed
;
prtin	PRC	e,0			; entry point
	MOV	-(XS),XR		; save XR
	JSR	icbld			; build integer block
	BLO	XR,dnamb,prti1		; jump if icblk below dynamic
	BHI	XR,dnamp,prti1		; jump if above dynamic
	MOV	dnamp,XR		; immediately delete it
;
;      delete icblk from dynamic store
;
prti1	MOV	-(XS),XR		; stack ptr for gtstg
	JSR	gtstg			; convert to string
	PPM				; convert error is impossible
	MOV	dnamp,XR		; reset pointer to delete scblk
	JSR	prtst			; print integer string
	MOV	XR,(XS)+		; restore entry XR
	EXI				; return to prtin caller
	ENP				; end procedure prtin
	EJC
;
;      prtmi -- print message and integer
;
;      prtmi is used to print messages together with an integer
;      value starting in column 15 (used by the routines at
;      the end of compilation).
;
;      jsr  prtmi	     call to print message and integer
;
prtmi	PRC	e,0			; entry point
	JSR	prtst			; print string message
	MOV	profs,=prtmf		; set column offset
	JSR	prtin			; print integer
	JSR	prtnl			; print line
	EXI				; return to prtmi caller
	ENP				; end procedure prtmi
	EJC
;
;      prtmm -- print memory used and available
;
;      prtmm is used to provide memory usage information in
;      both the end-of-compile and end-of-run statistics.
;
;      jsr  prtmm	     call to print memory stats
;
prtmm	PRC	e,0			;
	MOV	WA,dnamp		; next available loc
	SUB	WA,statb		; minus start
.IF    .cbyt
.ELSE
	BTW	WA			; convert to words
.FI
	MTI	WA			; convert to integer
	MOV	XR,=encm1		; point to /memory used (words)/
	JSR	prtmi			; print message
	MOV	WA,dname		; end of memory
	SUB	WA,dnamp		; minus next available loc
.IF    .cbyt
.ELSE
	BTW	WA			; convert to words
.FI
	MTI	WA			; convert to integer
	MOV	XR,=encm2		; point to /memory available (words)/
	JSR	prtmi			; print line
	EXI				; return to prtmm caller
	ENP				; end of procedure prtmm
	EJC
;
;      prtmx  -- as prtmi with eXTra copy to interactive chan.
;
;      jsr  prtmx	     call for printing
;      (wa,WB)		     destroyed
;
prtmx	PRC	e,0			; entry point
	JSR	prtst			; print string message
	MOV	profs,=prtmf		; set column offset
	JSR	prtin			; print integer
	JSR	prtis			; print line
	EXI				; return
	ENP				; end procedure prtmx
	EJC
;
;      prtnl -- print new line (end print line)
;
;      prtnl prints the contents of the print buffer, resets
;      the buffer to all blanks and resets the print pointer.
;
;      jsr  prtnl	     call to print line
;
prtnl	PRC	r,0			; entry point
	BNZ	headp,prnl0		; were headers printed
	JSR	prtps			; no - print them
;
;      call syspr
;
prnl0	MOV	-(XS),XR		; save entry XR
	MOV	prtsa,WA		; save wa
	MOV	prtsb,WB		; save WB
	MOV	XR,prbuf		; load pointer to buffer
	MOV	WA,profs		; load number of chars in buffer
	JSR	syspr			; call system print routine
	PPM	prnl2			; jump if failed
	LCT	WA,prlnw		; load length of buffer in words
	ADD	XR,*schar		; point to chars of buffer
	MOV	WB,nullw		; get word of blanks
;
;      loop to blank buffer
;
prnl1	MOV	(XR)+,WB		; store word of blanks, bump ptr
	BCT	WA,prnl1		; loop till all blanked
;
;      exit point
;
	MOV	WB,prtsb		; restore WB
	MOV	WA,prtsa		; restore wa
	MOV	XR,(XS)+		; restore entry XR
	ZER	profs			; reset print buffer pointer
	EXI				; return to prtnl caller
;
;      file full or no output file for load module
;
prnl2	BNZ	prtef,prnl3		; jump if not first time
	MNZ	prtef			; mark first occurrence
	ERB	253,print limit exceeded on standard output channel
;
;      stop at once
;
prnl3	MOV	WB,=nini8		; ending code
	MOV	WA,kvstn		; statement number
	MOV	XL,r_fcb		; get fcblk chain head
	JSR	sysej			; stop
	ENP				; end procedure prtnl
	EJC
;
;      prtnm -- print vaRIAble name
;
;      prtnm is used to print a character representation of the
;      name of a vaRIAble (not a value of datatype name)
;      names of pseudo-vaRIAbles may not be passed to prtnm.
;
;      (XL)		     name base
;      (wa)		     name offset
;      jsr  prtnm	     call to print name
;      (WB,WC,ra)	     destroyed
;
prtnm	PRC	r,0			; entry point (recursive, see prtvl)
	MOV	-(XS),WA		; save wa (offset is collectable)
	MOV	-(XS),XR		; save entry XR
	MOV	-(XS),XL		; save name base
	BHI	XL,state,prn02		; jump if not natural vaRIAble
;
;      here for natural vaRIAble name, recognized by the fact
;      that the name base points into the static area.
;
	MOV	XR,XL			; point to vrblk
	JSR	prtvn			; print name of vaRIAble
;
;      common exit point
;
prn01	MOV	XL,(XS)+		; restore name base
	MOV	XR,(XS)+		; restore entry value of XR
	MOV	WA,(XS)+		; restore wa
	EXI				; return to prtnm caller
;
;      here for case of non-natural vaRIAble
;
prn02	MOV	WB,WA			; copy name offset
	BNE	(XL),=b_pdt,prn03	; jump if array or table
;
;      for program defined datatype, prt fld name, left paren
;
	MOV	XR,pddfp(XL)		; load pointer to dfblk
	ADD	XR,WA			; add name offset
	MOV	XR,pdfof(XR)		; load vrblk pointer for field
	JSR	prtvn			; print field name
	MOV	WA,=ch_pp		; load left paren
	JSR	prtch			; print character
	EJC
;
;      prtnm (continued)
;
;      now we print an identifying name for the object if one
;      can be found. the following code searches for a natural
;      vaRIAble which contains this object as value. if such a
;      vaRIAble is found, its name is printed, else the value
;      of the object (as printed by prtvl) is used instead.
;
;      first we point to the parent tbblk if this is the case of
;      a table element. to do this, chase down the trnxt chain.
;
prn03	BNE	(XL),=b_tet,prn04	; jump if we got there (or not te)
	MOV	XL,tenxt(XL)		; else move out on chain
	BRN	prn03			; and loop back
;
;      now we are ready for the search. to speed things up in
;      the case of calls from dump where the same name base
;      will occur repeatedly while dumping an array or table,
;      we remember the last vrblk pointer found in prnmv. so
;      first check to see if we have this one again.
;
prn04	MOV	XR,prnmv		; point to vrblk we found last time
	MOV	WA,hshtb		; point to hash table in case not
	BRN	prn07			; jump into search for special check
;
;      loop through hash slots
;
prn05	MOV	XR,WA			; copy slot pointer
	ICA	WA			; bump slot pointer
	SUB	XR,*vrnxt		; introduce standard vrblk offset
;
;      loop through vrblks on one hash chain
;
prn06	MOV	XR,vrnxt(XR)		; point to next vrblk on hash chain
;
;      merge here first time to check block we found last time
;
prn07	MOV	WC,XR			; copy vrblk pointer
	BZE	WC,prn09		; jump if chain end (or prnmv zero)
	EJC
;
;      prtnm (continued)
;
;      loop to find value (chase down possible trblk chain)
;
prn08	MOV	XR,vrval(XR)		; load value
	BEQ	(XR),=b_trt,prn08	; loop if that was a trblk
;
;      now we have the value, is this the block we want
;
	BEQ	XR,XL,prn10		; jump if this matches the name base
	MOV	XR,WC			; else point back to that vrblk
	BRN	prn06			; and loop back
;
;      here to move to next hash slot
;
prn09	BLT	WA,hshte,prn05		; loop back if more to go
	MOV	XR,XL			; else not found, copy value pointer
	JSR	prtvl			; print value
	BRN	prn11			; and merge ahead
;
;      here when we find a matching entry
;
prn10	MOV	XR,WC			; copy vrblk pointer
	MOV	prnmv,XR		; save for next time in
	JSR	prtvn			; print vaRIAble name
;
;      merge here if no entry found
;
prn11	MOV	WC,(XL)			; load first word of name base
	BNE	WC,=b_pdt,prn13		; jump if not program defined
;
;      for program defined datatype, add right paren and exit
;
	MOV	WA,=ch_rp		; load right paren, merge
;
;      merge here to print final right paren or bracket
;
prn12	JSR	prtch			; print final character
	MOV	WA,WB			; restore name offset
	BRN	prn01			; merge back to exit
	EJC
;
;      prtnm (continued)
;
;      here for array or table
;
prn13	MOV	WA,=ch_bb		; load left bracket
	JSR	prtch			; and print it
	MOV	XL,(XS)			; restore block pointer
	MOV	WC,(XL)			; load type word again
	BNE	WC,=b_tet,prn15		; jump if not table
;
;      here for table, print subscript value
;
	MOV	XR,tesub(XL)		; load subscript value
	MOV	XL,WB			; save name offset
	JSR	prtvl			; print subscript value
	MOV	WB,XL			; restore name offset
;
;      merge here from array case to print right bracket
;
prn14	MOV	WA,=ch_rb		; load right bracket
	BRN	prn12			; merge back to print it
;
;      here for array or vector, to print subscript(s)
;
prn15	MOV	WA,WB			; copy name offset
	BTW	WA			; convert to words
	BEQ	WC,=b_art,prn16		; jump if arblk
;
;      here for vector
;
	SUB	WA,=vcvlb		; adjust for standard fields
	MTI	WA			; move to integer accum
	JSR	prtin			; print linear subscript
	BRN	prn14			; merge back for right bracket
	EJC
;
;      prtnm (continued)
;
;      here for array. first calculate absolute subscript
;      offsets by successive divisions by the dimension values.
;      this must be done right to left since the elements are
;      stored row-wise. the subscripts are stacked as integers.
;
prn16	MOV	WC,arofs(XL)		; load length of bounds info
	ICA	WC			; adjust for arpro field
	BTW	WC			; convert to words
	SUB	WA,WC			; get linear zero-origin subscript
	MTI	WA			; get integer value
	LCT	WA,arndm(XL)		; set num of dimensions as loop count
	ADD	XL,arofs(XL)		; point past bounds information
	SUB	XL,*arlbd		; set ok offset for proper ptr later
;
;      loop to stack subscript offsets
;
prn17	SUB	XL,*ardms		; point to next set of bounds
	STI	prnsi			; save current offset
	RMI	ardim(XL)		; get remainder on dividing by dimens
	MFI	-(XS)			; store on stack (one word)
	LDI	prnsi			; reload argument
	DVI	ardim(XL)		; divide to get quotient
	BCT	WA,prn17		; loop till all stacked
	ZER	XR			; set offset to first set of bounds
	LCT	WB,arndm(XL)		; load count of dims to control loop
	BRN	prn19			; jump into print loop
;
;      loop to print subscripts from stack adjusting by adding
;      the appropriate low bound value from the arblk
;
prn18	MOV	WA,=ch_cm		; load a comma
	JSR	prtch			; print it
;
;      merge here first time in (no comma required)
;
prn19	MTI	(XS)+			; load subscript offset as integer
	ADD	XL,XR			; point to current lbd
	ADI	arlbd(XL)		; add lbd to get signed subscript
	SUB	XL,XR			; point back to start of arblk
	JSR	prtin			; print subscript
	ADD	XR,*ardms		; bump offset to next bounds
	BCT	WB,prn18		; loop back till all printed
	BRN	prn14			; merge back to print right bracket
	ENP				; end procedure prtnm
	EJC
;
;      prtnv -- print name value
;
;      prtnv is used by the trace and dump routines to print
;      a line of the form
;
;      name = value
;
;      note that the name involved can never be a pseudo-var
;
;      (XL)		     name base
;      (wa)		     name offset
;      jsr  prtnv	     call to print name = value
;      (WB,WC,ra)	     destroyed
;
prtnv	PRC	e,0			; entry point
	JSR	prtnm			; print argument name
	MOV	-(XS),XR		; save entry XR
	MOV	-(XS),WA		; save name offset (collectable)
	MOV	XR,=tmbeb		; point to blank equal blank
	JSR	prtst			; print it
	MOV	XR,XL			; copy name base
	ADD	XR,WA			; point to value
	MOV	XR,(XR)			; load value pointer
	JSR	prtvl			; print value
	JSR	prtnl			; terminate line
	MOV	WA,(XS)+		; restore name offset
	MOV	XR,(XS)+		; restore entry XR
	EXI				; return to caller
	ENP				; end procedure prtnv
	EJC
;
;      prtpg  -- print a page throw
;
;      prints a page throw or a few blank lines on the standard
;      listing channel depending on the listing options chosen.
;
;      jsr  prtpg	     call for page eject
;
prtpg	PRC	e,0			; entry point
	BEQ	stage,=stgxt,prp01	; jump if execution time
	BZE	lstlc,prp06		; return if top of page already
	ZER	lstlc			; clear line count
;
;      check type of listing
;
prp01	MOV	-(XS),XR		; preserve XR
	BNZ	prstd,prp02		; eject if flag set
	BNZ	prich,prp03		; jump if interactive listing channel
	BZE	precl,prp03		; jump if compact listing
;
;      perform an eject
;
prp02	JSR	sysep			; eject
	BRN	prp04			; merge
;
;      compact or interactive channel listing. cant print
;      blanks until check made for headers printed and flag set.
;
;
prp03	MOV	XR,headp		; remember headp
	MNZ	headp			; set to avoid repeated prtpg calls
	JSR	prtnl			; print blank line
	JSR	prtnl			; print blank line
	JSR	prtnl			; print blank line
	MOV	lstlc,=num03		; count blank lines
	MOV	headp,XR		; restore header flag
	EJC
;
;      prptg (continued)
;
;      print the heading
;
prp04	BNZ	headp,prp05		; jump if header listed
	MNZ	headp			; mark headers printed
	MOV	-(XS),XL		; keep XL
	MOV	XR,=headr		; point to listing header
	JSR	prtst			; place it
	JSR	sysid			; get system identification
	JSR	prtst			; append eXTra chars
	JSR	prtnl			; print it
	MOV	XR,XL			; eXTra header line
	JSR	prtst			; place it
	JSR	prtnl			; print it
	JSR	prtnl			; print a blank
	JSR	prtnl			; and another
	ADD	lstlc,=num04		; four header lines printed
	MOV	XL,(XS)+		; restore XL
;
;      merge if header not printed
;
prp05	MOV	XR,(XS)+		; restore XR
;
;      return
;
prp06	EXI				; return
	ENP				; end procedure prtpg
	EJC
;
;      prtps - print page with test for standard listing option
;
;      if the standard listing option is selected, insist that
;      an eject be done
;
;      jsr  prtps	     call for eject
;
prtps	PRC	e,0			; entry point
	MOV	prstd,prsto		; copy option flag
	JSR	prtpg			; print page
	ZER	prstd			; clear flag
	EXI				; return
	ENP				; end procedure prtps
	EJC
;
;      prtsn -- print statement number
;
;      prtsn is used to initiate a print trace line by printing
;      asterisks and the current statement number. the actual
;      format of the output generated is.
;
;      ***nnnnn**** iii.....iiii
;
;      nnnnn is the statement number with leading zeros replaced
;      by asterisks (e.g. *******9****)
;
;      iii...iii represents a vaRIAble length output consisting
;      of a number of letter i characters equal to fnclevel.
;
;      jsr  prtsn	     call to print statement number
;      (WC)		     destroyed
;
prtsn	PRC	e,0			; entry point
	MOV	-(XS),XR		; save entry XR
	MOV	prsna,WA		; save entry wa
	MOV	XR,=tmasb		; point to asterisks
	JSR	prtst			; print asterisks
	MOV	profs,=num04		; point into middle of asterisks
	MTI	kvstn			; load statement number as integer
	JSR	prtin			; print integer statement number
	MOV	profs,=prsnf		; point past asterisks plus blank
	MOV	XR,kvfnc		; get fnclevel
	MOV	WA,=ch_li		; set letter i
;
;      loop to generate letter i fnclevel times
;
prsn1	BZE	XR,prsn2		; jump if all set
	JSR	prtch			; else print an i
	DCV	XR			; decrement counter
	BRN	prsn1			; loop back
;
;      merge with all letter i characters generated
;
prsn2	MOV	WA,=ch_bl		; get blank
	JSR	prtch			; print blank
	MOV	WA,prsna		; restore entry wa
	MOV	XR,(XS)+		; restore entry XR
	EXI				; return to prtsn caller
	ENP				; end procedure prtsn
	EJC
;
;      prtst -- print string
;
;      prtst places a string of characters in the print buffer
;
;      see prtnl for global locations used
;
;      note that the first word of the block (normally b_scl)
;      is not used and need not be set correctly (see prtvn)
;
;      (XR)		     string to be printed
;      jsr  prtst	     call to print string
;      (profs)		     updated past chars placed
;
prtst	PRC	r,0			; entry point
	BNZ	headp,prst0		; were headers printed
	JSR	prtps			; no - print them
;
;      call syspr
;
prst0	MOV	prsva,WA		; save wa
	MOV	prsvb,WB		; save WB
	ZER	WB			; set chars printed count to zero
;
;      loop to print successive lines for long string
;
prst1	MOV	WA,sclen(XR)		; load string length
	SUB	WA,WB			; subtract count of chars already out
	BZE	WA,prst4		; jump to exit if none left
	MOV	-(XS),XL		; else stack entry XL
	MOV	-(XS),XR		; save argument
	MOV	XL,XR			; copy for eventual move
	MOV	XR,prlen		; load print buffer length
	SUB	XR,profs		; get chars left in print buffer
	BNZ	XR,prst2		; skip if room left on this line
	JSR	prtnl			; else print this line
	MOV	XR,prlen		; and set full width available
	EJC
;
;      prtst (continued)
;
;      here with chars to print and some room in buffer
;
prst2	BLO	WA,XR,prst3		; jump if room for rest of string
	MOV	WA,XR			; else set to fill line
;
;      merge here with character count in wa
;
prst3	MOV	XR,prbuf		; point to print buffer
	PLC	XL,WB			; point to location in string
	PSC	XR,profs		; point to location in buffer
	ADD	WB,WA			; bump string chars count
	ADD	profs,WA		; bump buffer pointer
	MOV	prsvc,WB		; preserve char counter
	MVC				; move characters to buffer
	MOV	WB,prsvc		; recover char counter
	MOV	XR,(XS)+		; restore argument pointer
	MOV	XL,(XS)+		; restore entry XL
	BRN	prst1			; loop back to test for more
;
;      here to exit after printing string
;
prst4	MOV	WB,prsvb		; restore entry WB
	MOV	WA,prsva		; restore entry wa
	EXI				; return to prtst caller
	ENP				; end procedure prtst
	EJC
;
;      prttr -- print to terminal
;
;      called to print contents of standard print buffer to
;      online terminal. clears buffer down and resets profs.
;
;      jsr  prttr	     call for print
;      (wa,WB)		     destroyed
;
prttr	PRC	e,0			; entry point
	MOV	-(XS),XR		; save XR
	JSR	prtic			; print buffer contents
	MOV	XR,prbuf		; point to print bfr to clear it
	LCT	WA,prlnw		; get buffer length
	ADD	XR,*schar		; point past scblk header
	MOV	WB,nullw		; get blanks
;
;      loop to clear buffer
;
prtt1	MOV	(XR)+,WB		; clear a word
	BCT	WA,prtt1		; loop
	ZER	profs			; reset profs
	MOV	XR,(XS)+		; restore XR
	EXI				; return
	ENP				; end procedure prttr
	EJC
;
;      prtvl -- print a value
;
;      prtvl places an appropriate character representation of
;      a data value in the print buffer for dump/trace use.
;
;      (XR)		     value to be printed
;      jsr  prtvl	     call to print value
;      (wa,WB,WC,ra)	     destroyed
;
prtvl	PRC	r,0			; entry point, recursive
	MOV	-(XS),XL		; save entry XL
	MOV	-(XS),XR		; save argument
	CHK				; check for stack overflow
;
;      loop back here after finding a trap block (trblk)
;
prv01	MOV	prvsi,idval(XR)		; copy idval (if any)
	MOV	XL,(XR)			; load first word of block
	LEI	XL			; load entry point id
	BSW	XL,bl__t,prv02		; switch on block type
	IFF	bl_tr,prv04		; trblk
	IFF	bl_ar,prv05		; arblk
	IFF	bl_ic,prv08		; icblk
	IFF	bl_nm,prv09		; nmblk
	IFF	bl_pd,prv10		; pdblk
.IF    .cnra
.ELSE
	IFF	bl_rc,prv08		; rcblk
.FI
	IFF	bl_sc,prv11		; scblk
	IFF	bl_se,prv12		; seblk
	IFF	bl_tb,prv13		; tbblk
	IFF	bl_vc,prv13		; vcblk
.IF    .cnbf
.ELSE
	IFF	bl_bc,prv15		; bcblk
.FI
	ESW				; end of switch on block type
;
;      here for blocks for which we just print datatype name
;
prv02	JSR	dtype			; get datatype name
	JSR	prtst			; print datatype name
;
;      common exit point
;
prv03	MOV	XR,(XS)+		; reload argument
	MOV	XL,(XS)+		; restore XL
	EXI				; return to prtvl caller
;
;      here for trblk
;
prv04	MOV	XR,trval(XR)		; load real value
	BRN	prv01			; and loop back
	EJC
;
;      prtvl (continued)
;
;      here for array (arblk)
;
;      print array ( prototype ) blank number idval
;
prv05	MOV	XL,XR			; preserve argument
	MOV	XR,=scarr		; point to datatype name (array)
	JSR	prtst			; print it
	MOV	WA,=ch_pp		; load left paren
	JSR	prtch			; print left paren
	ADD	XL,arofs(XL)		; point to prototype
	MOV	XR,(XL)			; load prototype
	JSR	prtst			; print prototype
;
;      vcblk, tbblk, bcblk merge here for ) blank number idval
;
prv06	MOV	WA,=ch_rp		; load right paren
	JSR	prtch			; print right paren
;
;      pdblk merges here to print blank number idval
;
prv07	MOV	WA,=ch_bl		; load blank
	JSR	prtch			; print it
	MOV	WA,=ch_nm		; load number sign
	JSR	prtch			; print it
	MTI	prvsi			; get idval
	JSR	prtin			; print id number
	BRN	prv03			; back to exit
;
;      here for integer (icblk), real (rcblk)
;
;      print character representation of value
;
prv08	MOV	-(XS),XR		; stack argument for gtstg
	JSR	gtstg			; convert to string
	PPM				; error return is impossible
	JSR	prtst			; print the string
	MOV	dnamp,XR		; delete garbage string from storage
	BRN	prv03			; back to exit
	EJC
;
;      prtvl (continued)
;
;      name (nmblk)
;
;      for pseudo-vaRIAble, just print datatype name (name)
;      for all other names, print dot followed by name rep
;
prv09	MOV	XL,nmbas(XR)		; load name base
	MOV	WA,(XL)			; load first word of block
	BEQ	WA,=b_kvt,prv02		; just print name if keyword
	BEQ	WA,=b_evt,prv02		; just print name if expression var
	MOV	WA,=ch_dt		; else get dot
	JSR	prtch			; and print it
	MOV	WA,nmofs(XR)		; load name offset
	JSR	prtnm			; print name
	BRN	prv03			; back to exit
;
;      program datatype (pdblk)
;
;      print datatype name ch_bl ch_nm idval
;
prv10	JSR	dtype			; get datatype name
	JSR	prtst			; print datatype name
	BRN	prv07			; merge back to print id
;
;      here for string (scblk)
;
;      print quote string-characters quote
;
prv11	MOV	WA,=ch_sq		; load single quote
	JSR	prtch			; print quote
	JSR	prtst			; print string value
	JSR	prtch			; print another quote
	BRN	prv03			; back to exit
	EJC
;
;      prtvl (continued)
;
;      here for simple expression (seblk)
;
;      print asterisk vaRIAble-name
;
prv12	MOV	WA,=ch_as		; load asterisk
	JSR	prtch			; print asterisk
	MOV	XR,sevar(XR)		; load vaRIAble pointer
	JSR	prtvn			; print vaRIAble name
	BRN	prv03			; jump back to exit
;
;      here for table (tbblk) and array (vcblk)
;
;      print datatype ( prototype ) blank number idval
;
prv13	MOV	XL,XR			; preserve argument
	JSR	dtype			; get datatype name
	JSR	prtst			; print datatype name
	MOV	WA,=ch_pp		; load left paren
	JSR	prtch			; print left paren
	MOV	WA,tblen(XL)		; load length of block (=vclen)
	BTW	WA			; convert to word count
	SUB	WA,=tbsi_		; allow for standard fields
	BEQ	(XL),=b_tbt,prv14	; jump if table
	ADD	WA,=vctbd		; for vcblk, adjust size
;
;      print prototype
;
prv14	MTI	WA			; move as integer
	JSR	prtin			; print integer prototype
	BRN	prv06			; merge back for rest
.IF    .cnbf
.ELSE
	EJC
;
;      prtvl (continued)
;
;      here for buffer (bcblk)
;
prv15	MOV	XL,XR			; preserve argument
	MOV	XR,=scbuf		; point to datatype name (buffer)
	JSR	prtst			; print it
	MOV	WA,=ch_pp		; load left paren
	JSR	prtch			; print left paren
	MOV	XR,bcbuf(XL)		; point to bfblk
	MTI	bfalc(XR)		; load allocation size
	JSR	prtin			; print it
	MOV	WA,=ch_cm		; load comma
	JSR	prtch			; print it
	MTI	bclen(XL)		; load defined length
	JSR	prtin			; print it
	BRN	prv06			; merge to finish up
.FI
	ENP				; end procedure prtvl
	EJC
;
;      prtvn -- print natural vaRIAble name
;
;      prtvn prints the name of a natural vaRIAble
;
;      (XR)		     pointer to vrblk
;      jsr  prtvn	     call to print vaRIAble name
;
prtvn	PRC	e,0			; entry point
	MOV	-(XS),XR		; stack vrblk pointer
	ADD	XR,*vrsof		; point to possible string name
	BNZ	sclen(XR),prvn1		; jump if not system vaRIAble
	MOV	XR,vrsvo(XR)		; point to svblk with name
;
;      merge here with dummy scblk pointer in XR
;
prvn1	JSR	prtst			; print string name of vaRIAble
	MOV	XR,(XS)+		; restore vrblk pointer
	EXI				; return to prtvn caller
	ENP				; end procedure prtvn
.IF    .cnra
.ELSE
	EJC
;
;      rcbld -- build a real block
;
;      (RA)		     real value for rcblk
;      jsr  rcbld	     call to build real block
;      (XR)		     pointer to result rcblk
;      (wa)		     destroyed
;
rcbld	PRC	e,0			; entry point
	MOV	XR,dnamp		; load pointer to next available loc
	ADD	XR,*rcsi_		; point past new rcblk
	BLO	XR,dname,rcbl1		; jump if there is room
	MOV	WA,*rcsi_		; else load rcblk length
	JSR	alloc			; use standard allocator to get block
	ADD	XR,WA			; point past block to merge
;
;      merge here with XR pointing past the block obtained
;
rcbl1	MOV	dnamp,XR		; set new pointer
	SUB	XR,*rcsi_		; point back to start of block
	MOV	(XR),=b_rcl		; store type word
	STR	rcval(XR)		; store real value in rcblk
	EXI				; return to rcbld caller
	ENP				; end procedure rcbld
.FI
	EJC
;
;      readr -- read next source image at compile time
;
;      readr is used to read the next source image. to process
;      continuation cards properly, the compiler must read one
;      line ahead. thus readr does not destroy the current image
;      see also the nexts routine which actually gets the image.
;
;      jsr  readr	     call to read next image
;      (XR)		     ptr to next image (0 if none)
;      (r_cni)		     copy of pointer
;      (wa,WB,WC,XL)	     destroyed
;
readr	PRC	e,0			; entry point
	MOV	XR,r_cni		; get ptr to next image
	BNZ	XR,read3		; exit if already read
.IF    .cinc
	BNZ	cnind,reada		; if within include file
.FI
	BNE	stage,=stgic,read3	; exit if not initial compile
reada	MOV	WA,cswin		; max read length
	ZER	XL			; clear any dud value in XL
	JSR	alocs			; allocate buffer
	JSR	sysrd			; read input image
	PPM	read4			; jump if eof or new file name
	ICV	rdnln			; increment next line number
.IF    .cpol
	DCV	polct			; test if time to poll interface
	BNZ	polct,read0		; not yet
	ZER	WA			; =0 for poll
	MOV	WB,rdnln		; line number
	JSR	syspl			; allow interactive access
	ERR	320,user interrupt
	PPM				; single step
	PPM				; expression evaluation
	MOV	polcs,WA		; new countdown start value
	MOV	polct,WA		; new counter value
.FI
read0	BLE	sclen(XR),cswin,read1	; use smaller of string lnth ...
	MOV	sclen(XR),cswin		; ... and xxx of -inxxx
;
;      perform the trim
;
read1	MNZ	WB			; set trimr to perform trim
	JSR	trimr			; trim trailing blanks
;
;      merge here after read
;
read2	MOV	r_cni,XR		; store copy of pointer
;
;      merge here if no read attempted
;
read3	EXI				; return to readr caller
.IF    .csfn
;
;      here on end of file or new source file name.
;      if this is a new source file name, the r_sfn table will
;      be augmented with a new table entry consisting of the
;      current compiler statement number as subscript, and the
;      file name as value.
;
read4	BZE	sclen(XR),read5		; jump if true end of file
	ZER	WB			; new source file name
	MOV	rdnln,WB		; restart line counter for new file
	JSR	trimr			; remove unused space in block
	JSR	newfn			; record new file name
	BRN	reada			; now reissue read for record data
;
;      here on end of file
;
read5	MOV	dnamp,XR		; pop unused scblk
.IF    .cinc
	BZE	cnind,read6		; jump if not within an include file
	ZER	XL			; eof within include file
	JSR	sysif			; switch stream back to previous file
	PPM
	MOV	WA,cnind		; restore prev line number, file name
	ADD	WA,=vcvlb		; vector offset in words
	WTB	WA			; convert to bytes
	MOV	XR,r_ifa		; file name array
	ADD	XR,WA			; ptr to element
	MOV	r_sfc,(XR)		; change source file name
	MOV	(XR),=nulls		; release scblk
	MOV	XR,r_ifl		; line number array
	ADD	XR,WA			; ptr to element
	MOV	XL,(XR)			; icblk containing saved line number
	LDI	icval(XL)		; line number integer
	MFI	rdnln			; change source line number
	MOV	(XR),=inton		; release icblk
	DCV	cnind			; decrement nesting level
	MOV	WB,cmpsn		; current statement number
	ICV	WB			; anticipate end of previous stmt
	MTI	WB			; convert to integer
	JSR	icbld			; build icblk for stmt number
	MOV	XL,r_sfn		; file name table
	MNZ	WB			; lookup statement number by name
	JSR	tfind			; allocate new teblk
	PPM				; always possible to allocate block
	MOV	teval(XL),r_sfc		; record file name as entry value
	BEQ	stage,=stgic,reada	; if initial compile, reissue read
	BNZ	cnind,reada		; still reading from include file
;
;      outer nesting of execute-time compile of -include
;      resume with any string remaining prior to -include.
;
	MOV	XL,r_ici		; restore code argument string
	ZER	r_ici			; release original string
	MOV	WA,cnsil		; get length of string
	MOV	WB,cnspt		; offset of characters left
	SUB	WA,WB			; number of characters left
	MOV	scnil,WA		; set new scan length
	ZER	scnpt			; scan from start of substring
	JSR	sbstr			; create substring of remainder
	MOV	r_cim,XR		; set scan image
	BRN	read2			; return
.FI
.ELSE
;
;      here on end of file
;
read4	MOV	dnamp,XR		; pop unused scblk
.IF    .cinc
	BZE	cnind,read6		; jump if not within an include file
	ZER	XL			; eof within include file
	JSR	sysif			; switch stream back to previous file
	PPM
	DCV	cnind			; decrement nesting level
	BRN	reada			; reissue read from previous stream
.FI
.FI
read6	ZER	XR			; zero ptr as result
	BRN	read2			; merge
	ENP				; end procedure readr
	EJC
.IF    .c370
;
;      sbool-- setup for boolean operations on strings
;
;      1(XS)		     first argument (if two)
;      0(XS)		     second argument
;      (WB)		     number of arguments
;			      zero = one arguments
;			      non-zero = two arguments
;      jsr  sbool	     call to perform operation
;      ppm  loc		     transfer loc for arg1 not string
;      ppm  loc		     transfer loc for arg2 not string
;      ppm  loc		     transfer loc arg lengths not equal
;      ppm  loc		     transfer loc if null string args
;      (XS)		     arguments popped, result stacked
;      (XL)		     arg 1 chars to operate upon
;      (XR)		     copy of arg 2 if two arguments
;      (wa)		     no. of characters to process
;      (WC)		     no. of words to process (bct ready)
;      (WB)		     destroyed
;
;      the second argument string block is copied to a result
;      block, and pointers returned to allow the caller to
;      proceed with the desired operation if two arguments.
;
;      operations like and/or that do not alter the trailing
;      zeros in the last word of the string block can be
;      performed a word at a time.  operations such as compl
;      may either be performed a character at a time or will
;      have to adjust the last word if done a word at a time.
;
sbool	PRC	n,3			; entry point
	JSR	gtstg			; convert second arg to string
	PPM	sbl05			; jump if second arg not string
	MOV	XL,XR			; else save pointer
	MOV	WC,WA			; and length
	BZE	WB,sbl01		; only one argument if compl
	JSR	gtstg			; convert first argument to string
	PPM	sbl04			; jump if not string
	BNE	WA,WC,sbl03		; jump if lengths unequal
;
;      merge here if only one argument
;
sbl01	MOV	-(XS),XR		; stack first argument
	BZE	WC,sbl02		; return null if null argument
	JSR	alocs			; allocate space for copy
	BZE	WB,sbl06		; only one argument if compl
	MOV	WA,WC			; string length
	MOV	WB,XR			; save address of copy
	CTB	WA,schar		; get scblk length
	MVW				; move arg2 contents to copy
	MOV	XR,WB			; reload result ptr
sbl06	MOV	XL,(XS)+		; reload first argument
	MOV	-(XS),XR		; stack result
	ADD	XL,*schar		; point to characters in arg 1 block
	ADD	XR,*schar		; point to characters in result block
	MOV	WA,WC			; character count
	CTW	WC,0			; number of words of characters
	LCT	WC,WC			; prepare counter
	EXI
;
;      here if null arguments
;
sbl02	EXI	4			; take null string exit
;
;      here if argument lengths unequal
;
sbl03	EXI	3			; take unequal length error exit
;
;      here if first arg is not a string
;
sbl04	EXI	1			; take bad first arg error exit
;
;      here for second arg not a string
;
sbl05	EXI	2			; take bad second arg error exit
	ENP				; end procedure sbool
	EJC
.FI
;
;      sbstr -- build a substring
;
;      (XL)		     ptr to scblk/bfblk with chars
;      (wa)		     number of chars in substring
;      (WB)		     offset to first char in scblk
;      jsr  sbstr	     call to build substring
;      (XR)		     ptr to new scblk with substring
;      (XL)		     zero
;      (wa,WB,WC,XL,ia)	     destroyed
;
;      note that sbstr is called with a dummy string pointer
;      (pointing into a vrblk or svblk) to copy the name of a
;      vaRIAble as a standard string value.
;
sbstr	PRC	e,0			; entry point
	BZE	WA,sbst2		; jump if null substring
	JSR	alocs			; else allocate scblk
	MOV	WA,WC			; move number of characters
	MOV	WC,XR			; save ptr to new scblk
	PLC	XL,WB			; prepare to load chars from old blk
	PSC	XR			; prepare to store chars in new blk
	MVC				; move characters to new string
	MOV	XR,WC			; then restore scblk pointer
;
;      return point
;
sbst1	ZER	XL			; clear garbage pointer in XL
	EXI				; return to sbstr caller
;
;      here for null substring
;
sbst2	MOV	XR,=nulls		; set null string as result
	BRN	sbst1			; return
	ENP				; end procedure sbstr
	EJC
;
;      stgcc -- compute counters for stmt startup testing
;
;      jsr  stgcc	     call to recompute counters
;      (wa,WB)		     destroyed
;
;      on exit, stmcs and stmct contain the counter value to
;      tested in stmgo.
;
;
stgcc	PRC	e,0			;
.IF    .cpol
	MOV	WA,polcs		; assume no profiling or stcount tracing
	MOV	WB,=num01		; poll each time polcs expires
.ELSE
	MOV	WA,mxint		; assume no profiling or stcount tracing
.FI
	LDI	kvstl			; get stmt limit
	BNZ	kvpfl,stgc1		; jump if profiling enabled
	ILT	stgc3			; no stcount tracing if negative
	BZE	r_stc,stgc2		; jump if not stcount tracing
;
;      here if profiling or if stcount tracing enabled
;
.IF    .cpol
stgc1	MOV	WB,WA			; count polcs times within stmg
	MOV	WA,=num01		; break out of stmgo on each stmt
.ELSE
stgc1	MOV	WA,=num01		; break out of stmgo on each stmt
.FI
	BRN	stgc3			;
;
;      check that stmcs does not exceed kvstl
;
stgc2	MTI	WA			; breakout count start value
	SBI	kvstl			; proposed stmcs minus stmt limit
	ILE	stgc3			; jump if stmt count does not limit
	LDI	kvstl			; stlimit limits breakcount count
	MFI	WA			; use it instead
;
;      re-initialize counter
;
stgc3	MOV	stmcs,WA		; update breakout count start value
	MOV	stmct,WA		; reset breakout counter
.IF    .cpol
	MOV	polct,WB		;
.FI
	EXI
	EJC
;
;      tfind -- locate table element
;
;      (XR)		     subscript value for element
;      (XL)		     pointer to table
;      (WB)		     zero by value, non-zero by name
;      jsr  tfind	     call to locate element
;      ppm  loc		     transfer location if access fails
;      (XR)		     element value (if by value)
;      (XR)		     destroyed (if by name)
;      (XL,WA)		     teblk name (if by name)
;      (XL,WA)		     destroyed (if by value)
;      (WC,ra)		     destroyed
;
;      note that if a call by value specifies a non-existent
;      subscript, the default value is returned without building
;      a new teblk.
;
tfind	PRC	e,1			; entry point
	MOV	-(XS),WB		; save name/value indicator
	MOV	-(XS),XR		; save subscript value
	MOV	-(XS),XL		; save table pointer
	MOV	WA,tblen(XL)		; load length of tbblk
	BTW	WA			; convert to word count
	SUB	WA,=tbbuk		; get number of buckets
	MTI	WA			; convert to integer value
	STI	tfnsi			; save for later
	MOV	XL,(XR)			; load first word of subscript
	LEI	XL			; load block entry id (bl_xx)
	BSW	XL,bl__d,tfn00		; switch on block type
	IFF	bl_ic,tfn02		; jump if integer
.IF    .cnra
.ELSE
	IFF	bl_rc,tfn02		; real
.FI
	IFF	bl_p0,tfn03		; jump if pattern
	IFF	bl_p1,tfn03		; jump if pattern
	IFF	bl_p2,tfn03		; jump if pattern
	IFF	bl_nm,tfn04		; jump if name
	IFF	bl_sc,tfn05		; jump if string
	ESW				; end switch on block type
;
;      here for blocks for which we use the second word of the
;      block as the hash source (see block formats for details).
;
tfn00	MOV	WA,1(XR)		; load second word
;
;      merge here with one word hash source in wa
;
tfn01	MTI	WA			; convert to integer
	BRN	tfn06			; jump to merge
	EJC
;
;      tfind (continued)
;
;      here for integer or real
;      possibility of overflow exist on twos complement
;      machine if hash source is most negative integer or is
;      a real having the same bit pattern.
;
;
tfn02	LDI	1(XR)			; load value as hash source
	IGE	tfn06			; ok if positive or zero
	NGI				; make positive
	IOV	tfn06			; clear possible overflow
	BRN	tfn06			; merge
;
;      for pattern, use first word (pcode) as source
;
tfn03	MOV	WA,(XR)			; load first word as hash source
	BRN	tfn01			; merge back
;
;      for name, use offset as hash source
;
tfn04	MOV	WA,nmofs(XR)		; load offset as hash source
	BRN	tfn01			; merge back
;
;      here for string
;
tfn05	JSR	hashs			; call routine to compute hash
;
;      merge here with hash source in (ia)
;
tfn06	RMI	tfnsi			; compute hash index by remaindering
	MFI	WC			; get as one word integer
	WTB	WC			; convert to byte offset
	MOV	XL,(XS)			; get table ptr again
	ADD	XL,WC			; point to proper bucket
	MOV	XR,tbbuk(XL)		; load first teblk pointer
	BEQ	XR,(XS),tfn10		; jump if no teblks on chain
;
;      loop through teblks on hash chain
;
tfn07	MOV	WB,XR			; save teblk pointer
	MOV	XR,tesub(XR)		; load subscript value
	MOV	XL,1(XS)		; load input argument subscript val
	JSR	ident			; compare them
	PPM	tfn08			; jump if equal (ident)
;
;      here if no match with that teblk
;
	MOV	XL,WB			; restore teblk pointer
	MOV	XR,tenxt(XL)		; point to next teblk on chain
	BNE	XR,(XS),tfn07		; jump if there is one
;
;      here if no match with any teblk on chain
;
	MOV	WC,*tenxt		; set offset to link field (XL base)
	BRN	tfn11			; jump to merge
	EJC
;
;      tfind (continued)
;
;      here we have found a matching element
;
tfn08	MOV	XL,WB			; restore teblk pointer
	MOV	WA,*teval		; set teblk name offset
	MOV	WB,2(XS)		; restore name/value indicator
	BNZ	WB,tfn09		; jump if called by name
	JSR	acess			; else get value
	PPM	tfn12			; jump if reference fails
	ZER	WB			; restore name/value indicator
;
;      common exit for entry found
;
tfn09	ADD	XS,*num03		; pop stack entries
	EXI				; return to tfind caller
;
;      here if no teblks on the hash chain
;
tfn10	ADD	WC,*tbbuk		; get offset to bucket ptr
	MOV	XL,(XS)			; set tbblk ptr as base
;
;      merge here with (XL,WC) base,offset of final link
;
tfn11	MOV	XR,(XS)			; tbblk pointer
	MOV	XR,tbinv(XR)		; load default value in case
	MOV	WB,2(XS)		; load name/value indicator
	BZE	WB,tfn09		; exit with default if value call
	MOV	WB,XR			; copy default value
;
;      here we must build a new teblk
;
	MOV	WA,*tesi_		; set size of teblk
	JSR	alloc			; allocate teblk
	ADD	XL,WC			; point to hash link
	MOV	(XL),XR			; link new teblk at end of chain
	MOV	(XR),=b_tet		; store type word
	MOV	teval(XR),WB		; set default as initial value
	MOV	tenxt(XR),(XS)+		; set tbblk ptr to mark end of chain
	MOV	tesub(XR),(XS)+		; store subscript value
	MOV	WB,(XS)+		; restore name/value indicator
	MOV	XL,XR			; copy teblk pointer (name base)
	MOV	WA,*teval		; set offset
	EXI				; return to caller with new teblk
;
;      acess fail return
;
tfn12	EXI	1			; alternative return
	ENP				; end procedure tfind
	EJC
;
;      tmake -- make new table
;
;      (XL)		     initial lookup value
;      (WC)		     number of buckets desired
;      jsr  tmake	     call to make new table
;      (XR)		     new table
;      (wa,WB)		     destroyed
;
tmake	PRC	e,0			;
	MOV	WA,WC			; copy number of headers
	ADD	WA,=tbsi_		; adjust for standard fields
	WTB	WA			; convert length to bytes
	JSR	alloc			; allocate space for tbblk
	MOV	WB,XR			; copy pointer to tbblk
	MOV	(XR)+,=b_tbt		; store type word
	ZER	(XR)+			; zero id for the moment
	MOV	(XR)+,WA		; store length (tblen)
	MOV	(XR)+,XL		; store initial lookup value
	LCT	WC,WC			; set loop counter (num headers)
;
;      loop to initialize all bucket pointers
;
tma01	MOV	(XR)+,WB		; store tbblk ptr in bucket header
	BCT	WC,tma01		; loop till all stored
	MOV	XR,WB			; recall pointer to tbblk
	EXI
	ENP
	EJC
;
;      vmake -- create a vector
;
;      (wa)		     number of elements in vector
;      (XL)		     default value for vector elements
;      jsr  vmake	     call to create vector
;      ppm  loc		     if vector too large
;
;      (XR)		     pointer to vcblk
;      (wa,WB,WC,XL)	     destroyed
;
vmake	PRC	e,1			; entry point
	LCT	WB,WA			; copy elements for loop later on
	ADD	WA,=vcsi_		; add space for standard fields
	WTB	WA			; convert length to bytes
	BGT	WA,mxlen,vmak2		; fail if too large
	JSR	alloc			; allocate space for vcblk
	MOV	(XR),=b_vct		; store type word
	ZER	idval(XR)		; initialize idval
	MOV	vclen(XR),WA		; set length
	MOV	WC,XL			; copy default value
	MOV	XL,XR			; copy vcblk pointer
	ADD	XL,*vcvls		; point to first element value
;
;      loop to set vector elements to default value
;
vmak1	MOV	(XL)+,WC		; store one value
	BCT	WB,vmak1		; loop till all stored
	EXI				; success return
;
;      here if desired vector size too large
;
vmak2	EXI	1			; fail return
	ENP
	EJC
;
;      scane -- scan an element
;
;      scane is called at compile time (by expan ,cmpil,cncrd)
;      to scan one element from the input image.
;
;      (scncc)		     non-zero if called from cncrd
;      jsr  scane	     call to scan element
;      (XR)		     result pointer (see below)
;      (XL)		     syntax type code (t_xxx)
;
;      the following global locations are used.
;
;      r_cim		     pointer to string block (scblk)
;			     for current input image.
;
;      r_cni		     pointer to next input image string
;			     pointer (zero if none).
;
;      r_scp		     save pointer (exit XR) from last
;			     call in case rescan is set.
;
;      scnbl		     this location is set non-zero on
;			     exit if scane scanned past blanks
;			     before locating the current element
;			     the end of a line counts as blanks.
;
;      scncc		     cncrd sets this non-zero to scan
;			     control card names and clears it
;			     on return
;
;      scnil		     length of current input image
;
;      scngo		     if set non-zero on entry, f and s
;			     are returned as separate syntax
;			     types (not letters) (goto pro-
;			     cessing). scngo is reset on exit.
;
;      scnpt		     offset to current loc in r_cim
;
;      scnrs		     if set non-zero on entry, scane
;			     returns the same result as on the
;			     last call (rescan). scnrs is reset
;			     on exit from any call to scane.
;
;      scntp		     save syntax type from last
;			     call (in case rescan is set).
	EJC
;
;      scane (continued)
;
;
;
;      element scanned	     XL	       XR
;      ---------------	     --	       --
;
;      control card name     0	       pointer to scblk for name
;
;      unary operator	     t_uop     ptr to operator dvblk
;
;      left paren	     t_lpr     t_lpr
;
;      left bracket	     t_lbr     t_lbr
;
;      comma		     t_cma     t_cma
;
;      function call	     t_fnc     ptr to function vrblk
;
;      vaRIAble		     t_var     ptr to vrblk
;
;      string constant	     t_con     ptr to scblk
;
;      integer constant	     t_con     ptr to icblk
;
.IF    .cnra
.ELSE
;      real constant	     t_con     ptr to rcblk
;
.FI
;      binary operator	     t_bop     ptr to operator dvblk
;
;      right paren	     t_rpr     t_rpr
;
;      right bracket	     t_rbr     t_rbr
;
;      colon		     t_col     t_col
;
;      semi-colon	     t_smc     t_smc
;
;      f (scngo ne 0)	     t_fgo     t_fgo
;
;      s (scngo ne 0)	     t_sgo     t_sgo
	EJC
;
;      scane (continued)
;
;      entry point
;
scane	PRC	e,0			; entry point
	ZER	scnbl			; reset blanks flag
	MOV	scnsa,WA		; save wa
	MOV	scnsb,WB		; save WB
	MOV	scnsc,WC		; save WC
	BZE	scnrs,scn03		; jump if no rescan
;
;      here for rescan request
;
	MOV	XL,scntp		; set previous returned scan type
	MOV	XR,r_scp		; set previous returned pointer
	ZER	scnrs			; reset rescan switch
	BRN	scn13			; jump to exit
;
;      come here to read new image to test for continuation
;
scn01	JSR	readr			; read next image
	MOV	WB,*dvubs		; set WB for not reading name
	BZE	XR,scn30		; treat as semi-colon if none
	PLC	XR			; else point to first character
	LCH	WC,(XR)			; load first character
	BEQ	WC,=ch_dt,scn02		; jump if dot for continuation
	BNE	WC,=ch_pl,scn30		; else treat as semicolon unless plus
;
;      here for continuation line
;
scn02	JSR	nexts			; acquire next source image
	MOV	scnpt,=num01		; set scan pointer past continuation
	MNZ	scnbl			; set blanks flag
	EJC
;
;      scane (continued)
;
;      merge here to scan next element on current line
;
scn03	MOV	WA,scnpt		; load current offset
	BEQ	WA,scnil,scn01		; check continuation if end
	MOV	XL,r_cim		; point to current line
	PLC	XL,WA			; point to current character
	MOV	scnse,WA		; set start of element location
	MOV	WC,=opdvs		; point to operator dv list
	MOV	WB,*dvubs		; set constant for operator circuit
	BRN	scn06			; start scanning
;
;      loop here to ignore leading blanks and tabs
;
scn05	BZE	WB,scn10		; jump if trailing
	ICV	scnse			; increment start of element
	BEQ	WA,scnil,scn01		; jump if end of image
	MNZ	scnbl			; note blanks seen
;
;      the following jump is used repeatedly for scanning out
;      the characters of a numeric constant or vaRIAble name.
;      the registers are used as follows.
;
;      (XR)		     scratch
;      (XL)		     ptr to next character
;      (wa)		     current scan offset
;      (WB)		     *dvubs (0 if scanning name,const)
;      (WC)		     =opdvs (0 if scanning constant)
;
scn06	LCH	XR,(XL)+		; get next character
	ICV	WA			; bump scan offset
	MOV	scnpt,WA		; store offset past char scanned
.IF    .cucf
	BSW	XR,cfp_u,scn07		; switch on scanned character
.ELSE
	BSW	XR,cfp_a,scn07		; switch on scanned character
.FI
;
;      switch table for switch on character
;
	IFF	ch_bl,scn05		; blank
.IF    .caht
	IFF	ch_ht,scn05		; horizontal tab
.FI
.IF    .cavt
	IFF	ch_vt,scn05		; vertical tab
.FI
.IF    .caex
	IFF	ch_ey,scn37		; up arrow
.FI
	IFF	ch_d0,scn08		; digit 0
	IFF	ch_d1,scn08		; digit 1
	IFF	ch_d2,scn08		; digit 2
	IFF	ch_d3,scn08		; digit 3
	IFF	ch_d4,scn08		; digit 4
	IFF	ch_d5,scn08		; digit 5
	IFF	ch_d6,scn08		; digit 6
	IFF	ch_d7,scn08		; digit 7
	IFF	ch_d8,scn08		; digit 8
	IFF	ch_d9,scn08		; digit 9
	EJC
;
;      scane (continued)
;
	IFF	ch_la,scn09		; letter a
	IFF	ch_lb,scn09		; letter b
	IFF	ch_lc,scn09		; letter c
	IFF	ch_ld,scn09		; letter d
	IFF	ch_le,scn09		; letter e
	IFF	ch_lg,scn09		; letter g
	IFF	ch_lh,scn09		; letter h
	IFF	ch_li,scn09		; letter i
	IFF	ch_lj,scn09		; letter j
	IFF	ch_lk,scn09		; letter k
	IFF	ch_ll,scn09		; letter l
	IFF	ch_lm,scn09		; letter m
	IFF	ch_ln,scn09		; letter n
	IFF	ch_lo,scn09		; letter o
	IFF	ch_lp,scn09		; letter p
	IFF	ch_lq,scn09		; letter q
	IFF	ch_lr,scn09		; letter r
	IFF	ch_lt,scn09		; letter t
	IFF	ch_lu,scn09		; letter u
	IFF	ch_lv,scn09		; letter v
	IFF	ch_lw,scn09		; letter w
	IFF	ch_lx,scn09		; letter x
	IFF	ch_ly,scn09		; letter y
	IFF	ch_l_,scn09		; letter z
.IF    .casl
	IFF	ch_ua,scn09		; shifted a
	IFF	ch_ub,scn09		; shifted b
	IFF	ch_uc,scn09		; shifted c
	IFF	ch_ud,scn09		; shifted d
	IFF	ch_ue,scn09		; shifted e
	IFF	ch_uf,scn20		; shifted f
	IFF	ch_ug,scn09		; shifted g
	IFF	ch_uh,scn09		; shifted h
	IFF	ch_ui,scn09		; shifted i
	IFF	ch_uj,scn09		; shifted j
	IFF	ch_uk,scn09		; shifted k
	IFF	ch_ul,scn09		; shifted l
	IFF	ch_um,scn09		; shifted m
	IFF	ch_un,scn09		; shifted n
	IFF	ch_uo,scn09		; shifted o
	IFF	ch_up,scn09		; shifted p
	IFF	ch_uq,scn09		; shifted q
	IFF	ch_ur,scn09		; shifted r
	IFF	ch_us,scn21		; shifted s
	IFF	ch_ut,scn09		; shifted t
	IFF	ch_uu,scn09		; shifted u
	IFF	ch_uv,scn09		; shifted v
	IFF	ch_uw,scn09		; shifted w
	IFF	ch_ux,scn09		; shifted x
	IFF	ch_uy,scn09		; shifted y
	IFF	ch_uz,scn09		; shifted z
.FI
	EJC
;
;      scane (continued)
;
	IFF	ch_sq,scn16		; single quote
	IFF	ch_dq,scn17		; double quote
	IFF	ch_lf,scn20		; letter f
	IFF	ch_ls,scn21		; letter s
	IFF	ch_u_,scn24		; underline
	IFF	ch_pp,scn25		; left paren
	IFF	ch_rp,scn26		; right paren
	IFF	ch_rb,scn27		; right bracket
	IFF	ch_bb,scn28		; left bracket
	IFF	ch_cb,scn27		; right bracket
	IFF	ch_ob,scn28		; left bracket
	IFF	ch_cl,scn29		; colon
	IFF	ch_sm,scn30		; semi-colon
	IFF	ch_cm,scn31		; comma
	IFF	ch_dt,scn32		; dot
	IFF	ch_pl,scn33		; plus
	IFF	ch_mn,scn34		; minus
	IFF	ch_nt,scn35		; not
	IFF	ch_dl,scn36		; dollar
	IFF	ch_ex,scn37		; exclamation mark
	IFF	ch_pc,scn38		; percent
	IFF	ch_sl,scn40		; slash
	IFF	ch_nm,scn41		; number sign
	IFF	ch_at,scn42		; at
	IFF	ch_br,scn43		; vertical bar
	IFF	ch_am,scn44		; ampersand
	IFF	ch_qu,scn45		; question mark
	IFF	ch_eq,scn46		; equal
	IFF	ch_as,scn49		; asterisk
	ESW				; end switch on character
;
;      here for illegal character (underline merges)
;
scn07	BZE	WB,scn10		; jump if scanning name or constant
	ERB	230,syntax error: illegal character
	EJC
;
;      scane (continued)
;
;      here for digits 0-9
;
scn08	BZE	WB,scn09		; keep scanning if name/constant
	ZER	WC			; else set flag for scanning constant
;
;      here for letter. loop here when scanning name/constant
;
scn09	BEQ	WA,scnil,scn11		; jump if end of image
	ZER	WB			; set flag for scanning name/const
	BRN	scn06			; merge back to continue scan
;
;      come here for delimiter ending name or constant
;
scn10	DCV	WA			; reset offset to point to delimiter
;
;      come here after finishing scan of name or constant
;
scn11	MOV	scnpt,WA		; store updated scan offset
	MOV	WB,scnse		; point to start of element
	SUB	WA,WB			; get number of characters
	MOV	XL,r_cim		; point to line image
	BNZ	WC,scn15		; jump if name
;
;      here after scanning out numeric constant
;
	JSR	sbstr			; get string for constant
	MOV	dnamp,XR		; delete from storage (not needed)
	JSR	gtnum			; convert to numeric
	PPM	scn14			; jump if conversion failure
;
;      merge here to exit with constant
;
scn12	MOV	XL,=t_con		; set result type of constant
	EJC
;
;      scane (continued)
;
;      common exit point (XR,XL) set
;
scn13	MOV	WA,scnsa		; restore wa
	MOV	WB,scnsb		; restore WB
	MOV	WC,scnsc		; restore WC
	MOV	r_scp,XR		; save XR in case rescan
	MOV	scntp,XL		; save XL in case rescan
	ZER	scngo			; reset possible goto flag
	EXI				; return to scane caller
;
;      here if conversion error on numeric item
;
scn14	ERB	231,syntax error: invalid numeric item
;
;      here after scanning out vaRIAble name
;
scn15	JSR	sbstr			; build string name of vaRIAble
	BNZ	scncc,scn13		; return if cncrd call
	JSR	gtnvr			; locate/build vrblk
	PPM				; dummy (unused) error return
	MOV	XL,=t_var		; set type as vaRIAble
	BRN	scn13			; back to exit
;
;      here for single quote (start of string constant)
;
scn16	BZE	WB,scn10		; terminator if scanning name or cnst
	MOV	WB,=ch_sq		; set terminator as single quote
	BRN	scn18			; merge
;
;      here for double quote (start of string constant)
;
scn17	BZE	WB,scn10		; terminator if scanning name or cnst
	MOV	WB,=ch_dq		; set double quote terminator, merge
;
;      loop to scan out string constant
;
scn18	BEQ	WA,scnil,scn19		; error if end of image
	LCH	WC,(XL)+		; else load next character
	ICV	WA			; bump offset
	BNE	WC,WB,scn18		; loop back if not terminator
	EJC
;
;      scane (continued)
;
;      here after scanning out string constant
;
	MOV	WB,scnpt		; point to first character
	MOV	scnpt,WA		; save offset past final quote
	DCV	WA			; point back past last character
	SUB	WA,WB			; get number of characters
	MOV	XL,r_cim		; point to input image
	JSR	sbstr			; build substring value
	BRN	scn12			; back to exit with constant result
;
;      here if no matching quote found
;
scn19	MOV	scnpt,WA		; set updated scan pointer
	ERB	232,syntax error: unmatched string quote
;
;      here for f (possible failure goto)
;
scn20	MOV	XR,=t_fgo		; set return code for fail goto
	BRN	scn22			; jump to merge
;
;      here for s (possible success goto)
;
scn21	MOV	XR,=t_sgo		; set success goto as return code
;
;      special goto cases merge here
;
scn22	BZE	scngo,scn09		; treat as normal letter if not goto
;
;      merge here for special character exit
;
scn23	BZE	WB,scn10		; jump if end of name/constant
	MOV	XL,XR			; else copy code
	BRN	scn13			; and jump to exit
;
;      here for underline
;
scn24	BZE	WB,scn09		; part of name if scanning name
	BRN	scn07			; else illegal
	EJC
;
;      scane (continued)
;
;      here for left paren
;
scn25	MOV	XR,=t_lpr		; set left paren return code
	BNZ	WB,scn23		; return left paren unless name
	BZE	WC,scn10		; delimiter if scanning constant
;
;      here for left paren after name (function call)
;
	MOV	WB,scnse		; point to start of name
	MOV	scnpt,WA		; set pointer past left paren
	DCV	WA			; point back past last char of name
	SUB	WA,WB			; get name length
	MOV	XL,r_cim		; point to input image
	JSR	sbstr			; get string name for function
	JSR	gtnvr			; locate/build vrblk
	PPM				; dummy (unused) error return
	MOV	XL,=t_fnc		; set code for function call
	BRN	scn13			; back to exit
;
;      processing for special characters
;
scn26	MOV	XR,=t_rpr		; right paren, set code
	BRN	scn23			; take special character exit
;
scn27	MOV	XR,=t_rbr		; right bracket, set code
	BRN	scn23			; take special character exit
;
scn28	MOV	XR,=t_lbr		; left bracket, set code
	BRN	scn23			; take special character exit
;
scn29	MOV	XR,=t_col		; colon, set code
	BRN	scn23			; take special character exit
;
scn30	MOV	XR,=t_smc		; semi-colon, set code
	BRN	scn23			; take special character exit
;
scn31	MOV	XR,=t_cma		; comma, set code
	BRN	scn23			; take special character exit
	EJC
;
;      scane (continued)
;
;      here for operators. on entry, WC points to the table of
;      operator dope vectors and WB is the increment to step
;      to the next pair (binary/unary) of dope vectors in the
;      list. on reaching scn46, the pointer has been adjusted to
;      point to the appropriate pair of dope vectors.
;      the first three entries are special since they can occur
;      as part of a vaRIAble name (.) or constant (.+-).
;
scn32	BZE	WB,scn09		; dot can be part of name or constant
	ADD	WC,WB			; else bump pointer
;
scn33	BZE	WC,scn09		; plus can be part of constant
	BZE	WB,scn48		; plus cannot be part of name
	ADD	WC,WB			; else bump pointer
;
scn34	BZE	WC,scn09		; minus can be part of constant
	BZE	WB,scn48		; minus cannot be part of name
	ADD	WC,WB			; else bump pointer
;
scn35	ADD	WC,WB			; not
scn36	ADD	WC,WB			; dollar
scn37	ADD	WC,WB			; exclamation
scn38	ADD	WC,WB			; percent
scn39	ADD	WC,WB			; asterisk
scn40	ADD	WC,WB			; slash
scn41	ADD	WC,WB			; number sign
scn42	ADD	WC,WB			; at sign
scn43	ADD	WC,WB			; vertical bar
scn44	ADD	WC,WB			; ampersand
scn45	ADD	WC,WB			; question mark
;
;      all operators come here (equal merges directly)
;      (WC) points to the binary/unary pair of operator dvblks.
;
scn46	BZE	WB,scn10		; operator terminates name/constant
	MOV	XR,WC			; else copy dv pointer
	LCH	WC,(XL)			; load next character
	MOV	XL,=t_bop		; set binary op in case
	BEQ	WA,scnil,scn47		; should be binary if image end
	BEQ	WC,=ch_bl,scn47		; should be binary if followed by blk
.IF    .caht
	BEQ	WC,=ch_ht,scn47		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WC,=ch_vt,scn47		; jump if vertical tab
.FI
	BEQ	WC,=ch_sm,scn47		; semicolon can immediately follow =
	BEQ	WC,=ch_cl,scn47		; colon can immediately follow =
	BEQ	WC,=ch_rp,scn47		; right paren can immediately follow =
	BEQ	WC,=ch_rb,scn47		; right bracket can immediately follow =
	BEQ	WC,=ch_cb,scn47		; right bracket can immediately follow =
;
;      here for unary operator
;
	ADD	XR,*dvbs_		; point to dv for unary op
	MOV	XL,=t_uop		; set type for unary operator
	BLE	scntp,=t_uok,scn13	; ok unary if ok preceding element
	EJC
;
;      scane (continued)
;
;      merge here to require preceding blanks
;
scn47	BNZ	scnbl,scn13		; all ok if preceding blanks, exit
;
;      fail operator in this position
;
scn48	ERB	233,syntax error: invalid use of operator
;
;      here for asterisk, could be ** substitute for exclamation
;
scn49	BZE	WB,scn10		; end of name if scanning name
	BEQ	WA,scnil,scn39		; not ** if * at image end
	MOV	XR,WA			; else save offset past first *
	MOV	scnof,WA		; save another copy
	LCH	WA,(XL)+		; load next character
	BNE	WA,=ch_as,scn50		; not ** if next char not *
	ICV	XR			; else step offset past second *
	BEQ	XR,scnil,scn51		; ok exclam if end of image
	LCH	WA,(XL)			; else load next character
	BEQ	WA,=ch_bl,scn51		; exclamation if blank
.IF    .caht
	BEQ	WA,=ch_ht,scn51		; exclamation if horizontal tab
.FI
.IF    .cavt
	BEQ	WA,=ch_vt,scn51		; exclamation if vertical tab
.FI
;
;      unary *
;
scn50	MOV	WA,scnof		; recover stored offset
	MOV	XL,r_cim		; point to line again
	PLC	XL,WA			; point to current char
	BRN	scn39			; merge with unary *
;
;      here for ** as substitute for exclamation
;
scn51	MOV	scnpt,XR		; save scan pointer past 2nd *
	MOV	WA,XR			; copy scan pointer
	BRN	scn37			; merge with exclamation
	ENP				; end procedure scane
	EJC
;
;      scngf -- scan goto field
;
;      scngf is called from cmpil to scan and analyze a goto
;      field including the surrounding brackets or parentheses.
;      for a normal goto, the result returned is either a vrblk
;      pointer for a simple label operand, or a pointer to an
;      expression tree with a special outer unary operator
;      (o_goc). for a direct goto, the result returned is a
;      pointer to an expression tree with the special outer
;      unary operator o_god.
;
;      jsr  scngf	     call to scan goto field
;      (XR)		     result (see above)
;      (XL,WA,WB,WC)	     destroyed
;
scngf	PRC	e,0			; entry point
	JSR	scane			; scan initial element
	BEQ	XL,=t_lpr,scng1		; skip if left paren (normal goto)
	BEQ	XL,=t_lbr,scng2		; skip if left bracket (direct goto)
	ERB	234,syntax error: goto field incorrect
;
;      here for left paren (normal goto)
;
scng1	MOV	WB,=num01		; set expan flag for normal goto
	JSR	expan			; analyze goto field
	MOV	WA,=opdvn		; point to opdv for complex goto
	BLE	XR,statb,scng3		; jump if not in static (sgd15)
	BLO	XR,state,scng4		; jump to exit if simple label name
	BRN	scng3			; complex goto - merge
;
;      here for left bracket (direct goto)
;
scng2	MOV	WB,=num02		; set expan flag for direct goto
	JSR	expan			; scan goto field
	MOV	WA,=opdvd		; set opdv pointer for direct goto
	EJC
;
;      scngf (continued)
;
;      merge here to build outer unary operator block
;
scng3	MOV	-(XS),WA		; stack operator dv pointer
	MOV	-(XS),XR		; stack pointer to expression tree
	JSR	expop			; pop operator off
	MOV	XR,(XS)+		; reload new expression tree pointer
;
;      common exit point
;
scng4	EXI				; return to caller
	ENP				; end procedure scngf
	EJC
;
;      setvr -- set vrget,vrsto fields of vrblk
;
;      setvr sets the proper values in the vrget and vrsto
;      fields of a vrblk. it is called whenever trblks are
;      added or subtracted (trace,stoptr,input,output,detach)
;
;      (XR)		     pointer to vrblk
;      jsr  setvr	     call to set fields
;      (XL,WA)		     destroyed
;
;      note that setvr ignores the call if XR does not point
;      into the static region (i.e. is some other name base)
;
setvr	PRC	e,0			; entry point
	BHI	XR,state,setv1		; exit if not natural vaRIAble
;
;      here if we have a vrblk
;
	MOV	XL,XR			; copy vrblk pointer
	MOV	vrget(XR),=b_vrl	; store normal get value
	BEQ	vrsto(XR),=b_vre,setv1	; skip if protected vaRIAble
	MOV	vrsto(XR),=b_vrs	; store normal store value
	MOV	XL,vrval(XL)		; point to next entry on chain
	BNE	(XL),=b_trt,setv1	; jump if end of trblk chain
	MOV	vrget(XR),=b_vra	; store trapped routine address
	MOV	vrsto(XR),=b_vrv	; set trapped routine address
;
;      merge here to exit to caller
;
setv1	EXI				; return to setvr caller
	ENP				; end procedure setvr
.IF    .cnsr
.ELSE
	EJC
;
;      sorta -- sort array
;
;      routine to sort an array or table on same basis as in
;      sitbol. a table is converted to an array, leaving two
;      dimensional arrays and vectors as cases to be considered.
;      whole rows of arrays are permuted according to the
;      ordering of the keys they contain, and the stride
;      referred to, is the the length of a row. it is one
;      for a vector.
;      the sort used is heapsort, fundamentals of data structure
;      horowitz and sahni, pitman 1977, page 347.
;      it is an order n*log(n) algorithm. in order
;      to make it stable, comparands may not compare equal. this
;      is achieved by sorting a copy array (referred to as the
;      sort array) containing at its high address end, byte
;      offsets to the rows to be sorted held in the original
;      array (referred to as the key array). sortc, the
;      comparison routine, accesses the keys through these
;      offsets and in the case of equality, resolves it by
;      comparing the offsets themselves. the sort permutes the
;      offsets which are then used in a final operation to copy
;      the actual items into the new array in sorted order.
;      references to zeroth item are to notional item
;      preceding first actual item.
;      reverse sorting for rsort is done by having the less than
;      test for keys effectively be replaced by a
;      greater than test.
;
;      1(XS)		     first arg - array or table
;      0(XS)		     2nd arg - index or pdtype name
;      (wa)		     0 , non-zero for sort , rsort
;      jsr  sorta	     call to sort array
;      ppm  loc		     transfer loc if table is empty
;      (XR)		     sorted array
;      (XL,WA,WB,WC)	     destroyed
	EJC
;
;      sorta (continued)
;
sorta	PRC	n,1			; entry point
	MOV	srtsr,WA		; sort/rsort indicator
	MOV	srtst,*num01		; default stride of 1
	ZER	srtof			; default zero offset to sort key
	MOV	srtdf,=nulls		; clear datatype field name
	MOV	r_sxr,(XS)+		; unstack argument 2
	MOV	XR,(XS)+		; get first argument
	MNZ	WA			; use key/values of table entries
	JSR	gtarr			; convert to array
	PPM	srt18			; signal that table is empty
	PPM	srt16			; error if non-convertable
	MOV	-(XS),XR		; stack ptr to resulting key array
	MOV	-(XS),XR		; another copy for copyb
	JSR	copyb			; get copy array for sorting into
	PPM				; cant fail
	MOV	-(XS),XR		; stack pointer to sort array
	MOV	XR,r_sxr		; get second arg
	MOV	XL,num01(XS)		; get ptr to key array
	BNE	(XL),=b_vct,srt02	; jump if arblk
	BEQ	XR,=nulls,srt01		; jump if null second arg
	JSR	gtnvr			; get vrblk ptr for it
	ERR	257,erroneous 2nd arg in sort/rsort of vector
	MOV	srtdf,XR		; store datatype field name vrblk
;
;      compute n and offset to item a(0) in vector case
;
srt01	MOV	WC,*vclen		; offset to a(0)
	MOV	WB,*vcvls		; offset to first item
	MOV	WA,vclen(XL)		; get block length
	SUB	WA,*vcsi_		; get no. of entries, n (in bytes)
	BRN	srt04			; merge
;
;      here for array
;
srt02	LDI	ardim(XL)		; get possible dimension
	MFI	WA			; convert to short integer
	WTB	WA			; further convert to baus
	MOV	WB,*arvls		; offset to first value if one
	MOV	WC,*arpro		; offset before values if one dim.
	BEQ	arndm(XL),=num01,srt04	; jump in fact if one dim.
	BNE	arndm(XL),=num02,srt16	; fail unless two dimens
	LDI	arlb2(XL)		; get lower bound 2 as default
	BEQ	XR,=nulls,srt03		; jump if default second arg
	JSR	gtint			; convert to integer
	PPM	srt17			; fail
	LDI	icval(XR)		; get actual integer value
	EJC
;
;      sorta (continued)
;
;      here with sort column index in IA in array case
;
srt03	SBI	arlb2(XL)		; subtract low bound
	IOV	srt17			; fail if overflow
	ILT	srt17			; fail if below low bound
	SBI	ardm2(XL)		; check against dimension
	IGE	srt17			; fail if too large
	ADI	ardm2(XL)		; restore value
	MFI	WA			; get as small integer
	WTB	WA			; offset within row to key
	MOV	srtof,WA		; keep offset
	LDI	ardm2(XL)		; second dimension is row length
	MFI	WA			; convert to short integer
	MOV	XR,WA			; copy row length
	WTB	WA			; convert to bytes
	MOV	srtst,WA		; store as stride
	LDI	ardim(XL)		; get number of rows
	MFI	WA			; as a short integer
	WTB	WA			; convert n to baus
	MOV	WC,arlen(XL)		; offset past array end
	SUB	WC,WA			; adjust, giving space for n offsets
	DCA	WC			; point to a(0)
	MOV	WB,arofs(XL)		; offset to word before first item
	ICA	WB			; offset to first item
;
;      separate pre-processing for arrays and vectors done.
;      to simplify later key comparisons, removal of any trblk
;      trap blocks from entries in key array is effected.
;
;      (XL) = 1(XS) = pointer to key array
;      (XS) = pointer to sort array
;      wa = number of items, n (converted to bytes).
;      WB = offset to first item of arrays.
;      WC = offset to a(0)
;
srt04	BLE	WA,*num01,srt15		; return if only a single item
	MOV	srtsn,WA		; store number of items (in baus)
	MOV	srtso,WC		; store offset to a(0)
	MOV	WC,arlen(XL)		; length of array or vec (=vclen)
	ADD	WC,XL			; point past end of array or vector
	MOV	srtsf,WB		; store offset to first row
	ADD	XL,WB			; point to first item in key array
;
;      loop through array
;
srt05	MOV	XR,(XL)			; get an entry
;
;      hunt along trblk chain
;
srt06	BNE	(XR),=b_trt,srt07	; jump out if not trblk
	MOV	XR,trval(XR)		; get value field
	BRN	srt06			; loop
	EJC
;
;      sorta (continued)
;
;      XR is value from end of chain
;
srt07	MOV	(XL)+,XR		; store as array entry
	BLT	XL,WC,srt05		; loop if not done
	MOV	XL,(XS)			; get adrs of sort array
	MOV	XR,srtsf		; initial offset to first key
	MOV	WB,srtst		; get stride
	ADD	XL,srtso		; offset to a(0)
	ICA	XL			; point to a(1)
	MOV	WC,srtsn		; get n
	BTW	WC			; convert from bytes
	MOV	srtnr,WC		; store as row count
	LCT	WC,WC			; loop counter
;
;      store key offsets at top of sort array
;
srt08	MOV	(XL)+,XR		; store an offset
	ADD	XR,WB			; bump offset by stride
	BCT	WC,srt08		; loop through rows
;
;      perform the sort on offsets in sort array.
;
;      (srtsn)		     number of items to sort, n (bytes)
;      (srtso)		     offset to a(0)
;
srt09	MOV	WA,srtsn		; get n
	MOV	WC,srtnr		; get number of rows
	RSH	WC,1			; i = n / 2 (WC=i, index into array)
	WTB	WC			; convert back to bytes
;
;      loop to form initial heap
;
srt10	JSR	sorth			; sorth(i,n)
	DCA	WC			; i = i - 1
	BNZ	WC,srt10		; loop if i gt 0
	MOV	WC,WA			; i = n
;
;      sorting loop. at this point, a(1) is the largest
;      item, since algorithm initialises it as, and then maintains
;      it as, root of tree.
;
srt11	DCA	WC			; i = i - 1 (n - 1 initially)
	BZE	WC,srt12		; jump if done
	MOV	XR,(XS)			; get sort array address
	ADD	XR,srtso		; point to a(0)
	MOV	XL,XR			; a(0) address
	ADD	XL,WC			; a(i) address
	MOV	WB,num01(XL)		; copy a(i+1)
	MOV	num01(XL),num01(XR)	; move a(1) to a(i+1)
	MOV	num01(XR),WB		; complete exchange of a(1), a(i+1)
	MOV	WA,WC			; n = i for sorth
	MOV	WC,*num01		; i = 1 for sorth
	JSR	sorth			; sorth(1,n)
	MOV	WC,WA			; restore WC
	BRN	srt11			; loop
	EJC
;
;      sorta (continued)
;
;      offsets have been permuted into required order by sort.
;      copy array elements over them.
;
srt12	MOV	XR,(XS)			; base adrs of key array
	MOV	WC,XR			; copy it
	ADD	WC,srtso		; offset of a(0)
	ADD	XR,srtsf		; adrs of first row of sort array
	MOV	WB,srtst		; get stride
;
;      copying loop for successive items. sorted offsets are
;      held at end of sort array.
;
srt13	ICA	WC			; adrs of next of sorted offsets
	MOV	XL,WC			; copy it for access
	MOV	XL,(XL)			; get offset
	ADD	XL,num01(XS)		; add key array base adrs
	MOV	WA,WB			; get count of characters in row
	MVW				; copy a complete row
	DCV	srtnr			; decrement row count
	BNZ	srtnr,srt13		; repeat till all rows done
;
;      return point
;
srt15	MOV	XR,(XS)+		; pop result array ptr
	ICA	XS			; pop key array ptr
	ZER	r_sXL			; clear junk
	ZER	r_sxr			; clear junk
	EXI				; return
;
;      error point
;
srt16	ERB	256,sort/rsort 1st arg not suitable array or table
srt17	ERB	258,sort/rsort 2nd arg out of range or non-integer
;
;      return point if input table is empty
;
srt18	EXI	1			; return indication of null table
	ENP				; end procudure sorta
	EJC
;
;      sortc --	 compare sort keys
;
;      compare two sort keys given their offsets. if
;      equal, compare key offsets to give stable sort.
;      note that if srtsr is non-zero (request for reverse
;      sort), the quoted returns are inverted.
;      for objects of differing datatypes, the entry point
;      identifications are compared.
;
;      (XL)		     base adrs for keys
;      (wa)		     offset to key 1 item
;      (WB)		     offset to key 2 item
;      (srtsr)		     zero/non-zero for sort/rsort
;      (srtof)		     offset within row to comparands
;      jsr  sortc	     call to compare keys
;      ppm  loc		     key1 less than key2
;			     normal return, key1 gt than key2
;      (XL,XR,WA,WB)	     destroyed
;
sortc	PRC	e,1			; entry point
	MOV	srts1,WA		; save offset 1
	MOV	srts2,WB		; save offset 2
	MOV	srtsc,WC		; save WC
	ADD	XL,srtof		; add offset to comparand field
	MOV	XR,XL			; copy base + offset
	ADD	XL,WA			; add key1 offset
	ADD	XR,WB			; add key2 offset
	MOV	XL,(XL)			; get key1
	MOV	XR,(XR)			; get key2
	BNE	srtdf,=nulls,src12	; jump if datatype field name used
	EJC
;
;      sortc (continued)
;
;      merge after dealing with field name. try for strings.
;
src01	MOV	WC,(XL)			; get type code
	BNE	WC,(XR),src02		; skip if not same datatype
	BEQ	WC,=b_scl,src09		; jump if both strings
	BEQ	WC,=b_icl,src14		; jump if both integers
.IF    .cnbf
.ELSE
	BEQ	WC,=b_bct,src09		; jump if both buffers
.FI
;
;      datatypes different.  now try for numeric
;
src02	MOV	r_sXL,XL		; keep arg1
	MOV	r_sxr,XR		; keep arg2
.IF    .cnbf
.IF    .cnsc
	BEQ	WC,=b_scl,src11		; do not allow conversion to number
	BEQ	(XR),=b_scl,src11	; if either arg is a string
.FI
.ELSE
;
;      first examine for string/buffer comparison.  if so,
;      allow lcomp to compare chars in string and buffer
;      without converting buffer to a string.
;
	BEQ	WC,=b_scl,src13		; jump if key1 is a string
.IF    .cnsc
	BNE	WC,=b_bct,src15		; j if key1 is not a string or buffer
.ELSE
	BNE	WC,=b_bct,src14		; try converting key 2 to a number
.FI
;
;      here if key1 is a buffer, key2 known not to be a buffer.
;      if key2 is a string, then lcomp can proceed.
;
	BEQ	(XR),=b_scl,src09	; j if keys 1/2 are buffer/string
.IF    .cnsc
	BRN	src11			; prevent convert of key 1 to number
.ELSE
	BRN	src14			; try converting key 1 to number
.FI
;
;      here if key1 is a string, key2 known not to be a string.
;      if key2 is a buffer, then lcomp can proceed.
;
src13	BEQ	(XR),=b_bct,src09	; j if keys 1/2 are string/buffer
.IF    .cnsc
	BRN	src11			; prevent convert of key 1 to number
;
;      here if key1 is not a string or buffer.
;      examine key2.  if it is a string or buffer, then do not
;      convert key2 to a number.
;
src15	BEQ	(XR),=b_scl,src11	; j if key 2 is a string
	BEQ	(XR),=b_bct,src11	; j if key 2 is a buffer
;
;      here with keys 1/2 not strings or buffers
;
.FI
.FI
src14	MOV	-(XS),XL		; stack
	MOV	-(XS),XR		; args
	JSR	acomp			; compare objects
	PPM	src10			; not numeric
	PPM	src10			; not numeric
	PPM	src03			; key1 less
	PPM	src08			; keys equal
	PPM	src05			; key1 greater
;
;      return if key1 smaller (sort), greater (rsort)
;
src03	BNZ	srtsr,src06		; jump if rsort
;
src04	MOV	WC,srtsc		; restore WC
	EXI	1			; return
;
;      return if key1 greater (sort), smaller (rsort)
;
src05	BNZ	srtsr,src04		; jump if rsort
;
src06	MOV	WC,srtsc		; restore WC
	EXI				; return
;
;      keys are of same datatype
;
src07	BLT	XL,XR,src03		; item first created is less
	BGT	XL,XR,src05		; addresses rise in order of creation
;
;      drop through or merge for identical or equal objects
;
src08	BLT	srts1,srts2,src04	; test offsets or key addrss instead
	BRN	src06			; offset 1 greater
	EJC
;
;      sortc (continued)
;
.IF    .cnbf
;      strings
.ELSE
;      strings or buffers or some combination of same
.FI
;
src09	MOV	-(XS),XL		; stack
	MOV	-(XS),XR		; args
	JSR	lcomp			; compare objects
	PPM				; cant
	PPM				; fail
	PPM	src03			; key1 less
	PPM	src08			; keys equal
	PPM	src05			; key1 greater
;
;      arithmetic comparison failed - recover args
;
src10	MOV	XL,r_sXL		; get arg1
	MOV	XR,r_sxr		; get arg2
	MOV	WC,(XL)			; get type of key1
	BEQ	WC,(XR),src07		; jump if keys of same type
;
;      here to compare datatype ids
;
src11	MOV	XL,WC			; get block type word
	MOV	XR,(XR)			; get block type word
	LEI	XL			; entry point id for key1
	LEI	XR			; entry point id for key2
	BGT	XL,XR,src05		; jump if key1 gt key2
	BRN	src03			; key1 lt key2
;
;      datatype field name used
;
src12	JSR	sortf			; call routine to find field 1
	MOV	-(XS),XL		; stack item pointer
	MOV	XL,XR			; get key2
	JSR	sortf			; find field 2
	MOV	XR,XL			; place as key2
	MOV	XL,(XS)+		; recover key1
	BRN	src01			; merge
	ENP				; procedure sortc
	EJC
;
;      sortf -- find field for sortc
;
;      routine used by sortc to obtain item corresponding
;      to a given field name, if this exists, in a programmer
;      defined object passed as argument.
;      if such a match occurs, record is kept of datatype
;      name, field name and offset to field in order to
;      short-circuit later searches on same type. note that
;      dfblks are stored in static and hence cannot be moved.
;
;      (srtdf)		     vrblk pointer of field name
;      (XL)		     possible pdblk pointer
;      jsr  sortf	     call to search for field name
;      (XL)		     item found or original pdblk ptr
;      (WC)		     destroyed
;
sortf	PRC	e,0			; entry point
	BNE	(XL),=b_pdt,srtf3	; return if not pdblk
	MOV	-(XS),XR		; keep XR
	MOV	XR,srtfd		; get possible former dfblk ptr
	BZE	XR,srtf4		; jump if not
	BNE	XR,pddfp(XL),srtf4	; jump if not right datatype
	BNE	srtdf,srtff,srtf4	; jump if not right field name
	ADD	XL,srtfo		; add offset to required field
;
;      here with XL pointing to found field
;
srtf1	MOV	XL,(XL)			; get item from field
;
;      return point
;
srtf2	MOV	XR,(XS)+		; restore XR
;
srtf3	EXI				; return
	EJC
;
;      sortf (continued)
;
;      conduct a search
;
srtf4	MOV	XR,XL			; copy original pointer
	MOV	XR,pddfp(XR)		; point to dfblk
	MOV	srtfd,XR		; keep a copy
	MOV	WC,fargs(XR)		; get number of fields
	WTB	WC			; convert to bytes
	ADD	XR,dflen(XR)		; point past last field
;
;      loop to find name in pdfblk
;
srtf5	DCA	WC			; count down
	DCA	XR			; point in front
	BEQ	(XR),srtdf,srtf6	; skip out if found
	BNZ	WC,srtf5		; loop
	BRN	srtf2			; return - not found
;
;      found
;
srtf6	MOV	srtff,(XR)		; keep field name ptr
	ADD	WC,*pdfld		; add offset to first field
	MOV	srtfo,WC		; store as field offset
	ADD	XL,WC			; point to field
	BRN	srtf1			; return
	ENP				; procedure sortf
	EJC
;
;      sorth -- heap routine for sorta
;
;      this routine constructs a heap from elements of array, a.
;      in this application, the elements are offsets to keys in
;      a key array.
;
;      (XS)		     pointer to sort array base
;      1(XS)		     pointer to key array base
;      (wa)		     max array index, n (in bytes)
;      (WC)		     offset j in a to root (in *1 to *n)
;      jsr  sorth	     call sorth(j,n) to make heap
;      (XL,XR,WB)	     destroyed
;
sorth	PRC	n,0			; entry point
	MOV	srtsn,WA		; save n
	MOV	srtwc,WC		; keep WC
	MOV	XL,(XS)			; sort array base adrs
	ADD	XL,srtso		; add offset to a(0)
	ADD	XL,WC			; point to a(j)
	MOV	srtrt,(XL)		; get offset to root
	ADD	WC,WC			; double j - cant exceed n
;
;      loop to move down tree using doubled index j
;
srh01	BGT	WC,srtsn,srh03		; done if j gt n
	BEQ	WC,srtsn,srh02		; skip if j equals n
	MOV	XR,(XS)			; sort array base adrs
	MOV	XL,num01(XS)		; key array base adrs
	ADD	XR,srtso		; point to a(0)
	ADD	XR,WC			; adrs of a(j)
	MOV	WA,num01(XR)		; get a(j+1)
	MOV	WB,(XR)			; get a(j)
;
;      compare sons. (wa) right son, (WB) left son
;
	JSR	sortc			; compare keys - lt(a(j+1),a(j))
	PPM	srh02			; a(j+1) lt a(j)
	ICA	WC			; point to greater son, a(j+1)
	EJC
;
;      sorth (continued)
;
;      compare root with greater son
;
srh02	MOV	XL,num01(XS)		; key array base adrs
	MOV	XR,(XS)			; get sort array address
	ADD	XR,srtso		; adrs of a(0)
	MOV	WB,XR			; copy this adrs
	ADD	XR,WC			; adrs of greater son, a(j)
	MOV	WA,(XR)			; get a(j)
	MOV	XR,WB			; point back to a(0)
	MOV	WB,srtrt		; get root
	JSR	sortc			; compare them - lt(a(j),root)
	PPM	srh03			; father exceeds sons - done
	MOV	XR,(XS)			; get sort array adrs
	ADD	XR,srtso		; point to a(0)
	MOV	XL,XR			; copy it
	MOV	WA,WC			; copy j
	BTW	WC			; convert to words
	RSH	WC,1			; get j/2
	WTB	WC			; convert back to bytes
	ADD	XL,WA			; point to a(j)
	ADD	XR,WC			; adrs of a(j/2)
	MOV	(XR),(XL)		; a(j/2) = a(j)
	MOV	WC,WA			; recover j
	AOV	WC,WC,srh03		; j = j*2. done if too big
	BRN	srh01			; loop
;
;      finish by copying root offset back into array
;
srh03	BTW	WC			; convert to words
	RSH	WC,1			; j = j/2
	WTB	WC			; convert back to bytes
	MOV	XR,(XS)			; sort array adrs
	ADD	XR,srtso		; adrs of a(0)
	ADD	XR,WC			; adrs of a(j/2)
	MOV	(XR),srtrt		; a(j/2) = root
	MOV	WA,srtsn		; restore wa
	MOV	WC,srtwc		; restore WC
	EXI				; return
	ENP				; end procedure sorth
.FI
	EJC
;
;      trace -- set/reset a trace association
;
;      this procedure is shared by trace and stoptr to
;      either initiate or stop a trace respectively.
;
;      (XL)		     trblk ptr (trace) or zero (stoptr)
;      1(XS)		     first argument (name)
;      0(XS)		     second argument (trace type)
;      jsr  trace	     call to set/reset trace
;      ppm  loc		     transfer loc if 1st arg is bad name
;      ppm  loc		     transfer loc if 2nd arg is bad type
;      (XS)		     popped
;      (XL,XR,WA,WB,WC,ia)   destroyed
;
trace	PRC	n,2			; entry point
	JSR	gtstg			; get trace type string
	PPM	trc15			; jump if not string
	PLC	XR			; else point to string
	LCH	WA,(XR)			; load first character
.IF    .culc
	FLC	WA			; fold to lower case
.FI
	MOV	XR,(XS)			; load name argument
	MOV	(XS),XL			; stack trblk ptr or zero
	MOV	WC,=trtac		; set trtyp for access trace
	BEQ	WA,=ch_la,trc10		; jump if a (access)
	MOV	WC,=trtvl		; set trtyp for value trace
	BEQ	WA,=ch_lv,trc10		; jump if v (value)
	BEQ	WA,=ch_bl,trc10		; jump if blank (value)
;
;      here for l,k,f,c,r
;
	BEQ	WA,=ch_lf,trc01		; jump if f (function)
	BEQ	WA,=ch_lr,trc01		; jump if r (return)
	BEQ	WA,=ch_ll,trc03		; jump if l (label)
	BEQ	WA,=ch_lk,trc06		; jump if k (keyword)
	BNE	WA,=ch_lc,trc15		; else error if not c (call)
;
;      here for f,c,r
;
trc01	JSR	gtnvr			; point to vrblk for name
	PPM	trc16			; jump if bad name
	ICA	XS			; pop stack
	MOV	XR,vrfnc(XR)		; point to function block
	BNE	(XR),=b_pfc,trc17	; error if not program function
	BEQ	WA,=ch_lr,trc02		; jump if r (return)
	EJC
;
;      trace (continued)
;
;      here for f,c to set/reset call trace
;
	MOV	pfctr(XR),XL		; set/reset call trace
	BEQ	WA,=ch_lc,exnul		; exit with null if c (call)
;
;      here for f,r to set/reset return trace
;
trc02	MOV	pfrtr(XR),XL		; set/reset return trace
	EXI				; return
;
;      here for l to set/reset label trace
;
trc03	JSR	gtnvr			; point to vrblk
	PPM	trc16			; jump if bad name
	MOV	XL,vrlbl(XR)		; load label pointer
	BNE	(XL),=b_trt,trc04	; jump if no old trace
	MOV	XL,trlbl(XL)		; else delete old trace association
;
;      here with old label trace association deleted
;
trc04	BEQ	XL,=stndl,trc16		; error if undefined label
	MOV	WB,(XS)+		; get trblk ptr again
	BZE	WB,trc05		; jump if stoptr case
	MOV	vrlbl(XR),WB		; else set new trblk pointer
	MOV	vrtra(XR),=b_vrt	; set label trace routine address
	MOV	XR,WB			; copy trblk pointer
	MOV	trlbl(XR),XL		; store real label in trblk
	EXI				; return
;
;      here for stoptr case for label
;
trc05	MOV	vrlbl(XR),XL		; store label ptr back in vrblk
	MOV	vrtra(XR),=b_vrg	; store normal transfer address
	EXI				; return
	EJC
;
;      trace (continued)
;
;      here for k (keyword)
;
trc06	JSR	gtnvr			; point to vrblk
	PPM	trc16			; error if not natural var
	BNZ	vrlen(XR),trc16		; error if not system var
	ICA	XS			; pop stack
	BZE	XL,trc07		; jump if stoptr case
	MOV	trkvr(XL),XR		; store vrblk ptr in trblk for ktrex
;
;      merge here with trblk set up in WB (or zero)
;
trc07	MOV	XR,vrsvp(XR)		; point to svblk
	BEQ	XR,=v_ert,trc08		; jump if errtype
	BEQ	XR,=v_stc,trc09		; jump if stcount
	BNE	XR,=v_fnc,trc17		; else error if not fnclevel
;
;      fnclevel
;
	MOV	r_fnc,XL		; set/reset fnclevel trace
	EXI				; return
;
;      errtype
;
trc08	MOV	r_ert,XL		; set/reset errtype trace
	EXI				; return
;
;      stcount
;
trc09	MOV	r_stc,XL		; set/reset stcount trace
	JSR	stgcc			; update countdown counters
	EXI				; return
	EJC
;
;      trace (continued)
;
;      a,v merge here with trtyp value in WC
;
trc10	JSR	gtvar			; locate vaRIAble
	PPM	trc16			; error if not appropriate name
	MOV	WB,(XS)+		; get new trblk ptr again
	ADD	WA,XL			; point to vaRIAble location
	MOV	XR,WA			; copy vaRIAble pointer
;
;      loop to search trblk chain
;
trc11	MOV	XL,(XR)			; point to next entry
	BNE	(XL),=b_trt,trc13	; jump if not trblk
	BLT	WC,trtyp(XL),trc13	; jump if too far out on chain
	BEQ	WC,trtyp(XL),trc12	; jump if this matches our type
	ADD	XL,*trnxt		; else point to link field
	MOV	XR,XL			; copy pointer
	BRN	trc11			; and loop back
;
;      here to delete an old trblk of the type we were given
;
trc12	MOV	XL,trnxt(XL)		; get ptr to next block or value
	MOV	(XR),XL			; store to delete this trblk
;
;      here after deleting any old association of this type
;
trc13	BZE	WB,trc14		; jump if stoptr case
	MOV	(XR),WB			; else link new trblk in
	MOV	XR,WB			; copy trblk pointer
	MOV	trnxt(XR),XL		; store forward pointer
	MOV	trtyp(XR),WC		; store appropriate trap type code
;
;      here to make sure vrget,vrsto are set properly
;
trc14	MOV	XR,WA			; recall possible vrblk pointer
	SUB	XR,*vrval		; point back to vrblk
	JSR	setvr			; set fields if vrblk
	EXI				; return
;
;      here for bad trace type
;
trc15	EXI	2			; take bad trace type error exit
;
;      pop stack before failing
;
trc16	ICA	XS			; pop stack
;
;      here for bad name argument
;
trc17	EXI	1			; take bad name error exit
	ENP				; end procedure trace
	EJC
;
;      trbld -- build trblk
;
;      trblk is used by the input, output and trace functions
;      to construct a trblk (trap block)
;
;      (XR)		     trtag or trter
;      (XL)		     trfnc or trfpt
;      (WB)		     trtyp
;      jsr  trbld	     call to build trblk
;      (XR)		     pointer to trblk
;      (wa)		     destroyed
;
trbld	PRC	e,0			; entry point
	MOV	-(XS),XR		; stack trtag (or trfnm)
	MOV	WA,*trsi_		; set size of trblk
	JSR	alloc			; allocate trblk
	MOV	(XR),=b_trt		; store first word
	MOV	trfnc(XR),XL		; store trfnc (or trfpt)
	MOV	trtag(XR),(XS)+		; store trtag (or trfnm)
	MOV	trtyp(XR),WB		; store type
	MOV	trval(XR),=nulls	; for now, a null value
	EXI				; return to caller
	ENP				; end procedure trbld
	EJC
;
;      trimr -- trim trailing blanks
;
;      trimr is passed a pointer to an scblk which must be the
;      last block in dynamic storage. trailing blanks are
;      trimmed off and the dynamic storage pointer reset to
;      the end of the (possibly) shortened block.
;
;      (WB)		     non-zero to trim trailing blanks
;      (XR)		     pointer to string to trim
;      jsr  trimr	     call to trim string
;      (XR)		     pointer to trimmed string
;      (XL,WA,WB,WC)	     destroyed
;
;      the call with WB zero still performs the end zero pad
;      and dnamp readjustment. it is used from acess if kvtrm=0.
;
trimr	PRC	e,0			; entry point
	MOV	XL,XR			; copy string pointer
	MOV	WA,sclen(XR)		; load string length
	BZE	WA,trim2		; jump if null input
	PLC	XL,WA			; else point past last character
	BZE	WB,trim3		; jump if no trim
	MOV	WC,=ch_bl		; load blank character
;
;      loop through characters from right to left
;
trim0	LCH	WB,-(XL)		; load next character
.IF    .caht
	BEQ	WB,=ch_ht,trim1		; jump if horizontal tab
.FI
	BNE	WB,WC,trim3		; jump if non-blank found
trim1	DCV	WA			; else decrement character count
	BNZ	WA,trim0		; loop back if more to check
;
;      here if result is null (null or all-blank input)
;
trim2	MOV	dnamp,XR		; wipe out input string block
	MOV	XR,=nulls		; load null result
	BRN	trim5			; merge to exit
	EJC
;
;      trimr (continued)
;
;      here with non-blank found (merge for no trim)
;
trim3	MOV	sclen(XR),WA		; set new length
	MOV	XL,XR			; copy string pointer
	PSC	XL,WA			; ready for storing blanks
	CTB	WA,schar		; get length of block in bytes
	ADD	WA,XR			; point past new block
	MOV	dnamp,WA		; set new top of storage pointer
	LCT	WA,=cfp_c		; get count of chars in word
	ZER	WC			; set zero char
;
;      loop to zero pad last word of characters
;
trim4	SCH	WC,(XL)+		; store zero character
	BCT	WA,trim4		; loop back till all stored
	CSC	XL			; complete store characters
;
;      common exit point
;
trim5	ZER	XL			; clear garbage XL pointer
	EXI				; return to caller
	ENP				; end procedure trimr
	EJC
;
;      trxeq -- execute function type trace
;
;      trxeq is used to execute a trace when a fourth argument
;      has been supplied. trace has already been decremented.
;
;      (XR)		     pointer to trblk
;      (XL,WA)		     name base,offset for vaRIAble
;      jsr  trxeq	     call to execute trace
;      (WB,WC,ra)	     destroyed
;
;      the following stack entries are made before passing
;      control to the trace function using the cfunc routine.
;
;			     trxeq return point word(s)
;			     saved value of trace keyword
;			     trblk pointer
;			     name base
;			     name offset
;			     saved value of r_cod
;			     saved code ptr (-r_cod)
;			     saved value of flptr
;      flptr --------------- zero (dummy fail offset)
;			     nmblk for vaRIAble name
;      XS ------------------ trace tag
;
;      r_cod and the code ptr are set to dummy values which
;      cause control to return to the trxeq procedure on success
;      or failure (trxeq ignores a failure condition).
;
trxeq	PRC	r,0			; entry point (recursive)
	MOV	WC,r_cod		; load code block pointer
	SCP	WB			; get current code pointer
	SUB	WB,WC			; make code pointer into offset
	MOV	-(XS),kvtra		; stack trace keyword value
	MOV	-(XS),XR		; stack trblk pointer
	MOV	-(XS),XL		; stack name base
	MOV	-(XS),WA		; stack name offset
	MOV	-(XS),WC		; stack code block pointer
	MOV	-(XS),WB		; stack code pointer offset
	MOV	-(XS),flptr		; stack old failure pointer
	ZER	-(XS)			; set dummy fail offset
	MOV	flptr,XS		; set new failure pointer
	ZER	kvtra			; reset trace keyword to zero
	MOV	WC,=trxdc		; load new (dummy) code blk pointer
	MOV	r_cod,WC		; set as code block pointer
	LCP	WC			; and new code pointer
	EJC
;
;      trxeq (continued)
;
;      now prepare arguments for function
;
	MOV	WB,WA			; save name offset
	MOV	WA,*nmsi_		; load nmblk size
	JSR	alloc			; allocate space for nmblk
	MOV	(XR),=b_nml		; set type word
	MOV	nmbas(XR),XL		; store name base
	MOV	nmofs(XR),WB		; store name offset
	MOV	XL,6(XS)		; reload pointer to trblk
	MOV	-(XS),XR		; stack nmblk pointer (1st argument)
	MOV	-(XS),trtag(XL)		; stack trace tag (2nd argument)
	MOV	XL,trfnc(XL)		; load trace vrblk pointer
	MOV	XL,vrfnc(XL)		; load trace function pointer
	BEQ	XL,=stndf,trxq2		; jump if not a defined function
	MOV	WA,=num02		; set number of arguments to two
	BRN	cfunc			; jump to call function
;
;      see o_txr for details of return to this point
;
trxq1	MOV	XS,flptr		; point back to our stack entries
	ICA	XS			; pop off garbage fail offset
	MOV	flptr,(XS)+		; restore old failure pointer
	MOV	WB,(XS)+		; reload code offset
	MOV	WC,(XS)+		; load old code base pointer
	MOV	XR,WC			; copy cdblk pointer
	MOV	kvstn,cdstm(XR)		; restore stmnt no
	MOV	WA,(XS)+		; reload name offset
	MOV	XL,(XS)+		; reload name base
	MOV	XR,(XS)+		; reload trblk pointer
	MOV	kvtra,(XS)+		; restore trace keyword value
	ADD	WB,WC			; recompute absolute code pointer
	LCP	WB			; restore code pointer
	MOV	r_cod,WC		; and code block pointer
	EXI				; return to trxeq caller
;
;      here if the target function is not defined
;
trxq2	ERB	197,trace fourth arg is not function name or null
;
	ENP				; end procedure trxeq
	EJC
;
;      XScan -- execution function argument scan
;
;      XScan scans out one token in a prototype argument in
;      array,clear,data,define,load function calls. XScan
;      calls must be preceded by a call to the initialization
;      procedure XScni. the following vaRIAbles are used.
;
;      r_xsc		     pointer to scblk for function arg
;      xsofs		     offset (num chars scanned so far)
;
;      (wa)		     non-zero to skip and trim blanks
;      (WC)		     delimiter one (ch_xx)
;      (XL)		     delimiter two (ch_xx)
;      jsr  XScan	     call to scan next item
;      (XR)		     pointer to scblk for token scanned
;      (wa)		     completion code (see below)
;      (WC,XL)		     destroyed
;
;      the scan starts from the current position and continues
;      until one of the following three conditions occurs.
;
;      1)   delimiter one is encountered  (wa set to 1)
;
;      2)   delimiter two encountered  (wa set to 2)
;
;      3)   end of string encountered  (wa set to 0)
;
;      the result is a string containing all characters scanned
;      up to but not including any delimiter character.
;      the pointer is left pointing past the delimiter.
;
;      if only one delimiter is to be detected, delimiter one
;      and delimiter two should be set to the same value.
;
;      in the case where the end of string is encountered, the
;      string includes all the characters to the end of the
;      string. no further calls can be made to XScan until
;      XScni is called to initialize a new argument scan
	EJC
;
;      XScan (continued)
;
XScan	PRC	e,0			; entry point
	MOV	xscwb,WB		; preserve WB
	MOV	-(XS),WA		; record blank skip flag
	MOV	-(XS),WA		; and second copy
	MOV	XR,r_xsc		; point to argument string
	MOV	WA,sclen(XR)		; load string length
	MOV	WB,xsofs		; load current offset
	SUB	WA,WB			; get number of remaining characters
	BZE	WA,XScn3		; jump if no characters left
	PLC	XR,WB			; point to current character
;
;      loop to search for delimiter
;
XScn1	LCH	WB,(XR)+		; load next character
	BEQ	WB,WC,XScn4		; jump if delimiter one found
	BEQ	WB,XL,XScn5		; jump if delimiter two found
	BZE	(XS),XScn2		; jump if not skipping blanks
	ICV	xsofs			; assume blank and delete it
.IF    .caht
	BEQ	WB,=ch_ht,XScn2		; jump if horizontal tab
.FI
.IF    .cavt
	BEQ	WB,=ch_vt,XScn2		; jump if vertical tab
.FI
	BEQ	WB,=ch_bl,XScn2		; jump if blank
	DCV	xsofs			; undelete non-blank character
	ZER	(XS)			; and discontinue blank checking
;
;      here after performing any leading blank trimming.
;
XScn2	DCV	WA			; decrement count of chars left
	BNZ	WA,XScn1		; loop back if more chars to go
;
;      here for runout
;
XScn3	MOV	XL,r_xsc		; point to string block
	MOV	WA,sclen(XL)		; get string length
	MOV	WB,xsofs		; load offset
	SUB	WA,WB			; get substring length
	ZER	r_xsc			; clear string ptr for collector
	ZER	xscrt			; set zero (runout) return code
	BRN	XScn7			; jump to exit
	EJC
;
;      XScan (continued)
;
;      here if delimiter one found
;
XScn4	MOV	xscrt,=num01		; set return code
	BRN	XScn6			; jump to merge
;
;      here if delimiter two found
;
XScn5	MOV	xscrt,=num02		; set return code
;
;      merge here after detecting a delimiter
;
XScn6	MOV	XL,r_xsc		; reload pointer to string
	MOV	WC,sclen(XL)		; get original length of string
	SUB	WC,WA			; minus chars left = chars scanned
	MOV	WA,WC			; move to reg for sbstr
	MOV	WB,xsofs		; set offset
	SUB	WA,WB			; compute length for sbstr
	ICV	WC			; adjust new cursor past delimiter
	MOV	xsofs,WC		; store new offset
;
;      common exit point
;
XScn7	ZER	XR			; clear garbage character ptr in XR
	JSR	sbstr			; build sub-string
	ICA	XS			; remove copy of blank flag
	MOV	WB,(XS)+		; original blank skip/trim flag
	BZE	sclen(XR),XScn8		; cannot trim the null string
	JSR	trimr			; trim trailing blanks if requested
;
;      final exit point
;
XScn8	MOV	WA,xscrt		; load return code
	MOV	WB,xscwb		; restore WB
	EXI				; return to XScan caller
	ENP				; end procedure XScan
	EJC
;
;      XScni -- execution function argument scan
;
;      XScni initializes the scan used for prototype arguments
;      in the clear, define, load, data, array functions. see
;      XScan for the procedure which is used after this call.
;
;      -(XS)		     argument to be scanned (on stack)
;      jsr  XScni	     call to scan argument
;      ppm  loc		     transfer loc if arg is not string
;      ppm  loc		     transfer loc if argument is null
;      (XS)		     popped
;      (XR,r_xsc)	     argument (scblk ptr)
;      (wa)		     argument length
;      (ia,ra)		     destroyed
;
XScni	PRC	n,2			; entry point
	JSR	gtstg			; fetch argument as string
	PPM	XSci1			; jump if not convertible
	MOV	r_xsc,XR		; else store scblk ptr for XScan
	ZER	xsofs			; set offset to zero
	BZE	WA,XSci2		; jump if null string
	EXI				; return to XScni caller
;
;      here if argument is not a string
;
XSci1	EXI	1			; take not-string error exit
;
;      here for null string
;
XSci2	EXI	2			; take null-string error exit
	ENP				; end procedure XScni
	TTL	s p i t b o l -- stack overflow section
;
;      control comes here if the main stack overflows
;
	SEC				; start of stack overflow section
;
	ADD	errft,=num04		; force conclusive fatal error
	MOV	XS,flptr		; pop stack to avoid more fails
	BNZ	gbcfl,stak1		; jump if garbage collecting
	ERB	246,stack overflow
;
;      no chance of recovery in mid garbage collection
;
stak1	MOV	XR,=endso		; point to message
	ZER	kvdmp			; memory is undumpable
	BRN	stopr			; give up
	TTL	s p i t b o l -- error section
;
;      this section of code is entered whenever a procedure
;      return via an err parameter or an erb opcode is obeyed.
;
;      (wa)		     is the error code
;
;      the global vaRIAble stage indicates the point at which
;      the error occured as follows.
;
;      stage=stgic	     error during initial compile
;
;      stage=stgxc	     error during compile at execute
;			     time (code, convert function calls)
;
;      stage=stgev	     error during compilation of
;			     expression at execution time
;			     (eval, convert function call).
;
;      stage=stgxt	     error at execute time. compiler
;			     not active.
;
;      stage=stgce	     error during initial compile after
;			     scanning out the end line.
;
;      stage=stgxe	     error during compile at execute
;			     time after scanning end line.
;
;      stage=stgee	     error during expression evaluation
;
	SEC				; start of error section
;
error	BEQ	r_cim,=cmlab,cmple	; jump if error in scanning label
	MOV	kvert,WA		; save error code
	ZER	scnrs			; reset rescan switch for scane
	ZER	scngo			; reset goto switch for scane
.IF    .cpol
	MOV	polcs,=num01		; reset poll count
	MOV	polct,=num01		; reset poll count
.FI
	MOV	XR,stage		; load current stage
	BSW	XR,stgno		; jump to appropriate error circuit
	IFF	stgic,err01		; initial compile
	IFF	stgxc,err04		; execute time compile
	IFF	stgev,err04		; eval compiling expr.
	IFF	stgee,err04		; eval evaluating expr
	IFF	stgxt,err05		; execute time
	IFF	stgce,err01		; compile - after end
	IFF	stgxe,err04		; xeq compile-past end
	ESW				; end switch on error type
	EJC
;
;      error during initial compile
;
;      the error message is printed as part of the compiler
;      output. this printout includes the offending line (if not
;      printed already) and an error flag under the appropriate
;      column as indicated by scnse unless scnse is set to zero.
;
;      after printing the message, the generated code is
;      modified to an error call and control is returned to
;      the cmpil procedure after resetting the stack pointer.
;
;      if the error occurs after the end line, control returns
;      in a slightly different manner to ensure proper cleanup.
;
err01	MOV	XS,cmpxs		; reset stack pointer
	SSL	cmpss			; restore s-r stack ptr for cmpil
	BNZ	errsp,err03		; jump if error suppress flag set
.IF    .cera
.IF    .csfn
	MOV	WC,cmpsn		; current statement
	JSR	filnm			; obtain file name for this statement
.FI
	MOV	WB,scnse		; column number
	MOV	WC,rdcln		; line number
	MOV	XR,stage		;
	JSR	sysea			; advise system of error
	PPM	erra3			; if system does not want print
	MOV	-(XS),XR		; save any provided print message
.FI
	MOV	erlst,erich		; set flag for listr
	JSR	listr			; list line
	JSR	prtis			; terminate listing
	ZER	erlst			; clear listr flag
	MOV	WA,scnse		; load scan element offset
	BZE	WA,err02		; skip if not set
.IF    .caht
	LCT	WB,WA			; loop counter
	ICV	WA			; increase for ch_ex
	MOV	XL,r_cim		; point to bad statement
	JSR	alocs			; string block for error flag
	MOV	WA,XR			; remember string ptr
	PSC	XR			; ready for character storing
	PLC	XL			; ready to get chars
;
;      loop to replace all chars but tabs by blanks
;
erra1	LCH	WC,(XL)+		; get next char
	BEQ	WC,=ch_ht,erra2		; skip if tab
	MOV	WC,=ch_bl		; get a blank
	EJC
;
;      merge to store blank or tab in error line
;
erra2	SCH	WC,(XR)+		; store char
	BCT	WB,erra1		; loop
	MOV	XL,=ch_ex		; exclamation mark
	SCH	XL,(XR)			; store at end of error line
	CSC	XR			; end of sch loop
	MOV	profs,=stnpd		; allow for statement number
	MOV	XR,WA			; point to error line
	JSR	prtst			; print error line
.ELSE
	MTI	prlen			; get print buffer length
	MFI	gtnsi			; store as signed integer
	ADD	WA,=stnpd		; adjust for statement number
	MTI	WA			; copy to integer accumulator
	RMI	gtnsi			; remainder modulo print bfr length
	STI	profs			; use as character offset
	MOV	WA,=ch_ex		; get exclamation mark
	JSR	prtch			; generate under bad column
.FI
;
;      here after placing error flag as required
;
err02	JSR	prtis			; print blank line
.IF    .cera
	MOV	XR,(XS)+		; restore any sysea message
	BZE	XR,erra0		; did sysea provide message to print
	JSR	prtst			; print sysea message
.FI
erra0	JSR	ermsg			; generate flag and error message
	ADD	lstlc,=num03		; bump page ctr for blank, error, blk
erra3	ZER	XR			; in case of fatal error
	BHI	errft,=num03,stopr	; pack up if several fatals
;
;      count error, inhibit execution if required
;
	ICV	cmerc			; bump error count
	ADD	noxeq,cswer		; inhibit xeq if -noerrors
	BNE	stage,=stgic,cmp10	; special return if after end line
	EJC
;
;      loop to scan to end of statement
;
err03	MOV	XR,r_cim		; point to start of image
	PLC	XR			; point to first char
	LCH	XR,(XR)			; get first char
	BEQ	XR,=ch_mn,cmpce		; jump if error in control card
	ZER	scnrs			; clear rescan flag
	MNZ	errsp			; set error suppress flag
	JSR	scane			; scan next element
	BNE	XL,=t_smc,err03		; loop back if not statement end
	ZER	errsp			; clear error suppress flag
;
;      generate error call in code and return to cmpil
;
	MOV	cwcof,*cdcod		; reset offset in ccblk
	MOV	WA,=ocer_		; load compile error call
	JSR	cdwrd			; generate it
	MOV	cmsoc(XS),cwcof		; set success fill in offset
	MNZ	cmffc(XS)		; set failure fill in flag
	JSR	cdwrd			; generate succ. fill in word
	BRN	cmpse			; merge to generate error as cdfal
;
;      error during execute time compile or expression evaluatio
;
;      execute time compilation is initiated through gtcod or
;      gtexp which are called by compile, code or eval.
;      before causing statement failure through exfal it is
;      helpful to set keyword errteXT and for generality
;      these errors may be handled by the setexit mechanism.
;
err04	BGE	errft,=num03,labo1	; abort if too many fatal errors
.IF    .cpol
	BEQ	kvert,=nm320,err06	; treat user interrupt specially
.FI
	ZER	r_ccb			; forget garbage code block
	MOV	cwcof,*cccod		; set initial offset (mbe catspaw)
	SSL	iniss			; restore main prog s-r stack ptr
	JSR	ertex			; get fail message teXT
	DCA	XS			; ensure stack ok on loop start
;
;      pop stack until find flptr for most deeply nested prog.
;      defined function call or call of eval / code.
;
erra4	ICA	XS			; pop stack
	BEQ	XS,flprt,errc4		; jump if prog defined fn call found
	BNE	XS,gtcef,erra4		; loop if not eval or code call yet
	MOV	stage,=stgxt		; re-set stage for execute
	MOV	r_cod,r_gtc		; recover code ptr
	MOV	flptr,XS		; restore fail pointer
	ZER	r_cim			; forget possible image
.IF    .cinc
	ZER	cnind			; forget possible include
.FI
;
;      test errlimit
;
errb4	BNZ	kverl,err07		; jump if errlimit non-zero
	BRN	exfal			; fail
;
;      return from prog. defined function is outstanding
;
errc4	MOV	XS,flptr		; restore stack from flptr
	BRN	errb4			; merge
	EJC
;
;      error at execute time.
;
;      the action taken on an error is as follows.
;
;      if errlimit keyword is zero, an abort is signalled,
;      see coding for system label abort at l_abo.
;
;      otherwise, errlimit is decremented and an errtype trace
;      generated if required. control returns either via a jump
;      to continue (to take the failure exit) or a specified
;      setexit trap is executed and control passes to the trap.
;      if 3 or more fatal errors occur an abort is signalled
;      regardless of errlimit and setexit - looping is all too
;      probable otherwise. fatal errors include stack overflow
;      and exceeding stlimit.
;
err05	SSL	iniss			; restore main prog s-r stack ptr
	BNZ	dmvch,err08		; jump if in mid-dump
;
;      merge here from err08 and err04 (error 320)
;
err06	BZE	kverl,labo1		; abort if errlimit is zero
	JSR	ertex			; get fail message teXT
;
;      merge from err04
;
err07	BGE	errft,=num03,labo1	; abort if too many fatal errors
	DCV	kverl			; decrement errlimit
	MOV	XL,r_ert		; load errtype trace pointer
	JSR	ktrex			; generate errtype trace if required
	MOV	WA,r_cod		; get current code block
	MOV	r_cnt,WA		; set cdblk ptr for continuation
	SCP	WB			; current code pointer
	SUB	WB,WA			; offset within code block
	MOV	stxoc,WB		; save code ptr offset for scontinue
	MOV	XR,flptr		; set ptr to failure offset
	MOV	stxof,(XR)		; save failure offset for continue
	MOV	XR,r_sxc		; load setexit cdblk pointer
	BZE	XR,lcnt1		; continue if no setexit trap
	ZER	r_sxc			; else reset trap
	MOV	stxvr,=nulls		; reset setexit arg to null
	MOV	XL,(XR)			; load ptr to code block routine
	BRI	XL			; execute first trap statement
;
;      interrupted partly through a dump whilst store is in a
;      mess so do a tidy up operation. see dumpr for details.
;
err08	MOV	XR,dmvch		; chain head for affected vrblks
	BZE	XR,err06		; done if zero
	MOV	dmvch,(XR)		; set next link as chain head
	JSR	setvr			; restore vrget field
;
;      label to mark end of code
;
s_yyy	BRN	err08			; loop through chain
	TTL	s p i t b o l -- here endeth the code
;
;      end of assembly
;
	END				; end macro-spitbol assembly
