	.att_syntax	prefix
# copyright 1987-2012 robert b. k. dewar and mark emmer.
# copyright 2012-2015 david shields
#
# this file is part of macro spitbol.
#
#     macro spitbol is free software: you can redistribute it and/or modify
#     it under the terms of the gnu general public license as published by
#     the free software foundation, either version 2 of the license, or
#     (at your option) any later version.
#
#     macro spitbol is distributed in the hope that it will be useful,
#     but without any warranty; without even the implied warranty of
#     merchantability or fitness for a particular purpose.  see the
#     gnu general public license for more details.
#
#     you should have received a copy of the gnu general public license
#     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
#

	.att_syntax

        .text

	.include	"m.h"

	.extern	osisp
	.extern	compsp
	.extern	save_regs
	.extern	restore_regs
	.extern	_rc_
	.extern	reg_fl
	.extern	reg_w0

	.global	mxint

.ifdef zz_trace
	.extern	shields
	.extern	zz
	.extern	zz_
	.extern	zz_cp
	.extern	zz_xl
	.extern	zz_xr
	.extern	zz_xs
	.extern	zz_wa
	.extern	zz_wb
	.extern	zz_wc
	.extern	zz_w0
	.extern	zz_zz
	.extern	zz_id
	.extern	zz_de
	.extern	zz_0
	.extern	zz_1
	.extern	zz_2
	.extern	zz_3
	.extern	zz_4
	.extern	zz_arg
	.extern	zz_num
.endif
	.global	start


#
#
#   table to recover type word from type ordinal
#

	.extern	_rc_
	.global	typet
	.data

        d_word	b_art   # arblk type word - 0
        d_word	b_cdc   # cdblk type word - 1
        d_word	b_exl   # exblk type word - 2
        d_word	b_icl   # icblk type word - 3
        d_word	b_nml   # nmblk type word - 4
        d_word	p_aba   # p0blk type word - 5
        d_word	p_alt   # p1blk type word - 6
        d_word	p_any   # p2blk type word - 7
# next needed only if support real arithmetic cnra
#       d_word	b_rcl   # rcblk type word - 8
        d_word	b_scl   # scblk type word - 9
        d_word	b_sel   # seblk type word - 10
        d_word	b_tbt   # tbblk type word - 11
        d_word	b_vct   # vcblk type word - 12
        d_word	b_xnt   # xnblk type word - 13
        d_word	b_xrt   # xrblk type word - 14
        d_word	b_bct   # bcblk type word - 15
        d_word	b_pdt   # pdblk type word - 16
        d_word	b_trt   # trblk type word - 17
        d_word	b_bft   # bfblk type word   18
        d_word	b_cct   # ccblk type word - 19
        d_word	b_cmt   # cmblk type word - 20
        d_word	b_ctt   # ctblk type word - 21
        d_word	b_dfc   # dfblk type word - 22
        d_word	b_efc   # efblk type word - 23
        d_word	b_evt   # evblk type word - 24
        d_word	b_ffc   # ffblk type word - 25
        d_word	b_kvt   # kvblk type word - 26
        d_word	b_pfc   # pfblk type word - 27
        d_word	b_tet   # teblk type word - 28
#
#   table of minimal entry points that can be dded from c
#   via the minimal function (see inter.asm).
#
#   note that the order of entries in this table must correspond
#   to the order of entries in the call enumeration in osint.h
#   and osint.inc.
#
	.global calltab
calltab:
        d_word	relaj
        d_word	relcr
        d_word	reloc
        d_word	alloc
        d_word	alocs
        d_word	alost
        d_word	blkln
        d_word	insta
        d_word	rstrt
        d_word	start
        d_word	filnm
        d_word	dtype
#       d_word	enevs #  engine words
#       d_word	engts #   not used

	.global	b_efc
	.global	b_icl
	.global	b_rcl
	.global	b_scl
	.global	b_vct
	.global	b_xnt
	.global	b_xrt
	.global	c_aaa
	.global	c_yyy
	.global	dnamb
	.global	cswfl
	.global	dnamp
	.global	flprt
	.global	flptr
	.global	g_aaa
	.global	gbcnt
	.global	gtcef
	.global	headv
	.global	hshtb
	.global	kvstn
	.global	kvdmp
	.global	kvftr
	.global	kvcom
	.global	kvpfl
	.global	mxlen
	.global	polct
	.global	s_yyy
	.global	s_aaa
	.global	stage
	.global	state
	.global	stbas
	.global	statb
	.global	stmcs
	.global	stmct
	.global	timsx
	.global	typet
	.global	pmhbs
	.global	r_cod
	.global	r_fcb
	.global	w_yyy
	.global	end_min_data


	.extern	adr_
	.extern	atn_
	.extern	chp_
	.extern	cos_
	.extern	cpr_
	.extern	dvr_
	.extern	etx_
	.extern	itr_
	.extern	ldr_
	.extern	lnf_
	.extern	mlr_
	.extern	ngr_
	.extern	ovr_
	.extern	sbr_
	.extern	sin_
	.extern	str_
	.extern	sqr_
	.extern	tan_

	.extern	reg_cp

	.extern	reg_ia,reg_wa,reg_fl,reg_w0,reg_wc

	.macro	chk_
	.extern	chk__
	call	chk__
	.endm

	.extern	cvd__

	.macro	cvd_
	call	cvd__
	.endm

	.macro	icp_
	mov	reg_cp,%rax
	add	%rax,cfp_b
	mov	%rax,reg_cp
	.endm

	.macro	ino_	val
	mov	reg_fl,%al
	or	%al,%al
	jno	\val
	.endm

	.macro	iov_	val
	mov	reg_fl,%al
	or	%al,%al
	jo	\val
	.endm

	.extern	f_rti
	.macro	rti_

	call	f_rti
	mov	(reg_ia),%rbp
	.endm


	.macro	lcp_	val
	mov	\val,%rax
	mov	%rax,reg_cp
	.endm

	.macro	lcw_	val
	mov	reg_cp,%rax		# load address of code word
	mov	(%rax),%rax			# load code word
	mov	%rax,\val
	mov	reg_cp,%rax		# load address of code word
	add	cfp_b,%rax
	mov	%rax,reg_cp
	.endm

	.macro	rno_	val
	mov	reg_flx,%al
	or	%al,%al
	je	\val
	.endm

	.macro	rov_	val
	mov	reg_fl,%al
	or	%al,%al
	jne	\val
	.endm

	.macro	scp_	val
	mov	(reg_cp),%rax
	mov	%rax,\val
	.endm

.ifdef zz_trace
	.macro	zzz	val,a2,a3
	.data
%%desc:	db	\a3,0
	.text
	mov	\val,zz_id
	mov	\a2,m_word [zz_zz]
	mov	%%desc,zz_de
	call	zz_
	.endm
.endif
# ||ttl|27,l i c e n s e -- software license for this program||||97
# ||ttl|27,s p i t b o l -- notes to implementors||||117
# ||ttl|27,s p i t b o l - revision history||||149
# ||ejc|||||150
# ||ttl|27,s p i t b o l  -- basic information||||172
# ||ejc|||||173
# ||ejc|||||228
# ||ejc|||||275
# ||ejc|||||314
# ||ejc|||||367
# ||ejc|||||401
# ||ejc|||||464
# ||ejc|||||505
# ||ttl|27,s p i t b o l -- procedures section||||632
# ||sec||||; start of procedures section|670
        .text
        .global sec01
sec01:
# ||ejc|||||672
# |sysax|exp|1,0|||; define external entry point|676
        .extern sysax
# ||ejc|||||688
# |sysbs|exp|1,3|||; define external entry point|693
        .extern sysbs
# ||ejc|||||713
# |sysbx|exp|1,0|||; define external entry point|718
        .extern sysbx
# ||ejc|||||727
# |sysdc|exp|1,0|||; define external entry point|821
        .extern sysdc
# ||ejc|||||828
# |sysdm|exp|1,0|||; define external entry point|832
        .extern sysdm
# ||ejc|||||842
# |sysdt|exp|1,0|||; define external entry point|846
        .extern sysdt
# ||ejc|||||862
# |sysea|exp|1,1|||; define external entry point|866
        .extern sysea
# ||ejc|||||888
# |sysef|exp|1,3|||; define external entry point|892
        .extern sysef
# ||ejc|||||905
# |sysej|exp|1,0|||; define external entry point|909
        .extern sysej
# ||ejc|||||929
# |sysem|exp|1,0|||; define external entry point|933
        .extern sysem
# ||ejc|||||950
# |sysen|exp|1,3|||; define external entry point|954
        .extern sysen
# ||ejc|||||976
# |sysep|exp|1,0|||; define external entry point|980
        .extern sysep
# ||ejc|||||986
# |sysex|exp|1,3|||; define external entry point|990
        .extern sysex
# ||ejc|||||1035
# |sysfc|exp|1,2|||; define external entry point|1039
        .extern sysfc
# ||ejc|||||1085
# ||ejc|||||1140
# |sysgc|exp|1,0|||; define external entry point|1144
        .extern sysgc
# ||ejc|||||1168
# |syshs|exp|1,8|||; define external entry point|1172
        .extern syshs
# ||ejc|||||1211
# |sysid|exp|1,0|||; define external entry point|1215
        .extern sysid
# ||ejc|||||1240
# |sysif|exp|1,1|||; define external entry point|1245
        .extern sysif
# ||ejc|||||1278
# |sysil|exp|1,0|||; define external entry point|1283
        .extern sysil
# ||ejc|||||1302
# |sysin|exp|1,3|||; define external entry point|1306
        .extern sysin
# ||ejc|||||1325
# |sysio|exp|1,2|||; define external entry point|1329
        .extern sysio
# ||ejc|||||1364
# |sysld|exp|1,3|||; define external entry point|1368
        .extern sysld
# ||ejc|||||1387
# |sysmm|exp|1,0|||; define external entry point|1391
        .extern sysmm
# ||ejc|||||1403
# |sysmx|exp|1,0|||; define external entry point|1407
        .extern sysmx
# ||ejc|||||1433
# |sysou|exp|1,2|||; define external entry point|1437
        .extern sysou
# ||ejc|||||1459
# |syspi|exp|1,1|||; define external entry point|1463
        .extern syspi
# ||ejc|||||1479
# |syspl|exp|1,3|||; define external entry point|1483
        .extern syspl
# ||ejc|||||1506
# |syspp|exp|1,0|||; define external entry point|1510
        .extern syspp
# ||ejc|||||1572
# |syspr|exp|1,1|||; define external entry point|1576
        .extern syspr
# ||ejc|||||1602
# |sysrd|exp|1,1|||; define external entry point|1606
        .extern sysrd
# ||ejc|||||1638
# |sysri|exp|1,1|||; define external entry point|1642
        .extern sysri
# ||ejc|||||1661
# |sysrw|exp|1,3|||; define external entry point|1665
        .extern sysrw
# ||ejc|||||1678
# |sysst|exp|1,0|||; define external entry point|1683
        .extern sysst
# ||ejc|||||1700
# |systm|exp|1,0|||; define external entry point|1705
        .extern systm
# ||ejc|||||1719
# |systt|exp|1,0|||; define external entry point|1723
        .extern systt
# ||ejc|||||1730
# |sysul|exp|1,0|||; define external entry point|1734
        .extern sysul
# ||ejc|||||1750
# |sysxi|exp|1,2|||; define external entry point|1754
        .extern sysxi
# ||ejc|||||1810
# ||ejc|||||1850
# |acess|inp|25,r|1,1||;|1854
# |acomp|inp|25,n|1,5||;|1855
# |alloc|inp|25,e|1,0||;|1856
# |alocs|inp|25,e|1,0||;|1861
# |alost|inp|25,e|1,0||;|1862
# |arith|inp|25,n|1,3||;|1870
# |asign|inp|25,r|1,1||;|1872
# |asinp|inp|25,r|1,1||;|1873
# |blkln|inp|25,e|1,0||;|1874
# |cdgcg|inp|25,e|1,0||;|1875
# |cdgex|inp|25,r|1,0||;|1876
# |cdgnm|inp|25,r|1,0||;|1877
# |cdgvl|inp|25,r|1,0||;|1878
# |cdwrd|inp|25,e|1,0||;|1879
# |cmgen|inp|25,r|1,0||;|1880
# |cmpil|inp|25,e|1,0||;|1881
# |cncrd|inp|25,e|1,0||;|1882
# |copyb|inp|25,n|1,1||;|1883
# |dffnc|inp|25,e|1,0||;|1884
# |dtach|inp|25,e|1,0||;|1885
# |dtype|inp|25,e|1,0||;|1886
# |dumpr|inp|25,e|1,0||;|1887
# |ermsg|inp|25,e|1,0||;|1892
# |ertex|inp|25,e|1,0||;|1893
# |evali|inp|25,r|1,4||;|1894
# |evalp|inp|25,r|1,1||;|1895
# |evals|inp|25,r|1,3||;|1896
# |evalx|inp|25,r|1,1||;|1897
# |exbld|inp|25,e|1,0||;|1898
# |expan|inp|25,e|1,0||;|1899
# |expap|inp|25,e|1,1||;|1900
# |expdm|inp|25,n|1,0||;|1901
# |expop|inp|25,n|1,0||;|1902
# |filnm|inp|25,e|1,0||;|1904
# |flstg|inp|25,e|1,0||;|1907
# |gbcol|inp|25,e|1,0||;|1909
# |gbcpf|inp|25,e|1,0||;|1910
# |gtarr|inp|25,e|1,2||;|1911
# ||ejc|||||1912
# |gtcod|inp|25,e|1,1||;|1913
# |gtexp|inp|25,e|1,1||;|1914
# |gtint|inp|25,e|1,1||;|1915
# |gtnum|inp|25,e|1,1||;|1916
# |gtnvr|inp|25,e|1,1||;|1917
# |gtpat|inp|25,e|1,1||;|1918
# |gtrea|inp|25,e|1,1||;|1921
# |gtsmi|inp|25,n|1,2||;|1923
# |gtstg|inp|25,n|1,1||;|1928
# |gtvar|inp|25,e|1,1||;|1929
# |hashs|inp|25,e|1,0||;|1930
# |icbld|inp|25,e|1,0||;|1931
# |ident|inp|25,e|1,1||;|1932
# |inout|inp|25,e|1,0||;|1933
# |insta|inp|25,e|1,0||;|1938
# |iofcb|inp|25,n|1,3||;|1939
# |ioppf|inp|25,n|1,0||;|1940
# |ioput|inp|25,n|1,7||;|1941
# |ktrex|inp|25,r|1,0||;|1942
# |kwnam|inp|25,n|1,0||;|1943
# |lcomp|inp|25,n|1,5||;|1944
# |listr|inp|25,e|1,0||;|1945
# |listt|inp|25,e|1,0||;|1946
# |newfn|inp|25,e|1,0||;|1948
# |nexts|inp|25,e|1,0||;|1950
# |patin|inp|25,n|1,2||;|1951
# |patst|inp|25,n|1,1||;|1952
# |pbild|inp|25,e|1,0||;|1953
# |pconc|inp|25,e|1,0||;|1954
# |pcopy|inp|25,n|1,0||;|1955
# |prflr|inp|25,e|1,0||;|1958
# |prflu|inp|25,e|1,0||;|1959
# |prpar|inp|25,e|1,0||;|1961
# |prtch|inp|25,e|1,0||;|1962
# |prtic|inp|25,e|1,0||;|1963
# |prtis|inp|25,e|1,0||;|1964
# |prtin|inp|25,e|1,0||;|1965
# |prtmi|inp|25,e|1,0||;|1966
# |prtmm|inp|25,e|1,0||;|1967
# |prtmx|inp|25,e|1,0||;|1968
# |prtnl|inp|25,r|1,0||;|1969
# |prtnm|inp|25,r|1,0||;|1970
# |prtnv|inp|25,e|1,0||;|1971
# |prtpg|inp|25,e|1,0||;|1972
# |prtps|inp|25,e|1,0||;|1973
# |prtsn|inp|25,e|1,0||;|1974
# |prtst|inp|25,r|1,0||;|1975
# ||ejc|||||1976
# |prttr|inp|25,e|1,0||;|1977
# |prtvl|inp|25,r|1,0||;|1978
# |prtvn|inp|25,e|1,0||;|1979
# |rcbld|inp|25,e|1,0||;|1982
# |readr|inp|25,e|1,0||;|1984
# |relaj|inp|25,e|1,0||;|1986
# |relcr|inp|25,e|1,0||;|1987
# |reldn|inp|25,e|1,0||;|1988
# |reloc|inp|25,e|1,0||;|1989
# |relst|inp|25,e|1,0||;|1990
# |relws|inp|25,e|1,0||;|1991
# |rstrt|inp|25,e|1,0||;|1993
# |sbstr|inp|25,e|1,0||;|1997
# |scane|inp|25,e|1,0||;|1998
# |scngf|inp|25,e|1,0||;|1999
# |setvr|inp|25,e|1,0||;|2000
# |sorta|inp|25,n|1,1||;|2003
# |sortc|inp|25,e|1,1||;|2004
# |sortf|inp|25,e|1,0||;|2005
# |sorth|inp|25,n|1,0||;|2006
# |start|inp|25,e|1,0||;|2008
# |stgcc|inp|25,e|1,0||;|2009
# |tfind|inp|25,e|1,1||;|2010
# |tmake|inp|25,e|1,0||;|2011
# |trace|inp|25,n|1,2||;|2012
# |trbld|inp|25,e|1,0||;|2013
# |trimr|inp|25,e|1,0||;|2014
# |trxeq|inp|25,r|1,0||;|2015
# |vmake|inp|25,e|1,1||;|2016
# |xscan|inp|25,e|1,0||;|2017
# |xscni|inp|25,n|1,2||;|2018
# |arref|inr|||||2022
# |cfunc|inr|||||2023
# |exfal|inr|||||2024
# |exint|inr|||||2025
# |exits|inr|||||2026
# |exixr|inr|||||2027
# |exnam|inr|||||2028
# |exnul|inr|||||2029
# |exrea|inr|||||2032
# |exsid|inr|||||2034
# |exvnm|inr|||||2035
# |failp|inr|||||2036
# |flpop|inr|||||2037
# |indir|inr|||||2038
# |match|inr|||||2039
# |retrn|inr|||||2040
# |stcov|inr|||||2041
# |stmgo|inr|||||2042
# |stopr|inr|||||2043
# |succp|inr|||||2044
# |sysab|inr|||||2045
# |systu|inr|||||2046
# ||ttl|27,s p i t b o l -- definitions and data structures||||2047
# ||sec||||; start of definitions section|2051
        .data
        .global sec02
sec02:
# |cfp_a|equ|24,256|||; number of characters in alphabet|2064
        .set cfp_a,256
# |cfp_b|equ|24,8|||; bytes/word addressing factor|2066
        .set cfp_b,8
# |cfp_c|equ|24,8|||; number of characters per word|2068
        .set cfp_c,8
# |cfp_f|equ|24,16|||; offset in bytes to chars in|2070
        .set cfp_f,16
# |cfp_i|equ|24,1|||; number of words in integer constant|2073
        .set cfp_i,1
# |cfp_m|equ|24,9223372036854775807|||; max positive integer in one word|2075
        .set cfp_m,9223372036854775807
# |cfp_n|equ|24,64|||; number of bits in one word|2077
        .set cfp_n,64
# |cfp_r|equ|24,1|||; number of words in real constant|2087
        .set cfp_r,1
# |cfp_s|equ|24,9|||; number of sig digs for real output|2089
        .set cfp_s,9
# |cfp_x|equ|24,3|||; max digits in real exponent|2091
        .set cfp_x,3
# |mxdgs|equ|24,cfp_s+cfp_x|||; max digits in real number|2102
        .set mxdgs,cfp_s+cfp_x
# |nstmx|equ|24,mxdgs+5|||; max space for real|2107
        .set nstmx,mxdgs+5
# |cfp_u|equ|24,128|||; realistic upper bound on alphabet|2117
        .set cfp_u,128
# ||ejc|||||2119
# |e_srs|equ|24,100|||; 30 words|2136
        .set e_srs,100
# |e_sts|equ|24,1000|||; 500 words|2143
        .set e_sts,1000
# |e_cbs|equ|24,500|||; 500 words|2151
        .set e_cbs,500
# |e_hnb|equ|24,257|||; 127 bucket headers|2158
        .set e_hnb,257
# |e_hnw|equ|24,3|||; 6 words|2165
        .set e_hnw,3
# |e_fsp|equ|24,15|||; 15 percent|2175
        .set e_fsp,15
# |e_sed|equ|24,25|||; 25 percent|2183
        .set e_sed,25
# ||ejc|||||2185
# |ch_la|equ|24,97|||; letter a|2189
        .set ch_la,97
# |ch_lb|equ|24,98|||; letter b|2190
        .set ch_lb,98
# |ch_lc|equ|24,99|||; letter c|2191
        .set ch_lc,99
# |ch_ld|equ|24,100|||; letter d|2192
        .set ch_ld,100
# |ch_le|equ|24,101|||; letter e|2193
        .set ch_le,101
# |ch_lf|equ|24,102|||; letter f|2194
        .set ch_lf,102
# |ch_lg|equ|24,103|||; letter g|2195
        .set ch_lg,103
# |ch_lh|equ|24,104|||; letter h|2196
        .set ch_lh,104
# |ch_li|equ|24,105|||; letter i|2197
        .set ch_li,105
# |ch_lj|equ|24,106|||; letter j|2198
        .set ch_lj,106
# |ch_lk|equ|24,107|||; letter k|2199
        .set ch_lk,107
# |ch_ll|equ|24,108|||; letter l|2200
        .set ch_ll,108
# |ch_lm|equ|24,109|||; letter m|2201
        .set ch_lm,109
# |ch_ln|equ|24,110|||; letter n|2202
        .set ch_ln,110
# |ch_lo|equ|24,111|||; letter o|2203
        .set ch_lo,111
# |ch_lp|equ|24,112|||; letter p|2204
        .set ch_lp,112
# |ch_lq|equ|24,113|||; letter q|2205
        .set ch_lq,113
# |ch_lr|equ|24,114|||; letter r|2206
        .set ch_lr,114
# |ch_ls|equ|24,115|||; letter s|2207
        .set ch_ls,115
# |ch_lt|equ|24,116|||; letter t|2208
        .set ch_lt,116
# |ch_lu|equ|24,117|||; letter u|2209
        .set ch_lu,117
# |ch_lv|equ|24,118|||; letter v|2210
        .set ch_lv,118
# |ch_lw|equ|24,119|||; letter w|2211
        .set ch_lw,119
# |ch_lx|equ|24,120|||; letter x|2212
        .set ch_lx,120
# |ch_ly|equ|24,121|||; letter y|2213
        .set ch_ly,121
# |ch_l_|equ|24,122|||; letter z|2214
        .set ch_l_,122
# |ch_d0|equ|24,48|||; digit 0|2218
        .set ch_d0,48
# |ch_d1|equ|24,49|||; digit 1|2219
        .set ch_d1,49
# |ch_d2|equ|24,50|||; digit 2|2220
        .set ch_d2,50
# |ch_d3|equ|24,51|||; digit 3|2221
        .set ch_d3,51
# |ch_d4|equ|24,52|||; digit 4|2222
        .set ch_d4,52
# |ch_d5|equ|24,53|||; digit 5|2223
        .set ch_d5,53
# |ch_d6|equ|24,54|||; digit 6|2224
        .set ch_d6,54
# |ch_d7|equ|24,55|||; digit 7|2225
        .set ch_d7,55
# |ch_d8|equ|24,56|||; digit 8|2226
        .set ch_d8,56
# |ch_d9|equ|24,57|||; digit 9|2227
        .set ch_d9,57
# ||ejc|||||2228
# |ch_am|equ|24,38|||; keyword operator (ampersand)|2236
        .set ch_am,38
# |ch_as|equ|24,42|||; multiplication symbol (asterisk)|2237
        .set ch_as,42
# |ch_at|equ|24,64|||; cursor position operator (at)|2238
        .set ch_at,64
# |ch_bb|equ|24,60|||; left array bracket (less than)|2239
        .set ch_bb,60
# |ch_bl|equ|24,32|||; blank|2240
        .set ch_bl,32
# |ch_br|equ|24,124|||; alternation operator (vertical bar)|2241
        .set ch_br,124
# |ch_cl|equ|24,58|||; goto symbol (colon)|2242
        .set ch_cl,58
# |ch_cm|equ|24,44|||; comma|2243
        .set ch_cm,44
# |ch_dl|equ|24,36|||; indirection operator (dollar)|2244
        .set ch_dl,36
# |ch_dt|equ|24,46|||; name operator (dot)|2245
        .set ch_dt,46
# |ch_dq|equ|24,34|||; double quote|2246
        .set ch_dq,34
# |ch_eq|equ|24,61|||; equal sign|2247
        .set ch_eq,61
# |ch_ex|equ|24,33|||; exponentiation operator (exclm)|2248
        .set ch_ex,33
# |ch_mn|equ|24,45|||; minus sign / hyphen|2249
        .set ch_mn,45
# |ch_nm|equ|24,35|||; number sign|2250
        .set ch_nm,35
# |ch_nt|equ|24,126|||; negation operator (not)|2251
        .set ch_nt,126
# |ch_pc|equ|24,37|||; percent|2252
        .set ch_pc,37
# |ch_pl|equ|24,43|||; plus sign|2253
        .set ch_pl,43
# |ch_pp|equ|24,40|||; left parenthesis|2254
        .set ch_pp,40
# |ch_rb|equ|24,62|||; right array bracket (grtr than)|2255
        .set ch_rb,62
# |ch_rp|equ|24,41|||; right parenthesis|2256
        .set ch_rp,41
# |ch_qu|equ|24,63|||; interrogation operator (question)|2257
        .set ch_qu,63
# |ch_sl|equ|24,47|||; slash|2258
        .set ch_sl,47
# |ch_sm|equ|24,59|||; semicolon|2259
        .set ch_sm,59
# |ch_sq|equ|24,39|||; single quote|2260
        .set ch_sq,39
# |ch_u_|equ|24,95|||; special identifier char (underline)|2261
        .set ch_u_,95
# |ch_ob|equ|24,91|||; opening bracket|2262
        .set ch_ob,91
# |ch_cb|equ|24,93|||; closing bracket|2263
        .set ch_cb,93
# ||ejc|||||2264
# |ch_ht|equ|24,9|||; horizontal tab|2271
        .set ch_ht,9
# |ch_ey|equ|24,94|||; up arrow|2280
        .set ch_ey,94
# |ch_ua|equ|24,65|||; shifted a|2286
        .set ch_ua,65
# |ch_ub|equ|24,66|||; shifted b|2287
        .set ch_ub,66
# |ch_uc|equ|24,67|||; shifted c|2288
        .set ch_uc,67
# |ch_ud|equ|24,68|||; shifted d|2289
        .set ch_ud,68
# |ch_ue|equ|24,69|||; shifted e|2290
        .set ch_ue,69
# |ch_uf|equ|24,70|||; shifted f|2291
        .set ch_uf,70
# |ch_ug|equ|24,71|||; shifted g|2292
        .set ch_ug,71
# |ch_uh|equ|24,72|||; shifted h|2293
        .set ch_uh,72
# |ch_ui|equ|24,73|||; shifted i|2294
        .set ch_ui,73
# |ch_uj|equ|24,74|||; shifted j|2295
        .set ch_uj,74
# |ch_uk|equ|24,75|||; shifted k|2296
        .set ch_uk,75
# |ch_ul|equ|24,76|||; shifted l|2297
        .set ch_ul,76
# |ch_um|equ|24,77|||; shifted m|2298
        .set ch_um,77
# |ch_un|equ|24,78|||; shifted n|2299
        .set ch_un,78
# |ch_uo|equ|24,79|||; shifted o|2300
        .set ch_uo,79
# |ch_up|equ|24,80|||; shifted p|2301
        .set ch_up,80
# |ch_uq|equ|24,81|||; shifted q|2302
        .set ch_uq,81
# |ch_ur|equ|24,82|||; shifted r|2303
        .set ch_ur,82
# |ch_us|equ|24,83|||; shifted s|2304
        .set ch_us,83
# |ch_ut|equ|24,84|||; shifted t|2305
        .set ch_ut,84
# |ch_uu|equ|24,85|||; shifted u|2306
        .set ch_uu,85
# |ch_uv|equ|24,86|||; shifted v|2307
        .set ch_uv,86
# |ch_uw|equ|24,87|||; shifted w|2308
        .set ch_uw,87
# |ch_ux|equ|24,88|||; shifted x|2309
        .set ch_ux,88
# |ch_uy|equ|24,89|||; shifted y|2310
        .set ch_uy,89
# |ch_uz|equ|24,90|||; shifted z|2311
        .set ch_uz,90
# |iodel|equ|24,32|||;|2318
        .set iodel,32
# ||ejc|||||2322
# ||ejc|||||2353
# |offs1|equ|24,1|||;|2381
        .set offs1,1
# |offs2|equ|24,2|||;|2382
        .set offs2,2
# |offs3|equ|24,3|||;|2383
        .set offs3,3
# ||ejc|||||2389
# |bl_ar|equ|24,0|||; arblk	    array|2410
        .set bl_ar,0
# |bl_cd|equ|24,bl_ar+1|||; cdblk	    code|2411
        .set bl_cd,bl_ar+1
# |bl_ex|equ|24,bl_cd+1|||; exblk	    expression|2412
        .set bl_ex,bl_cd+1
# |bl_ic|equ|24,bl_ex+1|||; icblk	    integer|2413
        .set bl_ic,bl_ex+1
# |bl_nm|equ|24,bl_ic+1|||; nmblk	    name|2414
        .set bl_nm,bl_ic+1
# |bl_p0|equ|24,bl_nm+1|||; p0blk	    pattern|2415
        .set bl_p0,bl_nm+1
# |bl_p1|equ|24,bl_p0+1|||; p1blk	    pattern|2416
        .set bl_p1,bl_p0+1
# |bl_p2|equ|24,bl_p1+1|||; p2blk	    pattern|2417
        .set bl_p2,bl_p1+1
# |bl_rc|equ|24,bl_p2+1|||; rcblk	    real|2418
        .set bl_rc,bl_p2+1
# |bl_sc|equ|24,bl_rc+1|||; scblk	    string|2419
        .set bl_sc,bl_rc+1
# |bl_se|equ|24,bl_sc+1|||; seblk	    expression|2420
        .set bl_se,bl_sc+1
# |bl_tb|equ|24,bl_se+1|||; tbblk	    table|2421
        .set bl_tb,bl_se+1
# |bl_vc|equ|24,bl_tb+1|||; vcblk	    array|2422
        .set bl_vc,bl_tb+1
# |bl_xn|equ|24,bl_vc+1|||; xnblk	    external|2423
        .set bl_xn,bl_vc+1
# |bl_xr|equ|24,bl_xn+1|||; xrblk	    external|2424
        .set bl_xr,bl_xn+1
# |bl_bc|equ|24,bl_xr+1|||; bcblk	    buffer|2425
        .set bl_bc,bl_xr+1
# |bl_pd|equ|24,bl_bc+1|||; pdblk	    program defined datatype|2426
        .set bl_pd,bl_bc+1
# |bl__d|equ|24,bl_pd+1|||; number of block codes for data|2428
        .set bl__d,bl_pd+1
# |bl_tr|equ|24,bl_pd+1|||; trblk|2432
        .set bl_tr,bl_pd+1
# |bl_bf|equ|24,bl_tr+1|||; bfblk|2433
        .set bl_bf,bl_tr+1
# |bl_cc|equ|24,bl_bf+1|||; ccblk|2434
        .set bl_cc,bl_bf+1
# |bl_cm|equ|24,bl_cc+1|||; cmblk|2435
        .set bl_cm,bl_cc+1
# |bl_ct|equ|24,bl_cm+1|||; ctblk|2436
        .set bl_ct,bl_cm+1
# |bl_df|equ|24,bl_ct+1|||; dfblk|2437
        .set bl_df,bl_ct+1
# |bl_ef|equ|24,bl_df+1|||; efblk|2438
        .set bl_ef,bl_df+1
# |bl_ev|equ|24,bl_ef+1|||; evblk|2439
        .set bl_ev,bl_ef+1
# |bl_ff|equ|24,bl_ev+1|||; ffblk|2440
        .set bl_ff,bl_ev+1
# |bl_kv|equ|24,bl_ff+1|||; kvblk|2441
        .set bl_kv,bl_ff+1
# |bl_pf|equ|24,bl_kv+1|||; pfblk|2442
        .set bl_pf,bl_kv+1
# |bl_te|equ|24,bl_pf+1|||; teblk|2443
        .set bl_te,bl_pf+1
# |bl__i|equ|24,0|||; default identification code|2445
        .set bl__i,0
# |bl__t|equ|24,bl_tr+1|||; code for data or trace block|2446
        .set bl__t,bl_tr+1
# |bl___|equ|24,bl_te+1|||; number of block codes|2447
        .set bl___,bl_te+1
# ||ejc|||||2448
# ||ejc|||||2486
# |fcode|equ|24,0|||; pointer to code for function|2503
        .set fcode,0
# |fargs|equ|24,1|||; number of arguments|2504
        .set fargs,1
# ||ejc|||||2522
# |idval|equ|24,1|||; id value field|2534
        .set idval,1
# ||ejc|||||2549
# ||ejc|||||2583
# |artyp|equ|24,0|||; pointer to dummy routine b_art|2587
        .set artyp,0
# |arlen|equ|24,idval+1|||; length of arblk in bytes|2588
        .set arlen,idval+1
# |arofs|equ|24,arlen+1|||; offset in arblk to arpro field|2589
        .set arofs,arlen+1
# |arndm|equ|24,arofs+1|||; number of dimensions|2590
        .set arndm,arofs+1
# |arlbd|equ|24,arndm+1|||; low bound (first subscript)|2591
        .set arlbd,arndm+1
# |ardim|equ|24,arlbd+cfp_i|||; dimension (first subscript)|2592
        .set ardim,arlbd+cfp_i
# |arlb2|equ|24,ardim+cfp_i|||; low bound (second subscript)|2593
        .set arlb2,ardim+cfp_i
# |ardm2|equ|24,arlb2+cfp_i|||; dimension (second subscript)|2594
        .set ardm2,arlb2+cfp_i
# |arpro|equ|24,ardim+cfp_i|||; array prototype (one dimension)|2595
        .set arpro,ardim+cfp_i
# |arvls|equ|24,arpro+1|||; start of values (one dimension)|2596
        .set arvls,arpro+1
# |arpr2|equ|24,ardm2+cfp_i|||; array prototype (two dimensions)|2597
        .set arpr2,ardm2+cfp_i
# |arvl2|equ|24,arpr2+1|||; start of values (two dimensions)|2598
        .set arvl2,arpr2+1
# |arsi_|equ|24,arlbd|||; number of standard fields in block|2599
        .set arsi_,arlbd
# |ardms|equ|24,arlb2-arlbd|||; size of info for one set of bounds|2600
        .set ardms,arlb2-arlbd
# ||ejc|||||2686
# |cctyp|equ|24,0|||; pointer to dummy routine b_cct|2709
        .set cctyp,0
# |cclen|equ|24,cctyp+1|||; length of ccblk in bytes|2710
        .set cclen,cctyp+1
# |ccsln|equ|24,cclen+1|||; source line number|2712
        .set ccsln,cclen+1
# |ccuse|equ|24,ccsln+1|||; offset past last used word (bytes)|2713
        .set ccuse,ccsln+1
# |cccod|equ|24,ccuse+1|||; start of generated code in block|2717
        .set cccod,ccuse+1
# ||ejc|||||2722
# |cdjmp|equ|24,0|||; ptr to routine to execute statement|2747
        .set cdjmp,0
# |cdstm|equ|24,cdjmp+1|||; statement number|2748
        .set cdstm,cdjmp+1
# |cdsln|equ|24,cdstm+1|||; source line number|2750
        .set cdsln,cdstm+1
# |cdlen|equ|24,cdsln+1|||; length of cdblk in bytes|2751
        .set cdlen,cdsln+1
# |cdfal|equ|24,cdlen+1|||; failure exit (see below)|2752
        .set cdfal,cdlen+1
# |cdcod|equ|24,cdfal+1|||; executable pseudo-code|2757
        .set cdcod,cdfal+1
# |cdsi_|equ|24,cdcod|||; number of standard fields in cdblk|2758
        .set cdsi_,cdcod
# ||ejc|||||2783
# ||ejc|||||2837
# ||ejc|||||2884
# ||ejc|||||2931
# ||ejc|||||2970
# ||ejc|||||3018
# ||ejc|||||3069
# |cmidn|equ|24,0|||; pointer to dummy routine b_cmt|3091
        .set cmidn,0
# |cmlen|equ|24,cmidn+1|||; length of cmblk in bytes|3092
        .set cmlen,cmidn+1
# |cmtyp|equ|24,cmlen+1|||; type (c_xxx, see list below)|3093
        .set cmtyp,cmlen+1
# |cmopn|equ|24,cmtyp+1|||; operand pointer (see below)|3094
        .set cmopn,cmtyp+1
# |cmvls|equ|24,cmopn+1|||; operand value pointers (see below)|3095
        .set cmvls,cmopn+1
# |cmrop|equ|24,cmvls|||; right (only) operator operand|3096
        .set cmrop,cmvls
# |cmlop|equ|24,cmvls+1|||; left operator operand|3097
        .set cmlop,cmvls+1
# |cmsi_|equ|24,cmvls|||; number of standard fields in cmblk|3098
        .set cmsi_,cmvls
# |cmus_|equ|24,cmsi_+1|||; size of unary operator cmblk|3099
        .set cmus_,cmsi_+1
# |cmbs_|equ|24,cmsi_+2|||; size of binary operator cmblk|3100
        .set cmbs_,cmsi_+2
# |cmar1|equ|24,cmvls+1|||; array subscript pointers|3101
        .set cmar1,cmvls+1
# ||ejc|||||3120
# |c_arr|equ|24,0|||; array reference|3125
        .set c_arr,0
# |c_fnc|equ|24,c_arr+1|||; function call|3126
        .set c_fnc,c_arr+1
# |c_def|equ|24,c_fnc+1|||; deferred expression (unary *)|3127
        .set c_def,c_fnc+1
# |c_ind|equ|24,c_def+1|||; indirection (unary _)|3128
        .set c_ind,c_def+1
# |c_key|equ|24,c_ind+1|||; keyword reference (unary ampersand)|3129
        .set c_key,c_ind+1
# |c_ubo|equ|24,c_key+1|||; undefined binary operator|3130
        .set c_ubo,c_key+1
# |c_uuo|equ|24,c_ubo+1|||; undefined unary operator|3131
        .set c_uuo,c_ubo+1
# |c_uo_|equ|24,c_uuo+1|||; test value (=c_uuo+1=c_ubo+2)|3132
        .set c_uo_,c_uuo+1
# |c__nm|equ|24,c_uuo+1|||; number of codes for name operands|3133
        .set c__nm,c_uuo+1
# |c_bvl|equ|24,c_uuo+1|||; binary op with value operands|3138
        .set c_bvl,c_uuo+1
# |c_uvl|equ|24,c_bvl+1|||; unary operator with value operand|3139
        .set c_uvl,c_bvl+1
# |c_alt|equ|24,c_uvl+1|||; alternation (binary bar)|3140
        .set c_alt,c_uvl+1
# |c_cnc|equ|24,c_alt+1|||; concatenation|3141
        .set c_cnc,c_alt+1
# |c_cnp|equ|24,c_cnc+1|||; concatenation, not pattern match|3142
        .set c_cnp,c_cnc+1
# |c_unm|equ|24,c_cnp+1|||; unary op with name operand|3143
        .set c_unm,c_cnp+1
# |c_bvn|equ|24,c_unm+1|||; binary op (operands by value, name)|3144
        .set c_bvn,c_unm+1
# |c_ass|equ|24,c_bvn+1|||; assignment|3145
        .set c_ass,c_bvn+1
# |c_int|equ|24,c_ass+1|||; interrogation|3146
        .set c_int,c_ass+1
# |c_neg|equ|24,c_int+1|||; negation (unary not)|3147
        .set c_neg,c_int+1
# |c_sel|equ|24,c_neg+1|||; selection|3148
        .set c_sel,c_neg+1
# |c_pmt|equ|24,c_sel+1|||; pattern match|3149
        .set c_pmt,c_sel+1
# |c_pr_|equ|24,c_bvn|||; last preevaluable code|3151
        .set c_pr_,c_bvn
# |c__nv|equ|24,c_pmt+1|||; number of different cmblk types|3152
        .set c__nv,c_pmt+1
# ||ejc|||||3153
# |cttyp|equ|24,0|||; pointer to dummy routine b_ctt|3174
        .set cttyp,0
# |ctchs|equ|24,cttyp+1|||; start of character table words|3175
        .set ctchs,cttyp+1
# |ctsi_|equ|24,ctchs+cfp_a|||; number of words in ctblk|3176
        .set ctsi_,ctchs+cfp_a
# ||ejc|||||3184
# |dflen|equ|24,fargs+1|||; length of dfblk in bytes|3216
        .set dflen,fargs+1
# |dfpdl|equ|24,dflen+1|||; length of corresponding pdblk|3217
        .set dfpdl,dflen+1
# |dfnam|equ|24,dfpdl+1|||; pointer to scblk for datatype name|3218
        .set dfnam,dfpdl+1
# |dffld|equ|24,dfnam+1|||; start of vrblk ptrs for field names|3219
        .set dffld,dfnam+1
# |dfflb|equ|24,dffld-1|||; offset behind dffld for field func|3220
        .set dfflb,dffld-1
# |dfsi_|equ|24,dffld|||; number of standard fields in dfblk|3221
        .set dfsi_,dffld
# ||ejc|||||3226
# |dvopn|equ|24,0|||; entry address (ptr to o_xxx)|3243
        .set dvopn,0
# |dvtyp|equ|24,dvopn+1|||; type code (c_xxx, see cmblk)|3244
        .set dvtyp,dvopn+1
# |dvlpr|equ|24,dvtyp+1|||; left precedence (llxxx, see below)|3245
        .set dvlpr,dvtyp+1
# |dvrpr|equ|24,dvlpr+1|||; right precedence (rrxxx, see below)|3246
        .set dvrpr,dvlpr+1
# |dvus_|equ|24,dvlpr+1|||; size of unary operator dv|3247
        .set dvus_,dvlpr+1
# |dvbs_|equ|24,dvrpr+1|||; size of binary operator dv|3248
        .set dvbs_,dvrpr+1
# |dvubs|equ|24,dvus_+dvbs_|||; size of unop + binop (see scane)|3249
        .set dvubs,dvus_+dvbs_
# ||ejc|||||3279
# |rrass|equ|24,10|||; right	    equal|3283
        .set rrass,10
# |llass|equ|24,00|||; left	    equal|3284
        .set llass,00
# |rrpmt|equ|24,20|||; right	    question mark|3285
        .set rrpmt,20
# |llpmt|equ|24,30|||; left	    question mark|3286
        .set llpmt,30
# |rramp|equ|24,40|||; right	    ampersand|3287
        .set rramp,40
# |llamp|equ|24,50|||; left	    ampersand|3288
        .set llamp,50
# |rralt|equ|24,70|||; right	    vertical bar|3289
        .set rralt,70
# |llalt|equ|24,60|||; left	    vertical bar|3290
        .set llalt,60
# |rrcnc|equ|24,90|||; right	    blank|3291
        .set rrcnc,90
# |llcnc|equ|24,80|||; left	    blank|3292
        .set llcnc,80
# |rrats|equ|24,110|||; right	    at|3293
        .set rrats,110
# |llats|equ|24,100|||; left	    at|3294
        .set llats,100
# |rrplm|equ|24,120|||; right	    plus, minus|3295
        .set rrplm,120
# |llplm|equ|24,130|||; left	    plus, minus|3296
        .set llplm,130
# |rrnum|equ|24,140|||; right	    number|3297
        .set rrnum,140
# |llnum|equ|24,150|||; left	    number|3298
        .set llnum,150
# |rrdvd|equ|24,160|||; right	    slash|3299
        .set rrdvd,160
# |lldvd|equ|24,170|||; left	    slash|3300
        .set lldvd,170
# |rrmlt|equ|24,180|||; right	    asterisk|3301
        .set rrmlt,180
# |llmlt|equ|24,190|||; left	    asterisk|3302
        .set llmlt,190
# |rrpct|equ|24,200|||; right	    percent|3303
        .set rrpct,200
# |llpct|equ|24,210|||; left	    percent|3304
        .set llpct,210
# |rrexp|equ|24,230|||; right	    exclamation|3305
        .set rrexp,230
# |llexp|equ|24,220|||; left	    exclamation|3306
        .set llexp,220
# |rrdld|equ|24,240|||; right	    dollar, dot|3307
        .set rrdld,240
# |lldld|equ|24,250|||; left	    dollar, dot|3308
        .set lldld,250
# |rrnot|equ|24,270|||; right	    not|3309
        .set rrnot,270
# |llnot|equ|24,260|||; left	    not|3310
        .set llnot,260
# |lluno|equ|24,999|||; left	    all unary operators|3311
        .set lluno,999
# ||ejc|||||3327
# |eflen|equ|24,fargs+1|||; length of efblk in bytes|3354
        .set eflen,fargs+1
# |efuse|equ|24,eflen+1|||; use count (for opsyn)|3355
        .set efuse,eflen+1
# |efcod|equ|24,efuse+1|||; ptr to code (from sysld)|3356
        .set efcod,efuse+1
# |efvar|equ|24,efcod+1|||; ptr to associated vrblk|3357
        .set efvar,efcod+1
# |efrsl|equ|24,efvar+1|||; result type (see below)|3358
        .set efrsl,efvar+1
# |eftar|equ|24,efrsl+1|||; argument types (see below)|3359
        .set eftar,efrsl+1
# |efsi_|equ|24,eftar|||; number of standard fields in efblk|3360
        .set efsi_,eftar
# ||ejc|||||3383
# |evtyp|equ|24,0|||; pointer to dummy routine b_evt|3402
        .set evtyp,0
# |evexp|equ|24,evtyp+1|||; pointer to exblk for expression|3403
        .set evexp,evtyp+1
# |evvar|equ|24,evexp+1|||; pointer to trbev dummy trblk|3404
        .set evvar,evexp+1
# |evsi_|equ|24,evvar+1|||; size of evblk|3405
        .set evsi_,evvar+1
# ||ejc|||||3414
# |extyp|equ|24,0|||; ptr to routine b_exl to load expr|3440
        .set extyp,0
# |exstm|equ|24,cdstm|||; stores stmnt no. during evaluation|3441
        .set exstm,cdstm
# |exsln|equ|24,exstm+1|||; stores line no. during evaluation|3443
        .set exsln,exstm+1
# |exlen|equ|24,exsln+1|||; length of exblk in bytes|3444
        .set exlen,exsln+1
# |exflc|equ|24,exlen+1|||; failure code (=o_fex)|3448
        .set exflc,exlen+1
# |excod|equ|24,exflc+1|||; pseudo-code for expression|3449
        .set excod,exflc+1
# |exsi_|equ|24,excod|||; number of standard fields in exblk|3450
        .set exsi_,excod
# ||ejc|||||3465
# |ffdfp|equ|24,fargs+1|||; pointer to associated dfblk|3485
        .set ffdfp,fargs+1
# |ffnxt|equ|24,ffdfp+1|||; ptr to next ffblk on chain or zero|3486
        .set ffnxt,ffdfp+1
# |ffofs|equ|24,ffnxt+1|||; offset (bytes) to field in pdblk|3487
        .set ffofs,ffnxt+1
# |ffsi_|equ|24,ffofs+1|||; size of ffblk in words|3488
        .set ffsi_,ffofs+1
# ||ejc|||||3504
# |icget|equ|24,0|||; ptr to routine b_icl to load int|3519
        .set icget,0
# |icval|equ|24,icget+1|||; integer value|3520
        .set icval,icget+1
# |icsi_|equ|24,icval+cfp_i|||; size of icblk|3521
        .set icsi_,icval+cfp_i
# ||ejc|||||3524
# |kvtyp|equ|24,0|||; pointer to dummy routine b_kvt|3539
        .set kvtyp,0
# |kvvar|equ|24,kvtyp+1|||; pointer to dummy block trbkv|3540
        .set kvvar,kvtyp+1
# |kvnum|equ|24,kvvar+1|||; keyword number|3541
        .set kvnum,kvvar+1
# |kvsi_|equ|24,kvnum+1|||; size of kvblk|3542
        .set kvsi_,kvnum+1
# ||ejc|||||3547
# |nmtyp|equ|24,0|||; ptr to routine b_nml to load name|3562
        .set nmtyp,0
# |nmbas|equ|24,nmtyp+1|||; base pointer for variable|3563
        .set nmbas,nmtyp+1
# |nmofs|equ|24,nmbas+1|||; offset for variable|3564
        .set nmofs,nmbas+1
# |nmsi_|equ|24,nmofs+1|||; size of nmblk|3565
        .set nmsi_,nmofs+1
# ||ejc|||||3577
# |pcode|equ|24,0|||; ptr to match routine (p_xxx)|3590
        .set pcode,0
# |pthen|equ|24,pcode+1|||; pointer to subsequent node|3591
        .set pthen,pcode+1
# |pasi_|equ|24,pthen+1|||; size of p0blk|3592
        .set pasi_,pthen+1
# ||ejc|||||3599
# |parm1|equ|24,pthen+1|||; first parameter value|3614
        .set parm1,pthen+1
# |pbsi_|equ|24,parm1+1|||; size of p1blk in words|3615
        .set pbsi_,parm1+1
# ||ejc|||||3625
# |parm2|equ|24,parm1+1|||; second parameter value|3642
        .set parm2,parm1+1
# |pcsi_|equ|24,parm2+1|||; size of p2blk in words|3643
        .set pcsi_,parm2+1
# ||ejc|||||3653
# |pdtyp|equ|24,0|||; ptr to dummy routine b_pdt|3672
        .set pdtyp,0
# |pddfp|equ|24,idval+1|||; ptr to associated dfblk|3673
        .set pddfp,idval+1
# |pdfld|equ|24,pddfp+1|||; start of field value pointers|3674
        .set pdfld,pddfp+1
# |pdfof|equ|24,dffld-pdfld|||; difference in offset to field ptrs|3675
        .set pdfof,dffld-pdfld
# |pdsi_|equ|24,pdfld|||; size of standard fields in pdblk|3676
        .set pdsi_,pdfld
# |pddfs|equ|24,dfsi_-pdsi_|||; difference in dfblk, pdblk sizes|3677
        .set pddfs,dfsi_-pdsi_
# ||ejc|||||3686
# |pflen|equ|24,fargs+1|||; length of pfblk in bytes|3715
        .set pflen,fargs+1
# |pfvbl|equ|24,pflen+1|||; pointer to vrblk for function name|3716
        .set pfvbl,pflen+1
# |pfnlo|equ|24,pfvbl+1|||; number of locals|3717
        .set pfnlo,pfvbl+1
# |pfcod|equ|24,pfnlo+1|||; ptr to vrblk for entry label|3718
        .set pfcod,pfnlo+1
# |pfctr|equ|24,pfcod+1|||; trblk ptr if call traced else 0|3719
        .set pfctr,pfcod+1
# |pfrtr|equ|24,pfctr+1|||; trblk ptr if return traced else 0|3720
        .set pfrtr,pfctr+1
# |pfarg|equ|24,pfrtr+1|||; vrblk ptrs for arguments and locals|3721
        .set pfarg,pfrtr+1
# |pfagb|equ|24,pfarg-1|||; offset behind pfarg for arg, local|3722
        .set pfagb,pfarg-1
# |pfsi_|equ|24,pfarg|||; number of standard fields in pfblk|3723
        .set pfsi_,pfarg
# ||ejc|||||3733
# |rcget|equ|24,0|||; ptr to routine b_rcl to load real|3746
        .set rcget,0
# |rcval|equ|24,rcget+1|||; real value|3747
        .set rcval,rcget+1
# |rcsi_|equ|24,rcval+cfp_r|||; size of rcblk|3748
        .set rcsi_,rcval+cfp_r
# ||ejc|||||3752
# |scget|equ|24,0|||; ptr to routine b_scl to load string|3769
        .set scget,0
# |sclen|equ|24,scget+1|||; length of string in characters|3770
        .set sclen,scget+1
# |schar|equ|24,sclen+1|||; characters of string|3771
        .set schar,sclen+1
# |scsi_|equ|24,schar|||; size of standard fields in scblk|3772
        .set scsi_,schar
# ||ejc|||||3787
# |setyp|equ|24,0|||; ptr to routine b_sel to load expr|3800
        .set setyp,0
# |sevar|equ|24,setyp+1|||; ptr to vrblk for variable|3801
        .set sevar,setyp+1
# |sesi_|equ|24,sevar+1|||; length of seblk in words|3802
        .set sesi_,sevar+1
# ||ejc|||||3803
# ||ejc|||||3836
# |svbit|equ|24,0|||; bit string indicating attributes|3840
        .set svbit,0
# |svlen|equ|24,1|||; (=sclen) length of name in chars|3841
        .set svlen,1
# |svchs|equ|24,2|||; (=schar) characters of name|3842
        .set svchs,2
# |svsi_|equ|24,2|||; number of standard fields in svblk|3843
        .set svsi_,2
# |svpre|equ|24,1|||; set if preevaluation permitted|3844
        .set svpre,1
# |svffc|equ|24,svpre+svpre|||; set on if fast call permitted|3845
        .set svffc,svpre+svpre
# |svckw|equ|24,svffc+svffc|||; set on if keyword value constant|3846
        .set svckw,svffc+svffc
# |svprd|equ|24,svckw+svckw|||; set on if predicate function|3847
        .set svprd,svckw+svckw
# |svnbt|equ|24,4|||; number of bits to right of svknm|3848
        .set svnbt,4
# |svknm|equ|24,svprd+svprd|||; set on if keyword association|3849
        .set svknm,svprd+svprd
# |svfnc|equ|24,svknm+svknm|||; set on if system function|3850
        .set svfnc,svknm+svknm
# |svnar|equ|24,svfnc+svfnc|||; set on if system function|3851
        .set svnar,svfnc+svfnc
# |svlbl|equ|24,svnar+svnar|||; set on if system label|3852
        .set svlbl,svnar+svnar
# |svval|equ|24,svlbl+svlbl|||; set on if predefined value|3853
        .set svval,svlbl+svlbl
# |svfnf|equ|24,svfnc+svnar|||; function with no fast call|3860
        .set svfnf,svfnc+svnar
# |svfnn|equ|24,svfnf+svffc|||; function with fast call, no preeval|3861
        .set svfnn,svfnf+svffc
# |svfnp|equ|24,svfnn+svpre|||; function allowing preevaluation|3862
        .set svfnp,svfnn+svpre
# |svfpr|equ|24,svfnn+svprd|||; predicate function|3863
        .set svfpr,svfnn+svprd
# |svfnk|equ|24,svfnn+svknm|||; no preeval func + keyword|3864
        .set svfnk,svfnn+svknm
# |svkwv|equ|24,svknm+svval|||; keyword + value|3865
        .set svkwv,svknm+svval
# |svkwc|equ|24,svckw+svknm|||; keyword with constant value|3866
        .set svkwc,svckw+svknm
# |svkvc|equ|24,svkwv+svckw|||; constant keyword + value|3867
        .set svkvc,svkwv+svckw
# |svkvl|equ|24,svkvc+svlbl|||; constant keyword + value + label|3868
        .set svkvl,svkvc+svlbl
# |svfpk|equ|24,svfnp+svkvc|||; preeval fcn + const keywd + val|3869
        .set svfpk,svfnp+svkvc
# ||ejc|||||3886
# ||ejc|||||3934
# |k_abe|equ|24,0|||; abend|3947
        .set k_abe,0
# |k_anc|equ|24,k_abe+cfp_b|||; anchor|3948
        .set k_anc,k_abe+cfp_b
# |k_cas|equ|24,k_anc+cfp_b|||; case|3950
        .set k_cas,k_anc+cfp_b
# |k_cod|equ|24,k_cas+cfp_b|||; code|3951
        .set k_cod,k_cas+cfp_b
# |k_com|equ|24,k_cod+cfp_b|||; compare|3956
        .set k_com,k_cod+cfp_b
# |k_dmp|equ|24,k_com+cfp_b|||; dump|3957
        .set k_dmp,k_com+cfp_b
# |k_erl|equ|24,k_dmp+cfp_b|||; errlimit|3961
        .set k_erl,k_dmp+cfp_b
# |k_ert|equ|24,k_erl+cfp_b|||; errtype|3962
        .set k_ert,k_erl+cfp_b
# |k_ftr|equ|24,k_ert+cfp_b|||; ftrace|3963
        .set k_ftr,k_ert+cfp_b
# |k_fls|equ|24,k_ftr+cfp_b|||; fullscan|3964
        .set k_fls,k_ftr+cfp_b
# |k_inp|equ|24,k_fls+cfp_b|||; input|3965
        .set k_inp,k_fls+cfp_b
# |k_mxl|equ|24,k_inp+cfp_b|||; maxlength|3966
        .set k_mxl,k_inp+cfp_b
# |k_oup|equ|24,k_mxl+cfp_b|||; output|3967
        .set k_oup,k_mxl+cfp_b
# |k_pfl|equ|24,k_oup+cfp_b|||; profile|3971
        .set k_pfl,k_oup+cfp_b
# |k_tra|equ|24,k_pfl+cfp_b|||; trace|3972
        .set k_tra,k_pfl+cfp_b
# |k_trm|equ|24,k_tra+cfp_b|||; trim|3974
        .set k_trm,k_tra+cfp_b
# |k_fnc|equ|24,k_trm+cfp_b|||; fnclevel|3978
        .set k_fnc,k_trm+cfp_b
# |k_lst|equ|24,k_fnc+cfp_b|||; lastno|3979
        .set k_lst,k_fnc+cfp_b
# |k_lln|equ|24,k_lst+cfp_b|||; lastline|3981
        .set k_lln,k_lst+cfp_b
# |k_lin|equ|24,k_lln+cfp_b|||; line|3982
        .set k_lin,k_lln+cfp_b
# |k_stn|equ|24,k_lin+cfp_b|||; stno|3983
        .set k_stn,k_lin+cfp_b
# |k_abo|equ|24,k_stn+cfp_b|||; abort|3990
        .set k_abo,k_stn+cfp_b
# |k_arb|equ|24,k_abo+pasi_|||; arb|3991
        .set k_arb,k_abo+pasi_
# |k_bal|equ|24,k_arb+pasi_|||; bal|3992
        .set k_bal,k_arb+pasi_
# |k_fal|equ|24,k_bal+pasi_|||; fail|3993
        .set k_fal,k_bal+pasi_
# |k_fen|equ|24,k_fal+pasi_|||; fence|3994
        .set k_fen,k_fal+pasi_
# |k_rem|equ|24,k_fen+pasi_|||; rem|3995
        .set k_rem,k_fen+pasi_
# |k_suc|equ|24,k_rem+pasi_|||; succeed|3996
        .set k_suc,k_rem+pasi_
# ||ejc|||||3997
# |k_alp|equ|24,k_suc+1|||; alphabet|4003
        .set k_alp,k_suc+1
# |k_rtn|equ|24,k_alp+1|||; rtntype|4004
        .set k_rtn,k_alp+1
# |k_stc|equ|24,k_rtn+1|||; stcount|4005
        .set k_stc,k_rtn+1
# |k_etx|equ|24,k_stc+1|||; errtext|4006
        .set k_etx,k_stc+1
# |k_fil|equ|24,k_etx+1|||; file|4008
        .set k_fil,k_etx+1
# |k_lfl|equ|24,k_fil+1|||; lastfile|4009
        .set k_lfl,k_fil+1
# |k_stl|equ|24,k_lfl+1|||; stlimit|4010
        .set k_stl,k_lfl+1
# |k_lcs|equ|24,k_stl+1|||; lcase|4015
        .set k_lcs,k_stl+1
# |k_ucs|equ|24,k_lcs+1|||; ucase|4016
        .set k_ucs,k_lcs+1
# |k__al|equ|24,k_alp-k_alp|||; alphabet|4021
        .set k__al,k_alp-k_alp
# |k__rt|equ|24,k_rtn-k_alp|||; rtntype|4022
        .set k__rt,k_rtn-k_alp
# |k__sc|equ|24,k_stc-k_alp|||; stcount|4023
        .set k__sc,k_stc-k_alp
# |k__et|equ|24,k_etx-k_alp|||; errtext|4024
        .set k__et,k_etx-k_alp
# |k__fl|equ|24,k_fil-k_alp|||; file|4026
        .set k__fl,k_fil-k_alp
# |k__lf|equ|24,k_lfl-k_alp|||; lastfile|4027
        .set k__lf,k_lfl-k_alp
# |k__sl|equ|24,k_stl-k_alp|||; stlimit|4029
        .set k__sl,k_stl-k_alp
# |k__lc|equ|24,k_lcs-k_alp|||; lcase|4031
        .set k__lc,k_lcs-k_alp
# |k__uc|equ|24,k_ucs-k_alp|||; ucase|4032
        .set k__uc,k_ucs-k_alp
# |k__n_|equ|24,k__uc+1|||; number of special cases|4033
        .set k__n_,k__uc+1
# |k_p__|equ|24,k_fnc|||; first protected keyword|4040
        .set k_p__,k_fnc
# |k_v__|equ|24,k_abo|||; first keyword with constant value|4041
        .set k_v__,k_abo
# |k_s__|equ|24,k_alp|||; first keyword with special acess|4042
        .set k_s__,k_alp
# ||ejc|||||4043
# |tbtyp|equ|24,0|||; pointer to dummy routine b_tbt|4064
        .set tbtyp,0
# |tblen|equ|24,offs2|||; length of tbblk in bytes|4065
        .set tblen,offs2
# |tbinv|equ|24,offs3|||; default initial lookup value|4066
        .set tbinv,offs3
# |tbbuk|equ|24,tbinv+1|||; start of hash bucket pointers|4067
        .set tbbuk,tbinv+1
# |tbsi_|equ|24,tbbuk|||; size of standard fields in tbblk|4068
        .set tbsi_,tbbuk
# |tbnbk|equ|24,11|||; default no. of buckets|4069
        .set tbnbk,11
# ||ejc|||||4078
# |tetyp|equ|24,0|||; pointer to dummy routine b_tet|4095
        .set tetyp,0
# |tesub|equ|24,tetyp+1|||; subscript value|4096
        .set tesub,tetyp+1
# |teval|equ|24,tesub+1|||; (=vrval) table element value|4097
        .set teval,tesub+1
# |tenxt|equ|24,teval+1|||; link to next teblk|4098
        .set tenxt,teval+1
# |tesi_|equ|24,tenxt+1|||; size of teblk in words|4100
        .set tesi_,tenxt+1
# ||ejc|||||4109
# |tridn|equ|24,0|||; pointer to dummy routine b_trt|4129
        .set tridn,0
# |trtyp|equ|24,tridn+1|||; trap type code|4130
        .set trtyp,tridn+1
# |trval|equ|24,trtyp+1|||; value of trapped variable (=vrval)|4131
        .set trval,trtyp+1
# |trnxt|equ|24,trval|||; ptr to next trblk on trblk chain|4132
        .set trnxt,trval
# |trlbl|equ|24,trval|||; ptr to actual label (traced label)|4133
        .set trlbl,trval
# |trkvr|equ|24,trval|||; vrblk pointer for keyword trace|4134
        .set trkvr,trval
# |trtag|equ|24,trval+1|||; trace tag|4135
        .set trtag,trval+1
# |trter|equ|24,trtag|||; ptr to terminal vrblk or null|4136
        .set trter,trtag
# |trtrf|equ|24,trtag|||; ptr to trblk holding fcblk ptr|4137
        .set trtrf,trtag
# |trfnc|equ|24,trtag+1|||; trace function vrblk (zero if none)|4138
        .set trfnc,trtag+1
# |trfpt|equ|24,trfnc|||; fcblk ptr for sysio|4139
        .set trfpt,trfnc
# |trsi_|equ|24,trfnc+1|||; number of words in trblk|4140
        .set trsi_,trfnc+1
# |trtin|equ|24,0|||; trace type for input association|4142
        .set trtin,0
# |trtac|equ|24,trtin+1|||; trace type for access trace|4143
        .set trtac,trtin+1
# |trtvl|equ|24,trtac+1|||; trace type for value trace|4144
        .set trtvl,trtac+1
# |trtou|equ|24,trtvl+1|||; trace type for output association|4145
        .set trtou,trtvl+1
# |trtfc|equ|24,trtou+1|||; trace type for fcblk identification|4146
        .set trtfc,trtou+1
# ||ejc|||||4147
# ||ejc|||||4189
# ||ejc|||||4237
# ||ejc|||||4287
# |vctyp|equ|24,0|||; pointer to dummy routine b_vct|4306
        .set vctyp,0
# |vclen|equ|24,offs2|||; length of vcblk in bytes|4307
        .set vclen,offs2
# |vcvls|equ|24,offs3|||; start of vector values|4308
        .set vcvls,offs3
# |vcsi_|equ|24,vcvls|||; size of standard fields in vcblk|4309
        .set vcsi_,vcvls
# |vcvlb|equ|24,vcvls-1|||; offset one word behind vcvls|4310
        .set vcvlb,vcvls-1
# |vctbd|equ|24,tbsi_-vcsi_|||; difference in sizes - see prtvl|4311
        .set vctbd,tbsi_-vcsi_
# ||ejc|||||4316
# ||ejc|||||4359
# |vrget|equ|24,0|||; pointer to routine to load value|4363
        .set vrget,0
# |vrsto|equ|24,vrget+1|||; pointer to routine to store value|4364
        .set vrsto,vrget+1
# |vrval|equ|24,vrsto+1|||; variable value|4365
        .set vrval,vrsto+1
# |vrvlo|equ|24,vrval-vrsto|||; offset to value from store field|4366
        .set vrvlo,vrval-vrsto
# |vrtra|equ|24,vrval+1|||; pointer to routine to jump to label|4367
        .set vrtra,vrval+1
# |vrlbl|equ|24,vrtra+1|||; pointer to code for label|4368
        .set vrlbl,vrtra+1
# |vrlbo|equ|24,vrlbl-vrtra|||; offset to label from transfer field|4369
        .set vrlbo,vrlbl-vrtra
# |vrfnc|equ|24,vrlbl+1|||; pointer to function block|4370
        .set vrfnc,vrlbl+1
# |vrnxt|equ|24,vrfnc+1|||; pointer to next vrblk on hash chain|4371
        .set vrnxt,vrfnc+1
# |vrlen|equ|24,vrnxt+1|||; length of name (or zero)|4372
        .set vrlen,vrnxt+1
# |vrchs|equ|24,vrlen+1|||; characters of name (vrlen gt 0)|4373
        .set vrchs,vrlen+1
# |vrsvp|equ|24,vrlen+1|||; ptr to svblk (vrlen eq 0)|4374
        .set vrsvp,vrlen+1
# |vrsi_|equ|24,vrchs+1|||; number of standard fields in vrblk|4375
        .set vrsi_,vrchs+1
# |vrsof|equ|24,vrlen-sclen|||; offset to dummy scblk for name|4376
        .set vrsof,vrlen-sclen
# |vrsvo|equ|24,vrsvp-vrsof|||; pseudo-offset to vrsvp field|4377
        .set vrsvo,vrsvp-vrsof
# ||ejc|||||4413
# |xntyp|equ|24,0|||; pointer to dummy routine b_xnt|4435
        .set xntyp,0
# |xnlen|equ|24,xntyp+1|||; length of xnblk in bytes|4436
        .set xnlen,xntyp+1
# |xndta|equ|24,xnlen+1|||; data words|4437
        .set xndta,xnlen+1
# |xnsi_|equ|24,xndta|||; size of standard fields in xnblk|4438
        .set xnsi_,xndta
# ||ejc|||||4443
# |xrtyp|equ|24,0|||; pointer to dummy routine b_xrt|4465
        .set xrtyp,0
# |xrlen|equ|24,xrtyp+1|||; length of xrblk in bytes|4466
        .set xrlen,xrtyp+1
# |xrptr|equ|24,xrlen+1|||; start of address pointers|4467
        .set xrptr,xrlen+1
# |xrsi_|equ|24,xrptr|||; size of standard fields in xrblk|4468
        .set xrsi_,xrptr
# ||ejc|||||4469
# |cnvst|equ|24,8|||; max standard type code for convert|4475
        .set cnvst,8
# |cnvrt|equ|24,cnvst+1|||; convert code for reals|4479
        .set cnvrt,cnvst+1
# |cnvbt|equ|24,cnvrt|||; no buffers - same as real code|4482
        .set cnvbt,cnvrt
# |cnvtt|equ|24,cnvbt+1|||; bsw code for convert|4486
        .set cnvtt,cnvbt+1
# |iniln|equ|24,1024|||; default image length for compiler|4490
        .set iniln,1024
# |inils|equ|24,1024|||; image length if -sequ in effect|4491
        .set inils,1024
# |ionmb|equ|24,2|||; name base used for iochn in sysio|4493
        .set ionmb,2
# |ionmo|equ|24,4|||; name offset used for iochn in sysio|4494
        .set ionmo,4
# |mnlen|equ|24,1024|||; min value allowed keyword maxlngth|4499
        .set mnlen,1024
# |mxern|equ|24,329|||; err num inadequate startup memory|4500
        .set mxern,329
# |num01|equ|24,1|||;|4506
        .set num01,1
# |num02|equ|24,2|||;|4507
        .set num02,2
# |num03|equ|24,3|||;|4508
        .set num03,3
# |num04|equ|24,4|||;|4509
        .set num04,4
# |num05|equ|24,5|||;|4510
        .set num05,5
# |num06|equ|24,6|||;|4511
        .set num06,6
# |num07|equ|24,7|||;|4512
        .set num07,7
# |num08|equ|24,8|||;|4513
        .set num08,8
# |num09|equ|24,9|||;|4514
        .set num09,9
# |num10|equ|24,10|||;|4515
        .set num10,10
# |num25|equ|24,25|||;|4516
        .set num25,25
# |nm320|equ|24,320|||;|4517
        .set nm320,320
# |nm321|equ|24,321|||;|4518
        .set nm321,321
# |nini8|equ|24,998|||;|4519
        .set nini8,998
# |nini9|equ|24,999|||;|4520
        .set nini9,999
# |thsnd|equ|24,1000|||;|4521
        .set thsnd,1000
# ||ejc|||||4522
# |opbun|equ|24,5|||; no. of binary undefined ops|4526
        .set opbun,5
# |opuun|equ|24,6|||; no of unary undefined ops|4527
        .set opuun,6
# |prsnf|equ|24,13|||; offset used in prtsn|4531
        .set prsnf,13
# |prtmf|equ|24,21|||; offset to col 21 (prtmi)|4532
        .set prtmf,21
# |rilen|equ|24,1024|||; buffer length for sysri|4533
        .set rilen,1024
# |stgic|equ|24,0|||; initial compile|4537
        .set stgic,0
# |stgxc|equ|24,stgic+1|||; execution compile (code)|4538
        .set stgxc,stgic+1
# |stgev|equ|24,stgxc+1|||; expression eval during execution|4539
        .set stgev,stgxc+1
# |stgxt|equ|24,stgev+1|||; execution time|4540
        .set stgxt,stgev+1
# |stgce|equ|24,stgxt+1|||; initial compile after end line|4541
        .set stgce,stgxt+1
# |stgxe|equ|24,stgce+1|||; exec. compile after end line|4542
        .set stgxe,stgce+1
# |stgnd|equ|24,stgce-stgic|||; difference in stage after end|4543
        .set stgnd,stgce-stgic
# |stgee|equ|24,stgxe+1|||; eval evaluating expression|4544
        .set stgee,stgxe+1
# |stgno|equ|24,stgee+1|||; number of codes|4545
        .set stgno,stgee+1
# ||ejc|||||4546
# |stnpd|equ|24,8|||; statement no. pad count|4555
        .set stnpd,8
# |t_uop|equ|24,0|||; unary operator|4567
        .set t_uop,0
# |t_lpr|equ|24,t_uop+3|||; left paren|4568
        .set t_lpr,t_uop+3
# |t_lbr|equ|24,t_lpr+3|||; left bracket|4569
        .set t_lbr,t_lpr+3
# |t_cma|equ|24,t_lbr+3|||; comma|4570
        .set t_cma,t_lbr+3
# |t_fnc|equ|24,t_cma+3|||; function call|4571
        .set t_fnc,t_cma+3
# |t_var|equ|24,t_fnc+3|||; variable|4572
        .set t_var,t_fnc+3
# |t_con|equ|24,t_var+3|||; constant|4573
        .set t_con,t_var+3
# |t_bop|equ|24,t_con+3|||; binary operator|4574
        .set t_bop,t_con+3
# |t_rpr|equ|24,t_bop+3|||; right paren|4575
        .set t_rpr,t_bop+3
# |t_rbr|equ|24,t_rpr+3|||; right bracket|4576
        .set t_rbr,t_rpr+3
# |t_col|equ|24,t_rbr+3|||; colon|4577
        .set t_col,t_rbr+3
# |t_smc|equ|24,t_col+3|||; semi-colon|4578
        .set t_smc,t_col+3
# |t_fgo|equ|24,t_smc+1|||; failure goto|4582
        .set t_fgo,t_smc+1
# |t_sgo|equ|24,t_fgo+1|||; success goto|4583
        .set t_sgo,t_fgo+1
# |t_uok|equ|24,t_fnc|||; last code ok before unary operator|4589
        .set t_uok,t_fnc
# ||ejc|||||4590
# |t_uo0|equ|24,t_uop+0|||; unary operator, state zero|4594
        .set t_uo0,t_uop+0
# |t_uo1|equ|24,t_uop+1|||; unary operator, state one|4595
        .set t_uo1,t_uop+1
# |t_uo2|equ|24,t_uop+2|||; unary operator, state two|4596
        .set t_uo2,t_uop+2
# |t_lp0|equ|24,t_lpr+0|||; left paren, state zero|4597
        .set t_lp0,t_lpr+0
# |t_lp1|equ|24,t_lpr+1|||; left paren, state one|4598
        .set t_lp1,t_lpr+1
# |t_lp2|equ|24,t_lpr+2|||; left paren, state two|4599
        .set t_lp2,t_lpr+2
# |t_lb0|equ|24,t_lbr+0|||; left bracket, state zero|4600
        .set t_lb0,t_lbr+0
# |t_lb1|equ|24,t_lbr+1|||; left bracket, state one|4601
        .set t_lb1,t_lbr+1
# |t_lb2|equ|24,t_lbr+2|||; left bracket, state two|4602
        .set t_lb2,t_lbr+2
# |t_cm0|equ|24,t_cma+0|||; comma, state zero|4603
        .set t_cm0,t_cma+0
# |t_cm1|equ|24,t_cma+1|||; comma, state one|4604
        .set t_cm1,t_cma+1
# |t_cm2|equ|24,t_cma+2|||; comma, state two|4605
        .set t_cm2,t_cma+2
# |t_fn0|equ|24,t_fnc+0|||; function call, state zero|4606
        .set t_fn0,t_fnc+0
# |t_fn1|equ|24,t_fnc+1|||; function call, state one|4607
        .set t_fn1,t_fnc+1
# |t_fn2|equ|24,t_fnc+2|||; function call, state two|4608
        .set t_fn2,t_fnc+2
# |t_va0|equ|24,t_var+0|||; variable, state zero|4609
        .set t_va0,t_var+0
# |t_va1|equ|24,t_var+1|||; variable, state one|4610
        .set t_va1,t_var+1
# |t_va2|equ|24,t_var+2|||; variable, state two|4611
        .set t_va2,t_var+2
# |t_co0|equ|24,t_con+0|||; constant, state zero|4612
        .set t_co0,t_con+0
# |t_co1|equ|24,t_con+1|||; constant, state one|4613
        .set t_co1,t_con+1
# |t_co2|equ|24,t_con+2|||; constant, state two|4614
        .set t_co2,t_con+2
# |t_bo0|equ|24,t_bop+0|||; binary operator, state zero|4615
        .set t_bo0,t_bop+0
# |t_bo1|equ|24,t_bop+1|||; binary operator, state one|4616
        .set t_bo1,t_bop+1
# |t_bo2|equ|24,t_bop+2|||; binary operator, state two|4617
        .set t_bo2,t_bop+2
# |t_rp0|equ|24,t_rpr+0|||; right paren, state zero|4618
        .set t_rp0,t_rpr+0
# |t_rp1|equ|24,t_rpr+1|||; right paren, state one|4619
        .set t_rp1,t_rpr+1
# |t_rp2|equ|24,t_rpr+2|||; right paren, state two|4620
        .set t_rp2,t_rpr+2
# |t_rb0|equ|24,t_rbr+0|||; right bracket, state zero|4621
        .set t_rb0,t_rbr+0
# |t_rb1|equ|24,t_rbr+1|||; right bracket, state one|4622
        .set t_rb1,t_rbr+1
# |t_rb2|equ|24,t_rbr+2|||; right bracket, state two|4623
        .set t_rb2,t_rbr+2
# |t_cl0|equ|24,t_col+0|||; colon, state zero|4624
        .set t_cl0,t_col+0
# |t_cl1|equ|24,t_col+1|||; colon, state one|4625
        .set t_cl1,t_col+1
# |t_cl2|equ|24,t_col+2|||; colon, state two|4626
        .set t_cl2,t_col+2
# |t_sm0|equ|24,t_smc+0|||; semicolon, state zero|4627
        .set t_sm0,t_smc+0
# |t_sm1|equ|24,t_smc+1|||; semicolon, state one|4628
        .set t_sm1,t_smc+1
# |t_sm2|equ|24,t_smc+2|||; semicolon, state two|4629
        .set t_sm2,t_smc+2
# |t_nes|equ|24,t_sm2+1|||; number of entries in branch table|4631
        .set t_nes,t_sm2+1
# ||ejc|||||4632
# |cc_ca|equ|24,0|||; -case|4637
        .set cc_ca,0
# |cc_do|equ|24,cc_ca+1|||; -double|4638
        .set cc_do,cc_ca+1
# |cc_co|equ|24,cc_do+1|||; -compare|4643
        .set cc_co,cc_do+1
# |cc_du|equ|24,cc_co+1|||; -dump|4644
        .set cc_du,cc_co+1
# |cc_cp|equ|24,cc_du+1|||; -copy|4649
        .set cc_cp,cc_du+1
# |cc_ej|equ|24,cc_cp+1|||; -eject|4650
        .set cc_ej,cc_cp+1
# |cc_er|equ|24,cc_ej+1|||; -errors|4654
        .set cc_er,cc_ej+1
# |cc_ex|equ|24,cc_er+1|||; -execute|4655
        .set cc_ex,cc_er+1
# |cc_fa|equ|24,cc_ex+1|||; -fail|4656
        .set cc_fa,cc_ex+1
# |cc_in|equ|24,cc_fa+1|||; -include|4658
        .set cc_in,cc_fa+1
# |cc_ln|equ|24,cc_in+1|||; -line|4660
        .set cc_ln,cc_in+1
# |cc_li|equ|24,cc_ln+1|||; -list|4661
        .set cc_li,cc_ln+1
# |cc_nr|equ|24,cc_li+1|||; -noerrors|4673
        .set cc_nr,cc_li+1
# |cc_nx|equ|24,cc_nr+1|||; -noexecute|4674
        .set cc_nx,cc_nr+1
# |cc_nf|equ|24,cc_nx+1|||; -nofail|4675
        .set cc_nf,cc_nx+1
# |cc_nl|equ|24,cc_nf+1|||; -nolist|4676
        .set cc_nl,cc_nf+1
# |cc_no|equ|24,cc_nl+1|||; -noopt|4677
        .set cc_no,cc_nl+1
# |cc_np|equ|24,cc_no+1|||; -noprint|4678
        .set cc_np,cc_no+1
# |cc_op|equ|24,cc_np+1|||; -optimise|4679
        .set cc_op,cc_np+1
# |cc_pr|equ|24,cc_op+1|||; -print|4680
        .set cc_pr,cc_op+1
# |cc_si|equ|24,cc_pr+1|||; -single|4681
        .set cc_si,cc_pr+1
# |cc_sp|equ|24,cc_si+1|||; -space|4682
        .set cc_sp,cc_si+1
# |cc_st|equ|24,cc_sp+1|||; -stitl|4683
        .set cc_st,cc_sp+1
# |cc_ti|equ|24,cc_st+1|||; -title|4684
        .set cc_ti,cc_st+1
# |cc_tr|equ|24,cc_ti+1|||; -trace|4685
        .set cc_tr,cc_ti+1
# |cc_nc|equ|24,cc_tr+1|||; number of control cards|4686
        .set cc_nc,cc_tr+1
# |ccnoc|equ|24,4|||; no. of chars included in match|4687
        .set ccnoc,4
# |ccofs|equ|24,7|||; offset to start of title/subtitle|4688
        .set ccofs,7
# |ccinm|equ|24,9|||; max depth of include file nesting|4690
        .set ccinm,9
# ||ejc|||||4692
# |cmstm|equ|24,0|||; tree for statement body|4699
        .set cmstm,0
# |cmsgo|equ|24,cmstm+1|||; tree for success goto|4700
        .set cmsgo,cmstm+1
# |cmfgo|equ|24,cmsgo+1|||; tree for fail goto|4701
        .set cmfgo,cmsgo+1
# |cmcgo|equ|24,cmfgo+1|||; conditional goto flag|4702
        .set cmcgo,cmfgo+1
# |cmpcd|equ|24,cmcgo+1|||; previous cdblk pointer|4703
        .set cmpcd,cmcgo+1
# |cmffp|equ|24,cmpcd+1|||; failure fill in flag for previous|4704
        .set cmffp,cmpcd+1
# |cmffc|equ|24,cmffp+1|||; failure fill in flag for current|4705
        .set cmffc,cmffp+1
# |cmsop|equ|24,cmffc+1|||; success fill in offset for previous|4706
        .set cmsop,cmffc+1
# |cmsoc|equ|24,cmsop+1|||; success fill in offset for current|4707
        .set cmsoc,cmsop+1
# |cmlbl|equ|24,cmsoc+1|||; ptr to vrblk for current label|4708
        .set cmlbl,cmsoc+1
# |cmtra|equ|24,cmlbl+1|||; ptr to entry cdblk|4709
        .set cmtra,cmlbl+1
# |cmnen|equ|24,cmtra+1|||; count of stack entries for cmpil|4711
        .set cmnen,cmtra+1
# |pfpd1|equ|24,8|||; pad positions ...|4716
        .set pfpd1,8
# |pfpd2|equ|24,20|||; ... for profile ...|4717
        .set pfpd2,20
# |pfpd3|equ|24,32|||; ... printout|4718
        .set pfpd3,32
# |pf_i2|equ|24,cfp_i+cfp_i|||; size of table entry (2 ints)|4719
        .set pf_i2,cfp_i+cfp_i
# ||ejc|||||4722
# |rlend|equ|24,0|||; end|4762
        .set rlend,0
# |rladj|equ|24,rlend+1|||; adjustment|4763
        .set rladj,rlend+1
# |rlstr|equ|24,rladj+1|||; start|4764
        .set rlstr,rladj+1
# |rssi_|equ|24,rlstr+1|||; size of section|4765
        .set rssi_,rlstr+1
# |rnsi_|equ|24,5|||; number of structures|4766
        .set rnsi_,5
# |rldye|equ|24,0|||; dynamic region end|4770
        .set rldye,0
# |rldya|equ|24,rldye+1|||; dynamic region adjustment|4771
        .set rldya,rldye+1
# |rldys|equ|24,rldya+1|||; dynamic region start|4772
        .set rldys,rldya+1
# |rlste|equ|24,rldys+1|||; static region end|4773
        .set rlste,rldys+1
# |rlsta|equ|24,rlste+1|||; static region adjustment|4774
        .set rlsta,rlste+1
# |rlsts|equ|24,rlsta+1|||; static region start|4775
        .set rlsts,rlsta+1
# |rlwke|equ|24,rlsts+1|||; working section globals end|4776
        .set rlwke,rlsts+1
# |rlwka|equ|24,rlwke+1|||; working section globals adjustment|4777
        .set rlwka,rlwke+1
# |rlwks|equ|24,rlwka+1|||; working section globals start|4778
        .set rlwks,rlwka+1
# |rlcne|equ|24,rlwks+1|||; constants section end|4779
        .set rlcne,rlwks+1
# |rlcna|equ|24,rlcne+1|||; constants section adjustment|4780
        .set rlcna,rlcne+1
# |rlcns|equ|24,rlcna+1|||; constants section start|4781
        .set rlcns,rlcna+1
# |rlcde|equ|24,rlcns+1|||; code section end|4782
        .set rlcde,rlcns+1
# |rlcda|equ|24,rlcde+1|||; code section adjustment|4783
        .set rlcda,rlcde+1
# |rlcds|equ|24,rlcda+1|||; code section start|4784
        .set rlcds,rlcda+1
# |rlsi_|equ|24,rlcds+1|||; number of fields in structure|4785
        .set rlsi_,rlcds+1
# ||ttl|27,s p i t b o l -- constant section||||4788
# ||sec||||; start of constant section|4801
        .data
        .global sec03
sec03:
# |c_aaa|dac|1,0|||; first location of constant section|4805
c_aaa:  .long 0
# |alfsp|dac|2,e_fsp|||; free store percentage|4809
alfsp:  .long e_fsp
# |bits0|dbc|1,0|||; all zero bits|4813
# getarg 0
bits0:  .long 0
# |bits1|dbc|1,1|||; one bit in low order position|4814
# getarg 1
bits1:  .long 1
# |bits2|dbc|1,2|||; bit in position 2|4815
# getarg 2
bits2:  .long 2
# |bits3|dbc|1,4|||; bit in position 3|4816
# getarg 4
bits3:  .long 4
# |bits4|dbc|1,8|||; bit in position 4|4817
# getarg 8
bits4:  .long 8
# |bits5|dbc|1,16|||; bit in position 5|4818
# getarg 16
bits5:  .long 16
# |bits6|dbc|1,32|||; bit in position 6|4819
# getarg 32
bits6:  .long 32
# |bits7|dbc|1,64|||; bit in position 7|4820
# getarg 64
bits7:  .long 64
# |bits8|dbc|1,128|||; bit in position 8|4821
# getarg 128
bits8:  .long 128
# |bits9|dbc|1,256|||; bit in position 9|4822
# getarg 256
bits9:  .long 256
# |bit10|dbc|1,512|||; bit in position 10|4823
# getarg 512
bit10:  .long 512
# |bit11|dbc|1,1024|||; bit in position 11|4824
# getarg 1024
bit11:  .long 1024
# |bit12|dbc|1,2048|||; bit in position 12|4825
# getarg 2048
bit12:  .long 2048
# |bitsm|dbc|1,0|||; mask for max integer (value filled in at runtime)|4827
# getarg 0
bitsm:  .long 0
# |btfnc|dbc|2,svfnc|||; bit to test for function|4831
# getarg svfnc
btfnc:  .long svfnc
# |btknm|dbc|2,svknm|||; bit to test for keyword number|4832
# getarg svknm
btknm:  .long svknm
# |btlbl|dbc|2,svlbl|||; bit to test for label|4833
# getarg svlbl
btlbl:  .long svlbl
# |btffc|dbc|2,svffc|||; bit to test for fast call|4834
# getarg svffc
btffc:  .long svffc
# |btckw|dbc|2,svckw|||; bit to test for constant keyword|4835
# getarg svckw
btckw:  .long svckw
# |btkwv|dbc|2,svkwv|||; bits to test for keword with value|4836
# getarg svkwv
btkwv:  .long svkwv
# |btprd|dbc|2,svprd|||; bit to test for predicate function|4837
# getarg svprd
btprd:  .long svprd
# |btpre|dbc|2,svpre|||; bit to test for preevaluation|4838
# getarg svpre
btpre:  .long svpre
# |btval|dbc|2,svval|||; bit to test for value|4839
# getarg svval
btval:  .long svval
# ||ejc|||||4840
# |ccnms|dtc|27,/case/||||4845
ccnms:  .byte 'c','a','s','e',0,0,0,0
# ||dtc|27,/doub/||||4846
        .byte 'd','o','u','b',0,0,0,0
# ||dtc|27,/comp/||||4851
        .byte 'c','o','m','p',0,0,0,0
# ||dtc|27,/dump/||||4853
        .byte 'd','u','m','p',0,0,0,0
# ||dtc|27,/copy/||||4855
        .byte 'c','o','p','y',0,0,0,0
# ||dtc|27,/ejec/||||4857
        .byte 'e','j','e','c',0,0,0,0
# ||dtc|27,/erro/||||4858
        .byte 'e','r','r','o',0,0,0,0
# ||dtc|27,/exec/||||4859
        .byte 'e','x','e','c',0,0,0,0
# ||dtc|27,/fail/||||4860
        .byte 'f','a','i','l',0,0,0,0
# ||dtc|27,/incl/||||4862
        .byte 'i','n','c','l',0,0,0,0
# ||dtc|27,/line/||||4865
        .byte 'l','i','n','e',0,0,0,0
# ||dtc|27,/list/||||4867
        .byte 'l','i','s','t',0,0,0,0
# ||dtc|27,/noer/||||4868
        .byte 'n','o','e','r',0,0,0,0
# ||dtc|27,/noex/||||4869
        .byte 'n','o','e','x',0,0,0,0
# ||dtc|27,/nofa/||||4870
        .byte 'n','o','f','a',0,0,0,0
# ||dtc|27,/noli/||||4871
        .byte 'n','o','l','i',0,0,0,0
# ||dtc|27,/noop/||||4872
        .byte 'n','o','o','p',0,0,0,0
# ||dtc|27,/nopr/||||4873
        .byte 'n','o','p','r',0,0,0,0
# ||dtc|27,/opti/||||4874
        .byte 'o','p','t','i',0,0,0,0
# ||dtc|27,/prin/||||4875
        .byte 'p','r','i','n',0,0,0,0
# ||dtc|27,/sing/||||4876
        .byte 's','i','n','g',0,0,0,0
# ||dtc|27,/spac/||||4877
        .byte 's','p','a','c',0,0,0,0
# ||dtc|27,/stit/||||4878
        .byte 's','t','i','t',0,0,0,0
# ||dtc|27,/titl/||||4879
        .byte 't','i','t','l',0,0,0,0
# ||dtc|27,/trac/||||4880
        .byte 't','r','a','c',0,0,0,0
# |dmhdk|dac|6,b_scl|||; dump of keyword values|4884
dmhdk:  .long b_scl
# ||dac|1,22|||;|4885
        .long 22
# ||dtc|27,/dump of keyword values/||||4886
        .byte 'd','u','m','p',' ','o','f',' ','k','e','y','w','o','r','d',' ','v','a','l','u','e','s',0,0
# |dmhdv|dac|6,b_scl|||; dump of natural variables|4888
dmhdv:  .long b_scl
# ||dac|1,25|||;|4889
        .long 25
# ||dtc|27,/dump of natural variables/||||4890
        .byte 'd','u','m','p',' ','o','f',' ','n','a','t','u','r','a','l',' ','v','a','r','i','a','b','l','e','s',0,0,0,0,0,0,0
# ||ejc|||||4891
# |encm1|dac|6,b_scl|||;|4895
encm1:  .long b_scl
# ||dac|1,19|||;|4897
        .long 19
# ||dtc|27,/memory used (bytes)/||||4898
        .byte 'm','e','m','o','r','y',' ','u','s','e','d',' ','(','b','y','t','e','s',')',0,0,0,0,0
# |encm2|dac|6,b_scl|||;|4900
encm2:  .long b_scl
# ||dac|1,19|||;|4901
        .long 19
# ||dtc|27,/memory left (bytes)/||||4902
        .byte 'm','e','m','o','r','y',' ','l','e','f','t',' ','(','b','y','t','e','s',')',0,0,0,0,0
# |encm3|dac|6,b_scl|||;|4912
encm3:  .long b_scl
# ||dac|1,11|||;|4913
        .long 11
# ||dtc|27,/comp errors/||||4914
        .byte 'c','o','m','p',' ','e','r','r','o','r','s',0,0,0,0,0
# |encm4|dac|6,b_scl|||;|4916
encm4:  .long b_scl
# ||dac|1,20|||;|4921
        .long 20
# ||dtc|27,/comp time (millisec)/||||4922
        .byte 'c','o','m','p',' ','t','i','m','e',' ','(','m','i','l','l','i','s','e','c',')',0,0,0,0
# |encm5|dac|6,b_scl|||; execution suppressed|4925
encm5:  .long b_scl
# ||dac|1,20|||;|4926
        .long 20
# ||dtc|27,/execution suppressed/||||4927
        .byte 'e','x','e','c','u','t','i','o','n',' ','s','u','p','p','r','e','s','s','e','d',0,0,0,0
# |endab|dac|6,b_scl|||;|4931
endab:  .long b_scl
# ||dac|1,12|||;|4932
        .long 12
# ||dtc|27,/abnormal end/||||4933
        .byte 'a','b','n','o','r','m','a','l',' ','e','n','d',0,0,0,0
# ||ejc|||||4934
# |endmo|dac|6,b_scl|||;|4938
endmo:  .long b_scl
# |endml|dac|1,15|||;|4939
endml:  .long 15
# ||dtc|27,/memory overflow/||||4940
        .byte 'm','e','m','o','r','y',' ','o','v','e','r','f','l','o','w',0
# |endms|dac|6,b_scl|||;|4944
endms:  .long b_scl
# ||dac|1,10|||;|4945
        .long 10
# ||dtc|27,/normal end/||||4946
        .byte 'n','o','r','m','a','l',' ','e','n','d',0,0,0,0,0,0
# |endso|dac|6,b_scl|||; stack overflow in garbage collector|4950
endso:  .long b_scl
# ||dac|1,36|||;|4951
        .long 36
# ||dtc|27,/stack overflow in garbage collection/||||4952
        .byte 's','t','a','c','k',' ','o','v','e','r','f','l','o','w',' ','i','n',' ','g','a','r','b','a','g','e',' ','c','o','l','l','e','c','t','i','o','n',0,0,0,0
# |endtu|dac|6,b_scl|||;|4956
endtu:  .long b_scl
# ||dac|1,15|||;|4957
        .long 15
# ||dtc|27,/error - time up/||||4958
        .byte 'e','r','r','o','r',' ','-',' ','t','i','m','e',' ','u','p',0
# ||ejc|||||4959
# |ermms|dac|6,b_scl|||; error|4963
ermms:  .long b_scl
# ||dac|1,5|||;|4964
        .long 5
# ||dtc|27,/error/||||4965
        .byte 'e','r','r','o','r',0,0,0
# |ermns|dac|6,b_scl|||; string / -- /|4967
ermns:  .long b_scl
# ||dac|1,4|||;|4968
        .long 4
# ||dtc|27,/ -- /||||4969
        .byte ' ','-','-',' ',0,0,0,0
# |lstms|dac|6,b_scl|||; page|4973
lstms:  .long b_scl
# ||dac|1,5|||;|4974
        .long 5
# ||dtc|27,/page /||||4975
        .byte 'p','a','g','e',' ',0,0,0
# |headr|dac|6,b_scl|||;|4979
headr:  .long b_scl
# ||dac|1,27|||;|4980
        .long 27
# ||dtc|27,/macro spitbol version 15.01/||||4981
        .byte 'm','a','c','r','o',' ','s','p','i','t','b','o','l',' ','v','e','r','s','i','o','n',' ','1','5','.','0','1',0,0,0,0,0
# |headv|dac|6,b_scl|||; for exit() version no. check|4983
headv:  .long b_scl
# ||dac|1,5|||;|4984
        .long 5
# ||dtc|27,/15.01/||||4985
        .byte '1','5','.','0','1',0,0,0
# |gbsdp|dac|2,e_sed|||; sediment percentage|4989
gbsdp:  .long e_sed
# |int_r|dac|6,b_icl|||;|4995
int_r:  .long b_icl
# |intv0|dic|16,+0|||; 0|4996
intv0:  .long +0
# |inton|dac|6,b_icl|||;|4997
inton:  .long b_icl
# |intv1|dic|16,+1|||; 1|4998
intv1:  .long +1
# |inttw|dac|6,b_icl|||;|4999
inttw:  .long b_icl
# |intv2|dic|16,+2|||; 2|5000
intv2:  .long +2
# |intvt|dic|16,+10|||; 10|5001
intvt:  .long +10
# |intvh|dic|16,+100|||; 100|5002
intvh:  .long +100
# |intth|dic|16,+1000|||; 1000|5003
intth:  .long +1000
# |intab|dac|4,int_r|||; pointer to 0|5007
intab:  .long int_r
# ||dac|4,inton|||; pointer to 1|5008
        .long inton
# ||dac|4,inttw|||; pointer to 2|5009
        .long inttw
# ||ejc|||||5010
# |ndabb|dac|6,p_abb|||; arbno|5016
ndabb:  .long p_abb
# |ndabd|dac|6,p_abd|||; arbno|5017
ndabd:  .long p_abd
# |ndarc|dac|6,p_arc|||; arb|5018
ndarc:  .long p_arc
# |ndexb|dac|6,p_exb|||; expression|5019
ndexb:  .long p_exb
# |ndfnb|dac|6,p_fnb|||; fence()|5020
ndfnb:  .long p_fnb
# |ndfnd|dac|6,p_fnd|||; fence()|5021
ndfnd:  .long p_fnd
# |ndexc|dac|6,p_exc|||; expression|5022
ndexc:  .long p_exc
# |ndimb|dac|6,p_imb|||; immediate assignment|5023
ndimb:  .long p_imb
# |ndimd|dac|6,p_imd|||; immediate assignment|5024
ndimd:  .long p_imd
# |ndnth|dac|6,p_nth|||; pattern end (null pattern)|5025
ndnth:  .long p_nth
# |ndpab|dac|6,p_pab|||; pattern assignment|5026
ndpab:  .long p_pab
# |ndpad|dac|6,p_pad|||; pattern assignment|5027
ndpad:  .long p_pad
# |nduna|dac|6,p_una|||; anchor point movement|5028
nduna:  .long p_una
# |ndabo|dac|6,p_abo|||; abort|5036
ndabo:  .long p_abo
# ||dac|4,ndnth|||;|5037
        .long ndnth
# |ndarb|dac|6,p_arb|||; arb|5038
ndarb:  .long p_arb
# ||dac|4,ndnth|||;|5039
        .long ndnth
# |ndbal|dac|6,p_bal|||; bal|5040
ndbal:  .long p_bal
# ||dac|4,ndnth|||;|5041
        .long ndnth
# |ndfal|dac|6,p_fal|||; fail|5042
ndfal:  .long p_fal
# ||dac|4,ndnth|||;|5043
        .long ndnth
# |ndfen|dac|6,p_fen|||; fence|5044
ndfen:  .long p_fen
# ||dac|4,ndnth|||;|5045
        .long ndnth
# |ndrem|dac|6,p_rem|||; rem|5046
ndrem:  .long p_rem
# ||dac|4,ndnth|||;|5047
        .long ndnth
# |ndsuc|dac|6,p_suc|||; succeed|5048
ndsuc:  .long p_suc
# ||dac|4,ndnth|||;|5049
        .long ndnth
# |nulls|dac|6,b_scl|||; null string value|5057
nulls:  .long b_scl
# ||dac|1,0|||; sclen = 0|5058
        .long 0
# |nullw|dtc|27,/          /||||5059
nullw:  .byte ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',0,0,0,0,0,0
# |lcase|dac|6,b_scl|||;|5065
lcase:  .long b_scl
# ||dac|1,26|||;|5066
        .long 26
# ||dtc|27,/abcdefghijklmnopqrstuvwxyz/||||5067
        .byte 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',0,0,0,0,0,0
# |ucase|dac|6,b_scl|||;|5069
ucase:  .long b_scl
# ||dac|1,26|||;|5070
        .long 26
# ||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/||||5071
        .byte 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',0,0,0,0,0,0
# ||ejc|||||5073
# |opdvc|dac|6,o_cnc|||; concatenation|5077
opdvc:  .long o_cnc
# ||dac|2,c_cnc|||;|5078
        .long c_cnc
# ||dac|2,llcnc|||;|5079
        .long llcnc
# ||dac|2,rrcnc|||;|5080
        .long rrcnc
# |opdvp|dac|6,o_cnc|||; concatenation - not pattern match|5086
opdvp:  .long o_cnc
# ||dac|2,c_cnp|||;|5087
        .long c_cnp
# ||dac|2,llcnc|||;|5088
        .long llcnc
# ||dac|2,rrcnc|||;|5089
        .long rrcnc
# |opdvs|dac|6,o_ass|||; assignment|5094
opdvs:  .long o_ass
# ||dac|2,c_ass|||;|5095
        .long c_ass
# ||dac|2,llass|||;|5096
        .long llass
# ||dac|2,rrass|||;|5097
        .long rrass
# ||dac|1,6|||; unary equal|5099
        .long 6
# ||dac|2,c_uuo|||;|5100
        .long c_uuo
# ||dac|2,lluno|||;|5101
        .long lluno
# ||dac|6,o_pmv|||; pattern match|5103
        .long o_pmv
# ||dac|2,c_pmt|||;|5104
        .long c_pmt
# ||dac|2,llpmt|||;|5105
        .long llpmt
# ||dac|2,rrpmt|||;|5106
        .long rrpmt
# ||dac|6,o_int|||; interrogation|5108
        .long o_int
# ||dac|2,c_uvl|||;|5109
        .long c_uvl
# ||dac|2,lluno|||;|5110
        .long lluno
# ||dac|1,1|||; binary ampersand|5112
        .long 1
# ||dac|2,c_ubo|||;|5113
        .long c_ubo
# ||dac|2,llamp|||;|5114
        .long llamp
# ||dac|2,rramp|||;|5115
        .long rramp
# ||dac|6,o_kwv|||; keyword reference|5117
        .long o_kwv
# ||dac|2,c_key|||;|5118
        .long c_key
# ||dac|2,lluno|||;|5119
        .long lluno
# ||dac|6,o_alt|||; alternation|5121
        .long o_alt
# ||dac|2,c_alt|||;|5122
        .long c_alt
# ||dac|2,llalt|||;|5123
        .long llalt
# ||dac|2,rralt|||;|5124
        .long rralt
# ||ejc|||||5125
# ||dac|1,5|||; unary vertical bar|5129
        .long 5
# ||dac|2,c_uuo|||;|5130
        .long c_uuo
# ||dac|2,lluno|||;|5131
        .long lluno
# ||dac|1,0|||; binary at|5133
        .long 0
# ||dac|2,c_ubo|||;|5134
        .long c_ubo
# ||dac|2,llats|||;|5135
        .long llats
# ||dac|2,rrats|||;|5136
        .long rrats
# ||dac|6,o_cas|||; cursor assignment|5138
        .long o_cas
# ||dac|2,c_unm|||;|5139
        .long c_unm
# ||dac|2,lluno|||;|5140
        .long lluno
# ||dac|1,2|||; binary number sign|5142
        .long 2
# ||dac|2,c_ubo|||;|5143
        .long c_ubo
# ||dac|2,llnum|||;|5144
        .long llnum
# ||dac|2,rrnum|||;|5145
        .long rrnum
# ||dac|1,7|||; unary number sign|5147
        .long 7
# ||dac|2,c_uuo|||;|5148
        .long c_uuo
# ||dac|2,lluno|||;|5149
        .long lluno
# ||dac|6,o_dvd|||; division|5151
        .long o_dvd
# ||dac|2,c_bvl|||;|5152
        .long c_bvl
# ||dac|2,lldvd|||;|5153
        .long lldvd
# ||dac|2,rrdvd|||;|5154
        .long rrdvd
# ||dac|1,9|||; unary slash|5156
        .long 9
# ||dac|2,c_uuo|||;|5157
        .long c_uuo
# ||dac|2,lluno|||;|5158
        .long lluno
# ||dac|6,o_mlt|||; multiplication|5160
        .long o_mlt
# ||dac|2,c_bvl|||;|5161
        .long c_bvl
# ||dac|2,llmlt|||;|5162
        .long llmlt
# ||dac|2,rrmlt|||;|5163
        .long rrmlt
# ||ejc|||||5164
# ||dac|1,0|||; deferred expression|5168
        .long 0
# ||dac|2,c_def|||;|5169
        .long c_def
# ||dac|2,lluno|||;|5170
        .long lluno
# ||dac|1,3|||; binary percent|5172
        .long 3
# ||dac|2,c_ubo|||;|5173
        .long c_ubo
# ||dac|2,llpct|||;|5174
        .long llpct
# ||dac|2,rrpct|||;|5175
        .long rrpct
# ||dac|1,8|||; unary percent|5177
        .long 8
# ||dac|2,c_uuo|||;|5178
        .long c_uuo
# ||dac|2,lluno|||;|5179
        .long lluno
# ||dac|6,o_exp|||; exponentiation|5181
        .long o_exp
# ||dac|2,c_bvl|||;|5182
        .long c_bvl
# ||dac|2,llexp|||;|5183
        .long llexp
# ||dac|2,rrexp|||;|5184
        .long rrexp
# ||dac|1,10|||; unary exclamation|5186
        .long 10
# ||dac|2,c_uuo|||;|5187
        .long c_uuo
# ||dac|2,lluno|||;|5188
        .long lluno
# ||dac|6,o_ima|||; immediate assignment|5190
        .long o_ima
# ||dac|2,c_bvn|||;|5191
        .long c_bvn
# ||dac|2,lldld|||;|5192
        .long lldld
# ||dac|2,rrdld|||;|5193
        .long rrdld
# ||dac|6,o_inv|||; indirection|5195
        .long o_inv
# ||dac|2,c_ind|||;|5196
        .long c_ind
# ||dac|2,lluno|||;|5197
        .long lluno
# ||dac|1,4|||; binary not|5199
        .long 4
# ||dac|2,c_ubo|||;|5200
        .long c_ubo
# ||dac|2,llnot|||;|5201
        .long llnot
# ||dac|2,rrnot|||;|5202
        .long rrnot
# ||dac|1,0|||; negation|5204
        .long 0
# ||dac|2,c_neg|||;|5205
        .long c_neg
# ||dac|2,lluno|||;|5206
        .long lluno
# ||ejc|||||5207
# ||dac|6,o_sub|||; subtraction|5211
        .long o_sub
# ||dac|2,c_bvl|||;|5212
        .long c_bvl
# ||dac|2,llplm|||;|5213
        .long llplm
# ||dac|2,rrplm|||;|5214
        .long rrplm
# ||dac|6,o_com|||; complementation|5216
        .long o_com
# ||dac|2,c_uvl|||;|5217
        .long c_uvl
# ||dac|2,lluno|||;|5218
        .long lluno
# ||dac|6,o_add|||; addition|5220
        .long o_add
# ||dac|2,c_bvl|||;|5221
        .long c_bvl
# ||dac|2,llplm|||;|5222
        .long llplm
# ||dac|2,rrplm|||;|5223
        .long rrplm
# ||dac|6,o_aff|||; affirmation|5225
        .long o_aff
# ||dac|2,c_uvl|||;|5226
        .long c_uvl
# ||dac|2,lluno|||;|5227
        .long lluno
# ||dac|6,o_pas|||; pattern assignment|5229
        .long o_pas
# ||dac|2,c_bvn|||;|5230
        .long c_bvn
# ||dac|2,lldld|||;|5231
        .long lldld
# ||dac|2,rrdld|||;|5232
        .long rrdld
# ||dac|6,o_nam|||; name reference|5234
        .long o_nam
# ||dac|2,c_unm|||;|5235
        .long c_unm
# ||dac|2,lluno|||;|5236
        .long lluno
# |opdvd|dac|6,o_god|||; direct goto|5240
opdvd:  .long o_god
# ||dac|2,c_uvl|||;|5241
        .long c_uvl
# ||dac|2,lluno|||;|5242
        .long lluno
# |opdvn|dac|6,o_goc|||; complex normal goto|5244
opdvn:  .long o_goc
# ||dac|2,c_unm|||;|5245
        .long c_unm
# ||dac|2,lluno|||;|5246
        .long lluno
# ||ejc|||||5247
# |oamn_|dac|6,o_amn|||; array ref (multi-subs by value)|5251
oamn_:  .long o_amn
# |oamv_|dac|6,o_amv|||; array ref (multi-subs by value)|5252
oamv_:  .long o_amv
# |oaon_|dac|6,o_aon|||; array ref (one sub by name)|5253
oaon_:  .long o_aon
# |oaov_|dac|6,o_aov|||; array ref (one sub by value)|5254
oaov_:  .long o_aov
# |ocer_|dac|6,o_cer|||; compilation error|5255
ocer_:  .long o_cer
# |ofex_|dac|6,o_fex|||; failure in expression evaluation|5256
ofex_:  .long o_fex
# |ofif_|dac|6,o_fif|||; failure during goto evaluation|5257
ofif_:  .long o_fif
# |ofnc_|dac|6,o_fnc|||; function call (more than one arg)|5258
ofnc_:  .long o_fnc
# |ofne_|dac|6,o_fne|||; function name error|5259
ofne_:  .long o_fne
# |ofns_|dac|6,o_fns|||; function call (single argument)|5260
ofns_:  .long o_fns
# |ogof_|dac|6,o_gof|||; set goto failure trap|5261
ogof_:  .long o_gof
# |oinn_|dac|6,o_inn|||; indirection by name|5262
oinn_:  .long o_inn
# |okwn_|dac|6,o_kwn|||; keyword reference by name|5263
okwn_:  .long o_kwn
# |olex_|dac|6,o_lex|||; load expression by name|5264
olex_:  .long o_lex
# |olpt_|dac|6,o_lpt|||; load pattern|5265
olpt_:  .long o_lpt
# |olvn_|dac|6,o_lvn|||; load variable name|5266
olvn_:  .long o_lvn
# |onta_|dac|6,o_nta|||; negation, first entry|5267
onta_:  .long o_nta
# |ontb_|dac|6,o_ntb|||; negation, second entry|5268
ontb_:  .long o_ntb
# |ontc_|dac|6,o_ntc|||; negation, third entry|5269
ontc_:  .long o_ntc
# |opmn_|dac|6,o_pmn|||; pattern match by name|5270
opmn_:  .long o_pmn
# |opms_|dac|6,o_pms|||; pattern match (statement)|5271
opms_:  .long o_pms
# |opop_|dac|6,o_pop|||; pop top stack item|5272
opop_:  .long o_pop
# |ornm_|dac|6,o_rnm|||; return name from expression|5273
ornm_:  .long o_rnm
# |orpl_|dac|6,o_rpl|||; pattern replacement|5274
orpl_:  .long o_rpl
# |orvl_|dac|6,o_rvl|||; return value from expression|5275
orvl_:  .long o_rvl
# |osla_|dac|6,o_sla|||; selection, first entry|5276
osla_:  .long o_sla
# |oslb_|dac|6,o_slb|||; selection, second entry|5277
oslb_:  .long o_slb
# |oslc_|dac|6,o_slc|||; selection, third entry|5278
oslc_:  .long o_slc
# |osld_|dac|6,o_sld|||; selection, fourth entry|5279
osld_:  .long o_sld
# |ostp_|dac|6,o_stp|||; stop execution|5280
ostp_:  .long o_stp
# |ounf_|dac|6,o_unf|||; unexpected failure|5281
ounf_:  .long o_unf
# ||ejc|||||5282
# |opsnb|dac|2,ch_at|||; at|5286
opsnb:  .long ch_at
# ||dac|2,ch_am|||; ampersand|5287
        .long ch_am
# ||dac|2,ch_nm|||; number|5288
        .long ch_nm
# ||dac|2,ch_pc|||; percent|5289
        .long ch_pc
# ||dac|2,ch_nt|||; not|5290
        .long ch_nt
# |opnsu|dac|2,ch_br|||; vertical bar|5294
opnsu:  .long ch_br
# ||dac|2,ch_eq|||; equal|5295
        .long ch_eq
# ||dac|2,ch_nm|||; number|5296
        .long ch_nm
# ||dac|2,ch_pc|||; percent|5297
        .long ch_pc
# ||dac|2,ch_sl|||; slash|5298
        .long ch_sl
# ||dac|2,ch_ex|||; exclamation|5299
        .long ch_ex
# |pfi2a|dac|2,pf_i2|||;|5305
pfi2a:  .long pf_i2
# |pfms1|dac|6,b_scl||||5309
pfms1:  .long b_scl
# ||dac|1,15||||5310
        .long 15
# ||dtc|27,/program profile/||||5311
        .byte 'p','r','o','g','r','a','m',' ','p','r','o','f','i','l','e',0
# |pfms2|dac|6,b_scl||||5312
pfms2:  .long b_scl
# ||dac|1,42||||5313
        .long 42
# ||dtc|27,/stmt    number of     -- execution time --/||||5314
        .byte 's','t','m','t',' ',' ',' ',' ','n','u','m','b','e','r',' ','o','f',' ',' ',' ',' ',' ','-','-',' ','e','x','e','c','u','t','i','o','n',' ','t','i','m','e',' ','-','-',0,0,0,0,0,0
# |pfms3|dac|6,b_scl||||5315
pfms3:  .long b_scl
# ||dac|1,47||||5316
        .long 47
# ||dtc|27,/number  executions  total(msec) per excn(mcsec)/||||5317
        .byte 'n','u','m','b','e','r',' ',' ','e','x','e','c','u','t','i','o','n','s',' ',' ','t','o','t','a','l','(','m','s','e','c',')',' ','p','e','r',' ','e','x','c','n','(','m','c','s','e','c',')',0
# |reav0|drc|17,+0.0|||; 0.0|5327
        .align 8
reav0:  .double 0.0
# |reap1|drc|17,+0.1|||; 0.1|5330
        .align 8
reap1:  .double 0.1
# |reap5|drc|17,+0.5|||; 0.5|5331
        .align 8
reap5:  .double 0.5
# |reav1|drc|17,+1.0|||; 10**0|5333
        .align 8
reav1:  .double 1.0
# |reavt|drc|17,+1.0e+1|||; 10**1|5334
        .align 8
reavt:  .double 1.0e+1
# ||drc|17,+1.0e+2|||; 10**2|5335
        .align 8
        .double 1.0e+2
# ||drc|17,+1.0e+3|||; 10**3|5336
        .align 8
        .double 1.0e+3
# ||drc|17,+1.0e+4|||; 10**4|5337
        .align 8
        .double 1.0e+4
# ||drc|17,+1.0e+5|||; 10**5|5338
        .align 8
        .double 1.0e+5
# ||drc|17,+1.0e+6|||; 10**6|5339
        .align 8
        .double 1.0e+6
# ||drc|17,+1.0e+7|||; 10**7|5340
        .align 8
        .double 1.0e+7
# ||drc|17,+1.0e+8|||; 10**8|5341
        .align 8
        .double 1.0e+8
# ||drc|17,+1.0e+9|||; 10**9|5342
        .align 8
        .double 1.0e+9
# |reatt|drc|17,+1.0e+10|||; 10**10|5343
        .align 8
reatt:  .double 1.0e+10
# ||ejc|||||5345
# |scarr|dac|6,b_scl|||; array|5349
scarr:  .long b_scl
# ||dac|1,5|||;|5350
        .long 5
# ||dtc|27,/array/||||5351
        .byte 'a','r','r','a','y',0,0,0
# |sccod|dac|6,b_scl|||; code|5360
sccod:  .long b_scl
# ||dac|1,4|||;|5361
        .long 4
# ||dtc|27,/code/||||5362
        .byte 'c','o','d','e',0,0,0,0
# |scexp|dac|6,b_scl|||; expression|5364
scexp:  .long b_scl
# ||dac|1,10|||;|5365
        .long 10
# ||dtc|27,/expression/||||5366
        .byte 'e','x','p','r','e','s','s','i','o','n',0,0,0,0,0,0
# |scext|dac|6,b_scl|||; external|5368
scext:  .long b_scl
# ||dac|1,8|||;|5369
        .long 8
# ||dtc|27,/external/||||5370
        .byte 'e','x','t','e','r','n','a','l'
# |scint|dac|6,b_scl|||; integer|5372
scint:  .long b_scl
# ||dac|1,7|||;|5373
        .long 7
# ||dtc|27,/integer/||||5374
        .byte 'i','n','t','e','g','e','r',0
# |scnam|dac|6,b_scl|||; name|5376
scnam:  .long b_scl
# ||dac|1,4|||;|5377
        .long 4
# ||dtc|27,/name/||||5378
        .byte 'n','a','m','e',0,0,0,0
# |scnum|dac|6,b_scl|||; numeric|5380
scnum:  .long b_scl
# ||dac|1,7|||;|5381
        .long 7
# ||dtc|27,/numeric/||||5382
        .byte 'n','u','m','e','r','i','c',0
# |scpat|dac|6,b_scl|||; pattern|5384
scpat:  .long b_scl
# ||dac|1,7|||;|5385
        .long 7
# ||dtc|27,/pattern/||||5386
        .byte 'p','a','t','t','e','r','n',0
# |screa|dac|6,b_scl|||; real|5390
screa:  .long b_scl
# ||dac|1,4|||;|5391
        .long 4
# ||dtc|27,/real/||||5392
        .byte 'r','e','a','l',0,0,0,0
# |scstr|dac|6,b_scl|||; string|5395
scstr:  .long b_scl
# ||dac|1,6|||;|5396
        .long 6
# ||dtc|27,/string/||||5397
        .byte 's','t','r','i','n','g',0,0
# |sctab|dac|6,b_scl|||; table|5399
sctab:  .long b_scl
# ||dac|1,5|||;|5400
        .long 5
# ||dtc|27,/table/||||5401
        .byte 't','a','b','l','e',0,0,0
# |scfil|dac|6,b_scl|||; file (for extended load arguments)|5403
scfil:  .long b_scl
# ||dac|1,4|||;|5404
        .long 4
# ||dtc|27,/file/||||5405
        .byte 'f','i','l','e',0,0,0,0
# ||ejc|||||5407
# |scfrt|dac|6,b_scl|||; freturn|5411
scfrt:  .long b_scl
# ||dac|1,7|||;|5412
        .long 7
# ||dtc|27,/freturn/||||5413
        .byte 'f','r','e','t','u','r','n',0
# |scnrt|dac|6,b_scl|||; nreturn|5415
scnrt:  .long b_scl
# ||dac|1,7|||;|5416
        .long 7
# ||dtc|27,/nreturn/||||5417
        .byte 'n','r','e','t','u','r','n',0
# |scrtn|dac|6,b_scl|||; return|5419
scrtn:  .long b_scl
# ||dac|1,6|||;|5420
        .long 6
# ||dtc|27,/return/||||5421
        .byte 'r','e','t','u','r','n',0,0
# |scnmt|dac|4,scarr|||; arblk	    array|5431
scnmt:  .long scarr
# ||dac|4,sccod|||; cdblk	    code|5432
        .long sccod
# ||dac|4,scexp|||; exblk	    expression|5433
        .long scexp
# ||dac|4,scint|||; icblk	    integer|5434
        .long scint
# ||dac|4,scnam|||; nmblk	    name|5435
        .long scnam
# ||dac|4,scpat|||; p0blk	    pattern|5436
        .long scpat
# ||dac|4,scpat|||; p1blk	    pattern|5437
        .long scpat
# ||dac|4,scpat|||; p2blk	    pattern|5438
        .long scpat
# ||dac|4,screa|||; rcblk	    real|5443
        .long screa
# ||dac|4,scstr|||; scblk	    string|5445
        .long scstr
# ||dac|4,scexp|||; seblk	    expression|5446
        .long scexp
# ||dac|4,sctab|||; tbblk	    table|5447
        .long sctab
# ||dac|4,scarr|||; vcblk	    array|5448
        .long scarr
# ||dac|4,scext|||; xnblk	    external|5449
        .long scext
# ||dac|4,scext|||; xrblk	    external|5450
        .long scext
# ||dac|4,nulls|||; bfblk	    no buffer in this version|5452
        .long nulls
# |scre0|dac|6,b_scl|||;|5461
scre0:  .long b_scl
# ||dac|1,2|||;|5462
        .long 2
# ||dtc|27,/0./||||5463
        .byte '0','.',0,0,0,0,0,0
# ||ejc|||||5465
# |stlim|dic|16,+2147483647|||; default statement limit|5473
stlim:  .long +2147483647
# |stndf|dac|6,o_fun|||; ptr to undefined function err call|5481
stndf:  .long o_fun
# ||dac|1,0|||; dummy fargs count for call circuit|5482
        .long 0
# |stndl|dac|6,l_und|||; code ptr points to undefined lbl|5486
stndl:  .long l_und
# |stndo|dac|6,o_oun|||; ptr to undefined operator err call|5490
stndo:  .long o_oun
# ||dac|1,0|||; dummy fargs count for call circuit|5491
        .long 0
# |stnvr|dac|6,b_vrl|||; vrget|5497
stnvr:  .long b_vrl
# ||dac|6,b_vrs|||; vrsto|5498
        .long b_vrs
# ||dac|4,nulls|||; vrval|5499
        .long nulls
# ||dac|6,b_vrg|||; vrtra|5500
        .long b_vrg
# ||dac|4,stndl|||; vrlbl|5501
        .long stndl
# ||dac|4,stndf|||; vrfnc|5502
        .long stndf
# ||dac|1,0|||; vrnxt|5503
        .long 0
# ||ejc|||||5504
# |stpm1|dac|6,b_scl|||; in statement|5508
stpm1:  .long b_scl
# ||dac|1,12|||;|5509
        .long 12
# ||dtc|27,/in statement/||||5510
        .byte 'i','n',' ','s','t','a','t','e','m','e','n','t',0,0,0,0
# |stpm2|dac|6,b_scl|||;|5512
stpm2:  .long b_scl
# ||dac|1,14|||;|5513
        .long 14
# ||dtc|27,/stmts executed/||||5514
        .byte 's','t','m','t','s',' ','e','x','e','c','u','t','e','d',0,0
# |stpm3|dac|6,b_scl|||;|5516
stpm3:  .long b_scl
# ||dac|1,19|||;|5521
        .long 19
# ||dtc|27,/run time (millisec)/||||5522
        .byte 'r','u','n',' ','t','i','m','e',' ','(','m','i','l','l','i','s','e','c',')',0,0,0,0,0
# |stpm4|dac|6,b_scl|||;|5525
stpm4:  .long b_scl
# ||dac|1,12|||;|5526
        .long 12
# ||dtc|27,_mcsec / stmt_||||5527
        .byte 'm','c','s','e','c',' ','/',' ','s','t','m','t',0,0,0,0
# |stpm5|dac|6,b_scl|||;|5529
stpm5:  .long b_scl
# ||dac|1,13|||;|5530
        .long 13
# ||dtc|27,/regenerations/||||5531
        .byte 'r','e','g','e','n','e','r','a','t','i','o','n','s',0,0,0
# |stpm6|dac|6,b_scl|||; in line|5534
stpm6:  .long b_scl
# ||dac|1,7|||;|5535
        .long 7
# ||dtc|27,/in line/||||5536
        .byte 'i','n',' ','l','i','n','e',0
# |stpm7|dac|6,b_scl|||; in file|5540
stpm7:  .long b_scl
# ||dac|1,7|||;|5541
        .long 7
# ||dtc|27,/in file/||||5542
        .byte 'i','n',' ','f','i','l','e',0
# |strtu|dtc|27,/tu/||||5547
strtu:  .byte 't','u',0,0,0,0,0,0
# |svctb|dac|4,scstr|||; string|5553
svctb:  .long scstr
# ||dac|4,scint|||; integer|5554
        .long scint
# ||dac|4,scnam|||; name|5555
        .long scnam
# ||dac|4,scpat|||; pattern|5556
        .long scpat
# ||dac|4,scarr|||; array|5557
        .long scarr
# ||dac|4,sctab|||; table|5558
        .long sctab
# ||dac|4,scexp|||; expression|5559
        .long scexp
# ||dac|4,sccod|||; code|5560
        .long sccod
# ||dac|4,scnum|||; numeric|5561
        .long scnum
# ||dac|4,screa|||; real|5564
        .long screa
# ||dac|1,0|||; zero marks end of list|5570
        .long 0
# ||ejc|||||5571
# |tmasb|dac|6,b_scl|||; asterisks for trace statement no|5576
tmasb:  .long b_scl
# ||dac|1,13|||;|5577
        .long 13
# ||dtc|27,/************ /||||5578
        .byte '*','*','*','*','*','*','*','*','*','*','*','*',' ',0,0,0
# |tmbeb|dac|6,b_scl|||; blank-equal-blank|5581
tmbeb:  .long b_scl
# ||dac|1,3|||;|5582
        .long 3
# ||dtc|27,/ = /||||5583
        .byte ' ','=',' ',0,0,0,0,0
# |trbev|dac|6,b_trt|||; dummy trblk|5587
trbev:  .long b_trt
# |trbkv|dac|6,b_trt|||; dummy trblk|5591
trbkv:  .long b_trt
# |trxdr|dac|6,o_txr|||; block points to return routine|5595
trxdr:  .long o_txr
# |trxdc|dac|4,trxdr|||; pointer to block|5596
trxdc:  .long trxdr
# ||ejc|||||5597
# |v_eqf|dbc|2,svfpr|||; eq|5605
# getarg svfpr
v_eqf:  .long svfpr
# ||dac|1,2|||;|5606
        .long 2
# ||dtc|27,/eq/||||5607
        .byte 'e','q',0,0,0,0,0,0
# ||dac|6,s_eqf|||;|5608
        .long s_eqf
# ||dac|1,2|||;|5609
        .long 2
# |v_gef|dbc|2,svfpr|||; ge|5611
# getarg svfpr
v_gef:  .long svfpr
# ||dac|1,2|||;|5612
        .long 2
# ||dtc|27,/ge/||||5613
        .byte 'g','e',0,0,0,0,0,0
# ||dac|6,s_gef|||;|5614
        .long s_gef
# ||dac|1,2|||;|5615
        .long 2
# |v_gtf|dbc|2,svfpr|||; gt|5617
# getarg svfpr
v_gtf:  .long svfpr
# ||dac|1,2|||;|5618
        .long 2
# ||dtc|27,/gt/||||5619
        .byte 'g','t',0,0,0,0,0,0
# ||dac|6,s_gtf|||;|5620
        .long s_gtf
# ||dac|1,2|||;|5621
        .long 2
# |v_lef|dbc|2,svfpr|||; le|5623
# getarg svfpr
v_lef:  .long svfpr
# ||dac|1,2|||;|5624
        .long 2
# ||dtc|27,/le/||||5625
        .byte 'l','e',0,0,0,0,0,0
# ||dac|6,s_lef|||;|5626
        .long s_lef
# ||dac|1,2|||;|5627
        .long 2
# |v_lnf|dbc|2,svfnp|||; ln|5630
# getarg svfnp
v_lnf:  .long svfnp
# ||dac|1,2|||;|5631
        .long 2
# ||dtc|27,/ln/||||5632
        .byte 'l','n',0,0,0,0,0,0
# ||dac|6,s_lnf|||;|5633
        .long s_lnf
# ||dac|1,1|||;|5634
        .long 1
# |v_ltf|dbc|2,svfpr|||; lt|5637
# getarg svfpr
v_ltf:  .long svfpr
# ||dac|1,2|||;|5638
        .long 2
# ||dtc|27,/lt/||||5639
        .byte 'l','t',0,0,0,0,0,0
# ||dac|6,s_ltf|||;|5640
        .long s_ltf
# ||dac|1,2|||;|5641
        .long 2
# |v_nef|dbc|2,svfpr|||; ne|5643
# getarg svfpr
v_nef:  .long svfpr
# ||dac|1,2|||;|5644
        .long 2
# ||dtc|27,/ne/||||5645
        .byte 'n','e',0,0,0,0,0,0
# ||dac|6,s_nef|||;|5646
        .long s_nef
# ||dac|1,2|||;|5647
        .long 2
# |v_any|dbc|2,svfnp|||; any|5673
# getarg svfnp
v_any:  .long svfnp
# ||dac|1,3|||;|5674
        .long 3
# ||dtc|27,/any/||||5675
        .byte 'a','n','y',0,0,0,0,0
# ||dac|6,s_any|||;|5676
        .long s_any
# ||dac|1,1|||;|5677
        .long 1
# |v_arb|dbc|2,svkvc|||; arb|5679
# getarg svkvc
v_arb:  .long svkvc
# ||dac|1,3|||;|5680
        .long 3
# ||dtc|27,/arb/||||5681
        .byte 'a','r','b',0,0,0,0,0
# ||dac|2,k_arb|||;|5682
        .long k_arb
# ||dac|4,ndarb|||;|5683
        .long ndarb
# ||ejc|||||5684
# |v_arg|dbc|2,svfnn|||; arg|5688
# getarg svfnn
v_arg:  .long svfnn
# ||dac|1,3|||;|5689
        .long 3
# ||dtc|27,/arg/||||5690
        .byte 'a','r','g',0,0,0,0,0
# ||dac|6,s_arg|||;|5691
        .long s_arg
# ||dac|1,2|||;|5692
        .long 2
# |v_bal|dbc|2,svkvc|||; bal|5694
# getarg svkvc
v_bal:  .long svkvc
# ||dac|1,3|||;|5695
        .long 3
# ||dtc|27,/bal/||||5696
        .byte 'b','a','l',0,0,0,0,0
# ||dac|2,k_bal|||;|5697
        .long k_bal
# ||dac|4,ndbal|||;|5698
        .long ndbal
# |v_cos|dbc|2,svfnp|||; cos|5701
# getarg svfnp
v_cos:  .long svfnp
# ||dac|1,3|||;|5702
        .long 3
# ||dtc|27,/cos/||||5703
        .byte 'c','o','s',0,0,0,0,0
# ||dac|6,s_cos|||;|5704
        .long s_cos
# ||dac|1,1|||;|5705
        .long 1
# |v_end|dbc|2,svlbl|||; end|5708
# getarg svlbl
v_end:  .long svlbl
# ||dac|1,3|||;|5709
        .long 3
# ||dtc|27,/end/||||5710
        .byte 'e','n','d',0,0,0,0,0
# ||dac|6,l_end|||;|5711
        .long l_end
# |v_exp|dbc|2,svfnp|||; exp|5714
# getarg svfnp
v_exp:  .long svfnp
# ||dac|1,3|||;|5715
        .long 3
# ||dtc|27,/exp/||||5716
        .byte 'e','x','p',0,0,0,0,0
# ||dac|6,s_exp|||;|5717
        .long s_exp
# ||dac|1,1|||;|5718
        .long 1
# |v_len|dbc|2,svfnp|||; len|5721
# getarg svfnp
v_len:  .long svfnp
# ||dac|1,3|||;|5722
        .long 3
# ||dtc|27,/len/||||5723
        .byte 'l','e','n',0,0,0,0,0
# ||dac|6,s_len|||;|5724
        .long s_len
# ||dac|1,1|||;|5725
        .long 1
# |v_leq|dbc|2,svfpr|||; leq|5727
# getarg svfpr
v_leq:  .long svfpr
# ||dac|1,3|||;|5728
        .long 3
# ||dtc|27,/leq/||||5729
        .byte 'l','e','q',0,0,0,0,0
# ||dac|6,s_leq|||;|5730
        .long s_leq
# ||dac|1,2|||;|5731
        .long 2
# |v_lge|dbc|2,svfpr|||; lge|5733
# getarg svfpr
v_lge:  .long svfpr
# ||dac|1,3|||;|5734
        .long 3
# ||dtc|27,/lge/||||5735
        .byte 'l','g','e',0,0,0,0,0
# ||dac|6,s_lge|||;|5736
        .long s_lge
# ||dac|1,2|||;|5737
        .long 2
# |v_lgt|dbc|2,svfpr|||; lgt|5739
# getarg svfpr
v_lgt:  .long svfpr
# ||dac|1,3|||;|5740
        .long 3
# ||dtc|27,/lgt/||||5741
        .byte 'l','g','t',0,0,0,0,0
# ||dac|6,s_lgt|||;|5742
        .long s_lgt
# ||dac|1,2|||;|5743
        .long 2
# |v_lle|dbc|2,svfpr|||; lle|5745
# getarg svfpr
v_lle:  .long svfpr
# ||dac|1,3|||;|5746
        .long 3
# ||dtc|27,/lle/||||5747
        .byte 'l','l','e',0,0,0,0,0
# ||dac|6,s_lle|||;|5748
        .long s_lle
# ||dac|1,2|||;|5749
        .long 2
# ||ejc|||||5750
# |v_llt|dbc|2,svfpr|||; llt|5754
# getarg svfpr
v_llt:  .long svfpr
# ||dac|1,3|||;|5755
        .long 3
# ||dtc|27,/llt/||||5756
        .byte 'l','l','t',0,0,0,0,0
# ||dac|6,s_llt|||;|5757
        .long s_llt
# ||dac|1,2|||;|5758
        .long 2
# |v_lne|dbc|2,svfpr|||; lne|5760
# getarg svfpr
v_lne:  .long svfpr
# ||dac|1,3|||;|5761
        .long 3
# ||dtc|27,/lne/||||5762
        .byte 'l','n','e',0,0,0,0,0
# ||dac|6,s_lne|||;|5763
        .long s_lne
# ||dac|1,2|||;|5764
        .long 2
# |v_pos|dbc|2,svfnp|||; pos|5766
# getarg svfnp
v_pos:  .long svfnp
# ||dac|1,3|||;|5767
        .long 3
# ||dtc|27,/pos/||||5768
        .byte 'p','o','s',0,0,0,0,0
# ||dac|6,s_pos|||;|5769
        .long s_pos
# ||dac|1,1|||;|5770
        .long 1
# |v_rem|dbc|2,svkvc|||; rem|5772
# getarg svkvc
v_rem:  .long svkvc
# ||dac|1,3|||;|5773
        .long 3
# ||dtc|27,/rem/||||5774
        .byte 'r','e','m',0,0,0,0,0
# ||dac|2,k_rem|||;|5775
        .long k_rem
# ||dac|4,ndrem|||;|5776
        .long ndrem
# |v_set|dbc|2,svfnn|||; set|5779
# getarg svfnn
v_set:  .long svfnn
# ||dac|1,3|||;|5780
        .long 3
# ||dtc|27,/set/||||5781
        .byte 's','e','t',0,0,0,0,0
# ||dac|6,s_set|||;|5782
        .long s_set
# ||dac|1,3|||;|5783
        .long 3
# |v_sin|dbc|2,svfnp|||; sin|5787
# getarg svfnp
v_sin:  .long svfnp
# ||dac|1,3|||;|5788
        .long 3
# ||dtc|27,/sin/||||5789
        .byte 's','i','n',0,0,0,0,0
# ||dac|6,s_sin|||;|5790
        .long s_sin
# ||dac|1,1|||;|5791
        .long 1
# |v_tab|dbc|2,svfnp|||; tab|5794
# getarg svfnp
v_tab:  .long svfnp
# ||dac|1,3|||;|5795
        .long 3
# ||dtc|27,/tab/||||5796
        .byte 't','a','b',0,0,0,0,0
# ||dac|6,s_tab|||;|5797
        .long s_tab
# ||dac|1,1|||;|5798
        .long 1
# |v_tan|dbc|2,svfnp|||; tan|5801
# getarg svfnp
v_tan:  .long svfnp
# ||dac|1,3|||;|5802
        .long 3
# ||dtc|27,/tan/||||5803
        .byte 't','a','n',0,0,0,0,0
# ||dac|6,s_tan|||;|5804
        .long s_tan
# ||dac|1,1|||;|5805
        .long 1
# |v_atn|dbc|2,svfnp|||; atan|5817
# getarg svfnp
v_atn:  .long svfnp
# ||dac|1,4|||;|5818
        .long 4
# ||dtc|27,/atan/||||5819
        .byte 'a','t','a','n',0,0,0,0
# ||dac|6,s_atn|||;|5820
        .long s_atn
# ||dac|1,1|||;|5821
        .long 1
# |v_cas|dbc|2,svknm|||; case|5825
# getarg svknm
v_cas:  .long svknm
# ||dac|1,4|||;|5826
        .long 4
# ||dtc|27,/case/||||5827
        .byte 'c','a','s','e',0,0,0,0
# ||dac|2,k_cas|||;|5828
        .long k_cas
# |v_chr|dbc|2,svfnp|||; char|5831
# getarg svfnp
v_chr:  .long svfnp
# ||dac|1,4|||;|5832
        .long 4
# ||dtc|27,/char/||||5833
        .byte 'c','h','a','r',0,0,0,0
# ||dac|6,s_chr|||;|5834
        .long s_chr
# ||dac|1,1|||;|5835
        .long 1
# |v_chp|dbc|2,svfnp|||; chop|5839
# getarg svfnp
v_chp:  .long svfnp
# ||dac|1,4|||;|5840
        .long 4
# ||dtc|27,/chop/||||5841
        .byte 'c','h','o','p',0,0,0,0
# ||dac|6,s_chp|||;|5842
        .long s_chp
# ||dac|1,1|||;|5843
        .long 1
# |v_cod|dbc|2,svfnk|||; code|5845
# getarg svfnk
v_cod:  .long svfnk
# ||dac|1,4|||;|5846
        .long 4
# ||dtc|27,/code/||||5847
        .byte 'c','o','d','e',0,0,0,0
# ||dac|2,k_cod|||;|5848
        .long k_cod
# ||dac|6,s_cod|||;|5849
        .long s_cod
# ||dac|1,1|||;|5850
        .long 1
# |v_cop|dbc|2,svfnn|||; copy|5852
# getarg svfnn
v_cop:  .long svfnn
# ||dac|1,4|||;|5853
        .long 4
# ||dtc|27,/copy/||||5854
        .byte 'c','o','p','y',0,0,0,0
# ||dac|6,s_cop|||;|5855
        .long s_cop
# ||dac|1,1|||;|5856
        .long 1
# ||ejc|||||5857
# |v_dat|dbc|2,svfnn|||; data|5861
# getarg svfnn
v_dat:  .long svfnn
# ||dac|1,4|||;|5862
        .long 4
# ||dtc|27,/data/||||5863
        .byte 'd','a','t','a',0,0,0,0
# ||dac|6,s_dat|||;|5864
        .long s_dat
# ||dac|1,1|||;|5865
        .long 1
# |v_dte|dbc|2,svfnn|||; date|5867
# getarg svfnn
v_dte:  .long svfnn
# ||dac|1,4|||;|5868
        .long 4
# ||dtc|27,/date/||||5869
        .byte 'd','a','t','e',0,0,0,0
# ||dac|6,s_dte|||;|5870
        .long s_dte
# ||dac|1,1|||;|5871
        .long 1
# |v_dmp|dbc|2,svfnk|||; dump|5873
# getarg svfnk
v_dmp:  .long svfnk
# ||dac|1,4|||;|5874
        .long 4
# ||dtc|27,/dump/||||5875
        .byte 'd','u','m','p',0,0,0,0
# ||dac|2,k_dmp|||;|5876
        .long k_dmp
# ||dac|6,s_dmp|||;|5877
        .long s_dmp
# ||dac|1,1|||;|5878
        .long 1
# |v_dup|dbc|2,svfnn|||; dupl|5880
# getarg svfnn
v_dup:  .long svfnn
# ||dac|1,4|||;|5881
        .long 4
# ||dtc|27,/dupl/||||5882
        .byte 'd','u','p','l',0,0,0,0
# ||dac|6,s_dup|||;|5883
        .long s_dup
# ||dac|1,2|||;|5884
        .long 2
# |v_evl|dbc|2,svfnn|||; eval|5886
# getarg svfnn
v_evl:  .long svfnn
# ||dac|1,4|||;|5887
        .long 4
# ||dtc|27,/eval/||||5888
        .byte 'e','v','a','l',0,0,0,0
# ||dac|6,s_evl|||;|5889
        .long s_evl
# ||dac|1,1|||;|5890
        .long 1
# |v_ext|dbc|2,svfnn|||; exit|5894
# getarg svfnn
v_ext:  .long svfnn
# ||dac|1,4|||;|5895
        .long 4
# ||dtc|27,/exit/||||5896
        .byte 'e','x','i','t',0,0,0,0
# ||dac|6,s_ext|||;|5897
        .long s_ext
# ||dac|1,2|||;|5898
        .long 2
# |v_fal|dbc|2,svkvc|||; fail|5901
# getarg svkvc
v_fal:  .long svkvc
# ||dac|1,4|||;|5902
        .long 4
# ||dtc|27,/fail/||||5903
        .byte 'f','a','i','l',0,0,0,0
# ||dac|2,k_fal|||;|5904
        .long k_fal
# ||dac|4,ndfal|||;|5905
        .long ndfal
# |v_fil|dbc|2,svknm|||; file|5908
# getarg svknm
v_fil:  .long svknm
# ||dac|1,4|||;|5909
        .long 4
# ||dtc|27,/file/||||5910
        .byte 'f','i','l','e',0,0,0,0
# ||dac|2,k_fil|||;|5911
        .long k_fil
# |v_hst|dbc|2,svfnn|||; host|5914
# getarg svfnn
v_hst:  .long svfnn
# ||dac|1,4|||;|5915
        .long 4
# ||dtc|27,/host/||||5916
        .byte 'h','o','s','t',0,0,0,0
# ||dac|6,s_hst|||;|5917
        .long s_hst
# ||dac|1,5|||;|5918
        .long 5
# ||ejc|||||5919
# |v_itm|dbc|2,svfnf|||; item|5923
# getarg svfnf
v_itm:  .long svfnf
# ||dac|1,4|||;|5924
        .long 4
# ||dtc|27,/item/||||5925
        .byte 'i','t','e','m',0,0,0,0
# ||dac|6,s_itm|||;|5926
        .long s_itm
# ||dac|1,999|||;|5927
        .long 999
# |v_lin|dbc|2,svknm|||; line|5930
# getarg svknm
v_lin:  .long svknm
# ||dac|1,4|||;|5931
        .long 4
# ||dtc|27,/line/||||5932
        .byte 'l','i','n','e',0,0,0,0
# ||dac|2,k_lin|||;|5933
        .long k_lin
# |v_lod|dbc|2,svfnn|||; load|5938
# getarg svfnn
v_lod:  .long svfnn
# ||dac|1,4|||;|5939
        .long 4
# ||dtc|27,/load/||||5940
        .byte 'l','o','a','d',0,0,0,0
# ||dac|6,s_lod|||;|5941
        .long s_lod
# ||dac|1,2|||;|5942
        .long 2
# |v_lpd|dbc|2,svfnp|||; lpad|5945
# getarg svfnp
v_lpd:  .long svfnp
# ||dac|1,4|||;|5946
        .long 4
# ||dtc|27,/lpad/||||5947
        .byte 'l','p','a','d',0,0,0,0
# ||dac|6,s_lpd|||;|5948
        .long s_lpd
# ||dac|1,3|||;|5949
        .long 3
# |v_rpd|dbc|2,svfnp|||; rpad|5951
# getarg svfnp
v_rpd:  .long svfnp
# ||dac|1,4|||;|5952
        .long 4
# ||dtc|27,/rpad/||||5953
        .byte 'r','p','a','d',0,0,0,0
# ||dac|6,s_rpd|||;|5954
        .long s_rpd
# ||dac|1,3|||;|5955
        .long 3
# |v_rps|dbc|2,svfnp|||; rpos|5957
# getarg svfnp
v_rps:  .long svfnp
# ||dac|1,4|||;|5958
        .long 4
# ||dtc|27,/rpos/||||5959
        .byte 'r','p','o','s',0,0,0,0
# ||dac|6,s_rps|||;|5960
        .long s_rps
# ||dac|1,1|||;|5961
        .long 1
# |v_rtb|dbc|2,svfnp|||; rtab|5963
# getarg svfnp
v_rtb:  .long svfnp
# ||dac|1,4|||;|5964
        .long 4
# ||dtc|27,/rtab/||||5965
        .byte 'r','t','a','b',0,0,0,0
# ||dac|6,s_rtb|||;|5966
        .long s_rtb
# ||dac|1,1|||;|5967
        .long 1
# |v_si_|dbc|2,svfnp|||; size|5969
# getarg svfnp
v_si_:  .long svfnp
# ||dac|1,4|||;|5970
        .long 4
# ||dtc|27,/size/||||5971
        .byte 's','i','z','e',0,0,0,0
# ||dac|6,s_si_|||;|5972
        .long s_si_
# ||dac|1,1|||;|5973
        .long 1
# |v_srt|dbc|2,svfnn|||; sort|5978
# getarg svfnn
v_srt:  .long svfnn
# ||dac|1,4|||;|5979
        .long 4
# ||dtc|27,/sort/||||5980
        .byte 's','o','r','t',0,0,0,0
# ||dac|6,s_srt|||;|5981
        .long s_srt
# ||dac|1,2|||;|5982
        .long 2
# |v_spn|dbc|2,svfnp|||; span|5984
# getarg svfnp
v_spn:  .long svfnp
# ||dac|1,4|||;|5985
        .long 4
# ||dtc|27,/span/||||5986
        .byte 's','p','a','n',0,0,0,0
# ||dac|6,s_spn|||;|5987
        .long s_spn
# ||dac|1,1|||;|5988
        .long 1
# ||ejc|||||5989
# |v_sqr|dbc|2,svfnp|||; sqrt|5995
# getarg svfnp
v_sqr:  .long svfnp
# ||dac|1,4|||;|5996
        .long 4
# ||dtc|27,/sqrt/||||5997
        .byte 's','q','r','t',0,0,0,0
# ||dac|6,s_sqr|||;|5998
        .long s_sqr
# ||dac|1,1|||;|5999
        .long 1
# |v_stn|dbc|2,svknm|||; stno|6001
# getarg svknm
v_stn:  .long svknm
# ||dac|1,4|||;|6002
        .long 4
# ||dtc|27,/stno/||||6003
        .byte 's','t','n','o',0,0,0,0
# ||dac|2,k_stn|||;|6004
        .long k_stn
# |v_tim|dbc|2,svfnn|||; time|6006
# getarg svfnn
v_tim:  .long svfnn
# ||dac|1,4|||;|6007
        .long 4
# ||dtc|27,/time/||||6008
        .byte 't','i','m','e',0,0,0,0
# ||dac|6,s_tim|||;|6009
        .long s_tim
# ||dac|1,0|||;|6010
        .long 0
# |v_trm|dbc|2,svfnk|||; trim|6012
# getarg svfnk
v_trm:  .long svfnk
# ||dac|1,4|||;|6013
        .long 4
# ||dtc|27,/trim/||||6014
        .byte 't','r','i','m',0,0,0,0
# ||dac|2,k_trm|||;|6015
        .long k_trm
# ||dac|6,s_trm|||;|6016
        .long s_trm
# ||dac|1,1|||;|6017
        .long 1
# |v_abe|dbc|2,svknm|||; abend|6019
# getarg svknm
v_abe:  .long svknm
# ||dac|1,5|||;|6020
        .long 5
# ||dtc|27,/abend/||||6021
        .byte 'a','b','e','n','d',0,0,0
# ||dac|2,k_abe|||;|6022
        .long k_abe
# |v_abo|dbc|2,svkvl|||; abort|6024
# getarg svkvl
v_abo:  .long svkvl
# ||dac|1,5|||;|6025
        .long 5
# ||dtc|27,/abort/||||6026
        .byte 'a','b','o','r','t',0,0,0
# ||dac|2,k_abo|||;|6027
        .long k_abo
# ||dac|6,l_abo|||;|6028
        .long l_abo
# ||dac|4,ndabo|||;|6029
        .long ndabo
# |v_app|dbc|2,svfnf|||; apply|6031
# getarg svfnf
v_app:  .long svfnf
# ||dac|1,5|||;|6032
        .long 5
# ||dtc|27,/apply/||||6033
        .byte 'a','p','p','l','y',0,0,0
# ||dac|6,s_app|||;|6034
        .long s_app
# ||dac|1,999|||;|6035
        .long 999
# |v_abn|dbc|2,svfnp|||; arbno|6037
# getarg svfnp
v_abn:  .long svfnp
# ||dac|1,5|||;|6038
        .long 5
# ||dtc|27,/arbno/||||6039
        .byte 'a','r','b','n','o',0,0,0
# ||dac|6,s_abn|||;|6040
        .long s_abn
# ||dac|1,1|||;|6041
        .long 1
# |v_arr|dbc|2,svfnn|||; array|6043
# getarg svfnn
v_arr:  .long svfnn
# ||dac|1,5|||;|6044
        .long 5
# ||dtc|27,/array/||||6045
        .byte 'a','r','r','a','y',0,0,0
# ||dac|6,s_arr|||;|6046
        .long s_arr
# ||dac|1,2|||;|6047
        .long 2
# ||ejc|||||6048
# |v_brk|dbc|2,svfnp|||; break|6052
# getarg svfnp
v_brk:  .long svfnp
# ||dac|1,5|||;|6053
        .long 5
# ||dtc|27,/break/||||6054
        .byte 'b','r','e','a','k',0,0,0
# ||dac|6,s_brk|||;|6055
        .long s_brk
# ||dac|1,1|||;|6056
        .long 1
# |v_clr|dbc|2,svfnn|||; clear|6058
# getarg svfnn
v_clr:  .long svfnn
# ||dac|1,5|||;|6059
        .long 5
# ||dtc|27,/clear/||||6060
        .byte 'c','l','e','a','r',0,0,0
# ||dac|6,s_clr|||;|6061
        .long s_clr
# ||dac|1,1|||;|6062
        .long 1
# |v_ejc|dbc|2,svfnn|||; eject|6072
# getarg svfnn
v_ejc:  .long svfnn
# ||dac|1,5|||;|6073
        .long 5
# ||dtc|27,/eject/||||6074
        .byte 'e','j','e','c','t',0,0,0
# ||dac|6,s_ejc|||;|6075
        .long s_ejc
# ||dac|1,1|||;|6076
        .long 1
# |v_fen|dbc|2,svfpk|||; fence|6078
# getarg svfpk
v_fen:  .long svfpk
# ||dac|1,5|||;|6079
        .long 5
# ||dtc|27,/fence/||||6080
        .byte 'f','e','n','c','e',0,0,0
# ||dac|2,k_fen|||;|6081
        .long k_fen
# ||dac|6,s_fnc|||;|6082
        .long s_fnc
# ||dac|1,1|||;|6083
        .long 1
# ||dac|4,ndfen|||;|6084
        .long ndfen
# |v_fld|dbc|2,svfnn|||; field|6086
# getarg svfnn
v_fld:  .long svfnn
# ||dac|1,5|||;|6087
        .long 5
# ||dtc|27,/field/||||6088
        .byte 'f','i','e','l','d',0,0,0
# ||dac|6,s_fld|||;|6089
        .long s_fld
# ||dac|1,2|||;|6090
        .long 2
# |v_idn|dbc|2,svfpr|||; ident|6092
# getarg svfpr
v_idn:  .long svfpr
# ||dac|1,5|||;|6093
        .long 5
# ||dtc|27,/ident/||||6094
        .byte 'i','d','e','n','t',0,0,0
# ||dac|6,s_idn|||;|6095
        .long s_idn
# ||dac|1,2|||;|6096
        .long 2
# |v_inp|dbc|2,svfnk|||; input|6098
# getarg svfnk
v_inp:  .long svfnk
# ||dac|1,5|||;|6099
        .long 5
# ||dtc|27,/input/||||6100
        .byte 'i','n','p','u','t',0,0,0
# ||dac|2,k_inp|||;|6101
        .long k_inp
# ||dac|6,s_inp|||;|6102
        .long s_inp
# ||dac|1,3|||;|6103
        .long 3
# |v_lcs|dbc|2,svkwc|||; lcase|6106
# getarg svkwc
v_lcs:  .long svkwc
# ||dac|1,5|||;|6107
        .long 5
# ||dtc|27,/lcase/||||6108
        .byte 'l','c','a','s','e',0,0,0
# ||dac|2,k_lcs|||;|6109
        .long k_lcs
# |v_loc|dbc|2,svfnn|||; local|6112
# getarg svfnn
v_loc:  .long svfnn
# ||dac|1,5|||;|6113
        .long 5
# ||dtc|27,/local/||||6114
        .byte 'l','o','c','a','l',0,0,0
# ||dac|6,s_loc|||;|6115
        .long s_loc
# ||dac|1,2|||;|6116
        .long 2
# ||ejc|||||6117
# |v_ops|dbc|2,svfnn|||; opsyn|6121
# getarg svfnn
v_ops:  .long svfnn
# ||dac|1,5|||;|6122
        .long 5
# ||dtc|27,/opsyn/||||6123
        .byte 'o','p','s','y','n',0,0,0
# ||dac|6,s_ops|||;|6124
        .long s_ops
# ||dac|1,3|||;|6125
        .long 3
# |v_rmd|dbc|2,svfnp|||; remdr|6127
# getarg svfnp
v_rmd:  .long svfnp
# ||dac|1,5|||;|6128
        .long 5
# ||dtc|27,/remdr/||||6129
        .byte 'r','e','m','d','r',0,0,0
# ||dac|6,s_rmd|||;|6130
        .long s_rmd
# ||dac|1,2|||;|6131
        .long 2
# |v_rsr|dbc|2,svfnn|||; rsort|6135
# getarg svfnn
v_rsr:  .long svfnn
# ||dac|1,5|||;|6136
        .long 5
# ||dtc|27,/rsort/||||6137
        .byte 'r','s','o','r','t',0,0,0
# ||dac|6,s_rsr|||;|6138
        .long s_rsr
# ||dac|1,2|||;|6139
        .long 2
# |v_tbl|dbc|2,svfnn|||; table|6142
# getarg svfnn
v_tbl:  .long svfnn
# ||dac|1,5|||;|6143
        .long 5
# ||dtc|27,/table/||||6144
        .byte 't','a','b','l','e',0,0,0
# ||dac|6,s_tbl|||;|6145
        .long s_tbl
# ||dac|1,3|||;|6146
        .long 3
# |v_tra|dbc|2,svfnk|||; trace|6148
# getarg svfnk
v_tra:  .long svfnk
# ||dac|1,5|||;|6149
        .long 5
# ||dtc|27,/trace/||||6150
        .byte 't','r','a','c','e',0,0,0
# ||dac|2,k_tra|||;|6151
        .long k_tra
# ||dac|6,s_tra|||;|6152
        .long s_tra
# ||dac|1,4|||;|6153
        .long 4
# |v_ucs|dbc|2,svkwc|||; ucase|6156
# getarg svkwc
v_ucs:  .long svkwc
# ||dac|1,5|||;|6157
        .long 5
# ||dtc|27,/ucase/||||6158
        .byte 'u','c','a','s','e',0,0,0
# ||dac|2,k_ucs|||;|6159
        .long k_ucs
# |v_anc|dbc|2,svknm|||; anchor|6162
# getarg svknm
v_anc:  .long svknm
# ||dac|1,6|||;|6163
        .long 6
# ||dtc|27,/anchor/||||6164
        .byte 'a','n','c','h','o','r',0,0
# ||dac|2,k_anc|||;|6165
        .long k_anc
# |v_bkx|dbc|2,svfnp|||; breakx|6176
# getarg svfnp
v_bkx:  .long svfnp
# ||dac|1,6|||;|6177
        .long 6
# ||dtc|27,/breakx/||||6178
        .byte 'b','r','e','a','k','x',0,0
# ||dac|6,s_bkx|||;|6179
        .long s_bkx
# ||dac|1,1|||;|6180
        .long 1
# |v_def|dbc|2,svfnn|||; define|6191
# getarg svfnn
v_def:  .long svfnn
# ||dac|1,6|||;|6192
        .long 6
# ||dtc|27,/define/||||6193
        .byte 'd','e','f','i','n','e',0,0
# ||dac|6,s_def|||;|6194
        .long s_def
# ||dac|1,2|||;|6195
        .long 2
# |v_det|dbc|2,svfnn|||; detach|6197
# getarg svfnn
v_det:  .long svfnn
# ||dac|1,6|||;|6198
        .long 6
# ||dtc|27,/detach/||||6199
        .byte 'd','e','t','a','c','h',0,0
# ||dac|6,s_det|||;|6200
        .long s_det
# ||dac|1,1|||;|6201
        .long 1
# ||ejc|||||6202
# |v_dif|dbc|2,svfpr|||; differ|6206
# getarg svfpr
v_dif:  .long svfpr
# ||dac|1,6|||;|6207
        .long 6
# ||dtc|27,/differ/||||6208
        .byte 'd','i','f','f','e','r',0,0
# ||dac|6,s_dif|||;|6209
        .long s_dif
# ||dac|1,2|||;|6210
        .long 2
# |v_ftr|dbc|2,svknm|||; ftrace|6212
# getarg svknm
v_ftr:  .long svknm
# ||dac|1,6|||;|6213
        .long 6
# ||dtc|27,/ftrace/||||6214
        .byte 'f','t','r','a','c','e',0,0
# ||dac|2,k_ftr|||;|6215
        .long k_ftr
# |v_lst|dbc|2,svknm|||; lastno|6226
# getarg svknm
v_lst:  .long svknm
# ||dac|1,6|||;|6227
        .long 6
# ||dtc|27,/lastno/||||6228
        .byte 'l','a','s','t','n','o',0,0
# ||dac|2,k_lst|||;|6229
        .long k_lst
# |v_nay|dbc|2,svfnp|||; notany|6231
# getarg svfnp
v_nay:  .long svfnp
# ||dac|1,6|||;|6232
        .long 6
# ||dtc|27,/notany/||||6233
        .byte 'n','o','t','a','n','y',0,0
# ||dac|6,s_nay|||;|6234
        .long s_nay
# ||dac|1,1|||;|6235
        .long 1
# |v_oup|dbc|2,svfnk|||; output|6237
# getarg svfnk
v_oup:  .long svfnk
# ||dac|1,6|||;|6238
        .long 6
# ||dtc|27,/output/||||6239
        .byte 'o','u','t','p','u','t',0,0
# ||dac|2,k_oup|||;|6240
        .long k_oup
# ||dac|6,s_oup|||;|6241
        .long s_oup
# ||dac|1,3|||;|6242
        .long 3
# |v_ret|dbc|2,svlbl|||; return|6244
# getarg svlbl
v_ret:  .long svlbl
# ||dac|1,6|||;|6245
        .long 6
# ||dtc|27,/return/||||6246
        .byte 'r','e','t','u','r','n',0,0
# ||dac|6,l_rtn|||;|6247
        .long l_rtn
# |v_rew|dbc|2,svfnn|||; rewind|6249
# getarg svfnn
v_rew:  .long svfnn
# ||dac|1,6|||;|6250
        .long 6
# ||dtc|27,/rewind/||||6251
        .byte 'r','e','w','i','n','d',0,0
# ||dac|6,s_rew|||;|6252
        .long s_rew
# ||dac|1,1|||;|6253
        .long 1
# |v_stt|dbc|2,svfnn|||; stoptr|6255
# getarg svfnn
v_stt:  .long svfnn
# ||dac|1,6|||;|6256
        .long 6
# ||dtc|27,/stoptr/||||6257
        .byte 's','t','o','p','t','r',0,0
# ||dac|6,s_stt|||;|6258
        .long s_stt
# ||dac|1,2|||;|6259
        .long 2
# ||ejc|||||6260
# |v_sub|dbc|2,svfnn|||; substr|6264
# getarg svfnn
v_sub:  .long svfnn
# ||dac|1,6|||;|6265
        .long 6
# ||dtc|27,/substr/||||6266
        .byte 's','u','b','s','t','r',0,0
# ||dac|6,s_sub|||;|6267
        .long s_sub
# ||dac|1,3|||;|6268
        .long 3
# |v_unl|dbc|2,svfnn|||; unload|6270
# getarg svfnn
v_unl:  .long svfnn
# ||dac|1,6|||;|6271
        .long 6
# ||dtc|27,/unload/||||6272
        .byte 'u','n','l','o','a','d',0,0
# ||dac|6,s_unl|||;|6273
        .long s_unl
# ||dac|1,1|||;|6274
        .long 1
# |v_col|dbc|2,svfnn|||; collect|6276
# getarg svfnn
v_col:  .long svfnn
# ||dac|1,7|||;|6277
        .long 7
# ||dtc|27,/collect/||||6278
        .byte 'c','o','l','l','e','c','t',0
# ||dac|6,s_col|||;|6279
        .long s_col
# ||dac|1,1|||;|6280
        .long 1
# |v_com|dbc|2,svknm|||; compare|6283
# getarg svknm
v_com:  .long svknm
# ||dac|1,7|||;|6284
        .long 7
# ||dtc|27,/compare/||||6285
        .byte 'c','o','m','p','a','r','e',0
# ||dac|2,k_com|||;|6286
        .long k_com
# |v_cnv|dbc|2,svfnn|||; convert|6289
# getarg svfnn
v_cnv:  .long svfnn
# ||dac|1,7|||;|6290
        .long 7
# ||dtc|27,/convert/||||6291
        .byte 'c','o','n','v','e','r','t',0
# ||dac|6,s_cnv|||;|6292
        .long s_cnv
# ||dac|1,2|||;|6293
        .long 2
# |v_enf|dbc|2,svfnn|||; endfile|6295
# getarg svfnn
v_enf:  .long svfnn
# ||dac|1,7|||;|6296
        .long 7
# ||dtc|27,/endfile/||||6297
        .byte 'e','n','d','f','i','l','e',0
# ||dac|6,s_enf|||;|6298
        .long s_enf
# ||dac|1,1|||;|6299
        .long 1
# |v_etx|dbc|2,svknm|||; errtext|6301
# getarg svknm
v_etx:  .long svknm
# ||dac|1,7|||;|6302
        .long 7
# ||dtc|27,/errtext/||||6303
        .byte 'e','r','r','t','e','x','t',0
# ||dac|2,k_etx|||;|6304
        .long k_etx
# |v_ert|dbc|2,svknm|||; errtype|6306
# getarg svknm
v_ert:  .long svknm
# ||dac|1,7|||;|6307
        .long 7
# ||dtc|27,/errtype/||||6308
        .byte 'e','r','r','t','y','p','e',0
# ||dac|2,k_ert|||;|6309
        .long k_ert
# |v_frt|dbc|2,svlbl|||; freturn|6311
# getarg svlbl
v_frt:  .long svlbl
# ||dac|1,7|||;|6312
        .long 7
# ||dtc|27,/freturn/||||6313
        .byte 'f','r','e','t','u','r','n',0
# ||dac|6,l_frt|||;|6314
        .long l_frt
# |v_int|dbc|2,svfpr|||; integer|6316
# getarg svfpr
v_int:  .long svfpr
# ||dac|1,7|||;|6317
        .long 7
# ||dtc|27,/integer/||||6318
        .byte 'i','n','t','e','g','e','r',0
# ||dac|6,s_int|||;|6319
        .long s_int
# ||dac|1,1|||;|6320
        .long 1
# |v_nrt|dbc|2,svlbl|||; nreturn|6322
# getarg svlbl
v_nrt:  .long svlbl
# ||dac|1,7|||;|6323
        .long 7
# ||dtc|27,/nreturn/||||6324
        .byte 'n','r','e','t','u','r','n',0
# ||dac|6,l_nrt|||;|6325
        .long l_nrt
# ||ejc|||||6326
# |v_pfl|dbc|2,svknm|||; profile|6333
# getarg svknm
v_pfl:  .long svknm
# ||dac|1,7|||;|6334
        .long 7
# ||dtc|27,/profile/||||6335
        .byte 'p','r','o','f','i','l','e',0
# ||dac|2,k_pfl|||;|6336
        .long k_pfl
# |v_rpl|dbc|2,svfnp|||; replace|6339
# getarg svfnp
v_rpl:  .long svfnp
# ||dac|1,7|||;|6340
        .long 7
# ||dtc|27,/replace/||||6341
        .byte 'r','e','p','l','a','c','e',0
# ||dac|6,s_rpl|||;|6342
        .long s_rpl
# ||dac|1,3|||;|6343
        .long 3
# |v_rvs|dbc|2,svfnp|||; reverse|6345
# getarg svfnp
v_rvs:  .long svfnp
# ||dac|1,7|||;|6346
        .long 7
# ||dtc|27,/reverse/||||6347
        .byte 'r','e','v','e','r','s','e',0
# ||dac|6,s_rvs|||;|6348
        .long s_rvs
# ||dac|1,1|||;|6349
        .long 1
# |v_rtn|dbc|2,svknm|||; rtntype|6351
# getarg svknm
v_rtn:  .long svknm
# ||dac|1,7|||;|6352
        .long 7
# ||dtc|27,/rtntype/||||6353
        .byte 'r','t','n','t','y','p','e',0
# ||dac|2,k_rtn|||;|6354
        .long k_rtn
# |v_stx|dbc|2,svfnn|||; setexit|6356
# getarg svfnn
v_stx:  .long svfnn
# ||dac|1,7|||;|6357
        .long 7
# ||dtc|27,/setexit/||||6358
        .byte 's','e','t','e','x','i','t',0
# ||dac|6,s_stx|||;|6359
        .long s_stx
# ||dac|1,1|||;|6360
        .long 1
# |v_stc|dbc|2,svknm|||; stcount|6362
# getarg svknm
v_stc:  .long svknm
# ||dac|1,7|||;|6363
        .long 7
# ||dtc|27,/stcount/||||6364
        .byte 's','t','c','o','u','n','t',0
# ||dac|2,k_stc|||;|6365
        .long k_stc
# |v_stl|dbc|2,svknm|||; stlimit|6367
# getarg svknm
v_stl:  .long svknm
# ||dac|1,7|||;|6368
        .long 7
# ||dtc|27,/stlimit/||||6369
        .byte 's','t','l','i','m','i','t',0
# ||dac|2,k_stl|||;|6370
        .long k_stl
# |v_suc|dbc|2,svkvc|||; succeed|6372
# getarg svkvc
v_suc:  .long svkvc
# ||dac|1,7|||;|6373
        .long 7
# ||dtc|27,/succeed/||||6374
        .byte 's','u','c','c','e','e','d',0
# ||dac|2,k_suc|||;|6375
        .long k_suc
# ||dac|4,ndsuc|||;|6376
        .long ndsuc
# |v_alp|dbc|2,svkwc|||; alphabet|6378
# getarg svkwc
v_alp:  .long svkwc
# ||dac|1,8|||;|6379
        .long 8
# ||dtc|27,/alphabet/||||6380
        .byte 'a','l','p','h','a','b','e','t'
# ||dac|2,k_alp|||;|6381
        .long k_alp
# |v_cnt|dbc|2,svlbl|||; continue|6383
# getarg svlbl
v_cnt:  .long svlbl
# ||dac|1,8|||;|6384
        .long 8
# ||dtc|27,/continue/||||6385
        .byte 'c','o','n','t','i','n','u','e'
# ||dac|6,l_cnt|||;|6386
        .long l_cnt
# ||ejc|||||6387
# |v_dtp|dbc|2,svfnp|||; datatype|6391
# getarg svfnp
v_dtp:  .long svfnp
# ||dac|1,8|||;|6392
        .long 8
# ||dtc|27,/datatype/||||6393
        .byte 'd','a','t','a','t','y','p','e'
# ||dac|6,s_dtp|||;|6394
        .long s_dtp
# ||dac|1,1|||;|6395
        .long 1
# |v_erl|dbc|2,svknm|||; errlimit|6397
# getarg svknm
v_erl:  .long svknm
# ||dac|1,8|||;|6398
        .long 8
# ||dtc|27,/errlimit/||||6399
        .byte 'e','r','r','l','i','m','i','t'
# ||dac|2,k_erl|||;|6400
        .long k_erl
# |v_fnc|dbc|2,svknm|||; fnclevel|6402
# getarg svknm
v_fnc:  .long svknm
# ||dac|1,8|||;|6403
        .long 8
# ||dtc|27,/fnclevel/||||6404
        .byte 'f','n','c','l','e','v','e','l'
# ||dac|2,k_fnc|||;|6405
        .long k_fnc
# |v_fls|dbc|2,svknm|||; fullscan|6407
# getarg svknm
v_fls:  .long svknm
# ||dac|1,8|||;|6408
        .long 8
# ||dtc|27,/fullscan/||||6409
        .byte 'f','u','l','l','s','c','a','n'
# ||dac|2,k_fls|||;|6410
        .long k_fls
# |v_lfl|dbc|2,svknm|||; lastfile|6413
# getarg svknm
v_lfl:  .long svknm
# ||dac|1,8|||;|6414
        .long 8
# ||dtc|27,/lastfile/||||6415
        .byte 'l','a','s','t','f','i','l','e'
# ||dac|2,k_lfl|||;|6416
        .long k_lfl
# |v_lln|dbc|2,svknm|||; lastline|6420
# getarg svknm
v_lln:  .long svknm
# ||dac|1,8|||;|6421
        .long 8
# ||dtc|27,/lastline/||||6422
        .byte 'l','a','s','t','l','i','n','e'
# ||dac|2,k_lln|||;|6423
        .long k_lln
# |v_mxl|dbc|2,svknm|||; maxlngth|6426
# getarg svknm
v_mxl:  .long svknm
# ||dac|1,8|||;|6427
        .long 8
# ||dtc|27,/maxlngth/||||6428
        .byte 'm','a','x','l','n','g','t','h'
# ||dac|2,k_mxl|||;|6429
        .long k_mxl
# |v_ter|dbc|1,0|||; terminal|6431
# getarg 0
v_ter:  .long 0
# ||dac|1,8|||;|6432
        .long 8
# ||dtc|27,/terminal/||||6433
        .byte 't','e','r','m','i','n','a','l'
# ||dac|1,0|||;|6434
        .long 0
# |v_bsp|dbc|2,svfnn|||; backspace|6437
# getarg svfnn
v_bsp:  .long svfnn
# ||dac|1,9|||;|6438
        .long 9
# ||dtc|27,/backspace/||||6439
        .byte 'b','a','c','k','s','p','a','c','e',0,0,0,0,0,0,0
# ||dac|6,s_bsp|||;|6440
        .long s_bsp
# ||dac|1,1|||;|6441
        .long 1
# |v_pro|dbc|2,svfnn|||; prototype|6444
# getarg svfnn
v_pro:  .long svfnn
# ||dac|1,9|||;|6445
        .long 9
# ||dtc|27,/prototype/||||6446
        .byte 'p','r','o','t','o','t','y','p','e',0,0,0,0,0,0,0
# ||dac|6,s_pro|||;|6447
        .long s_pro
# ||dac|1,1|||;|6448
        .long 1
# |v_scn|dbc|2,svlbl|||; scontinue|6450
# getarg svlbl
v_scn:  .long svlbl
# ||dac|1,9|||;|6451
        .long 9
# ||dtc|27,/scontinue/||||6452
        .byte 's','c','o','n','t','i','n','u','e',0,0,0,0,0,0,0
# ||dac|6,l_scn|||;|6453
        .long l_scn
# ||dbc|1,0|||; dummy entry to end list|6455
# getarg 0
        .long 0
# ||dac|1,10|||; length gt 9 (scontinue)|6456
        .long 10
# ||ejc|||||6457
# |vdmkw|dac|4,v_anc|||; anchor|6462
vdmkw:  .long v_anc
# ||dac|4,v_cas|||; ccase|6464
        .long v_cas
# ||dac|4,v_cod|||; code|6466
        .long v_cod
# ||dac|1,1|||; compare not printed|6471
        .long 1
# ||dac|4,v_dmp|||; dump|6474
        .long v_dmp
# ||dac|4,v_erl|||; errlimit|6475
        .long v_erl
# ||dac|4,v_etx|||; errtext|6476
        .long v_etx
# ||dac|4,v_ert|||; errtype|6477
        .long v_ert
# ||dac|4,v_fil|||; file|6479
        .long v_fil
# ||dac|4,v_fnc|||; fnclevel|6481
        .long v_fnc
# ||dac|4,v_ftr|||; ftrace|6482
        .long v_ftr
# ||dac|4,v_fls|||; fullscan|6483
        .long v_fls
# ||dac|4,v_inp|||; input|6484
        .long v_inp
# ||dac|4,v_lfl|||; lastfile|6486
        .long v_lfl
# ||dac|4,v_lln|||; lastline|6489
        .long v_lln
# ||dac|4,v_lst|||; lastno|6491
        .long v_lst
# ||dac|4,v_lin|||; line|6493
        .long v_lin
# ||dac|4,v_mxl|||; maxlength|6495
        .long v_mxl
# ||dac|4,v_oup|||; output|6496
        .long v_oup
# ||dac|4,v_pfl|||; profile|6499
        .long v_pfl
# ||dac|4,v_rtn|||; rtntype|6501
        .long v_rtn
# ||dac|4,v_stc|||; stcount|6502
        .long v_stc
# ||dac|4,v_stl|||; stlimit|6503
        .long v_stl
# ||dac|4,v_stn|||; stno|6504
        .long v_stn
# ||dac|4,v_tra|||; trace|6505
        .long v_tra
# ||dac|4,v_trm|||; trim|6506
        .long v_trm
# ||dac|1,0|||; end of list|6507
        .long 0
# |vsrch|dac|1,0|||; dummy entry to get proper indexing|6511
vsrch:  .long 0
# ||dac|4,v_eqf|||; start of 1 char variables (none)|6512
        .long v_eqf
# ||dac|4,v_eqf|||; start of 2 char variables|6513
        .long v_eqf
# ||dac|4,v_any|||; start of 3 char variables|6514
        .long v_any
# ||dac|4,v_atn|||; start of 4 char variables|6516
        .long v_atn
# ||dac|4,v_abe|||; start of 5 char variables|6524
        .long v_abe
# ||dac|4,v_anc|||; start of 6 char variables|6525
        .long v_anc
# ||dac|4,v_col|||; start of 7 char variables|6526
        .long v_col
# ||dac|4,v_alp|||; start of 8 char variables|6527
        .long v_alp
# ||dac|4,v_bsp|||; start of 9 char variables|6529
        .long v_bsp
# |c_yyy|dac|1,0|||; last location in constant section|6536
c_yyy:  .long 0
# ||ttl|27,s p i t b o l -- working storage section||||6537
# ||sec||||; start of working storage section|6583
        .global esec03
esec03:
        .data
        .global sec04
sec04:
# ||ejc|||||6584
# |cmlab|dac|6,b_scl|||; string used to check label legality|6588
cmlab:  .long b_scl
# ||dac|1,2|||;|6589
        .long 2
# ||dtc|27,/  /||||6590
        .byte ' ',' ',0,0,0,0,0,0
# |w_aaa|dac|1,0|||;|6594
w_aaa:  .long 0
# |actrm|dac|1,0|||; trim indicator|6598
actrm:  .long 0
# |aldyn|dac|1,0|||; amount of dynamic store|6602
aldyn:  .long 0
# |allia|dic|16,+0|||; dump ia|6603
allia:  .long +0
# |allsv|dac|1,0|||; save wb in alloc|6604
allsv:  .long 0
# |alsta|dac|1,0|||; save wa in alost|6608
alsta:  .long 0
# |arcdm|dac|1,0|||; count dimensions|6612
arcdm:  .long 0
# |arnel|dic|16,+0|||; count elements|6613
arnel:  .long +0
# |arptr|dac|1,0|||; offset ptr into arblk|6614
arptr:  .long 0
# |arsvl|dic|16,+0|||; save integer low bound|6615
arsvl:  .long +0
# ||ejc|||||6616
# |arfsi|dic|16,+0|||; save current evolving subscript|6620
arfsi:  .long +0
# |arfxs|dac|1,0|||; save base stack pointer|6621
arfxs:  .long 0
# |befof|dac|1,0|||; save offset ptr into efblk|6625
befof:  .long 0
# |bpfpf|dac|1,0|||; save pfblk pointer|6629
bpfpf:  .long 0
# |bpfsv|dac|1,0|||; save old function value|6630
bpfsv:  .long 0
# |bpfxt|dac|1,0|||; pointer to stacked arguments|6631
bpfxt:  .long 0
# |clsvi|dic|16,+0|||; save integer argument|6635
clsvi:  .long +0
# |cnscc|dac|1,0|||; pointer to control card string|6639
cnscc:  .long 0
# |cnswc|dac|1,0|||; word count|6640
cnswc:  .long 0
# |cnr_t|dac|1,0|||; pointer to r_ttl or r_stl|6641
cnr_t:  .long 0
# |cnvtp|dac|1,0|||; save ptr into scvtb|6645
cnvtp:  .long 0
# |datdv|dac|1,0|||; save vrblk ptr for datatype name|6649
datdv:  .long 0
# |datxs|dac|1,0|||; save initial stack pointer|6650
datxs:  .long 0
# |deflb|dac|1,0|||; save vrblk ptr for label|6654
deflb:  .long 0
# |defna|dac|1,0|||; count function arguments|6655
defna:  .long 0
# |defvr|dac|1,0|||; save vrblk ptr for function name|6656
defvr:  .long 0
# |defxs|dac|1,0|||; save initial stack pointer|6657
defxs:  .long 0
# |dmarg|dac|1,0|||; dump argument|6661
dmarg:  .long 0
# |dmpsa|dac|1,0|||; preserve wa over prtvl call|6662
dmpsa:  .long 0
# |dmpsb|dac|1,0|||; preserve wb over syscm call|6664
dmpsb:  .long 0
# |dmpsv|dac|1,0|||; general scratch save|6666
dmpsv:  .long 0
# |dmvch|dac|1,0|||; chain pointer for variable blocks|6667
dmvch:  .long 0
# |dmpch|dac|1,0|||; save sorted vrblk chain pointer|6668
dmpch:  .long 0
# |dmpkb|dac|1,0|||; dummy kvblk for use in dumpr|6669
dmpkb:  .long 0
# |dmpkt|dac|1,0|||; kvvar trblk ptr (must follow dmpkb)|6670
dmpkt:  .long 0
# |dmpkn|dac|1,0|||; keyword number (must follow dmpkt)|6671
dmpkn:  .long 0
# |dtcnb|dac|1,0|||; name base|6675
dtcnb:  .long 0
# |dtcnm|dac|1,0|||; name ptr|6676
dtcnm:  .long 0
# |dupsi|dic|16,+0|||; store integer string length|6680
dupsi:  .long +0
# |enfch|dac|1,0|||; for iochn chain head|6684
enfch:  .long 0
# ||ejc|||||6685
# |ertwa|dac|1,0|||; save wa|6689
ertwa:  .long 0
# |ertwb|dac|1,0|||; save wb|6690
ertwb:  .long 0
# |evlin|dac|1,0|||; dummy pattern block pcode|6694
evlin:  .long 0
# |evlis|dac|1,0|||; then node (must follow evlin)|6695
evlis:  .long 0
# |evliv|dac|1,0|||; value of parm1 (must follow evlis)|6696
evliv:  .long 0
# |evlio|dac|1,0|||; ptr to original node|6697
evlio:  .long 0
# |evlif|dac|1,0|||; flag for simple/complex argument|6698
evlif:  .long 0
# |expsv|dac|1,0|||; save op dope vector pointer|6702
expsv:  .long 0
# |gbcfl|dac|1,0|||; garbage collector active flag|6706
gbcfl:  .long 0
# |gbclm|dac|1,0|||; pointer to last move block (pass 3)|6707
gbclm:  .long 0
# |gbcnm|dac|1,0|||; dummy first move block|6708
gbcnm:  .long 0
# |gbcns|dac|1,0|||; rest of dummy block (follows gbcnm)|6709
gbcns:  .long 0
# |gbcia|dic|16,+0|||; dump ia|6715
gbcia:  .long +0
# |gbcsd|dac|1,0|||; first address beyond sediment|6716
gbcsd:  .long 0
# |gbcsf|dac|1,0|||; free space within sediment|6717
gbcsf:  .long 0
# |gbsva|dac|1,0|||; save wa|6719
gbsva:  .long 0
# |gbsvb|dac|1,0|||; save wb|6720
gbsvb:  .long 0
# |gbsvc|dac|1,0|||; save wc|6721
gbsvc:  .long 0
# |gnvhe|dac|1,0|||; ptr to end of hash chain|6725
gnvhe:  .long 0
# |gnvnw|dac|1,0|||; number of words in string name|6726
gnvnw:  .long 0
# |gnvsa|dac|1,0|||; save wa|6727
gnvsa:  .long 0
# |gnvsb|dac|1,0|||; save wb|6728
gnvsb:  .long 0
# |gnvsp|dac|1,0|||; pointer into vsrch table|6729
gnvsp:  .long 0
# |gnvst|dac|1,0|||; pointer to chars of string|6730
gnvst:  .long 0
# |gtawa|dac|1,0|||; save wa|6734
gtawa:  .long 0
# |gtina|dac|1,0|||; save wa|6738
gtina:  .long 0
# |gtinb|dac|1,0|||; save wb|6739
gtinb:  .long 0
# ||ejc|||||6740
# |gtnnf|dac|1,0|||; zero/nonzero for result +/-|6744
gtnnf:  .long 0
# |gtnsi|dic|16,+0|||; general integer save|6745
gtnsi:  .long +0
# |gtndf|dac|1,0|||; 0/1 for dec point so far no/yes|6748
gtndf:  .long 0
# |gtnes|dac|1,0|||; zero/nonzero exponent +/-|6749
gtnes:  .long 0
# |gtnex|dic|16,+0|||; real exponent|6750
gtnex:  .long +0
# |gtnsc|dac|1,0|||; scale (places after point)|6751
gtnsc:  .long 0
# |gtnsr|drc|17,+0.0|||; general real save|6752
        .align 8
gtnsr:  .double 0.0
# |gtnrd|dac|1,0|||; flag for ok real number|6753
gtnrd:  .long 0
# |gtpsb|dac|1,0|||; save wb|6758
gtpsb:  .long 0
# |gtssf|dac|1,0|||; 0/1 for result +/-|6762
gtssf:  .long 0
# |gtsvc|dac|1,0|||; save wc|6763
gtsvc:  .long 0
# |gtsvb|dac|1,0|||; save wb|6764
gtsvb:  .long 0
# |gtses|dac|1,0|||; char + or - for exponent +/-|6769
gtses:  .long 0
# |gtsrs|drc|17,+0.0|||; general real save|6770
        .align 8
gtsrs:  .double 0.0
# |gtvrc|dac|1,0|||; save wc|6776
gtvrc:  .long 0
# |ioptt|dac|1,0|||; type of association|6791
ioptt:  .long 0
# |lodfn|dac|1,0|||; pointer to vrblk for func name|6797
lodfn:  .long 0
# |lodna|dac|1,0|||; count number of arguments|6798
lodna:  .long 0
# |mxint|dac|1,0|||;|6804
mxint:  .long 0
# |pfsvw|dac|1,0|||; to save a w-reg|6810
pfsvw:  .long 0
# |prnsi|dic|16,+0|||; scratch integer loc|6815
prnsi:  .long +0
# |prsna|dac|1,0|||; save wa|6819
prsna:  .long 0
# |prsva|dac|1,0|||; save wa|6823
prsva:  .long 0
# |prsvb|dac|1,0|||; save wb|6824
prsvb:  .long 0
# |prsvc|dac|1,0|||; save char counter|6825
prsvc:  .long 0
# |prtsa|dac|1,0|||; save wa|6829
prtsa:  .long 0
# |prtsb|dac|1,0|||; save wb|6830
prtsb:  .long 0
# |prvsi|dac|1,0|||; save idval|6834
prvsi:  .long 0
# |psave|dac|1,0|||; temporary save for current node ptr|6838
psave:  .long 0
# |psavc|dac|1,0|||; save cursor in p_spn, p_str|6839
psavc:  .long 0
# |rlals|dac|1,0|||; ptr to list of bounds and adjusts|6844
rlals:  .long 0
# |rldcd|dac|1,0|||; save code adjustment|6848
rldcd:  .long 0
# |rldst|dac|1,0|||; save static adjustment|6849
rldst:  .long 0
# |rldls|dac|1,0|||; save list pointer|6850
rldls:  .long 0
# |rtnbp|dac|1,0|||; to save a block pointer|6855
rtnbp:  .long 0
# |rtnfv|dac|1,0|||; new function value (result)|6856
rtnfv:  .long 0
# |rtnsv|dac|1,0|||; old function value (saved value)|6857
rtnsv:  .long 0
# |sbssv|dac|1,0|||; save third argument|6861
sbssv:  .long 0
# |scnsa|dac|1,0|||; save wa|6865
scnsa:  .long 0
# |scnsb|dac|1,0|||; save wb|6866
scnsb:  .long 0
# |scnsc|dac|1,0|||; save wc|6867
scnsc:  .long 0
# |scnof|dac|1,0|||; save offset|6868
scnof:  .long 0
# ||ejc|||||6871
# |srtdf|dac|1,0|||; datatype field name|6875
srtdf:  .long 0
# |srtfd|dac|1,0|||; found dfblk address|6876
srtfd:  .long 0
# |srtff|dac|1,0|||; found field name|6877
srtff:  .long 0
# |srtfo|dac|1,0|||; offset to field name|6878
srtfo:  .long 0
# |srtnr|dac|1,0|||; number of rows|6879
srtnr:  .long 0
# |srtof|dac|1,0|||; offset within row to sort key|6880
srtof:  .long 0
# |srtrt|dac|1,0|||; root offset|6881
srtrt:  .long 0
# |srts1|dac|1,0|||; save offset 1|6882
srts1:  .long 0
# |srts2|dac|1,0|||; save offset 2|6883
srts2:  .long 0
# |srtsc|dac|1,0|||; save wc|6884
srtsc:  .long 0
# |srtsf|dac|1,0|||; sort array first row offset|6885
srtsf:  .long 0
# |srtsn|dac|1,0|||; save n|6886
srtsn:  .long 0
# |srtso|dac|1,0|||; offset to a(0)|6887
srtso:  .long 0
# |srtsr|dac|1,0|||; 0, non-zero for sort, rsort|6888
srtsr:  .long 0
# |srtst|dac|1,0|||; stride from one row to next|6889
srtst:  .long 0
# |srtwc|dac|1,0|||; dump wc|6890
srtwc:  .long 0
# |stpsi|dic|16,+0|||; save value of stcount|6895
stpsi:  .long +0
# |stpti|dic|16,+0|||; save time elapsed|6896
stpti:  .long +0
# |tfnsi|dic|16,+0|||; number of headers|6900
tfnsi:  .long +0
# |xscrt|dac|1,0|||; save return code|6904
xscrt:  .long 0
# |xscwb|dac|1,0|||; save register wb|6905
xscwb:  .long 0
# |g_aaa|dac|1,0|||;|6909
g_aaa:  .long 0
# |alfsf|dic|16,+0|||; factor in free store pcntage check|6913
alfsf:  .long +0
# |cmerc|dac|1,0|||; count of initial compile errors|6917
cmerc:  .long 0
# |cmpln|dac|1,0|||; line number of first line of stmt|6918
cmpln:  .long 0
# |cmpxs|dac|1,0|||; save stack ptr in case of errors|6919
cmpxs:  .long 0
# |cmpsn|dac|1,1|||; number of next statement to compile|6920
cmpsn:  .long 1
# |cnsil|dac|1,0|||; save scnil during include process.|6925
cnsil:  .long 0
# |cnind|dac|1,0|||; current include file nest level|6926
cnind:  .long 0
# |cnspt|dac|1,0|||; save scnpt during include process.|6927
cnspt:  .long 0
# |cnttl|dac|1,0|||; flag for -title, -stitl|6929
cnttl:  .long 0
# |cpsts|dac|1,0|||; suppress comp. stats if non zero|6933
cpsts:  .long 0
# |cswdb|dac|1,0|||; 0/1 for -single/-double|6937
cswdb:  .long 0
# |cswer|dac|1,0|||; 0/1 for -errors/-noerrors|6938
cswer:  .long 0
# |cswex|dac|1,0|||; 0/1 for -execute/-noexecute|6939
cswex:  .long 0
# |cswfl|dac|1,1|||; 0/1 for -nofail/-fail|6940
cswfl:  .long 1
# |cswin|dac|2,iniln|||; xxx for -inxxx|6941
cswin:  .long iniln
# |cswls|dac|1,1|||; 0/1 for -nolist/-list|6942
cswls:  .long 1
# |cswno|dac|1,0|||; 0/1 for -optimise/-noopt|6943
cswno:  .long 0
# |cswpr|dac|1,0|||; 0/1 for -noprint/-print|6944
cswpr:  .long 0
# |ctmsk|dbc|1,0|||; last bit position used in r_ctp|6948
# getarg 0
ctmsk:  .long 0
# |curid|dac|1,0|||; current id value|6949
curid:  .long 0
# ||ejc|||||6950
# |cwcof|dac|1,0|||; next word offset in current ccblk|6954
cwcof:  .long 0
# |dnams|dac|1,0|||; size of sediment in baus|6959
dnams:  .long 0
# |erich|dac|1,0|||; copy error reports to int.chan if 1|6964
erich:  .long 0
# |erlst|dac|1,0|||; for listr when errors go to int.ch.|6965
erlst:  .long 0
# |errft|dac|1,0|||; fatal error flag|6966
errft:  .long 0
# |errsp|dac|1,0|||; error suppression flag|6967
errsp:  .long 0
# |exsts|dac|1,0|||; suppress exec stats if set|6971
exsts:  .long 0
# |flprt|dac|1,0|||; location of fail offset for return|6975
flprt:  .long 0
# |flptr|dac|1,0|||; location of failure offset on stack|6976
flptr:  .long 0
# |gbsed|dic|16,+0|||; factor in sediment pcntage check|6981
gbsed:  .long +0
# |gbcnt|dac|1,0|||; count of garbage collections|6983
gbcnt:  .long 0
# |gtcef|dac|1,0|||; save fail ptr in case of error|6987
gtcef:  .long 0
# |gtsrn|drc|17,+0.0|||; rounding factor 0.5*10**-cfp_s|6995
        .align 8
gtsrn:  .double 0.0
# |gtssc|drc|17,+0.0|||; scaling value 10**cfp_s|6996
        .align 8
gtssc:  .double 0.0
# |gtswk|dac|1,0|||; ptr to work area for gtstg|6999
gtswk:  .long 0
# |headp|dac|1,0|||; header printed flag|7003
headp:  .long 0
# |hshnb|dic|16,+0|||; number of hash buckets|7007
hshnb:  .long +0
# |initr|dac|1,0|||; save terminal flag|7011
initr:  .long 0
# ||ejc|||||7012
# |kvabe|dac|1,0|||; abend|7018
kvabe:  .long 0
# |kvanc|dac|1,0|||; anchor|7019
kvanc:  .long 0
# |kvcas|dac|1,0|||; case|7021
kvcas:  .long 0
# |kvcod|dac|1,0|||; code|7023
kvcod:  .long 0
# |kvcom|dac|1,0|||; compare|7025
kvcom:  .long 0
# |kvdmp|dac|1,0|||; dump|7027
kvdmp:  .long 0
# |kverl|dac|1,0|||; errlimit|7028
kverl:  .long 0
# |kvert|dac|1,0|||; errtype|7029
kvert:  .long 0
# |kvftr|dac|1,0|||; ftrace|7030
kvftr:  .long 0
# |kvfls|dac|1,1|||; fullscan|7031
kvfls:  .long 1
# |kvinp|dac|1,1|||; input|7032
kvinp:  .long 1
# |kvmxl|dac|1,5000|||; maxlength|7033
kvmxl:  .long 5000
# |kvoup|dac|1,1|||; output|7034
kvoup:  .long 1
# |kvpfl|dac|1,0|||; profile|7037
kvpfl:  .long 0
# |kvtra|dac|1,0|||; trace|7039
kvtra:  .long 0
# |kvtrm|dac|1,0|||; trim|7040
kvtrm:  .long 0
# |kvfnc|dac|1,0|||; fnclevel|7041
kvfnc:  .long 0
# |kvlst|dac|1,0|||; lastno|7042
kvlst:  .long 0
# |kvlln|dac|1,0|||; lastline|7044
kvlln:  .long 0
# |kvlin|dac|1,0|||; line|7045
kvlin:  .long 0
# |kvstn|dac|1,0|||; stno|7047
kvstn:  .long 0
# |kvalp|dac|1,0|||; alphabet|7051
kvalp:  .long 0
# |kvrtn|dac|4,nulls|||; rtntype (scblk pointer)|7052
kvrtn:  .long nulls
# |kvstl|dic|16,+2147483647|||; stlimit|7058
kvstl:  .long +2147483647
# |kvstc|dic|16,+2147483647|||; stcount (counts down from stlimit)|7059
kvstc:  .long +2147483647
# |lstid|dac|1,0|||; include depth of current image|7069
lstid:  .long 0
# |lstlc|dac|1,0|||; count lines on source list page|7071
lstlc:  .long 0
# |lstnp|dac|1,0|||; max number of lines on page|7072
lstnp:  .long 0
# |lstpf|dac|1,1|||; set nonzero if current image listed|7073
lstpf:  .long 1
# |lstpg|dac|1,0|||; current source list page number|7074
lstpg:  .long 0
# |lstpo|dac|1,0|||; offset to   page nnn	 message|7075
lstpo:  .long 0
# |lstsn|dac|1,0|||; remember last stmnum listed|7076
lstsn:  .long 0
# |mxlen|dac|1,0|||; initialised by sysmx call|7080
mxlen:  .long 0
# |noxeq|dac|1,0|||; set non-zero to inhibit execution|7084
noxeq:  .long 0
# |pfdmp|dac|1,0|||; set non-0 if &profile set non-0|7090
pfdmp:  .long 0
# |pffnc|dac|1,0|||; set non-0 if funct just entered|7091
pffnc:  .long 0
# |pfstm|dic|16,+0|||; to store starting time of stmt|7092
pfstm:  .long +0
# |pfetm|dic|16,+0|||; to store ending time of stmt|7093
pfetm:  .long +0
# |pfnte|dac|1,0|||; nr of table entries|7094
pfnte:  .long 0
# |pfste|dic|16,+0|||; gets int rep of table entry size|7095
pfste:  .long +0
# ||ejc|||||7098
# |pmdfl|dac|1,0|||; pattern assignment flag|7102
pmdfl:  .long 0
# |pmhbs|dac|1,0|||; history stack base pointer|7103
pmhbs:  .long 0
# |pmssl|dac|1,0|||; length of subject string in chars|7104
pmssl:  .long 0
# |polcs|dac|1,1|||; poll interval start value|7109
polcs:  .long 1
# |polct|dac|1,1|||; poll interval counter|7110
polct:  .long 1
# |prich|dac|1,0|||; printer on interactive channel|7115
prich:  .long 0
# |prstd|dac|1,0|||; tested by prtpg|7116
prstd:  .long 0
# |prsto|dac|1,0|||; standard listing option flag|7117
prsto:  .long 0
# |prbuf|dac|1,0|||; ptr to print bfr in static|7121
prbuf:  .long 0
# |precl|dac|1,0|||; extended/compact listing flag|7122
precl:  .long 0
# |prlen|dac|1,0|||; length of print buffer in chars|7123
prlen:  .long 0
# |prlnw|dac|1,0|||; length of print buffer in words|7124
prlnw:  .long 0
# |profs|dac|1,0|||; offset to next location in prbuf|7125
profs:  .long 0
# |prtef|dac|1,0|||; endfile flag|7126
prtef:  .long 0
# ||ejc|||||7127
# |rdcln|dac|1,0|||; current statement line number|7131
rdcln:  .long 0
# |rdnln|dac|1,0|||; next statement line number|7132
rdnln:  .long 0
# |rsmem|dac|1,0|||; reserve memory|7136
rsmem:  .long 0
# |stmcs|dac|1,1|||; counter startup value|7140
stmcs:  .long 1
# |stmct|dac|1,1|||; counter active value|7141
stmct:  .long 1
# |a_aaa|dac|1,0|||; start of adjustable values|7163
a_aaa:  .long 0
# |cmpss|dac|1,0|||; save subroutine stack ptr|7164
cmpss:  .long 0
# |dnamb|dac|1,0|||; start of dynamic area|7165
dnamb:  .long 0
# |dnamp|dac|1,0|||; next available loc in dynamic area|7166
dnamp:  .long 0
# |dname|dac|1,0|||; end of available dynamic area|7167
dname:  .long 0
# |hshtb|dac|1,0|||; pointer to start of vrblk hash tabl|7168
hshtb:  .long 0
# |hshte|dac|1,0|||; pointer past end of vrblk hash tabl|7169
hshte:  .long 0
# |iniss|dac|1,0|||; save subroutine stack ptr|7170
iniss:  .long 0
# |pftbl|dac|1,0|||; gets adrs of (imag) table base|7171
pftbl:  .long 0
# |prnmv|dac|1,0|||; vrblk ptr from last name search|7172
prnmv:  .long 0
# |statb|dac|1,0|||; start of static area|7173
statb:  .long 0
# |state|dac|1,0|||; end of static area|7174
state:  .long 0
# |stxvr|dac|4,nulls|||; vrblk pointer or null|7175
stxvr:  .long nulls
# |r_aaa|dac|1,0|||; start of relocatable values|7184
r_aaa:  .long 0
# |r_arf|dac|1,0|||; array block pointer for arref|7185
r_arf:  .long 0
# |r_ccb|dac|1,0|||; ptr to ccblk being built (cdwrd)|7186
r_ccb:  .long 0
# |r_cim|dac|1,0|||; ptr to current compiler input str|7187
r_cim:  .long 0
# |r_cmp|dac|1,0|||; copy of r_cim used in cmpil|7188
r_cmp:  .long 0
# |r_cni|dac|1,0|||; ptr to next compiler input string|7189
r_cni:  .long 0
# |r_cnt|dac|1,0|||; cdblk pointer for setexit continue|7190
r_cnt:  .long 0
# |r_cod|dac|1,0|||; pointer to current cdblk or exblk|7191
r_cod:  .long 0
# |r_ctp|dac|1,0|||; ptr to current ctblk for patst|7192
r_ctp:  .long 0
# |r_cts|dac|1,0|||; ptr to last string scanned by patst|7193
r_cts:  .long 0
# |r_ert|dac|1,0|||; trblk pointer for errtype trace|7194
r_ert:  .long 0
# |r_etx|dac|4,nulls|||; pointer to errtext string|7195
r_etx:  .long nulls
# |r_exs|dac|1,0|||; = save xl in expdm|7196
r_exs:  .long 0
# |r_fcb|dac|1,0|||; fcblk chain head|7197
r_fcb:  .long 0
# |r_fnc|dac|1,0|||; trblk pointer for fnclevel trace|7198
r_fnc:  .long 0
# |r_gtc|dac|1,0|||; keep code ptr for gtcod,gtexp|7199
r_gtc:  .long 0
# |r_ici|dac|1,0|||; saved r_cim during include process.|7201
r_ici:  .long 0
# |r_ifa|dac|1,0|||; array of file names by incl. depth|7203
r_ifa:  .long 0
# |r_ifl|dac|1,0|||; array of line nums by include depth|7204
r_ifl:  .long 0
# |r_ifn|dac|1,0|||; last include file name|7206
r_ifn:  .long 0
# |r_inc|dac|1,0|||; table of include file names seen|7207
r_inc:  .long 0
# |r_io1|dac|1,0|||; file arg1 for ioput|7209
r_io1:  .long 0
# |r_io2|dac|1,0|||; file arg2 for ioput|7210
r_io2:  .long 0
# |r_iof|dac|1,0|||; fcblk ptr or 0|7211
r_iof:  .long 0
# |r_ion|dac|1,0|||; name base ptr|7212
r_ion:  .long 0
# |r_iop|dac|1,0|||; predecessor block ptr for ioput|7213
r_iop:  .long 0
# |r_iot|dac|1,0|||; trblk ptr for ioput|7214
r_iot:  .long 0
# |r_pms|dac|1,0|||; subject string ptr in pattern match|7219
r_pms:  .long 0
# |r_ra2|dac|1,0|||; replace second argument last time|7220
r_ra2:  .long 0
# |r_ra3|dac|1,0|||; replace third argument last time|7221
r_ra3:  .long 0
# |r_rpt|dac|1,0|||; ptr to ctblk replace table last usd|7222
r_rpt:  .long 0
# |r_scp|dac|1,0|||; save pointer from last scane call|7223
r_scp:  .long 0
# |r_sfc|dac|4,nulls|||; current source file name|7225
r_sfc:  .long nulls
# |r_sfn|dac|1,0|||; ptr to source file name table|7226
r_sfn:  .long 0
# |r_sxl|dac|1,0|||; preserve xl in sortc|7228
r_sxl:  .long 0
# |r_sxr|dac|1,0|||; preserve xr in sorta/sortc|7229
r_sxr:  .long 0
# |r_stc|dac|1,0|||; trblk pointer for stcount trace|7230
r_stc:  .long 0
# |r_stl|dac|1,0|||; source listing sub-title|7231
r_stl:  .long 0
# |r_sxc|dac|1,0|||; code (cdblk) ptr for setexit trap|7232
r_sxc:  .long 0
# |r_ttl|dac|4,nulls|||; source listing title|7233
r_ttl:  .long nulls
# |r_xsc|dac|1,0|||; string pointer for xscan|7234
r_xsc:  .long 0
# ||ejc|||||7235
# |r_uba|dac|4,stndo|||; binary at|7240
r_uba:  .long stndo
# |r_ubm|dac|4,stndo|||; binary ampersand|7241
r_ubm:  .long stndo
# |r_ubn|dac|4,stndo|||; binary number sign|7242
r_ubn:  .long stndo
# |r_ubp|dac|4,stndo|||; binary percent|7243
r_ubp:  .long stndo
# |r_ubt|dac|4,stndo|||; binary not|7244
r_ubt:  .long stndo
# |r_uub|dac|4,stndo|||; unary vertical bar|7245
r_uub:  .long stndo
# |r_uue|dac|4,stndo|||; unary equal|7246
r_uue:  .long stndo
# |r_uun|dac|4,stndo|||; unary number sign|7247
r_uun:  .long stndo
# |r_uup|dac|4,stndo|||; unary percent|7248
r_uup:  .long stndo
# |r_uus|dac|4,stndo|||; unary slash|7249
r_uus:  .long stndo
# |r_uux|dac|4,stndo|||; unary exclamation|7250
r_uux:  .long stndo
# |r_yyy|dac|1,0|||; last relocatable location|7251
r_yyy:  .long 0
# |scnbl|dac|1,0|||; set non-zero if scanned past blanks|7255
scnbl:  .long 0
# |scncc|dac|1,0|||; non-zero to scan control card name|7256
scncc:  .long 0
# |scngo|dac|1,0|||; set non-zero to scan goto field|7257
scngo:  .long 0
# |scnil|dac|1,0|||; length of current input image|7258
scnil:  .long 0
# |scnpt|dac|1,0|||; pointer to next location in r_cim|7259
scnpt:  .long 0
# |scnrs|dac|1,0|||; set non-zero to signal rescan|7260
scnrs:  .long 0
# |scnse|dac|1,0|||; start of current element|7261
scnse:  .long 0
# |scntp|dac|1,0|||; save syntax type from last call|7262
scntp:  .long 0
# |stage|dac|1,0|||; initial value = initial compile|7266
stage:  .long 0
# ||ejc|||||7267
# |stbas|dac|1,0|||; pointer past stack base|7271
stbas:  .long 0
# |stxoc|dac|1,0|||; code pointer offset|7275
stxoc:  .long 0
# |stxof|dac|1,0|||; failure offset|7276
stxof:  .long 0
# |timsx|dic|16,+0|||; time at start of execution|7280
timsx:  .long +0
# |timup|dac|1,0|||; set when time up occurs|7281
timup:  .long 0
# |xsofs|dac|1,0|||; offset to current location in r_xsc|7285
xsofs:  .long 0
# |w_yyy|dac|1,0|||;|7289
w_yyy:  .long 0
# ||ttl|27,s p i t b o l -- minimal code||||7290
# ||sec||||; start of program section|7291
        .global esec04
esec04:
prc_:   .fill 19,8
        .global end_min_data
end_min_data:
        .text
        .global sec05
sec05:
# |s_aaa|ent|2,bl__i|||; mark start of code|7292
	.align	2
	.byte	bl__i
s_aaa:
# ||ttl|27,s p i t b o l -- relocation||||7294
# |relaj|prc|25,e|1,0||; entry point|7310
relaj:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save xr|7311
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wa||; save wa|7312
# getarg WA
        push WA
# ||mov|3,rlals|7,xl||; save ptr to list of bounds|7313
# getarg XL
# getarg rlals
        movq XL,rlals
# ||mov|7,xr|8,wb||; ptr to first pointer to process|7314
# getarg WB
# getarg XR
        movq WB,XR
# |rlaj0|mov|7,xl|3,rlals||; restore xl|7318
rlaj0:
# getarg rlals
# getarg XL
        movq rlals,XL
# ||bne|7,xr|9,(xs)|6,rlaj1|; proceed if more to do|7319
# getarg XR
# getarg (XT)
# getarg rlaj1
        cmpq XR,(XT)
        jne  rlaj1
# ||mov|8,wa|10,(xs)+||; restore wa|7320
# getarg WA
        pop  WA
# ||mov|7,xr|10,(xs)+||; restore xr|7321
# getarg XR
        pop  XR
# ||exi||||; return to caller|7322
# getarg 
        ret
# |rlaj1|mov|8,wa|9,(xr)||; load next pointer on list|7326
rlaj1:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||lct|8,wb|18,=rnsi_||; number of sections of adjusters|7327
# getarg WB
# getarg W0
        .data
l_0001: .long rnsi_
        .text
        movq l_0001,W0
        mov  WB,W0
# |rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|; ok if past end of section|7331
rlaj2:
# getarg WA
# getarg rlend(,XL,8)
# getarg rlaj3
        cmpq WA,rlend(,XL,8)
        ja   rlaj3
# ||blt|8,wa|13,rlstr(xl)|6,rlaj3|; or if before start of section|7332
# getarg WA
# getarg rlstr(,XL,8)
# getarg rlaj3
        cmpq WA,rlstr(,XL,8)
        jb   rlaj3
# ||add|8,wa|13,rladj(xl)||; within section, add adjustment|7333
# getarg rladj(,XL,8)
# getarg WA
        addq rladj(,XL,8),WA
# ||mov|9,(xr)|8,wa||; return updated ptr to memory|7334
# getarg WA
# getarg (XR)
        movq WA,(XR)
# ||brn|6,rlaj4|||; done with this pointer|7335
# getarg rlaj4
        jmp  rlaj4
# |rlaj3|add|7,xl|19,*rssi_||; advance to next section|7339
rlaj3:
# getarg W0
# getarg XL
        .data
l_0002: .long 8*rssi_
        .text
        movq l_0002,W0
        addq W0,XL
# ||bct|8,wb|6,rlaj2||; jump if more to go|7340
# getarg WB
# getarg rlaj2
        decq WB
        jnz  rlaj2
# |rlaj4|ica|7,xr|||; increment to next ptr on list|7344
rlaj4:
# getarg XR
        addq $8,XR
# ||brn|6,rlaj0|||; jump to check	 for completion|7345
# getarg rlaj0
        jmp  rlaj0
# ||enp||||; end procedure relaj|7346
# ||ejc|||||7347
# |relcr|prc|25,e|1,0||; entry point|7368
relcr:
# getarg 0
# ||add|7,xl|19,*rlsi_||; point past build area|7369
# getarg W0
# getarg XL
        .data
l_0003: .long 8*rlsi_
        .text
        movq l_0003,W0
        addq W0,XL
# ||mov|11,-(xl)|8,wa||; save original code address|7370
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|8,wa|22,=s_aaa||; compute adjustment|7371
# getarg W0
# getarg WA
        .data
l_0004: .long s_aaa
        .text
        movq l_0004,W0
        movq W0,WA
# ||sub|8,wa|9,(xl)||; as new s_aaa minus original s_aaa|7372
# getarg (XL)
# getarg WA
        subq (XL),WA
# ||mov|11,-(xl)|8,wa||; save code adjustment|7373
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|8,wa|22,=s_yyy||; end of target code section|7374
# getarg W0
# getarg WA
        .data
l_0005: .long s_yyy
        .text
        movq l_0005,W0
        movq W0,WA
# ||sub|8,wa|22,=s_aaa||; length of code section|7375
# getarg W0
# getarg WA
        movq l_0004,W0
        subq W0,WA
# ||add|8,wa|13,num01(xl)||; plus original start address|7376
# getarg num01(,XL,8)
# getarg WA
        addq num01(,XL,8),WA
# ||mov|11,-(xl)|8,wa||; end of original code section|7377
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|11,-(xl)|8,wb||; save constant section address|7378
# getarg WB
# getarg (XL)
        sub  $8,XL
        movq WB,(XL)
# ||mov|8,wb|21,=c_aaa||; start of constants section|7379
# getarg W0
# getarg WB
        .data
l_0006: .long c_aaa
        .text
        movq l_0006,W0
        movq W0,WB
# ||mov|8,wa|21,=c_yyy||; end of constants section|7380
# getarg W0
# getarg WA
        .data
l_0007: .long c_yyy
        .text
        movq l_0007,W0
        movq W0,WA
# ||sub|8,wa|8,wb||; length of constants section|7381
# getarg WB
# getarg WA
        subq WB,WA
# ||sub|8,wb|9,(xl)||; new c_aaa minus original c_aaa|7382
# getarg (XL)
# getarg WB
        subq (XL),WB
# ||mov|11,-(xl)|8,wb||; save constant adjustment|7383
# getarg WB
# getarg (XL)
        sub  $8,XL
        movq WB,(XL)
# ||add|8,wa|13,num01(xl)||; length plus original start adr|7384
# getarg num01(,XL,8)
# getarg WA
        addq num01(,XL,8),WA
# ||mov|11,-(xl)|8,wa||; save as end of original constants|7385
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|11,-(xl)|8,wc||; save working globals address|7386
# getarg WC
# getarg (XL)
        sub  $8,XL
        movq WC,(XL)
# ||mov|8,wc|20,=g_aaa||; start of working globals section|7387
# getarg W0
# getarg WC
        .data
l_0008: .long g_aaa
        .text
        movq l_0008,W0
        movq W0,WC
# ||mov|8,wa|20,=w_yyy||; end of working section|7388
# getarg W0
# getarg WA
        .data
l_0009: .long w_yyy
        .text
        movq l_0009,W0
        movq W0,WA
# ||sub|8,wa|8,wc||; length of working globals|7389
# getarg WC
# getarg WA
        subq WC,WA
# ||sub|8,wc|9,(xl)||; new g_aaa minus original g_aaa|7390
# getarg (XL)
# getarg WC
        subq (XL),WC
# ||mov|11,-(xl)|8,wc||; save working globals adjustment|7391
# getarg WC
# getarg (XL)
        sub  $8,XL
        movq WC,(XL)
# ||add|8,wa|13,num01(xl)||; length plus original start adr|7392
# getarg num01(,XL,8)
# getarg WA
        addq num01(,XL,8),WA
# ||mov|11,-(xl)|8,wa||; save as end of working globals|7393
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|8,wb|3,statb||; old start of static region|7394
# getarg statb
# getarg WB
        movq statb,WB
# ||mov|11,-(xl)|8,wb||; save|7395
# getarg WB
# getarg (XL)
        sub  $8,XL
        movq WB,(XL)
# ||sub|7,xr|8,wb||; compute adjustment|7396
# getarg WB
# getarg XR
        subq WB,XR
# ||mov|11,-(xl)|7,xr||; save new statb minus old statb|7397
# getarg XR
# getarg (XL)
        sub  $8,XL
        movq XR,(XL)
# ||mov|11,-(xl)|3,state||; old end of static region|7398
# getarg state
# getarg W0
# getarg (XL)
        sub  $8,XL
        movq state,W0
        movq W0,(XL)
# ||mov|8,wb|3,dnamb||; old start of dynamic region|7399
# getarg dnamb
# getarg WB
        movq dnamb,WB
# ||mov|11,-(xl)|8,wb||; save|7400
# getarg WB
# getarg (XL)
        sub  $8,XL
        movq WB,(XL)
# ||scp|8,wa|||; new start of dynamic|7401
# getarg WA
        scp_ WA
# ||sub|8,wa|8,wb||; compute adjustment|7402
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|11,-(xl)|8,wa||; save new dnamb minus old dnamb|7403
# getarg WA
# getarg (XL)
        sub  $8,XL
        movq WA,(XL)
# ||mov|8,wc|3,dnamp||; old end of dynamic region in use|7404
# getarg dnamp
# getarg WC
        movq dnamp,WC
# ||mov|11,-(xl)|8,wc||; save as end of old dynamic region|7405
# getarg WC
# getarg (XL)
        sub  $8,XL
        movq WC,(XL)
# ||exi|||||7406
# getarg 
        ret
# ||enp|||||7407
# ||ejc|||||7408
# |reldn|prc|25,e|1,0||; entry point|7423
reldn:
# getarg 0
# ||mov|3,rldcd|13,rlcda(xl)||; save code adjustment|7424
# getarg rlcda(,XL,8)
# getarg W0
# getarg rldcd
        movq rlcda(,XL,8),W0
        movq W0,rldcd
# ||mov|3,rldst|13,rlsta(xl)||; save static adjustment|7425
# getarg rlsta(,XL,8)
# getarg W0
# getarg rldst
        movq rlsta(,XL,8),W0
        movq W0,rldst
# ||mov|3,rldls|7,xl||; save list pointer|7426
# getarg XL
# getarg rldls
        movq XL,rldls
# |rld01|add|9,(xr)|3,rldcd||; adjust block type word|7430
rld01:
# getarg rldcd
# getarg W0
# getarg (XR)
        movq rldcd,W0
        addq W0,(XR)
# ||mov|7,xl|9,(xr)||; load block type word|7431
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||lei|7,xl|||; load entry point id (bl_xx)|7432
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||ejc|||||7445
# ||bsw|7,xl|2,bl___||; switch on block type|7449
# getarg XL
        jmp  *l_0010(,XL,8)
        .data
l_0010:
# ||iff|2,bl_ar|6,rld03||; arblk|7486
# getarg rld03
        .long rld03
# ||iff|2,bl_cd|6,rld07||; cdblk|7486
# getarg rld07
        .long rld07
# ||iff|2,bl_ex|6,rld10||; exblk|7486
# getarg rld10
        .long rld10
# ||iff|2,bl_ic|6,rld05||; icblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_nm|6,rld13||; nmblk|7486
# getarg rld13
        .long rld13
# ||iff|2,bl_p0|6,rld13||; p0blk|7486
# getarg rld13
        .long rld13
# ||iff|2,bl_p1|6,rld14||; p1blk|7486
# getarg rld14
        .long rld14
# ||iff|2,bl_p2|6,rld14||; p2blk|7486
# getarg rld14
        .long rld14
# ||iff|2,bl_rc|6,rld05||; rcblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_sc|6,rld05||; scblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_se|6,rld13||; seblk|7486
# getarg rld13
        .long rld13
# ||iff|2,bl_tb|6,rld17||; tbblk|7486
# getarg rld17
        .long rld17
# ||iff|2,bl_vc|6,rld17||; vcblk|7486
# getarg rld17
        .long rld17
# ||iff|2,bl_xn|6,rld05||; xnblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_xr|6,rld20||; xrblk|7486
# getarg rld20
        .long rld20
# ||iff|2,bl_bc|6,rld05||; bcblk - dummy to fill out iffs|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_pd|6,rld15||; pdblk|7486
# getarg rld15
        .long rld15
# ||iff|2,bl_tr|6,rld19||; trblk|7486
# getarg rld19
        .long rld19
# ||iff|2,bl_bf|6,rld05||; bfblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_cc|6,rld05||; ccblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_cm|6,rld05||; cmblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_ct|6,rld05||; ctblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_df|6,rld05||; dfblk|7486
# getarg rld05
        .long rld05
# ||iff|2,bl_ef|6,rld08||; efblk|7486
# getarg rld08
        .long rld08
# ||iff|2,bl_ev|6,rld09||; evblk|7486
# getarg rld09
        .long rld09
# ||iff|2,bl_ff|6,rld11||; ffblk|7486
# getarg rld11
        .long rld11
# ||iff|2,bl_kv|6,rld13||; kvblk|7486
# getarg rld13
        .long rld13
# ||iff|2,bl_pf|6,rld16||; pfblk|7486
# getarg rld16
        .long rld16
# ||iff|2,bl_te|6,rld18||; teblk|7486
# getarg rld18
        .long rld18
# ||esw||||; end of jump table|7486
        .text
# |rld03|mov|8,wa|13,arlen(xr)||; load length|7490
rld03:
# getarg arlen(,XR,8)
# getarg WA
        movq arlen(,XR,8),WA
# ||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)|7491
# getarg arofs(,XR,8)
# getarg WB
        movq arofs(,XR,8),WB
# |rld04|add|8,wa|7,xr||; point past last reloc field|7500
rld04:
# getarg XR
# getarg WA
        addq XR,WA
# ||add|8,wb|7,xr||; point to first reloc field|7501
# getarg XR
# getarg WB
        addq XR,WB
# ||mov|7,xl|3,rldls||; point to list of bounds|7502
# getarg rldls
# getarg XL
        movq rldls,XL
# ||jsr|6,relaj|||; adjust pointers|7503
# getarg relaj
        call relaj
# ||ejc|||||7504
# |rld05|mov|8,wa|9,(xr)||; block type word|7514
rld05:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||jsr|6,blkln|||; get length of block|7515
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; point to next block|7516
# getarg WA
# getarg XR
        addq WA,XR
# ||blt|7,xr|8,wc|6,rld01|; continue if more to process|7517
# getarg XR
# getarg WC
# getarg rld01
        cmpq XR,WC
        jb   rld01
# ||mov|7,xl|3,rldls||; restore xl|7518
# getarg rldls
# getarg XL
        movq rldls,XL
# ||exi||||; return to caller if done|7519
# getarg 
        ret
# |rld07|mov|8,wa|13,cdlen(xr)||; load length|7532
rld07:
# getarg cdlen(,XR,8)
# getarg WA
        movq cdlen(,XR,8),WA
# ||mov|8,wb|19,*cdfal||; set offset|7533
# getarg W0
# getarg WB
        .data
l_0011: .long 8*cdfal
        .text
        movq l_0011,W0
        movq W0,WB
# ||bne|9,(xr)|22,=b_cdc|6,rld04|; jump back if not complex goto|7534
# getarg (XR)
# getarg W0
# getarg rld04
        .data
l_0012: .long b_cdc
        .text
        movq l_0012,W0
        cmpq (XR),W0
        jne  rld04
# ||mov|8,wb|19,*cdcod||; do not process cdfal word|7535
# getarg W0
# getarg WB
        .data
l_0013: .long 8*cdcod
        .text
        movq l_0013,W0
        movq W0,WB
# ||brn|6,rld04|||; jump back|7536
# getarg rld04
        jmp  rld04
# |rld08|mov|8,wa|19,*efrsl||; set length|7544
rld08:
# getarg W0
# getarg WA
        .data
l_0014: .long 8*efrsl
        .text
        movq l_0014,W0
        movq W0,WA
# ||mov|8,wb|19,*efcod||; and offset|7545
# getarg W0
# getarg WB
        .data
l_0015: .long 8*efcod
        .text
        movq l_0015,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7546
# getarg rld04
        jmp  rld04
# |rld09|mov|8,wa|19,*offs3||; point past third field|7550
rld09:
# getarg W0
# getarg WA
        .data
l_0016: .long 8*offs3
        .text
        movq l_0016,W0
        movq W0,WA
# ||mov|8,wb|19,*evexp||; set offset|7551
# getarg W0
# getarg WB
        .data
l_0017: .long 8*evexp
        .text
        movq l_0017,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7552
# getarg rld04
        jmp  rld04
# |rld10|mov|8,wa|13,exlen(xr)||; load length|7556
rld10:
# getarg exlen(,XR,8)
# getarg WA
        movq exlen(,XR,8),WA
# ||mov|8,wb|19,*exflc||; set offset|7557
# getarg W0
# getarg WB
        .data
l_0018: .long 8*exflc
        .text
        movq l_0018,W0
        movq W0,WB
# ||brn|6,rld04|||; jump back|7558
# getarg rld04
        jmp  rld04
# ||ejc|||||7559
# |rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|; skip dfblk if not first field|7573
rld11:
# getarg ffofs(,XR,8)
# getarg W0
# getarg rld12
        .data
l_0019: .long 8*pdfld
        .text
        movq l_0019,W0
        cmpq ffofs(,XR,8),W0
        jne  rld12
# ||mov|11,-(xs)|7,xr||; save xr|7574
# getarg XR
        push XR
# ||mov|7,xr|13,ffdfp(xr)||; load old ptr to dfblk|7575
# getarg ffdfp(,XR,8)
# getarg XR
        movq ffdfp(,XR,8),XR
# ||add|7,xr|3,rldst||; current location of dfblk|7576
# getarg rldst
# getarg XR
        addq rldst,XR
# ||add|9,(xr)|3,rldcd||; adjust dfblk type word|7577
# getarg rldcd
# getarg W0
# getarg (XR)
        movq rldcd,W0
        addq W0,(XR)
# ||mov|8,wa|13,dflen(xr)||; length of dfblk|7578
# getarg dflen(,XR,8)
# getarg WA
        movq dflen(,XR,8),WA
# ||mov|8,wb|19,*dfnam||; offset to dfnam field|7579
# getarg W0
# getarg WB
        .data
l_0020: .long 8*dfnam
        .text
        movq l_0020,W0
        movq W0,WB
# ||add|8,wa|7,xr||; point past last reloc field|7580
# getarg XR
# getarg WA
        addq XR,WA
# ||add|8,wb|7,xr||; point to first reloc field|7581
# getarg XR
# getarg WB
        addq XR,WB
# ||mov|7,xl|3,rldls||; point to list of bounds|7582
# getarg rldls
# getarg XL
        movq rldls,XL
# ||jsr|6,relaj|||; adjust pointers|7583
# getarg relaj
        call relaj
# ||mov|7,xr|13,dfnam(xr)||; pointer to static scblk|7584
# getarg dfnam(,XR,8)
# getarg XR
        movq dfnam(,XR,8),XR
# ||add|9,(xr)|3,rldcd||; adjust scblk type word|7585
# getarg rldcd
# getarg W0
# getarg (XR)
        movq rldcd,W0
        addq W0,(XR)
# ||mov|7,xr|10,(xs)+||; restore ffblk pointer|7586
# getarg XR
        pop  XR
# |rld12|mov|8,wa|19,*ffofs||; set length|7592
rld12:
# getarg W0
# getarg WA
        .data
l_0021: .long 8*ffofs
        .text
        movq l_0021,W0
        movq W0,WA
# ||mov|8,wb|19,*ffdfp||; set offset|7593
# getarg W0
# getarg WB
        .data
l_0022: .long 8*ffdfp
        .text
        movq l_0022,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7594
# getarg rld04
        jmp  rld04
# |rld13|mov|8,wa|19,*offs2||; point past second field|7598
rld13:
# getarg W0
# getarg WA
        .data
l_0023: .long 8*offs2
        .text
        movq l_0023,W0
        movq W0,WA
# ||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)|7599
# getarg W0
# getarg WB
        .data
l_0024: .long 8*offs1
        .text
        movq l_0024,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7600
# getarg rld04
        jmp  rld04
# |rld14|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)|7607
rld14:
# getarg W0
# getarg WA
        .data
l_0025: .long 8*parm2
        .text
        movq l_0025,W0
        movq W0,WA
# ||mov|8,wb|19,*pthen||; set offset|7608
# getarg W0
# getarg WB
        .data
l_0026: .long 8*pthen
        .text
        movq l_0026,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7609
# getarg rld04
        jmp  rld04
# |rld15|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk|7619
rld15:
# getarg pddfp(,XR,8)
# getarg XL
        movq pddfp(,XR,8),XL
# ||add|7,xl|3,rldst||; adjust for static relocation|7620
# getarg rldst
# getarg XL
        addq rldst,XL
# ||mov|8,wa|13,dfpdl(xl)||; get pdblk length|7621
# getarg dfpdl(,XL,8)
# getarg WA
        movq dfpdl(,XL,8),WA
# ||mov|8,wb|19,*pddfp||; set offset|7622
# getarg W0
# getarg WB
        .data
l_0027: .long 8*pddfp
        .text
        movq l_0027,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7623
# getarg rld04
        jmp  rld04
# ||ejc|||||7624
# |rld16|add|13,pfvbl(xr)|3,rldst||; adjust non-contiguous field|7631
rld16:
# getarg rldst
# getarg W0
# getarg pfvbl(,XR,8)
        movq rldst,W0
        addq W0,pfvbl(,XR,8)
# ||mov|8,wa|13,pflen(xr)||; get pfblk length|7632
# getarg pflen(,XR,8)
# getarg WA
        movq pflen(,XR,8),WA
# ||mov|8,wb|19,*pfcod||; offset to first reloc|7633
# getarg W0
# getarg WB
        .data
l_0028: .long 8*pfcod
        .text
        movq l_0028,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7634
# getarg rld04
        jmp  rld04
# |rld17|mov|8,wa|13,offs2(xr)||; load length|7638
rld17:
# getarg offs2(,XR,8)
# getarg WA
        movq offs2(,XR,8),WA
# ||mov|8,wb|19,*offs3||; set offset|7639
# getarg W0
# getarg WB
        movq l_0016,W0
        movq W0,WB
# ||brn|6,rld04|||; jump back|7640
# getarg rld04
        jmp  rld04
# |rld18|mov|8,wa|19,*tesi_||; set length|7644
rld18:
# getarg W0
# getarg WA
        .data
l_0029: .long 8*tesi_
        .text
        movq l_0029,W0
        movq W0,WA
# ||mov|8,wb|19,*tesub||; and offset|7645
# getarg W0
# getarg WB
        .data
l_0030: .long 8*tesub
        .text
        movq l_0030,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7646
# getarg rld04
        jmp  rld04
# |rld19|mov|8,wa|19,*trsi_||; set length|7650
rld19:
# getarg W0
# getarg WA
        .data
l_0031: .long 8*trsi_
        .text
        movq l_0031,W0
        movq W0,WA
# ||mov|8,wb|19,*trval||; and offset|7651
# getarg W0
# getarg WB
        .data
l_0032: .long 8*trval
        .text
        movq l_0032,W0
        movq W0,WB
# ||brn|6,rld04|||; all set|7652
# getarg rld04
        jmp  rld04
# |rld20|mov|8,wa|13,xrlen(xr)||; load length|7656
rld20:
# getarg xrlen(,XR,8)
# getarg WA
        movq xrlen(,XR,8),WA
# ||mov|8,wb|19,*xrptr||; set offset|7657
# getarg W0
# getarg WB
        .data
l_0033: .long 8*xrptr
        .text
        movq l_0033,W0
        movq W0,WB
# ||brn|6,rld04|||; jump back|7658
# getarg rld04
        jmp  rld04
# ||enp||||; end procedure reldn|7659
# ||ejc|||||7660
# |reloc|prc|25,e|1,0||; entry point|7672
reloc:
# getarg 0
# ||mov|7,xr|13,rldys(xl)||; old start of dynamic|7673
# getarg rldys(,XL,8)
# getarg XR
        movq rldys(,XL,8),XR
# ||mov|8,wc|13,rldye(xl)||; old end of dynamic|7674
# getarg rldye(,XL,8)
# getarg WC
        movq rldye(,XL,8),WC
# ||add|7,xr|13,rldya(xl)||; create new start of dynamic|7675
# getarg rldya(,XL,8)
# getarg XR
        addq rldya(,XL,8),XR
# ||add|8,wc|13,rldya(xl)||; create new end of dynamic|7676
# getarg rldya(,XL,8)
# getarg WC
        addq rldya(,XL,8),WC
# ||jsr|6,reldn|||; relocate pointers in dynamic|7677
# getarg reldn
        call reldn
# ||jsr|6,relws|||; relocate pointers in working sect|7678
# getarg relws
        call relws
# ||jsr|6,relst|||; relocate pointers in static|7679
# getarg relst
        call relst
# ||exi||||; return to caller|7680
# getarg 
        ret
# ||enp||||; end procedure reloc|7681
# ||ejc|||||7682
# |relst|prc|25,e|1,0||; entry point|7697
relst:
# getarg 0
# ||mov|7,xr|3,pftbl||; profile table|7698
# getarg pftbl
# getarg XR
        movq pftbl,XR
# ||bze|7,xr|6,rls01||; branch if no table allocated|7699
# getarg XR
# getarg rls01
        or   XR,XR
        jz   rls01
# ||add|9,(xr)|13,rlcda(xl)||; adjust block type word|7700
# getarg rlcda(,XL,8)
# getarg W0
# getarg (XR)
        movq rlcda(,XL,8),W0
        addq W0,(XR)
# |rls01|mov|8,wc|3,hshtb||; point to start of hash table|7704
rls01:
# getarg hshtb
# getarg WC
        movq hshtb,WC
# ||mov|8,wb|8,wc||; point to first hash bucket|7705
# getarg WC
# getarg WB
        movq WC,WB
# ||mov|8,wa|3,hshte||; point beyond hash table|7706
# getarg hshte
# getarg WA
        movq hshte,WA
# ||jsr|6,relaj|||; adjust bucket pointers|7707
# getarg relaj
        call relaj
# |rls02|beq|8,wc|3,hshte|6,rls05|; done if none left|7711
rls02:
# getarg WC
# getarg hshte
# getarg rls05
        cmpq WC,hshte
        je   rls05
# ||mov|7,xr|8,wc||; else copy slot pointer|7712
# getarg WC
# getarg XR
        movq WC,XR
# ||ica|8,wc|||; bump slot pointer|7713
# getarg WC
        addq $8,WC
# ||sub|7,xr|19,*vrnxt||; set offset to merge into loop|7714
# getarg W0
# getarg XR
        .data
l_0034: .long 8*vrnxt
        .text
        movq l_0034,W0
        subq W0,XR
# |rls03|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|7718
rls03:
# getarg vrnxt(,XR,8)
# getarg XR
        movq vrnxt(,XR,8),XR
# ||bze|7,xr|6,rls02||; jump for next bucket if chain end|7719
# getarg XR
# getarg rls02
        or   XR,XR
        jz   rls02
# ||mov|8,wa|19,*vrlen||; offset of first loc past ptr fields|7720
# getarg W0
# getarg WA
        .data
l_0035: .long 8*vrlen
        .text
        movq l_0035,W0
        movq W0,WA
# ||mov|8,wb|19,*vrget||; offset of first location in vrblk|7721
# getarg W0
# getarg WB
        .data
l_0036: .long 8*vrget
        .text
        movq l_0036,W0
        movq W0,WB
# ||bnz|13,vrlen(xr)|6,rls04||; jump if not system variable|7722
# getarg vrlen(,XR,8)
# getarg rls04
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  rls04
# ||mov|8,wa|19,*vrsi_||; offset to include vrsvp field|7723
# getarg W0
# getarg WA
        .data
l_0037: .long 8*vrsi_
        .text
        movq l_0037,W0
        movq W0,WA
# |rls04|add|8,wa|7,xr||; create end ptr|7727
rls04:
# getarg XR
# getarg WA
        addq XR,WA
# ||add|8,wb|7,xr||; create start ptr|7728
# getarg XR
# getarg WB
        addq XR,WB
# ||jsr|6,relaj|||; adjust pointers in vrblk|7729
# getarg relaj
        call relaj
# ||brn|6,rls03|||; check for another vrblk on chain|7730
# getarg rls03
        jmp  rls03
# |rls05|exi||||; return to caller|7734
rls05:
# getarg 
        ret
# ||enp||||; end procedure relst|7735
# ||ejc|||||7736
# |relws|prc|25,e|1,0||; entry point|7752
relws:
# getarg 0
# ||mov|8,wb|20,=a_aaa||; point to start of adjustables|7753
# getarg W0
# getarg WB
        .data
l_0038: .long a_aaa
        .text
        movq l_0038,W0
        movq W0,WB
# ||mov|8,wa|20,=r_yyy||; point to end of adjustables|7754
# getarg W0
# getarg WA
        .data
l_0039: .long r_yyy
        .text
        movq l_0039,W0
        movq W0,WA
# ||jsr|6,relaj|||; relocate adjustable pointers|7755
# getarg relaj
        call relaj
# ||add|3,dname|13,rldya(xl)||; adjust ptr missed by relaj|7756
# getarg rldya(,XL,8)
# getarg W0
# getarg dname
        movq rldya(,XL,8),W0
        addq W0,dname
# ||mov|8,wb|20,=kvrtn||; case of kvrtn|7757
# getarg W0
# getarg WB
        .data
l_0040: .long kvrtn
        .text
        movq l_0040,W0
        movq W0,WB
# ||mov|8,wa|8,wb||; handled specially|7758
# getarg WB
# getarg WA
        movq WB,WA
# ||ica|8,wa|||; one value to adjust|7759
# getarg WA
        addq $8,WA
# ||jsr|6,relaj|||; adjust kvrtn|7760
# getarg relaj
        call relaj
# ||exi||||; return to caller|7761
# getarg 
        ret
# ||enp||||; end procedure relws|7762
# ||ttl|27,s p i t b o l -- initialization||||7764
# |start|prc|25,e|1,0||; entry point|7774
start:
# getarg 0
# ||mov|3,mxint|8,wb||;|7776
# getarg WB
# getarg mxint
        movq WB,mxint
# ||mov|4,bitsm|8,wb||;|7777
# getarg WB
# getarg bitsm
        movq WB,bitsm
# ||zer|8,wb|||;|7778
# getarg WB
        xor  WB,WB
# ||mov|7,xs|8,wa||; discard return|7779
# getarg WA
# getarg XT
        movq WA,XT
# ||jsr|6,systm|||; initialise timer|7781
# getarg systm
        call systm
# ||sti|3,timsx|||; store time|7783
# getarg timsx
        mov  IA,timsx
# ||mov|3,statb|7,xr||; start address of static|7784
# getarg XR
# getarg statb
        movq XR,statb
# ||mov|3,rsmem|19,*e_srs||; reserve memory|7836
# getarg W0
# getarg rsmem
        .data
l_0041: .long 8*e_srs
        .text
        movq l_0041,W0
        movq W0,rsmem
# ||mov|3,stbas|7,xs||; store stack base|7837
# getarg XT
# getarg stbas
        movq XT,stbas
# ||sss|3,iniss|||; save s-r stack ptr|7838
# ||ldi|4,intvh|||; get 100|7843
# getarg intvh
        mov  intvh,IA
# ||dvi|4,alfsp|||; form 100 / alfsp|7844
# getarg alfsp
        mov  alfsp,W0
        call dvi__
# ||sti|3,alfsf|||; store the factor|7845
# getarg alfsf
        mov  IA,alfsf
# ||ldi|4,intvh|||; get 100|7851
# getarg intvh
        mov  intvh,IA
# ||dvi|4,gbsdp|||; form 100 / gbsdp|7852
# getarg gbsdp
        mov  gbsdp,W0
        call dvi__
# ||sti|3,gbsed|||; store the factor|7853
# getarg gbsed
        mov  IA,gbsed
# ||lct|8,wb|18,=cfp_s||; load counter for significant digits|7862
# getarg WB
# getarg W0
        .data
l_0042: .long cfp_s
        .text
        movq l_0042,W0
        mov  WB,W0
# ||ldr|4,reav1|||; load 1.0|7863
        .data
l_0043: .long
        .text
        movq l_0043,W0
        call ldr_
# |ini03|mlr|4,reavt|||; * 10.0|7867
ini03:
        .data
l_0044: .long
        .text
        movq l_0044,W0
        call mlr_
# ||bct|8,wb|6,ini03||; loop till done|7868
# getarg WB
# getarg ini03
        decq WB
        jnz  ini03
# ||str|3,gtssc|||; store 10**(max sig digits)|7869
        .data
l_0045: .long
        .text
        movq l_0045,W0
        call str_
# ||ldr|4,reap5|||; load 0.5|7870
        .data
l_0046: .long
        .text
        movq l_0046,W0
        call ldr_
# ||dvr|3,gtssc|||; compute 0.5*10**(max sig digits)|7871
        movq l_0045,W0
        call dvr_
# ||str|3,gtsrn|||; store as rounding bias|7872
        .data
l_0047: .long
        .text
        movq l_0047,W0
        call str_
# ||zer|8,wc|||; set to read parameters|7875
# getarg WC
        xor  WC,WC
# ||jsr|6,prpar|||; read them|7876
# getarg prpar
        call prpar
# ||ejc|||||7877
# ||sub|7,xl|19,*e_srs||; allow for reserve memory|7882
# getarg W0
# getarg XL
        movq l_0041,W0
        subq W0,XL
# ||mov|8,wa|3,prlen||; get print buffer length|7883
# getarg prlen
# getarg WA
        movq prlen,WA
# ||add|8,wa|18,=cfp_a||; add no. of chars in alphabet|7884
# getarg W0
# getarg WA
        .data
l_0048: .long cfp_a
        .text
        movq l_0048,W0
        addq W0,WA
# ||add|8,wa|18,=nstmx||; add chars for gtstg bfr|7885
# getarg W0
# getarg WA
        .data
l_0049: .long nstmx
        .text
        movq l_0049,W0
        addq W0,WA
# ||ctb|8,wa|1,8||; convert to bytes, allowing a margin|7886
# getarg WA
        add  ($cfp_b-1)+$cfp_b*8,WA
        and  WA,-$8
# ||mov|7,xr|3,statb||; point to static base|7887
# getarg statb
# getarg XR
        movq statb,XR
# ||add|7,xr|8,wa||; increment for above buffers|7888
# getarg WA
# getarg XR
        addq WA,XR
# ||add|7,xr|19,*e_hnb||; increment for hash table|7889
# getarg W0
# getarg XR
        .data
l_0050: .long 8*e_hnb
        .text
        movq l_0050,W0
        addq W0,XR
# ||add|7,xr|19,*e_sts||; bump for initial static block|7890
# getarg W0
# getarg XR
        .data
l_0051: .long 8*e_sts
        .text
        movq l_0051,W0
        addq W0,XR
# ||jsr|6,sysmx|||; get mxlen|7891
# getarg sysmx
        call sysmx
# ||mov|3,kvmxl|8,wa||; provisionally store as maxlngth|7892
# getarg WA
# getarg kvmxl
        movq WA,kvmxl
# ||mov|3,mxlen|8,wa||; and as mxlen|7893
# getarg WA
# getarg mxlen
        movq WA,mxlen
# ||bgt|7,xr|8,wa|6,ini06|; skip if static hi exceeds mxlen|7894
# getarg XR
# getarg WA
# getarg ini06
        cmpq XR,WA
        ja   ini06
# ||ctb|8,wa|1,1||; round up and make bigger than mxlen|7895
# getarg WA
        add  ($cfp_b-1)+$cfp_b*1,WA
        and  WA,-$8
# ||mov|7,xr|8,wa||; use it instead|7896
# getarg WA
# getarg XR
        movq WA,XR
# |ini06|mov|3,dnamb|7,xr||; dynamic base adrs|7901
ini06:
# getarg XR
# getarg dnamb
        movq XR,dnamb
# ||mov|3,dnamp|7,xr||; dynamic ptr|7902
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||bnz|8,wa|6,ini07||; skip if non-zero mxlen|7903
# getarg WA
# getarg WA
# getarg ini07
        or   WA,WA
        jnz  ini07
# ||dca|7,xr|||; point a word in front|7904
# getarg XR
        subq $8,XR
# ||mov|3,kvmxl|7,xr||; use as maxlngth|7905
# getarg XR
# getarg kvmxl
        movq XR,kvmxl
# ||mov|3,mxlen|7,xr||; and as mxlen|7906
# getarg XR
# getarg mxlen
        movq XR,mxlen
# ||ejc|||||7907
# |ini07|mov|3,dname|7,xl||; store dynamic end address|7912
ini07:
# getarg XL
# getarg dname
        movq XL,dname
# ||blt|3,dnamb|7,xl|6,ini09|; skip if high enough|7913
# getarg dnamb
# getarg XL
# getarg ini09
        cmpq dnamb,XL
        jb   ini09
# ||jsr|6,sysmm|||; request more memory|7914
# getarg sysmm
        call sysmm
# ||wtb|7,xr|||; get as baus (sgd05)|7915
# getarg XR
        sal  XR,3
# ||add|7,xl|7,xr||; bump by amount obtained|7916
# getarg XR
# getarg XL
        addq XR,XL
# ||bnz|7,xr|6,ini07||; try again|7917
# getarg XR
# getarg XR
# getarg ini07
        or   XR,XR
        jnz  ini07
# ||mov|8,wa|18,=mxern||; insufficient memory for maxlength|7919
# getarg W0
# getarg WA
        .data
l_0052: .long mxern
        .text
        movq l_0052,W0
        movq W0,WA
# ||zer|8,wb|||; no column number info|7920
# getarg WB
        xor  WB,WB
# ||zer|8,wc|||; no line number info|7921
# getarg WC
        xor  WC,WC
# ||mov|7,xr|18,=stgic||; initial compile stage|7922
# getarg W0
# getarg XR
        .data
l_0053: .long stgic
        .text
        movq l_0053,W0
        movq W0,XR
# ||mov|7,xl|21,=nulls||; no file name|7924
# getarg W0
# getarg XL
        .data
l_0054: .long nulls
        .text
        movq l_0054,W0
        movq W0,XL
# ||jsr|6,sysea|||; advise of error|7926
# getarg sysea
        call sysea
        decq rcode
        js   call_1
# ||ppm|6,ini08|||; cant use error logic yet|7927
# getarg ini08
# getarg ini08
        decq rcode
        jns  l_0055
        jmp  ini08
l_0055:
call_1:
# ||brn|6,ini08|||; force termination|7928
# getarg ini08
        jmp  ini08
# ||erb|1,329|26,requested maxlngth too large|||7932
        movq $329,rcode
        jmp  err_
# |ini08|mov|7,xr|21,=endmo||; point to failure message|7934
ini08:
# getarg W0
# getarg XR
        .data
l_0056: .long endmo
        .text
        movq l_0056,W0
        movq W0,XR
# ||mov|8,wa|4,endml||; message length|7935
# getarg endml
# getarg WA
        movq endml,WA
# ||jsr|6,syspr|||; print it (prtst not yet usable)|7936
# getarg syspr
        call syspr
        decq rcode
        js   call_2
# ||ppm||||; should not fail|7937
# getarg 
        decq rcode
        jns  l_0057
        movq $299,rcode
        jmp  err_
l_0057:
call_2:
# ||zer|7,xl|||; no fcb chain yet|7938
# getarg XL
        xor  XL,XL
# ||mov|8,wb|18,=num10||; set special code value|7939
# getarg W0
# getarg WB
        .data
l_0058: .long num10
        .text
        movq l_0058,W0
        movq W0,WB
# ||jsr|6,sysej|||; pack up (stopr not yet usable)|7940
# getarg sysej
        call sysej
# |ini09|mov|7,xr|3,statb||; point to static again|7944
ini09:
# getarg statb
# getarg XR
        movq statb,XR
# ||jsr|6,insta|||; initialize static|7945
# getarg insta
        call insta
# ||mov|8,wa|18,=e_hnb||; get number of hash headers|7949
# getarg W0
# getarg WA
        .data
l_0059: .long e_hnb
        .text
        movq l_0059,W0
        movq W0,WA
# ||mti|8,wa|||; convert to integer|7950
# getarg WA
        mov  WA,IA
# ||sti|3,hshnb|||; store for use by gtnvr procedure|7951
# getarg hshnb
        mov  IA,hshnb
# ||lct|8,wa|8,wa||; counter for clearing hash table|7952
# ||mov|3,hshtb|7,xr||; pointer to hash table|7953
# getarg XR
# getarg hshtb
        movq XR,hshtb
# |ini11|zer|10,(xr)+|||; blank a word|7957
ini11:
        mov  $0,W0
        stosq
# ||bct|8,wa|6,ini11||; loop|7958
# getarg WA
# getarg ini11
        decq WA
        jnz  ini11
# ||mov|3,hshte|7,xr||; end of hash table adrs is kept|7959
# getarg XR
# getarg hshte
        movq XR,hshte
# ||mov|3,state|7,xr||; store static end address|7960
# getarg XR
# getarg state
        movq XR,state
# ||mov|8,wc|18,=num01||; table will have only one bucket|7965
# getarg W0
# getarg WC
        .data
l_0060: .long num01
        .text
        movq l_0060,W0
        movq W0,WC
# ||mov|7,xl|21,=nulls||; default table value|7966
# getarg W0
# getarg XL
        movq l_0054,W0
        movq W0,XL
# ||mov|3,r_sfc|7,xl||; current source file name|7967
# getarg XL
# getarg r_sfc
        movq XL,r_sfc
# ||jsr|6,tmake|||; create table|7968
# getarg tmake
        call tmake
# ||mov|3,r_sfn|7,xr||; save ptr to table|7969
# getarg XR
# getarg r_sfn
        movq XR,r_sfn
# ||mov|8,wc|18,=num01||; table will have only one bucket|7975
# getarg W0
# getarg WC
        movq l_0060,W0
        movq W0,WC
# ||mov|7,xl|21,=nulls||; default table value|7976
# getarg W0
# getarg XL
        movq l_0054,W0
        movq W0,XL
# ||jsr|6,tmake|||; create table|7977
# getarg tmake
        call tmake
# ||mov|3,r_inc|7,xr||; save ptr to table|7978
# getarg XR
# getarg r_inc
        movq XR,r_inc
# ||mov|8,wa|18,=ccinm||; maximum nesting level|7983
# getarg W0
# getarg WA
        .data
l_0061: .long ccinm
        .text
        movq l_0061,W0
        movq W0,WA
# ||mov|7,xl|21,=nulls||; null string default value|7984
# getarg W0
# getarg XL
        movq l_0054,W0
        movq W0,XL
# ||jsr|6,vmake|||; create array|7985
# getarg vmake
        call vmake
        decq rcode
        js   call_3
# ||ppm|||||7986
# getarg 
        decq rcode
        jns  l_0062
        movq $299,rcode
        jmp  err_
l_0062:
call_3:
# ||mov|3,r_ifa|7,xr||; save ptr to array|7987
# getarg XR
# getarg r_ifa
        movq XR,r_ifa
# ||mov|8,wa|18,=ccinm||; maximum nesting level|7991
# getarg W0
# getarg WA
        movq l_0061,W0
        movq W0,WA
# ||mov|7,xl|21,=inton||; integer one default value|7992
# getarg W0
# getarg XL
        .data
l_0063: .long inton
        .text
        movq l_0063,W0
        movq W0,XL
# ||jsr|6,vmake|||; create array|7993
# getarg vmake
        call vmake
        decq rcode
        js   call_4
# ||ppm|||||7994
# getarg 
        decq rcode
        jns  l_0064
        movq $299,rcode
        jmp  err_
l_0064:
call_4:
# ||mov|3,r_ifl|7,xr||; save ptr to array|7995
# getarg XR
# getarg r_ifl
        movq XR,r_ifl
# ||mov|7,xl|21,=v_inp||; point to string /input/|8002
# getarg W0
# getarg XL
        .data
l_0065: .long v_inp
        .text
        movq l_0065,W0
        movq W0,XL
# ||mov|8,wb|18,=trtin||; trblk type for input|8003
# getarg W0
# getarg WB
        .data
l_0066: .long trtin
        .text
        movq l_0066,W0
        movq W0,WB
# ||jsr|6,inout|||; perform input association|8004
# getarg inout
        call inout
# ||mov|7,xl|21,=v_oup||; point to string /output/|8005
# getarg W0
# getarg XL
        .data
l_0067: .long v_oup
        .text
        movq l_0067,W0
        movq W0,XL
# ||mov|8,wb|18,=trtou||; trblk type for output|8006
# getarg W0
# getarg WB
        .data
l_0068: .long trtou
        .text
        movq l_0068,W0
        movq W0,WB
# ||jsr|6,inout|||; perform output association|8007
# getarg inout
        call inout
# ||mov|8,wc|3,initr||; terminal flag|8008
# getarg initr
# getarg WC
        movq initr,WC
# ||bze|8,wc|6,ini13||; skip if no terminal|8009
# getarg WC
# getarg ini13
        or   WC,WC
        jz   ini13
# ||jsr|6,prpar|||; associate terminal|8010
# getarg prpar
        call prpar
# ||ejc|||||8011
# |ini13|jsr|6,sysdc|||; call date check|8015
ini13:
# getarg sysdc
        call sysdc
# ||mov|3,flptr|7,xs||; in case stack overflows in compiler|8016
# getarg XT
# getarg flptr
        movq XT,flptr
# ||jsr|6,cmpil|||; call compiler|8020
# getarg cmpil
        call cmpil
# ||mov|3,r_cod|7,xr||; set ptr to first code block|8021
# getarg XR
# getarg r_cod
        movq XR,r_cod
# ||mov|3,r_ttl|21,=nulls||; forget title|8022
# getarg W0
# getarg r_ttl
        movq l_0054,W0
        movq W0,r_ttl
# ||mov|3,r_stl|21,=nulls||; forget sub-title|8023
# getarg W0
# getarg r_stl
        movq l_0054,W0
        movq W0,r_stl
# ||zer|3,r_cim|||; forget compiler input image|8024
# getarg r_cim
        mov  $0,W0
        mov  W0,r_cim
# ||zer|3,r_ccb|||; forget interim code block|8025
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||zer|3,cnind|||; in case end occurred with include|8027
# getarg cnind
        mov  $0,W0
        mov  W0,cnind
# ||zer|3,lstid|||; listing include depth|8028
# getarg lstid
        mov  $0,W0
        mov  W0,lstid
# ||zer|7,xl|||; clear dud value|8030
# getarg XL
        xor  XL,XL
# ||zer|8,wb|||; dont shift dynamic store up|8031
# getarg WB
        xor  WB,WB
# ||zer|3,dnams|||; collect sediment too|8033
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# ||jsr|6,gbcol|||; clear garbage left from compile|8034
# getarg gbcol
        call gbcol
# ||mov|3,dnams|7,xr||; record new sediment size|8035
# getarg XR
# getarg dnams
        movq XR,dnams
# ||bnz|3,cpsts|6,inix0||; skip if no listing of comp stats|8039
# getarg cpsts
# getarg inix0
        xor  W0,W0
        cmpq cpsts,W0
        jnz  inix0
# ||jsr|6,prtpg|||; eject page|8040
# getarg prtpg
        call prtpg
# ||jsr|6,prtmm|||; print memory usage|8044
# getarg prtmm
        call prtmm
# ||mti|3,cmerc|||; get count of errors as integer|8045
# getarg cmerc
        mov  cmerc,IA
# ||mov|7,xr|21,=encm3||; point to /compile errors/|8046
# getarg W0
# getarg XR
        .data
l_0069: .long encm3
        .text
        movq l_0069,W0
        movq W0,XR
# ||jsr|6,prtmi|||; print it|8047
# getarg prtmi
        call prtmi
# ||mti|3,gbcnt|||; garbage collection count|8048
# getarg gbcnt
        mov  gbcnt,IA
# ||sbi|4,intv1|||; adjust for unavoidable collect|8049
# getarg intv1
        sub  intv1,IA
        xor  W0,W0
        seto reg_fl
# ||mov|7,xr|21,=stpm5||; point to /storage regenerations/|8050
# getarg W0
# getarg XR
        .data
l_0070: .long stpm5
        .text
        movq l_0070,W0
        movq W0,XR
# ||jsr|6,prtmi|||; print gbcol count|8051
# getarg prtmi
        call prtmi
# ||jsr|6,systm|||; get time|8052
# getarg systm
        call systm
# ||sbi|3,timsx|||; get compilation time|8053
# getarg timsx
        sub  timsx,IA
        xor  W0,W0
        seto reg_fl
# ||mov|7,xr|21,=encm4||; point to compilation time (msec)/|8054
# getarg W0
# getarg XR
        .data
l_0071: .long encm4
        .text
        movq l_0071,W0
        movq W0,XR
# ||jsr|6,prtmi|||; print message|8055
# getarg prtmi
        call prtmi
# ||add|3,lstlc|18,=num05||; bump line count|8056
# getarg W0
# getarg lstlc
        .data
l_0072: .long num05
        .text
        movq l_0072,W0
        addq W0,lstlc
# ||bze|3,headp|6,inix0||; no eject if nothing printed|8058
# getarg headp
# getarg inix0
        xor  W0,W0
        cmpq headp,W0
        jz   inix0
# ||jsr|6,prtpg|||; eject printer|8059
# getarg prtpg
        call prtpg
# ||ejc|||||8061
# |inix0|bgt|3,cswin|18,=iniln|6,inix1|; skip if not default -in72 used|8067
inix0:
# getarg cswin
# getarg W0
# getarg inix1
        .data
l_0073: .long iniln
        .text
        movq l_0073,W0
        cmpq cswin,W0
        ja   inix1
# ||mov|3,cswin|18,=inils||; else use default record length|8068
# getarg W0
# getarg cswin
        .data
l_0074: .long inils
        .text
        movq l_0074,W0
        movq W0,cswin
# |inix1|jsr|6,systm|||; get time again|8072
inix1:
# getarg systm
        call systm
# ||sti|3,timsx|||; store for end run processing|8073
# getarg timsx
        mov  IA,timsx
# ||zer|3,gbcnt|||; initialise collect count|8074
# getarg gbcnt
        mov  $0,W0
        mov  W0,gbcnt
# ||jsr|6,sysbx|||; call before starting execution|8075
# getarg sysbx
        call sysbx
# ||add|3,noxeq|3,cswex||; add -noexecute flag|8076
# getarg cswex
# getarg W0
# getarg noxeq
        movq cswex,W0
        addq W0,noxeq
# ||bnz|3,noxeq|6,inix2||; jump if execution suppressed|8077
# getarg noxeq
# getarg inix2
        xor  W0,W0
        cmpq noxeq,W0
        jnz  inix2
# |iniy0|mnz|3,headp|||; mark headers out regardless|8087
iniy0:
# getarg headp
        mov  XS,headp
# ||zer|11,-(xs)|||; set failure location on stack|8088
        push $0
# ||mov|3,flptr|7,xs||; save ptr to failure offset word|8089
# getarg XT
# getarg flptr
        movq XT,flptr
# ||mov|7,xr|3,r_cod||; load ptr to entry code block|8090
# getarg r_cod
# getarg XR
        movq r_cod,XR
# ||mov|3,stage|18,=stgxt||; set stage for execute time|8091
# getarg W0
# getarg stage
        .data
l_0075: .long stgxt
        .text
        movq l_0075,W0
        movq W0,stage
# ||mov|3,polcs|18,=num01||; reset interface polling interval|8093
# getarg W0
# getarg polcs
        movq l_0060,W0
        movq W0,polcs
# ||mov|3,polct|18,=num01||; reset interface polling interval|8094
# getarg W0
# getarg polct
        movq l_0060,W0
        movq W0,polct
# ||mov|3,pfnte|3,cmpsn||; copy stmts compiled count in case|8098
# getarg cmpsn
# getarg W0
# getarg pfnte
        movq cmpsn,W0
        movq W0,pfnte
# ||mov|3,pfdmp|3,kvpfl||; start profiling if &profile set|8099
# getarg kvpfl
# getarg W0
# getarg pfdmp
        movq kvpfl,W0
        movq W0,pfdmp
# ||jsr|6,systm|||; time yet again|8100
# getarg systm
        call systm
# ||sti|3,pfstm|||;|8101
# getarg pfstm
        mov  IA,pfstm
# ||jsr|6,stgcc|||; compute stmgo countdown counters|8103
# getarg stgcc
        call stgcc
# ||bri|9,(xr)|||; start xeq with first statement|8104
# getarg (XR)
        jmp  *(XR)
# |inix2|zer|8,wa|||; set abend value to zero|8109
inix2:
# getarg WA
        xor  WA,WA
# ||mov|8,wb|18,=nini9||; set special code value|8117
# getarg W0
# getarg WB
        .data
l_0076: .long nini9
        .text
        movq l_0076,W0
        movq W0,WB
# ||zer|7,xl|||; no fcb chain|8118
# getarg XL
        xor  XL,XL
# ||jsr|6,sysej|||; end of job, exit to system|8119
# getarg sysej
        call sysej
# ||enp||||; end procedure start|8120
# |rstrt|prc|25,e|1,0||; entry point|8124
rstrt:
# getarg 0
# ||mov|7,xs|3,stbas||; discard return|8125
# getarg stbas
# getarg XT
        movq stbas,XT
# ||zer|7,xl|||; clear xl|8126
# getarg XL
        xor  XL,XL
# ||brn|6,iniy0|||; resume execution|8127
# getarg iniy0
        jmp  iniy0
# ||enp||||; end procedure rstrt|8128
# ||ttl|27,s p i t b o l -- snobol4 operator routines||||8130
# ||ejc|||||8150
# |o_add|ent||||; entry point|8154
	.align	2
	nop
o_add:
# ||jsr|6,arith|||; fetch arithmetic operands|8156
# getarg arith
        call arith
        decq rcode
        js   call_5
# ||err|1,001|26,addition left operand is not numeric|||8157
# getarg 001
        decq rcode
        jns  l_0077
        movq $1,rcode
        jmp  err_
l_0077:
# ||err|1,002|26,addition right operand is not numeric|||8158
# getarg 002
        decq rcode
        jns  l_0078
        movq $2,rcode
        jmp  err_
l_0078:
# ||ppm|6,oadd1|||; jump if real operands|8161
# getarg oadd1
# getarg oadd1
        decq rcode
        jns  l_0079
        jmp  oadd1
l_0079:
call_5:
# ||adi|13,icval(xl)|||; add right operand to left|8166
# getarg icval(,XL,8)
        add  icval(,XL,8),IA
        seto reg_fl
# ||ino|6,exint|||; return integer if no overflow|8167
# getarg exint
        ino_ exint
# ||erb|1,003|26,addition caused integer overflow|||8168
        movq $3,rcode
        jmp  err_
# |oadd1|adr|13,rcval(xl)|||; add right operand to left|8174
oadd1:
        mov  XL,W0
        add  8*rcval,W0
        .data
l_0080: .long
        .text
        movq l_0080,W0
        call adr_
# ||rno|6,exrea|||; return real if no overflow|8175
# getarg exrea
        rno_ exrea
# ||erb|1,261|26,addition caused real overflow|||8176
        movq $261,rcode
        jmp  err_
# ||ejc|||||8178
# |o_aff|ent||||; entry point|8182
	.align	2
	nop
o_aff:
# ||mov|7,xr|10,(xs)+||; load operand|8183
# getarg XR
        pop  XR
# ||jsr|6,gtnum|||; convert to numeric|8184
# getarg gtnum
        call gtnum
        decq rcode
        js   call_6
# ||err|1,004|26,affirmation operand is not numeric|||8185
# getarg 004
        decq rcode
        jns  l_0081
        movq $4,rcode
        jmp  err_
l_0081:
call_6:
# ||mov|11,-(xs)|7,xr||; result if converted to numeric|8186
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8187
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8188
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8189
# |o_alt|ent||||; entry point|8193
	.align	2
	nop
o_alt:
# ||mov|7,xr|10,(xs)+||; load right operand|8194
# getarg XR
        pop  XR
# ||jsr|6,gtpat|||; convert to pattern|8195
# getarg gtpat
        call gtpat
        decq rcode
        js   call_7
# ||err|1,005|26,alternation right operand is not pattern|||8196
# getarg 005
        decq rcode
        jns  l_0082
        movq $5,rcode
        jmp  err_
l_0082:
call_7:
# |oalt1|mov|8,wb|22,=p_alt||; set pcode for alternative node|8200
oalt1:
# getarg W0
# getarg WB
        .data
l_0083: .long p_alt
        .text
        movq l_0083,W0
        movq W0,WB
# ||jsr|6,pbild|||; build alternative node|8201
# getarg pbild
        call pbild
# ||mov|7,xl|7,xr||; save address of alternative node|8202
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; load left operand|8203
# getarg XR
        pop  XR
# ||jsr|6,gtpat|||; convert to pattern|8204
# getarg gtpat
        call gtpat
        decq rcode
        js   call_8
# ||err|1,006|26,alternation left operand is not pattern|||8205
# getarg 006
        decq rcode
        jns  l_0084
        movq $6,rcode
        jmp  err_
l_0084:
call_8:
# ||beq|7,xr|22,=p_alt|6,oalt2|; jump if left arg is alternation|8206
# getarg XR
# getarg W0
# getarg oalt2
        movq l_0083,W0
        cmpq XR,W0
        je   oalt2
# ||mov|13,pthen(xl)|7,xr||; set left operand as successor|8207
# getarg XR
# getarg pthen(,XL,8)
        movq XR,pthen(,XL,8)
# ||mov|11,-(xs)|7,xl||; stack result|8208
# getarg XL
        push XL
# ||lcw|7,xr|||; get next code word|8209
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8210
# getarg (XR)
        jmp  *(XR)
# |oalt2|mov|13,pthen(xl)|13,parm1(xr)||; build the (b / c) node|8218
oalt2:
# getarg parm1(,XR,8)
# getarg W0
# getarg pthen(,XL,8)
        movq parm1(,XR,8),W0
        movq W0,pthen(,XL,8)
# ||mov|11,-(xs)|13,pthen(xr)||; set a as new left arg|8219
# getarg pthen(,XR,8)
        push pthen(,XR,8)
# ||mov|7,xr|7,xl||; set (b / c) as new right arg|8220
# getarg XL
# getarg XR
        movq XL,XR
# ||brn|6,oalt1|||; merge back to build a / (b / c)|8221
# getarg oalt1
        jmp  oalt1
# ||ejc|||||8222
# |o_amn|ent||||; entry point|8226
	.align	2
	nop
o_amn:
# ||lcw|7,xr|||; load number of subscripts|8227
# getarg XR
        lcw_ XR
# ||mov|8,wb|7,xr||; set flag for by name|8228
# getarg XR
# getarg WB
        movq XR,WB
# ||brn|6,arref|||; jump to array reference routine|8229
# getarg arref
        jmp  arref
# ||ejc|||||8230
# |o_amv|ent||||; entry point|8234
	.align	2
	nop
o_amv:
# ||lcw|7,xr|||; load number of subscripts|8235
# getarg XR
        lcw_ XR
# ||zer|8,wb|||; set flag for by value|8236
# getarg WB
        xor  WB,WB
# ||brn|6,arref|||; jump to array reference routine|8237
# getarg arref
        jmp  arref
# ||ejc|||||8238
# |o_aon|ent||||; entry point|8242
	.align	2
	nop
o_aon:
# ||mov|7,xr|9,(xs)||; load subscript value|8243
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|7,xl|13,num01(xs)||; load array value|8244
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||mov|8,wa|9,(xl)||; load first word of array operand|8245
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||beq|8,wa|22,=b_vct|6,oaon2|; jump if vector reference|8246
# getarg WA
# getarg W0
# getarg oaon2
        .data
l_0085: .long b_vct
        .text
        movq l_0085,W0
        cmpq WA,W0
        je   oaon2
# ||beq|8,wa|22,=b_tbt|6,oaon3|; jump if table reference|8247
# getarg WA
# getarg W0
# getarg oaon3
        .data
l_0086: .long b_tbt
        .text
        movq l_0086,W0
        cmpq WA,W0
        je   oaon3
# |oaon1|mov|7,xr|18,=num01||; set number of subscripts to one|8251
oaon1:
# getarg W0
# getarg XR
        movq l_0060,W0
        movq W0,XR
# ||mov|8,wb|7,xr||; set flag for by name|8252
# getarg XR
# getarg WB
        movq XR,WB
# ||brn|6,arref|||; jump to array reference routine|8253
# getarg arref
        jmp  arref
# |oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|; use long routine if not integer|8257
oaon2:
# getarg (XR)
# getarg W0
# getarg oaon1
        .data
l_0087: .long b_icl
        .text
        movq l_0087,W0
        cmpq (XR),W0
        jne  oaon1
# ||ldi|13,icval(xr)|||; load integer subscript value|8258
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||mfi|8,wa|6,exfal||; copy as address int, fail if ovflo|8259
# getarg exfal
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   exfal
        mov  IA,WA
# ||bze|8,wa|6,exfal||; fail if zero|8260
# getarg WA
# getarg exfal
        or   WA,WA
        jz   exfal
# ||add|8,wa|18,=vcvlb||; compute offset in words|8261
# getarg W0
# getarg WA
        .data
l_0088: .long vcvlb
        .text
        movq l_0088,W0
        addq W0,WA
# ||wtb|8,wa|||; convert to bytes|8262
# getarg WA
        sal  WA,3
# ||mov|9,(xs)|8,wa||; complete name on stack|8263
# getarg WA
# getarg (XT)
        movq WA,(XT)
# ||blt|8,wa|13,vclen(xl)|6,oaon4|; exit if subscript not too large|8264
# getarg WA
# getarg vclen(,XL,8)
# getarg oaon4
        cmpq WA,vclen(,XL,8)
        jb   oaon4
# ||brn|6,exfal|||; else fail|8265
# getarg exfal
        jmp  exfal
# |oaon3|mnz|8,wb|||; set flag for name reference|8269
oaon3:
# getarg WB
        mov  XS,WB
# ||jsr|6,tfind|||; locate/create table element|8270
# getarg tfind
        call tfind
        decq rcode
        js   call_9
# ||ppm|6,exfal|||; fail if access fails|8271
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0089
        jmp  exfal
l_0089:
call_9:
# ||mov|13,num01(xs)|7,xl||; store name base on stack|8272
# getarg XL
# getarg num01(,XT,8)
        movq XL,num01(,XT,8)
# ||mov|9,(xs)|8,wa||; store name offset on stack|8273
# getarg WA
# getarg (XT)
        movq WA,(XT)
# |oaon4|lcw|7,xr|||; result on stack, get code word|8277
oaon4:
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8278
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8279
# |o_aov|ent||||; entry point|8283
	.align	2
	nop
o_aov:
# ||mov|7,xr|10,(xs)+||; load subscript value|8284
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; load array value|8285
# getarg XL
        pop  XL
# ||mov|8,wa|9,(xl)||; load first word of array operand|8286
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||beq|8,wa|22,=b_vct|6,oaov2|; jump if vector reference|8287
# getarg WA
# getarg W0
# getarg oaov2
        movq l_0085,W0
        cmpq WA,W0
        je   oaov2
# ||beq|8,wa|22,=b_tbt|6,oaov3|; jump if table reference|8288
# getarg WA
# getarg W0
# getarg oaov3
        movq l_0086,W0
        cmpq WA,W0
        je   oaov3
# |oaov1|mov|11,-(xs)|7,xl||; restack array value|8292
oaov1:
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; restack subscript|8293
# getarg XR
        push XR
# ||mov|7,xr|18,=num01||; set number of subscripts to one|8294
# getarg W0
# getarg XR
        movq l_0060,W0
        movq W0,XR
# ||zer|8,wb|||; set flag for value call|8295
# getarg WB
        xor  WB,WB
# ||brn|6,arref|||; jump to array reference routine|8296
# getarg arref
        jmp  arref
# |oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|; use long routine if not integer|8300
oaov2:
# getarg (XR)
# getarg W0
# getarg oaov1
        movq l_0087,W0
        cmpq (XR),W0
        jne  oaov1
# ||ldi|13,icval(xr)|||; load integer subscript value|8301
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||mfi|8,wa|6,exfal||; move as one word int, fail if ovflo|8302
# getarg exfal
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   exfal
        mov  IA,WA
# ||bze|8,wa|6,exfal||; fail if zero|8303
# getarg WA
# getarg exfal
        or   WA,WA
        jz   exfal
# ||add|8,wa|18,=vcvlb||; compute offset in words|8304
# getarg W0
# getarg WA
        movq l_0088,W0
        addq W0,WA
# ||wtb|8,wa|||; convert to bytes|8305
# getarg WA
        sal  WA,3
# ||bge|8,wa|13,vclen(xl)|6,exfal|; fail if subscript too large|8306
# getarg WA
# getarg vclen(,XL,8)
# getarg exfal
        cmpq WA,vclen(,XL,8)
        jae  exfal
# ||jsr|6,acess|||; access value|8307
# getarg acess
        call acess
        decq rcode
        js   call_10
# ||ppm|6,exfal|||; fail if access fails|8308
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0090
        jmp  exfal
l_0090:
call_10:
# ||mov|11,-(xs)|7,xr||; stack result|8309
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8310
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8311
# getarg (XR)
        jmp  *(XR)
# |oaov3|zer|8,wb|||; set flag for value reference|8315
oaov3:
# getarg WB
        xor  WB,WB
# ||jsr|6,tfind|||; call table search routine|8316
# getarg tfind
        call tfind
        decq rcode
        js   call_11
# ||ppm|6,exfal|||; fail if access fails|8317
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0091
        jmp  exfal
l_0091:
call_11:
# ||mov|11,-(xs)|7,xr||; stack result|8318
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8319
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8320
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8321
# |o_ass|ent||||; entry point|8325
	.align	2
	nop
o_ass:
# |oass0|mov|8,wb|10,(xs)+||; load value to be assigned|8329
oass0:
# getarg WB
        pop  WB
# ||mov|8,wa|10,(xs)+||; load name offset|8330
# getarg WA
        pop  WA
# ||mov|7,xl|9,(xs)||; load name base|8331
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|9,(xs)|8,wb||; store assigned value as result|8332
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||jsr|6,asign|||; perform assignment|8333
# getarg asign
        call asign
        decq rcode
        js   call_12
# ||ppm|6,exfal|||; fail if assignment fails|8334
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0092
        jmp  exfal
l_0092:
call_12:
# ||lcw|7,xr|||; result on stack, get code word|8335
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8336
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8337
# |o_cer|ent||||; entry point|8341
	.align	2
	nop
o_cer:
# ||erb|1,007|26,compilation error encountered during execution|||8342
        movq $7,rcode
        jmp  err_
# ||ejc|||||8343
# |o_cas|ent||||; entry point|8347
	.align	2
	nop
o_cas:
# ||mov|8,wc|10,(xs)+||; load name offset (parm2)|8348
# getarg WC
        pop  WC
# ||mov|7,xr|10,(xs)+||; load name base (parm1)|8349
# getarg XR
        pop  XR
# ||mov|8,wb|22,=p_cas||; set pcode for cursor assignment|8350
# getarg W0
# getarg WB
        .data
l_0093: .long p_cas
        .text
        movq l_0093,W0
        movq W0,WB
# ||jsr|6,pbild|||; build node|8351
# getarg pbild
        call pbild
# ||mov|11,-(xs)|7,xr||; stack result|8352
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8353
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8354
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8355
# |o_cnc|ent||||; entry point|8359
	.align	2
	nop
o_cnc:
# ||mov|7,xr|9,(xs)||; load right argument|8360
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||beq|7,xr|21,=nulls|6,ocnc3|; jump if right arg is null|8361
# getarg XR
# getarg W0
# getarg ocnc3
        movq l_0054,W0
        cmpq XR,W0
        je   ocnc3
# ||mov|7,xl|12,1(xs)||; load left argument|8362
# getarg 1(,XT,8)
# getarg XL
        movq 1(,XT,8),XL
# ||beq|7,xl|21,=nulls|6,ocnc4|; jump if left argument is null|8363
# getarg XL
# getarg W0
# getarg ocnc4
        movq l_0054,W0
        cmpq XL,W0
        je   ocnc4
# ||mov|8,wa|22,=b_scl||; get constant to test for string|8364
# getarg W0
# getarg WA
        .data
l_0094: .long b_scl
        .text
        movq l_0094,W0
        movq W0,WA
# ||bne|8,wa|9,(xl)|6,ocnc2|; jump if left arg not a string|8365
# getarg WA
# getarg (XL)
# getarg ocnc2
        cmpq WA,(XL)
        jne  ocnc2
# ||bne|8,wa|9,(xr)|6,ocnc2|; jump if right arg not a string|8366
# getarg WA
# getarg (XR)
# getarg ocnc2
        cmpq WA,(XR)
        jne  ocnc2
# |ocnc1|mov|8,wa|13,sclen(xl)||; load left argument length|8370
ocnc1:
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||add|8,wa|13,sclen(xr)||; compute result length|8371
# getarg sclen(,XR,8)
# getarg WA
        addq sclen(,XR,8),WA
# ||jsr|6,alocs|||; allocate scblk for result|8372
# getarg alocs
        call alocs
# ||mov|12,1(xs)|7,xr||; store result ptr over left argument|8373
# getarg XR
# getarg 1(,XT,8)
        movq XR,1(,XT,8)
# ||psc|7,xr|||; prepare to store chars of result|8374
# getarg XR
        add  $cfp_f,XR
# ||mov|8,wa|13,sclen(xl)||; get number of chars in left arg|8375
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||plc|7,xl|||; prepare to load left arg chars|8376
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move characters of left argument|8377
        rep
        movsb
# ||mov|7,xl|10,(xs)+||; load right arg pointer, pop stack|8378
# getarg XL
        pop  XL
# ||mov|8,wa|13,sclen(xl)||; load number of chars in right arg|8379
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||plc|7,xl|||; prepare to load right arg chars|8380
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move characters of right argument|8381
        rep
        movsb
# ||zer|7,xl|||; clear garbage value in xl|8382
# getarg XL
        xor  XL,XL
# ||lcw|7,xr|||; result on stack, get code word|8383
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8384
# getarg (XR)
        jmp  *(XR)
# |ocnc2|jsr|6,gtstg|||; convert right arg to string|8388
ocnc2:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_13
# ||ppm|6,ocnc5|||; jump if right arg is not string|8389
# getarg ocnc5
# getarg ocnc5
        decq rcode
        jns  l_0097
        jmp  ocnc5
l_0097:
call_13:
# ||mov|7,xl|7,xr||; save right arg ptr|8390
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtstg|||; convert left arg to string|8391
# getarg gtstg
        call gtstg
        decq rcode
        js   call_14
# ||ppm|6,ocnc6|||; jump if left arg is not a string|8392
# getarg ocnc6
# getarg ocnc6
        decq rcode
        jns  l_0098
        jmp  ocnc6
l_0098:
call_14:
# ||mov|11,-(xs)|7,xr||; stack left argument|8393
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xl||; stack right argument|8394
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; move left arg to proper reg|8395
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; move right arg to proper reg|8396
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||brn|6,ocnc1|||; merge back to concatenate strings|8397
# getarg ocnc1
        jmp  ocnc1
# ||ejc|||||8398
# |ocnc3|ica|7,xs|||; remove right arg from stack|8404
ocnc3:
# getarg XT
        addq $8,XT
# ||lcw|7,xr|||; left argument on stack|8405
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8406
# getarg (XR)
        jmp  *(XR)
# |ocnc4|ica|7,xs|||; unstack one argument|8410
ocnc4:
# getarg XT
        addq $8,XT
# ||mov|9,(xs)|7,xr||; store right argument|8411
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||lcw|7,xr|||; result on stack, get code word|8412
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8413
# getarg (XR)
        jmp  *(XR)
# |ocnc5|mov|7,xl|7,xr||; move right argument ptr|8417
ocnc5:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; load left arg pointer|8418
# getarg XR
        pop  XR
# |ocnc6|jsr|6,gtpat|||; convert left arg to pattern|8422
ocnc6:
# getarg gtpat
        call gtpat
        decq rcode
        js   call_15
# ||err|1,008|26,concatenation left operand is not a string or pattern|||8423
# getarg 008
        decq rcode
        jns  l_0099
        movq $8,rcode
        jmp  err_
l_0099:
call_15:
# ||mov|11,-(xs)|7,xr||; save result on stack|8424
# getarg XR
        push XR
# ||mov|7,xr|7,xl||; point to right operand|8425
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,gtpat|||; convert to pattern|8426
# getarg gtpat
        call gtpat
        decq rcode
        js   call_16
# ||err|1,009|26,concatenation right operand is not a string or pattern|||8427
# getarg 009
        decq rcode
        jns  l_0100
        movq $9,rcode
        jmp  err_
l_0100:
call_16:
# ||mov|7,xl|7,xr||; move for pconc|8428
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; reload left operand ptr|8429
# getarg XR
        pop  XR
# ||jsr|6,pconc|||; concatenate patterns|8430
# getarg pconc
        call pconc
# ||mov|11,-(xs)|7,xr||; stack result|8431
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8432
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8433
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8434
# |o_com|ent||||; entry point|8438
	.align	2
	nop
o_com:
# ||mov|7,xr|10,(xs)+||; load operand|8439
# getarg XR
        pop  XR
# ||mov|8,wa|9,(xr)||; load type word|8440
# getarg (XR)
# getarg WA
        movq (XR),WA
# |ocom1|beq|8,wa|22,=b_icl|6,ocom2|; jump if integer|8444
ocom1:
# getarg WA
# getarg W0
# getarg ocom2
        movq l_0087,W0
        cmpq WA,W0
        je   ocom2
# ||beq|8,wa|22,=b_rcl|6,ocom3|; jump if real|8447
# getarg WA
# getarg W0
# getarg ocom3
        .data
l_0101: .long b_rcl
        .text
        movq l_0101,W0
        cmpq WA,W0
        je   ocom3
# ||jsr|6,gtnum|||; else convert to numeric|8449
# getarg gtnum
        call gtnum
        decq rcode
        js   call_17
# ||err|1,010|26,negation operand is not numeric|||8450
# getarg 010
        decq rcode
        jns  l_0102
        movq $10,rcode
        jmp  err_
l_0102:
call_17:
# ||brn|6,ocom1|||; back to check cases|8451
# getarg ocom1
        jmp  ocom1
# |ocom2|ldi|13,icval(xr)|||; load integer value|8455
ocom2:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||ngi||||; negate|8456
        neg  IA
        seto reg_fl
# ||ino|6,exint|||; return integer if no overflow|8457
# getarg exint
        ino_ exint
# ||erb|1,011|26,negation caused integer overflow|||8458
        movq $11,rcode
        jmp  err_
# |ocom3|ldr|13,rcval(xr)|||; load real value|8464
ocom3:
        mov  XR,W0
        add  8*rcval,W0
        .data
l_0103: .long
        .text
        movq l_0103,W0
        call ldr_
# ||ngr||||; negate|8465
        call ngr_
# ||brn|6,exrea|||; return real result|8466
# getarg exrea
        jmp  exrea
# ||ejc|||||8468
# |o_dvd|ent||||; entry point|8472
	.align	2
	nop
o_dvd:
# ||jsr|6,arith|||; fetch arithmetic operands|8473
# getarg arith
        call arith
        decq rcode
        js   call_18
# ||err|1,012|26,division left operand is not numeric|||8474
# getarg 012
        decq rcode
        jns  l_0104
        movq $12,rcode
        jmp  err_
l_0104:
# ||err|1,013|26,division right operand is not numeric|||8475
# getarg 013
        decq rcode
        jns  l_0105
        movq $13,rcode
        jmp  err_
l_0105:
# ||ppm|6,odvd2|||; jump if real operands|8478
# getarg odvd2
# getarg odvd2
        decq rcode
        jns  l_0106
        jmp  odvd2
l_0106:
call_18:
# ||dvi|13,icval(xl)|||; divide left operand by right|8483
# getarg icval(,XL,8)
        mov  icval(,XL,8),W0
        call dvi__
# ||ino|6,exint|||; result ok if no overflow|8484
# getarg exint
        ino_ exint
# ||erb|1,014|26,division caused integer overflow|||8485
        movq $14,rcode
        jmp  err_
# |odvd2|dvr|13,rcval(xl)|||; divide left operand by right|8491
odvd2:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call dvr_
# ||rno|6,exrea|||; return real if no overflow|8492
# getarg exrea
        rno_ exrea
# ||erb|1,262|26,division caused real overflow|||8493
        movq $262,rcode
        jmp  err_
# ||ejc|||||8495
# |o_exp|ent||||; entry point|8499
	.align	2
	nop
o_exp:
# ||mov|7,xr|10,(xs)+||; load exponent|8500
# getarg XR
        pop  XR
# ||jsr|6,gtnum|||; convert to number|8501
# getarg gtnum
        call gtnum
        decq rcode
        js   call_19
# ||err|1,015|26,exponentiation right operand is not numeric|||8502
# getarg 015
        decq rcode
        jns  l_0107
        movq $15,rcode
        jmp  err_
l_0107:
call_19:
# ||mov|7,xl|7,xr||; move exponent to xl|8503
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; load base|8504
# getarg XR
        pop  XR
# ||jsr|6,gtnum|||; convert to numeric|8505
# getarg gtnum
        call gtnum
        decq rcode
        js   call_20
# ||err|1,016|26,exponentiation left operand is not numeric|||8506
# getarg 016
        decq rcode
        jns  l_0108
        movq $16,rcode
        jmp  err_
l_0108:
call_20:
# ||beq|9,(xl)|22,=b_rcl|6,oexp7|; jump if real exponent|8509
# getarg (XL)
# getarg W0
# getarg oexp7
        movq l_0101,W0
        cmpq (XL),W0
        je   oexp7
# ||ldi|13,icval(xl)|||; load exponent|8511
# getarg icval(,XL,8)
        mov  icval(,XL,8),IA
# ||ilt|6,oex12|||; jump if negative exponent|8512
# getarg oex12
        mov  IA,W0
        or   W0,W0
        jl   oex12
# ||beq|8,wa|22,=b_rcl|6,oexp3|; jump if base is real|8515
# getarg WA
# getarg W0
# getarg oexp3
        movq l_0101,W0
        cmpq WA,W0
        je   oexp3
# ||mfi|8,wa|6,oexp2||; convert exponent to 1 word integer|8520
# getarg oexp2
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   oexp2
        mov  IA,WA
# ||lct|8,wa|8,wa||; set loop counter|8521
# ||ldi|13,icval(xr)|||; load base as initial value|8522
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||bnz|8,wa|6,oexp1||; jump into loop if non-zero exponent|8523
# getarg WA
# getarg WA
# getarg oexp1
        or   WA,WA
        jnz  oexp1
# ||ieq|6,oexp4|||; error if 0**0|8524
# getarg oexp4
        mov  IA,W0
        or   W0,W0
        je   oexp4
# ||ldi|4,intv1|||; nonzero**0|8525
# getarg intv1
        mov  intv1,IA
# ||brn|6,exint|||; give one as result for nonzero**0|8526
# getarg exint
        jmp  exint
# |oex13|mli|13,icval(xr)|||; multiply by base|8530
oex13:
# getarg icval(,XR,8)
        imul icval(,XR,8),IA
        seto reg_fl
# ||iov|6,oexp2|||; jump if overflow|8531
# getarg oexp2
        iov_ oexp2
# |oexp1|bct|8,wa|6,oex13||; loop if more to go|8532
oexp1:
# getarg WA
# getarg oex13
        decq WA
        jnz  oex13
# ||brn|6,exint|||; else return integer result|8533
# getarg exint
        jmp  exint
# |oexp2|erb|1,017|26,exponentiation caused integer overflow|||8537
oexp2:
        movq $17,rcode
        jmp  err_
# ||ejc|||||8538
# |oexp3|mfi|8,wa|6,oexp6||; convert exponent to one word|8546
oexp3:
# getarg oexp6
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   oexp6
        mov  IA,WA
# ||lct|8,wa|8,wa||; set loop counter|8547
# ||ldr|13,rcval(xr)|||; load base as initial value|8548
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||bnz|8,wa|6,oexp5||; jump into loop if non-zero exponent|8549
# getarg WA
# getarg WA
# getarg oexp5
        or   WA,WA
        jnz  oexp5
# ||req|6,oexp4|||; error if 0.0**0|8550
# getarg oexp4
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        je   oexp4
# ||ldr|4,reav1|||; nonzero**0|8551
        movq l_0043,W0
        call ldr_
# ||brn|6,exrea|||; return 1.0 if nonzero**zero|8552
# getarg exrea
        jmp  exrea
# |oexp4|erb|1,018|26,exponentiation result is undefined|||8557
oexp4:
        movq $18,rcode
        jmp  err_
# |oex14|mlr|13,rcval(xr)|||; multiply by base|8563
oex14:
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call mlr_
# ||rov|6,oexp6|||; jump if overflow|8564
# getarg oexp6
        rov_ oexp6
# |oexp5|bct|8,wa|6,oex14||; loop till computation complete|8565
oexp5:
# getarg WA
# getarg oex14
        decq WA
        jnz  oex14
# ||brn|6,exrea|||; then return real result|8566
# getarg exrea
        jmp  exrea
# |oexp6|erb|1,266|26,exponentiation caused real overflow|||8570
oexp6:
        movq $266,rcode
        jmp  err_
# |oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|; jump if base real|8575
oexp7:
# getarg (XR)
# getarg W0
# getarg oexp8
        movq l_0101,W0
        cmpq (XR),W0
        je   oexp8
# ||ldi|13,icval(xr)|||; load integer base|8576
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||itr||||; convert to real|8577
        call itr_
# ||jsr|6,rcbld|||; create real in (xr)|8578
# getarg rcbld
        call rcbld
# |oexp8|zer|8,wb|||; set positive result flag|8583
oexp8:
# getarg WB
        xor  WB,WB
# ||ldr|13,rcval(xr)|||; load base to ra|8584
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||rne|6,oexp9|||; jump if base non-zero|8585
# getarg oexp9
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jne  oexp9
# ||ldr|13,rcval(xl)|||; base is zero.	 check exponent|8586
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call ldr_
# ||req|6,oexp4|||; jump if 0.0 ** 0.0|8587
# getarg oexp4
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        je   oexp4
# ||ldr|4,reav0|||; 0.0 to non-zero exponent yields 0.0|8588
        .data
l_0109: .long
        .text
        movq l_0109,W0
        call ldr_
# ||brn|6,exrea|||; return zero result|8589
# getarg exrea
        jmp  exrea
# |oexp9|rgt|6,oex10|||; jump if base gt 0.0|8595
oexp9:
# getarg oex10
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jg   oex10
# ||ngr||||; make base positive|8596
        call ngr_
# ||jsr|6,rcbld|||; create positive base in (xr)|8597
# getarg rcbld
        call rcbld
# ||ldr|13,rcval(xl)|||; examine exponent|8598
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call ldr_
# ||chp||||; chop to integral value|8599
        call chp_
# ||rti|6,oexp6|||; convert to integer, br if too large|8600
# getarg oexp6
        rti_
        jc   oexp6
# ||sbr|13,rcval(xl)|||; chop(exponent) - exponent|8601
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call sbr_
# ||rne|6,oex11|||; non-integral power with neg base|8602
# getarg oex11
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jne  oex11
# ||mfi|8,wb|||; record even/odd exponent|8603
# getarg WB
        mov  IA,WB
# ||anb|8,wb|4,bits1||; odd exponent yields negative result|8604
# getarg WB
# getarg bits1
        and  WB,bits1
# ||ldr|13,rcval(xr)|||; restore base to ra|8605
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# |oex10|lnf||||; log of base|8609
oex10:
        call lnf_
# ||rov|6,oexp6|||; too large|8610
# getarg oexp6
        rov_ oexp6
# ||mlr|13,rcval(xl)|||; times exponent|8611
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call mlr_
# ||rov|6,oexp6|||; too large|8612
# getarg oexp6
        rov_ oexp6
# ||etx||||; e ** (exponent * ln(base))|8613
        call etx_
# ||rov|6,oexp6|||; too large|8614
# getarg oexp6
        rov_ oexp6
# ||bze|8,wb|6,exrea||; if no sign fixup required|8615
# getarg WB
# getarg exrea
        or   WB,WB
        jz   exrea
# ||ngr||||; negative result needed|8616
        call ngr_
# ||brn|6,exrea|||;|8617
# getarg exrea
        jmp  exrea
# |oex11|erb|1,311|26,exponentiation of negative base to non-integral power|||8621
oex11:
        movq $311,rcode
        jmp  err_
# |oex12|mov|11,-(xs)|7,xr||; stack base|8630
oex12:
# getarg XR
        push XR
# ||itr||||; convert to real exponent|8631
        call itr_
# ||jsr|6,rcbld|||; real negative exponent in (xr)|8632
# getarg rcbld
        call rcbld
# ||mov|7,xl|7,xr||; put exponent in xl|8633
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; restore base value|8634
# getarg XR
        pop  XR
# ||brn|6,oexp7|||; process real exponent|8635
# getarg oexp7
        jmp  oexp7
# ||ejc|||||8639
# |o_fex|ent||||; entry point|8647
	.align	2
	nop
o_fex:
# ||brn|6,evlx6|||; jump to failure loc in evalx|8648
# getarg evlx6
        jmp  evlx6
# ||ejc|||||8649
# |o_fif|ent||||; entry point|8653
	.align	2
	nop
o_fif:
# ||erb|1,020|26,goto evaluation failure|||8654
        movq $20,rcode
        jmp  err_
# ||ejc|||||8655
# |o_fnc|ent||||; entry point|8659
	.align	2
	nop
o_fnc:
# ||lcw|8,wa|||; load number of arguments|8660
# getarg WA
        lcw_ WA
# ||lcw|7,xr|||; load function vrblk pointer|8661
# getarg XR
        lcw_ XR
# ||mov|7,xl|13,vrfnc(xr)||; load function pointer|8662
# getarg vrfnc(,XR,8)
# getarg XL
        movq vrfnc(,XR,8),XL
# ||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num|8663
# getarg WA
# getarg fargs(,XL,8)
# getarg cfunc
        cmpq WA,fargs(,XL,8)
        jne  cfunc
# ||bri|9,(xl)|||; jump to function if arg count ok|8664
# getarg (XL)
        jmp  *(XL)
# ||ejc|||||8665
# |o_fne|ent||||; entry point|8669
	.align	2
	nop
o_fne:
# ||lcw|8,wa|||; get next code word|8670
# getarg WA
        lcw_ WA
# ||bne|8,wa|21,=ornm_|6,ofne1|; fail if not evaluating expression|8671
# getarg WA
# getarg W0
# getarg ofne1
        .data
l_0110: .long ornm_
        .text
        movq l_0110,W0
        cmpq WA,W0
        jne  ofne1
# ||bze|13,num02(xs)|6,evlx3||; ok if expr. was wanted by value|8672
# getarg num02(,XT,8)
# getarg evlx3
        xor  W0,W0
        cmpq num02(,XT,8),W0
        jz   evlx3
# |ofne1|erb|1,021|26,function called by name returned a value|||8676
ofne1:
        movq $21,rcode
        jmp  err_
# ||ejc|||||8677
# |o_fns|ent||||; entry point|8681
	.align	2
	nop
o_fns:
# ||lcw|7,xr|||; load function vrblk pointer|8682
# getarg XR
        lcw_ XR
# ||mov|8,wa|18,=num01||; set number of arguments to one|8683
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# ||mov|7,xl|13,vrfnc(xr)||; load function pointer|8684
# getarg vrfnc(,XR,8)
# getarg XL
        movq vrfnc(,XR,8),XL
# ||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num|8685
# getarg WA
# getarg fargs(,XL,8)
# getarg cfunc
        cmpq WA,fargs(,XL,8)
        jne  cfunc
# ||bri|9,(xl)|||; jump to function if arg count ok|8686
# getarg (XL)
        jmp  *(XL)
# ||ejc|||||8687
# |o_fun|ent||||; entry point|8690
	.align	2
	nop
o_fun:
# ||erb|1,022|26,undefined function called|||8691
        movq $22,rcode
        jmp  err_
# ||ejc|||||8692
# |o_goc|ent||||; entry point|8696
	.align	2
	nop
o_goc:
# ||mov|7,xr|13,num01(xs)||; load name base pointer|8697
# getarg num01(,XT,8)
# getarg XR
        movq num01(,XT,8),XR
# ||bhi|7,xr|3,state|6,ogoc1|; jump if not natural variable|8698
# getarg XR
# getarg state
# getarg ogoc1
        cmpq XR,state
        ja   ogoc1
# ||add|7,xr|19,*vrtra||; else point to vrtra field|8699
# getarg W0
# getarg XR
        .data
l_0111: .long 8*vrtra
        .text
        movq l_0111,W0
        addq W0,XR
# ||bri|9,(xr)|||; and jump through it|8700
# getarg (XR)
        jmp  *(XR)
# |ogoc1|erb|1,023|26,goto operand is not a natural variable|||8704
ogoc1:
        movq $23,rcode
        jmp  err_
# ||ejc|||||8705
# |o_god|ent||||; entry point|8709
	.align	2
	nop
o_god:
# ||mov|7,xr|9,(xs)||; load operand|8710
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|8,wa|9,(xr)||; load first word|8711
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_cds|6,bcds0|; jump if code block to code routine|8712
# getarg WA
# getarg W0
# getarg bcds0
        .data
l_0112: .long b_cds
        .text
        movq l_0112,W0
        cmpq WA,W0
        je   bcds0
# ||beq|8,wa|22,=b_cdc|6,bcdc0|; jump if code block to code routine|8713
# getarg WA
# getarg W0
# getarg bcdc0
        movq l_0012,W0
        cmpq WA,W0
        je   bcdc0
# ||erb|1,024|26,goto operand in direct goto is not code|||8714
        movq $24,rcode
        jmp  err_
# ||ejc|||||8715
# |o_gof|ent||||; entry point|8722
	.align	2
	nop
o_gof:
# ||mov|7,xr|3,flptr||; point to fail offset on stack|8723
# getarg flptr
# getarg XR
        movq flptr,XR
# ||ica|9,(xr)|||; point failure to o_fif word|8724
# getarg (XR)
        addq $8,(XR)
# ||icp||||; point to next code word|8725
        icp_
# ||lcw|7,xr|||; fetch next code word|8726
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8727
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8728
# |o_ima|ent||||; entry point|8736
	.align	2
	nop
o_ima:
# ||mov|8,wb|22,=p_imc||; set pcode for last node|8737
# getarg W0
# getarg WB
        .data
l_0113: .long p_imc
        .text
        movq l_0113,W0
        movq W0,WB
# ||mov|8,wc|10,(xs)+||; pop name offset (parm2)|8738
# getarg WC
        pop  WC
# ||mov|7,xr|10,(xs)+||; pop name base (parm1)|8739
# getarg XR
        pop  XR
# ||jsr|6,pbild|||; build p_imc node|8740
# getarg pbild
        call pbild
# ||mov|7,xl|7,xr||; save ptr to node|8741
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; load left argument|8742
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||jsr|6,gtpat|||; convert to pattern|8743
# getarg gtpat
        call gtpat
        decq rcode
        js   call_21
# ||err|1,025|26,immediate assignment left operand is not pattern|||8744
# getarg 025
        decq rcode
        jns  l_0114
        movq $25,rcode
        jmp  err_
l_0114:
call_21:
# ||mov|9,(xs)|7,xr||; save ptr to left operand pattern|8745
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|8,wb|22,=p_ima||; set pcode for first node|8746
# getarg W0
# getarg WB
        .data
l_0115: .long p_ima
        .text
        movq l_0115,W0
        movq W0,WB
# ||jsr|6,pbild|||; build p_ima node|8747
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_ima successor|8748
# getarg pthen(,XR,8)
        pop  pthen(,XR,8)
# ||jsr|6,pconc|||; concatenate to form final pattern|8749
# getarg pconc
        call pconc
# ||mov|11,-(xs)|7,xr||; stack result|8750
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8751
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8752
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8753
# |o_inn|ent||||; entry point|8757
	.align	2
	nop
o_inn:
# ||mnz|8,wb|||; set flag for result by name|8758
# getarg WB
        mov  XS,WB
# ||brn|6,indir|||; jump to common routine|8759
# getarg indir
        jmp  indir
# ||ejc|||||8760
# |o_int|ent||||; entry point|8764
	.align	2
	nop
o_int:
# ||mov|9,(xs)|21,=nulls||; replace operand with null|8765
# getarg W0
# getarg (XT)
        movq l_0054,W0
        movq W0,(XT)
# ||lcw|7,xr|||; get next code word|8766
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8767
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8768
# |o_inv|ent||||; entry point|8772
	.align	2
	nop
o_inv:
# ||zer|8,wb|||; set flag for by value|8773
# getarg WB
        xor  WB,WB
# ||brn|6,indir|||; jump to common routine|8774
# getarg indir
        jmp  indir
# ||ejc|||||8775
# |o_kwn|ent||||; entry point|8779
	.align	2
	nop
o_kwn:
# ||jsr|6,kwnam|||; get keyword name|8780
# getarg kwnam
        call kwnam
# ||brn|6,exnam|||; exit with result name|8781
# getarg exnam
        jmp  exnam
# ||ejc|||||8782
# |o_kwv|ent||||; entry point|8786
	.align	2
	nop
o_kwv:
# ||jsr|6,kwnam|||; get keyword name|8787
# getarg kwnam
        call kwnam
# ||mov|3,dnamp|7,xr||; delete kvblk|8788
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||jsr|6,acess|||; access value|8789
# getarg acess
        call acess
        decq rcode
        js   call_22
# ||ppm|6,exnul|||; dummy (unused) failure return|8790
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0116
        jmp  exnul
l_0116:
call_22:
# ||mov|11,-(xs)|7,xr||; stack result|8791
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8792
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8793
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8794
# |o_lex|ent||||; entry point|8798
	.align	2
	nop
o_lex:
# ||mov|8,wa|19,*evsi_||; set size of evblk|8799
# getarg W0
# getarg WA
        .data
l_0117: .long 8*evsi_
        .text
        movq l_0117,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for evblk|8800
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_evt||; set type word|8801
# getarg W0
# getarg (XR)
        .data
l_0118: .long b_evt
        .text
        movq l_0118,W0
        movq W0,(XR)
# ||mov|13,evvar(xr)|21,=trbev||; set dummy trblk pointer|8802
# getarg W0
# getarg evvar(,XR,8)
        .data
l_0119: .long trbev
        .text
        movq l_0119,W0
        movq W0,evvar(,XR,8)
# ||lcw|8,wa|||; load exblk pointer|8803
# getarg WA
        lcw_ WA
# ||mov|13,evexp(xr)|8,wa||; set exblk pointer|8804
# getarg WA
# getarg evexp(,XR,8)
        movq WA,evexp(,XR,8)
# ||mov|7,xl|7,xr||; move name base to proper reg|8805
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*evvar||; set name offset = zero|8806
# getarg W0
# getarg WA
        .data
l_0120: .long 8*evvar
        .text
        movq l_0120,W0
        movq W0,WA
# ||brn|6,exnam|||; exit with name in (xl,wa)|8807
# getarg exnam
        jmp  exnam
# ||ejc|||||8808
# |o_lpt|ent||||; entry point|8812
	.align	2
	nop
o_lpt:
# ||lcw|7,xr|||; load pattern pointer|8813
# getarg XR
        lcw_ XR
# ||mov|11,-(xs)|7,xr||; stack result|8814
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8815
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8816
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8817
# |o_lvn|ent||||; entry point|8821
	.align	2
	nop
o_lvn:
# ||lcw|8,wa|||; load vrblk pointer|8822
# getarg WA
        lcw_ WA
# ||mov|11,-(xs)|8,wa||; stack vrblk ptr (name base)|8823
# getarg WA
        push WA
# ||mov|11,-(xs)|19,*vrval||; stack name offset|8824
# getarg W0
        .data
l_0121: .long 8*vrval
        .text
        movq l_0121,W0
        push W0
# ||lcw|7,xr|||; get next code word|8825
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8826
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8827
# |o_mlt|ent||||; entry point|8831
	.align	2
	nop
o_mlt:
# ||jsr|6,arith|||; fetch arithmetic operands|8832
# getarg arith
        call arith
        decq rcode
        js   call_23
# ||err|1,026|26,multiplication left operand is not numeric|||8833
# getarg 026
        decq rcode
        jns  l_0122
        movq $26,rcode
        jmp  err_
l_0122:
# ||err|1,027|26,multiplication right operand is not numeric|||8834
# getarg 027
        decq rcode
        jns  l_0123
        movq $27,rcode
        jmp  err_
l_0123:
# ||ppm|6,omlt1|||; jump if real operands|8837
# getarg omlt1
# getarg omlt1
        decq rcode
        jns  l_0124
        jmp  omlt1
l_0124:
call_23:
# ||mli|13,icval(xl)|||; multiply left operand by right|8842
# getarg icval(,XL,8)
        imul icval(,XL,8),IA
        seto reg_fl
# ||ino|6,exint|||; return integer if no overflow|8843
# getarg exint
        ino_ exint
# ||erb|1,028|26,multiplication caused integer overflow|||8844
        movq $28,rcode
        jmp  err_
# |omlt1|mlr|13,rcval(xl)|||; multiply left operand by right|8850
omlt1:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call mlr_
# ||rno|6,exrea|||; return real if no overflow|8851
# getarg exrea
        rno_ exrea
# ||erb|1,263|26,multiplication caused real overflow|||8852
        movq $263,rcode
        jmp  err_
# ||ejc|||||8854
# |o_nam|ent||||; entry point|8858
	.align	2
	nop
o_nam:
# ||mov|8,wa|19,*nmsi_||; set length of nmblk|8859
# getarg W0
# getarg WA
        .data
l_0125: .long 8*nmsi_
        .text
        movq l_0125,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate nmblk|8860
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_nml||; set name block code|8861
# getarg W0
# getarg (XR)
        .data
l_0126: .long b_nml
        .text
        movq l_0126,W0
        movq W0,(XR)
# ||mov|13,nmofs(xr)|10,(xs)+||; set name offset from operand|8862
# getarg nmofs(,XR,8)
        pop  nmofs(,XR,8)
# ||mov|13,nmbas(xr)|10,(xs)+||; set name base from operand|8863
# getarg nmbas(,XR,8)
        pop  nmbas(,XR,8)
# ||mov|11,-(xs)|7,xr||; stack result|8864
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8865
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8866
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8867
# |o_nta|ent||||; entry point|8873
	.align	2
	nop
o_nta:
# ||lcw|8,wa|||; load new failure offset|8874
# getarg WA
        lcw_ WA
# ||mov|11,-(xs)|3,flptr||; stack old failure pointer|8875
# getarg flptr
        push flptr
# ||mov|11,-(xs)|8,wa||; stack new failure offset|8876
# getarg WA
        push WA
# ||mov|3,flptr|7,xs||; set new failure pointer|8877
# getarg XT
# getarg flptr
        movq XT,flptr
# ||lcw|7,xr|||; get next code word|8878
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8879
# getarg (XR)
        jmp  *(XR)
# |o_ntb|ent||||; entry point|8883
	.align	2
	nop
o_ntb:
# ||mov|3,flptr|13,num02(xs)||; restore old failure pointer|8884
# getarg num02(,XT,8)
# getarg W0
# getarg flptr
        movq num02(,XT,8),W0
        movq W0,flptr
# ||brn|6,exfal|||; and fail|8885
# getarg exfal
        jmp  exfal
# |o_ntc|ent||||; entry point|8889
	.align	2
	nop
o_ntc:
# ||ica|7,xs|||; pop failure offset|8890
# getarg XT
        addq $8,XT
# ||mov|3,flptr|10,(xs)+||; restore old failure pointer|8891
# getarg flptr
        pop  flptr
# ||brn|6,exnul|||; exit giving null result|8892
# getarg exnul
        jmp  exnul
# ||ejc|||||8893
# |o_oun|ent||||; entry point|8897
	.align	2
	nop
o_oun:
# ||erb|1,029|26,undefined operator referenced|||8898
        movq $29,rcode
        jmp  err_
# ||ejc|||||8899
# |o_pas|ent||||; entry point|8907
	.align	2
	nop
o_pas:
# ||mov|8,wb|22,=p_pac||; load pcode for p_pac node|8908
# getarg W0
# getarg WB
        .data
l_0127: .long p_pac
        .text
        movq l_0127,W0
        movq W0,WB
# ||mov|8,wc|10,(xs)+||; load name offset (parm2)|8909
# getarg WC
        pop  WC
# ||mov|7,xr|10,(xs)+||; load name base (parm1)|8910
# getarg XR
        pop  XR
# ||jsr|6,pbild|||; build p_pac node|8911
# getarg pbild
        call pbild
# ||mov|7,xl|7,xr||; save ptr to node|8912
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; load left operand|8913
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||jsr|6,gtpat|||; convert to pattern|8914
# getarg gtpat
        call gtpat
        decq rcode
        js   call_24
# ||err|1,030|26,pattern assignment left operand is not pattern|||8915
# getarg 030
        decq rcode
        jns  l_0128
        movq $30,rcode
        jmp  err_
l_0128:
call_24:
# ||mov|9,(xs)|7,xr||; save ptr to left operand pattern|8916
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|8,wb|22,=p_paa||; set pcode for p_paa node|8917
# getarg W0
# getarg WB
        .data
l_0129: .long p_paa
        .text
        movq l_0129,W0
        movq W0,WB
# ||jsr|6,pbild|||; build p_paa node|8918
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_paa successor|8919
# getarg pthen(,XR,8)
        pop  pthen(,XR,8)
# ||jsr|6,pconc|||; concatenate to form final pattern|8920
# getarg pconc
        call pconc
# ||mov|11,-(xs)|7,xr||; stack result|8921
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|8922
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|8923
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8924
# |o_pmn|ent||||; entry point|8928
	.align	2
	nop
o_pmn:
# ||zer|8,wb|||; set type code for match by name|8929
# getarg WB
        xor  WB,WB
# ||brn|6,match|||; jump to routine to start match|8930
# getarg match
        jmp  match
# ||ejc|||||8931
# |o_pms|ent||||; entry point|8939
	.align	2
	nop
o_pms:
# ||mov|8,wb|18,=num02||; set flag for statement to match|8940
# getarg W0
# getarg WB
        .data
l_0130: .long num02
        .text
        movq l_0130,W0
        movq W0,WB
# ||brn|6,match|||; jump to routine to start match|8941
# getarg match
        jmp  match
# ||ejc|||||8942
# |o_pmv|ent||||; entry point|8946
	.align	2
	nop
o_pmv:
# ||mov|8,wb|18,=num01||; set type code for value match|8947
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||brn|6,match|||; jump to routine to start match|8948
# getarg match
        jmp  match
# ||ejc|||||8949
# |o_pop|ent||||; entry point|8953
	.align	2
	nop
o_pop:
# ||ica|7,xs|||; pop top stack entry|8954
# getarg XT
        addq $8,XT
# ||lcw|7,xr|||; get next code word|8955
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|8956
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||8957
# |o_stp|ent||||; entry point|8961
	.align	2
	nop
o_stp:
# ||brn|6,lend0|||; jump to end circuit|8962
# getarg lend0
        jmp  lend0
# ||ejc|||||8963
# |o_rnm|ent||||; entry point|8970
	.align	2
	nop
o_rnm:
# ||brn|6,evlx4|||; return to evalx procedure|8971
# getarg evlx4
        jmp  evlx4
# ||ejc|||||8972
# |o_rpl|ent||||; entry point|8986
	.align	2
	nop
o_rpl:
# ||jsr|6,gtstg|||; convert replacement val to string|8987
# getarg gtstg
        call gtstg
        decq rcode
        js   call_25
# ||err|1,031|26,pattern replacement right operand is not a string|||8988
# getarg 031
        decq rcode
        jns  l_0131
        movq $31,rcode
        jmp  err_
l_0131:
call_25:
# ||mov|7,xl|9,(xs)||; load subject string pointer|8992
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|8,wa|13,sclen(xl)||; add subject string length|8997
# getarg sclen(,XL,8)
# getarg WA
        addq sclen(,XL,8),WA
# ||add|8,wa|13,num02(xs)||; add starting cursor|8998
# getarg num02(,XT,8)
# getarg WA
        addq num02(,XT,8),WA
# ||sub|8,wa|13,num01(xs)||; minus final cursor = total length|8999
# getarg num01(,XT,8)
# getarg WA
        subq num01(,XT,8),WA
# ||bze|8,wa|6,orpl3||; jump if result is null|9000
# getarg WA
# getarg orpl3
        or   WA,WA
        jz   orpl3
# ||mov|11,-(xs)|7,xr||; restack replacement string|9001
# getarg XR
        push XR
# ||jsr|6,alocs|||; allocate scblk for result|9002
# getarg alocs
        call alocs
# ||mov|8,wa|13,num03(xs)||; get initial cursor (part 1 len)|9003
# getarg num03(,XT,8)
# getarg WA
        movq num03(,XT,8),WA
# ||mov|13,num03(xs)|7,xr||; stack result pointer|9004
# getarg XR
# getarg num03(,XT,8)
        movq XR,num03(,XT,8)
# ||psc|7,xr|||; point to characters of result|9005
# getarg XR
        add  $cfp_f,XR
# ||bze|8,wa|6,orpl1||; jump if first part is null|9009
# getarg WA
# getarg orpl1
        or   WA,WA
        jz   orpl1
# ||mov|7,xl|13,num01(xs)||; else point to subject string|9010
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||plc|7,xl|||; point to subject string chars|9011
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move first part to result|9012
        rep
        movsb
# ||ejc|||||9013
# |orpl1|mov|7,xl|10,(xs)+||; load replacement string, pop|9018
orpl1:
# getarg XL
        pop  XL
# ||mov|8,wa|13,sclen(xl)||; load length|9019
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||bze|8,wa|6,orpl2||; jump if null replacement|9020
# getarg WA
# getarg orpl2
        or   WA,WA
        jz   orpl2
# ||plc|7,xl|||; else point to chars of replacement|9021
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move in chars (part 2)|9022
        rep
        movsb
# |orpl2|mov|7,xl|10,(xs)+||; load subject string pointer, pop|9026
orpl2:
# getarg XL
        pop  XL
# ||mov|8,wc|10,(xs)+||; load final cursor, pop|9027
# getarg WC
        pop  WC
# ||mov|8,wa|13,sclen(xl)||; load subject string length|9028
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||sub|8,wa|8,wc||; minus final cursor = part 3 length|9029
# getarg WC
# getarg WA
        subq WC,WA
# ||bze|8,wa|6,oass0||; jump to assign if part 3 is null|9030
# getarg WA
# getarg oass0
        or   WA,WA
        jz   oass0
# ||plc|7,xl|8,wc||; else point to last part of string|9031
# getarg XL
# getarg WC
        mov  WC,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mvc||||; move part 3 to result|9032
        rep
        movsb
# ||brn|6,oass0|||; jump to perform assignment|9033
# getarg oass0
        jmp  oass0
# |orpl3|add|7,xs|19,*num02||; pop subject str ptr, final cursor|9037
orpl3:
# getarg W0
# getarg XT
        .data
l_0135: .long 8*num02
        .text
        movq l_0135,W0
        addq W0,XT
# ||mov|9,(xs)|21,=nulls||; set null result|9038
# getarg W0
# getarg (XT)
        movq l_0054,W0
        movq W0,(XT)
# ||brn|6,oass0|||; jump to assign null value|9039
# getarg oass0
        jmp  oass0
# ||ejc|||||9058
# |o_rvl|ent||||; entry point|9066
	.align	2
	nop
o_rvl:
# ||brn|6,evlx3|||; return to evalx procedure|9067
# getarg evlx3
        jmp  evlx3
# ||ejc|||||9068
# |o_sla|ent||||; entry point|9074
	.align	2
	nop
o_sla:
# ||lcw|8,wa|||; load new failure offset|9075
# getarg WA
        lcw_ WA
# ||mov|11,-(xs)|3,flptr||; stack old failure pointer|9076
# getarg flptr
        push flptr
# ||mov|11,-(xs)|8,wa||; stack new failure offset|9077
# getarg WA
        push WA
# ||mov|3,flptr|7,xs||; set new failure pointer|9078
# getarg XT
# getarg flptr
        movq XT,flptr
# ||lcw|7,xr|||; get next code word|9079
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9080
# getarg (XR)
        jmp  *(XR)
# |o_slb|ent||||; entry point|9084
	.align	2
	nop
o_slb:
# ||mov|7,xr|10,(xs)+||; load result|9085
# getarg XR
        pop  XR
# ||ica|7,xs|||; pop fail offset|9086
# getarg XT
        addq $8,XT
# ||mov|3,flptr|9,(xs)||; restore old failure pointer|9087
# getarg (XT)
# getarg W0
# getarg flptr
        movq (XT),W0
        movq W0,flptr
# ||mov|9,(xs)|7,xr||; restack result|9088
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||lcw|8,wa|||; load new code offset|9089
# getarg WA
        lcw_ WA
# ||add|8,wa|3,r_cod||; point to absolute code location|9090
# getarg r_cod
# getarg WA
        addq r_cod,WA
# ||lcp|8,wa|||; set new code pointer|9091
# getarg WA
        lcp_ WA
# ||lcw|7,xr|||; get next code word|9092
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9093
# getarg (XR)
        jmp  *(XR)
# |o_slc|ent||||; entry point|9097
	.align	2
	nop
o_slc:
# ||lcw|8,wa|||; load new fail offset|9098
# getarg WA
        lcw_ WA
# ||mov|9,(xs)|8,wa||; store new fail offset|9099
# getarg WA
# getarg (XT)
        movq WA,(XT)
# ||lcw|7,xr|||; get next code word|9100
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9101
# getarg (XR)
        jmp  *(XR)
# |o_sld|ent||||; entry point|9105
	.align	2
	nop
o_sld:
# ||ica|7,xs|||; pop failure offset|9106
# getarg XT
        addq $8,XT
# ||mov|3,flptr|10,(xs)+||; restore old failure pointer|9107
# getarg flptr
        pop  flptr
# ||lcw|7,xr|||; get next code word|9108
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9109
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9110
# |o_sub|ent||||; entry point|9114
	.align	2
	nop
o_sub:
# ||jsr|6,arith|||; fetch arithmetic operands|9115
# getarg arith
        call arith
        decq rcode
        js   call_26
# ||err|1,032|26,subtraction left operand is not numeric|||9116
# getarg 032
        decq rcode
        jns  l_0136
        movq $32,rcode
        jmp  err_
l_0136:
# ||err|1,033|26,subtraction right operand is not numeric|||9117
# getarg 033
        decq rcode
        jns  l_0137
        movq $33,rcode
        jmp  err_
l_0137:
# ||ppm|6,osub1|||; jump if real operands|9120
# getarg osub1
# getarg osub1
        decq rcode
        jns  l_0138
        jmp  osub1
l_0138:
call_26:
# ||sbi|13,icval(xl)|||; subtract right operand from left|9125
# getarg icval(,XL,8)
        sub  icval(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||ino|6,exint|||; return integer if no overflow|9126
# getarg exint
        ino_ exint
# ||erb|1,034|26,subtraction caused integer overflow|||9127
        movq $34,rcode
        jmp  err_
# |osub1|sbr|13,rcval(xl)|||; subtract right operand from left|9133
osub1:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call sbr_
# ||rno|6,exrea|||; return real if no overflow|9134
# getarg exrea
        rno_ exrea
# ||erb|1,264|26,subtraction caused real overflow|||9135
        movq $264,rcode
        jmp  err_
# ||ejc|||||9137
# |o_txr|ent||||; entry point|9141
	.align	2
	nop
o_txr:
# ||brn|6,trxq1|||; jump into trxeq procedure|9142
# getarg trxq1
        jmp  trxq1
# ||ejc|||||9143
# |o_unf|ent||||; entry point|9153
	.align	2
	nop
o_unf:
# ||erb|1,035|26,unexpected failure in -nofail mode|||9154
        movq $35,rcode
        jmp  err_
# ||ttl|27,s p i t b o l -- block action routines||||9155
# |b_aaa|ent|2,bl__i|||; entry point of first block routine|9200
	.align	2
	.byte	bl__i
b_aaa:
# ||ejc|||||9201
# |b_exl|ent|2,bl_ex|||; entry point (exblk)|9210
	.align	2
	.byte	bl_ex
b_exl:
# ||mov|11,-(xs)|7,xr||; stack result|9211
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9212
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9213
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9214
# |b_sel|ent|2,bl_se|||; entry point (seblk)|9221
	.align	2
	.byte	bl_se
b_sel:
# ||mov|11,-(xs)|7,xr||; stack result|9222
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9223
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9224
# getarg (XR)
        jmp  *(XR)
# |b_e__|ent|2,bl__i|||; entry point|9228
	.align	2
	.byte	bl__i
b_e__:
# ||ejc|||||9229
# |b_trt|ent|2,bl_tr|||; entry point (trblk)|9235
	.align	2
	.byte	bl_tr
b_trt:
# |b_t__|ent|2,bl__i|||; end of trblk,seblk,exblk entries|9239
	.align	2
	.byte	bl__i
b_t__:
# ||ejc|||||9240
# |b_art|ent|2,bl_ar|||; entry point (arblk)|9246
	.align	2
	.byte	bl_ar
b_art:
# ||ejc|||||9247
# |b_bct|ent|2,bl_bc|||; entry point (bcblk)|9255
	.align	2
	.byte	bl_bc
b_bct:
# ||ejc|||||9256
# |b_bft|ent|2,bl_bf|||; entry point (bfblk)|9264
	.align	2
	.byte	bl_bf
b_bft:
# ||ejc|||||9265
# |b_cct|ent|2,bl_cc|||; entry point (ccblk)|9271
	.align	2
	.byte	bl_cc
b_cct:
# ||ejc|||||9272
# |b_cdc|ent|2,bl_cd|||; entry point (cdblk)|9283
	.align	2
	.byte	bl_cd
b_cdc:
# |bcdc0|mov|7,xs|3,flptr||; pop garbage off stack|9284
bcdc0:
# getarg flptr
# getarg XT
        movq flptr,XT
# ||mov|9,(xs)|13,cdfal(xr)||; set failure offset|9285
# getarg cdfal(,XR,8)
# getarg W0
# getarg (XT)
        movq cdfal(,XR,8),W0
        movq W0,(XT)
# ||brn|6,stmgo|||; enter stmt|9286
# getarg stmgo
        jmp  stmgo
# ||ejc|||||9287
# |b_cds|ent|2,bl_cd|||; entry point (cdblk)|9295
	.align	2
	.byte	bl_cd
b_cds:
# |bcds0|mov|7,xs|3,flptr||; pop garbage off stack|9296
bcds0:
# getarg flptr
# getarg XT
        movq flptr,XT
# ||mov|9,(xs)|19,*cdfal||; set failure offset|9297
# getarg W0
# getarg (XT)
        movq l_0011,W0
        movq W0,(XT)
# ||brn|6,stmgo|||; enter stmt|9298
# getarg stmgo
        jmp  stmgo
# ||ejc|||||9299
# |b_cmt|ent|2,bl_cm|||; entry point (cmblk)|9305
	.align	2
	.byte	bl_cm
b_cmt:
# ||ejc|||||9306
# |b_ctt|ent|2,bl_ct|||; entry point (ctblk)|9312
	.align	2
	.byte	bl_ct
b_ctt:
# ||ejc|||||9313
# |b_dfc|ent|2,bl_df|||; entry point|9322
	.align	2
	.byte	bl_df
b_dfc:
# ||mov|8,wa|13,dfpdl(xl)||; load length of pdblk|9323
# getarg dfpdl(,XL,8)
# getarg WA
        movq dfpdl(,XL,8),WA
# ||jsr|6,alloc|||; allocate pdblk|9324
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_pdt||; store type word|9325
# getarg W0
# getarg (XR)
        .data
l_0139: .long b_pdt
        .text
        movq l_0139,W0
        movq W0,(XR)
# ||mov|13,pddfp(xr)|7,xl||; store dfblk pointer|9326
# getarg XL
# getarg pddfp(,XR,8)
        movq XL,pddfp(,XR,8)
# ||mov|8,wc|7,xr||; save pointer to pdblk|9327
# getarg XR
# getarg WC
        movq XR,WC
# ||add|7,xr|8,wa||; point past pdblk|9328
# getarg WA
# getarg XR
        addq WA,XR
# ||lct|8,wa|13,fargs(xl)||; set to count fields|9329
# getarg WA
# getarg fargs(,XL,8)
        mov  WA,fargs(,XL,8)
# |bdfc1|mov|11,-(xr)|10,(xs)+||; move a field value|9333
bdfc1:
# getarg (XR)
        sub  $8,XR
        pop  (XR)
# ||bct|8,wa|6,bdfc1||; loop till all moved|9334
# getarg WA
# getarg bdfc1
        decq WA
        jnz  bdfc1
# ||mov|7,xr|8,wc||; recall pointer to pdblk|9335
# getarg WC
# getarg XR
        movq WC,XR
# ||brn|6,exsid|||; exit setting id field|9336
# getarg exsid
        jmp  exsid
# ||ejc|||||9337
# |b_efc|ent|2,bl_ef|||; entry point (efblk)|9346
	.align	2
	.byte	bl_ef
b_efc:
# ||mov|8,wc|13,fargs(xl)||; load number of arguments|9349
# getarg fargs(,XL,8)
# getarg WC
        movq fargs(,XL,8),WC
# ||wtb|8,wc|||; convert to offset|9350
# getarg WC
        sal  WC,3
# ||mov|11,-(xs)|7,xl||; save pointer to efblk|9351
# getarg XL
        push XL
# ||mov|7,xt|7,xs||; copy pointer to arguments|9352
# getarg XT
# getarg XT
        movq XT,XT
# |befc1|ica|7,xt|||; point to next entry|9356
befc1:
# getarg XT
        addq $8,XT
# ||mov|7,xr|9,(xs)||; load pointer to efblk|9357
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||dca|8,wc|||; decrement eftar offset|9358
# getarg WC
        subq $8,WC
# ||add|7,xr|8,wc||; point to next eftar entry|9359
# getarg WC
# getarg XR
        addq WC,XR
# ||mov|7,xr|13,eftar(xr)||; load eftar entry|9360
# getarg eftar(,XR,8)
# getarg XR
        movq eftar(,XR,8),XR
# ||bsw|7,xr|1,5||; switch on type|9369
# getarg XR
        jmp  *l_0140(,XR,8)
        .data
l_0140:
# ||iff|1,0|6,befc7||; no conversion needed|9387
# getarg befc7
        .long befc7
# ||iff|1,1|6,befc2||; string|9387
# getarg befc2
        .long befc2
# ||iff|1,2|6,befc3||; integer|9387
# getarg befc3
        .long befc3
# ||iff|1,3|6,befc4||; real|9387
# getarg befc4
        .long befc4
# ||iff|1,4|6,beff1||; file|9387
# getarg beff1
        .long beff1
# ||esw||||; end of switch on type|9387
        .text
# |beff1|mov|11,-(xs)|7,xt||; save entry pointer|9392
beff1:
# getarg XT
        push XT
# ||mov|3,befof|8,wc||; save offset|9393
# getarg WC
# getarg befof
        movq WC,befof
# ||mov|11,-(xs)|9,(xt)||; stack arg pointer|9394
# getarg (XT)
        push (XT)
# ||jsr|6,iofcb|||; convert to fcb|9395
# getarg iofcb
        call iofcb
        decq rcode
        js   call_27
# ||err|1,298|26,external function argument is not file|||9396
# getarg 298
        decq rcode
        jns  l_0141
        movq $298,rcode
        jmp  err_
l_0141:
# ||err|1,298|26,external function argument is not file|||9397
# getarg 298
        decq rcode
        jns  l_0142
        movq $298,rcode
        jmp  err_
l_0142:
# ||err|1,298|26,external function argument is not file|||9398
# getarg 298
        decq rcode
        jns  l_0143
        movq $298,rcode
        jmp  err_
l_0143:
call_27:
# ||mov|7,xr|8,wa||; point to fcb|9399
# getarg WA
# getarg XR
        movq WA,XR
# ||mov|7,xt|10,(xs)+||; reload entry pointer|9400
# getarg XT
        pop  XT
# ||brn|6,befc5|||; jump to merge|9401
# getarg befc5
        jmp  befc5
# |befc2|mov|11,-(xs)|9,(xt)||; stack arg ptr|9406
befc2:
# getarg (XT)
        push (XT)
# ||jsr|6,gtstg|||; convert argument to string|9407
# getarg gtstg
        call gtstg
        decq rcode
        js   call_28
# ||err|1,039|26,external function argument is not a string|||9408
# getarg 039
        decq rcode
        jns  l_0144
        movq $39,rcode
        jmp  err_
l_0144:
call_28:
# ||brn|6,befc6|||; jump to merge|9409
# getarg befc6
        jmp  befc6
# ||ejc|||||9410
# |befc3|mov|7,xr|9,(xt)||; load next argument|9416
befc3:
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|3,befof|8,wc||; save offset|9417
# getarg WC
# getarg befof
        movq WC,befof
# ||jsr|6,gtint|||; convert to integer|9418
# getarg gtint
        call gtint
        decq rcode
        js   call_29
# ||err|1,040|26,external function argument is not integer|||9419
# getarg 040
        decq rcode
        jns  l_0145
        movq $40,rcode
        jmp  err_
l_0145:
call_29:
# ||brn|6,befc5|||; merge with real case|9422
# getarg befc5
        jmp  befc5
# |befc4|mov|7,xr|9,(xt)||; load next argument|9426
befc4:
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|3,befof|8,wc||; save offset|9427
# getarg WC
# getarg befof
        movq WC,befof
# ||jsr|6,gtrea|||; convert to real|9428
# getarg gtrea
        call gtrea
        decq rcode
        js   call_30
# ||err|1,265|26,external function argument is not real|||9429
# getarg 265
        decq rcode
        jns  l_0146
        movq $265,rcode
        jmp  err_
l_0146:
call_30:
# |befc5|mov|8,wc|3,befof||; restore offset|9434
befc5:
# getarg befof
# getarg WC
        movq befof,WC
# |befc6|mov|9,(xt)|7,xr||; store converted result|9438
befc6:
# getarg XR
# getarg (XT)
        movq XR,(XT)
# |befc7|bnz|8,wc|6,befc1||; loop back if more to go|9442
befc7:
# getarg WC
# getarg WC
# getarg befc1
        or   WC,WC
        jnz  befc1
# ||mov|7,xl|10,(xs)+||; restore efblk pointer|9446
# getarg XL
        pop  XL
# ||mov|8,wa|13,fargs(xl)||; get number of args|9447
# getarg fargs(,XL,8)
# getarg WA
        movq fargs(,XL,8),WA
# ||jsr|6,sysex|||; call routine to call external fnc|9448
# getarg sysex
        call sysex
        decq rcode
        js   call_31
# ||ppm|6,exfal|||; fail if failure|9449
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0147
        jmp  exfal
l_0147:
# ||err|1,327|26,calling external function - not found|||9450
# getarg 327
        decq rcode
        jns  l_0148
        movq $327,rcode
        jmp  err_
l_0148:
# ||err|1,326|26,calling external function - bad argument type|||9451
# getarg 326
        decq rcode
        jns  l_0149
        movq $326,rcode
        jmp  err_
l_0149:
call_31:
# ||wtb|8,wa|||; convert number of args to bytes|9453
# getarg WA
        sal  WA,3
# ||add|7,xs|8,wa||; remove arguments from stack|9454
# getarg WA
# getarg XT
        addq WA,XT
# ||ejc|||||9456
# ||mov|8,wb|13,efrsl(xl)||; get result type id|9464
# getarg efrsl(,XL,8)
# getarg WB
        movq efrsl(,XL,8),WB
# ||bnz|8,wb|6,befa8||; branch if not unconverted|9465
# getarg WB
# getarg WB
# getarg befa8
        or   WB,WB
        jnz  befa8
# ||bne|9,(xr)|22,=b_scl|6,befc8|; jump if not a string|9466
# getarg (XR)
# getarg W0
# getarg befc8
        movq l_0094,W0
        cmpq (XR),W0
        jne  befc8
# ||bze|13,sclen(xr)|6,exnul||; return null if null|9467
# getarg sclen(,XR,8)
# getarg exnul
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jz   exnul
# |befa8|bne|8,wb|18,=num01|6,befc8|; jump if not a string|9471
befa8:
# getarg WB
# getarg W0
# getarg befc8
        movq l_0060,W0
        cmpq WB,W0
        jne  befc8
# ||bze|13,sclen(xr)|6,exnul||; return null if null|9472
# getarg sclen(,XR,8)
# getarg exnul
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jz   exnul
# |befc8|blt|7,xr|3,dnamb|6,befc9|; jump if not in dynamic storage|9476
befc8:
# getarg XR
# getarg dnamb
# getarg befc9
        cmpq XR,dnamb
        jb   befc9
# ||ble|7,xr|3,dnamp|6,exixr|; return result if already dynamic|9477
# getarg XR
# getarg dnamp
# getarg exixr
        cmpq XR,dnamp
        jbe  exixr
# |befc9|mov|8,wa|9,(xr)||; get possible type word|9481
befc9:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||bze|8,wb|6,bef11||; jump if unconverted result|9482
# getarg WB
# getarg bef11
        or   WB,WB
        jz   bef11
# ||mov|8,wa|22,=b_scl||; string|9483
# getarg W0
# getarg WA
        movq l_0094,W0
        movq W0,WA
# ||beq|8,wb|18,=num01|6,bef10|; yes jump|9484
# getarg WB
# getarg W0
# getarg bef10
        movq l_0060,W0
        cmpq WB,W0
        je   bef10
# ||mov|8,wa|22,=b_icl||; integer|9485
# getarg W0
# getarg WA
        movq l_0087,W0
        movq W0,WA
# ||beq|8,wb|18,=num02|6,bef10|; yes jump|9486
# getarg WB
# getarg W0
# getarg bef10
        movq l_0130,W0
        cmpq WB,W0
        je   bef10
# ||mov|8,wa|22,=b_rcl||; real|9489
# getarg W0
# getarg WA
        movq l_0101,W0
        movq W0,WA
# |bef10|mov|9,(xr)|8,wa||; stored before copying to dynamic|9494
bef10:
# getarg WA
# getarg (XR)
        movq WA,(XR)
# |bef11|beq|9,(xr)|22,=b_scl|6,bef12|; branch if string result|9498
bef11:
# getarg (XR)
# getarg W0
# getarg bef12
        movq l_0094,W0
        cmpq (XR),W0
        je   bef12
# ||jsr|6,blkln|||; get length of block|9499
# getarg blkln
        call blkln
# ||mov|7,xl|7,xr||; copy address of old block|9500
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,alloc|||; allocate dynamic block same size|9501
# getarg alloc
        call alloc
# ||mov|11,-(xs)|7,xr||; set pointer to new block as result|9502
# getarg XR
        push XR
# ||mvw||||; copy old block to dynamic block|9503
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0150:
        or   WA,WA
        jz   l_0151
        movsq
        decq WA
        jmp  l_0150
l_0151:
        cld
# ||zer|7,xl|||; clear garbage value|9504
# getarg XL
        xor  XL,XL
# ||lcw|7,xr|||; get next code word|9505
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9506
# getarg (XR)
        jmp  *(XR)
# |bef12|mov|7,xl|7,xr||; save source string pointer|9512
bef12:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|13,sclen(xr)||; fetch string length|9513
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||bze|8,wa|6,exnul||; return null string if length zero|9514
# getarg WA
# getarg exnul
        or   WA,WA
        jz   exnul
# ||jsr|6,alocs|||; allocate space for string|9515
# getarg alocs
        call alocs
# ||mov|11,-(xs)|7,xr||; save as result pointer|9516
# getarg XR
        push XR
# ||psc|7,xr|||; prepare to store chars of result|9517
# getarg XR
        add  $cfp_f,XR
# ||plc|7,xl|||; point to chars in source string|9518
# getarg XL
        add  $cfp_f,XL
# ||mov|8,wa|8,wc||; number of characters to copy|9519
# getarg WC
# getarg WA
        movq WC,WA
# ||mvc||||; move characters to result string|9520
        rep
        movsb
# ||zer|7,xl|||; clear garbage value|9521
# getarg XL
        xor  XL,XL
# ||lcw|7,xr|||; get next code word|9522
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9523
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9525
# |b_evt|ent|2,bl_ev|||; entry point (evblk)|9531
	.align	2
	.byte	bl_ev
b_evt:
# ||ejc|||||9532
# |b_ffc|ent|2,bl_ff|||; entry point (ffblk)|9541
	.align	2
	.byte	bl_ff
b_ffc:
# ||mov|7,xr|7,xl||; copy ffblk pointer|9542
# getarg XL
# getarg XR
        movq XL,XR
# ||lcw|8,wc|||; load next code word|9543
# getarg WC
        lcw_ WC
# ||mov|7,xl|9,(xs)||; load pdblk pointer|9544
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||bne|9,(xl)|22,=b_pdt|6,bffc2|; jump if not pdblk at all|9545
# getarg (XL)
# getarg W0
# getarg bffc2
        movq l_0139,W0
        cmpq (XL),W0
        jne  bffc2
# ||mov|8,wa|13,pddfp(xl)||; load dfblk pointer from pdblk|9546
# getarg pddfp(,XL,8)
# getarg WA
        movq pddfp(,XL,8),WA
# |bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|; jump if this is the correct ffblk|9550
bffc1:
# getarg WA
# getarg ffdfp(,XR,8)
# getarg bffc3
        cmpq WA,ffdfp(,XR,8)
        je   bffc3
# ||mov|7,xr|13,ffnxt(xr)||; else link to next ffblk on chain|9551
# getarg ffnxt(,XR,8)
# getarg XR
        movq ffnxt(,XR,8),XR
# ||bnz|7,xr|6,bffc1||; loop back if another entry to check|9552
# getarg XR
# getarg XR
# getarg bffc1
        or   XR,XR
        jnz  bffc1
# |bffc2|erb|1,041|26,field function argument is wrong datatype|||9556
bffc2:
        movq $41,rcode
        jmp  err_
# ||ejc|||||9557
# |bffc3|mov|8,wa|13,ffofs(xr)||; load field offset|9563
bffc3:
# getarg ffofs(,XR,8)
# getarg WA
        movq ffofs(,XR,8),WA
# ||beq|8,wc|21,=ofne_|6,bffc5|; jump if called by name|9564
# getarg WC
# getarg W0
# getarg bffc5
        .data
l_0153: .long ofne_
        .text
        movq l_0153,W0
        cmpq WC,W0
        je   bffc5
# ||add|7,xl|8,wa||; else point to value field|9565
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|7,xr|9,(xl)||; load value|9566
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||bne|9,(xr)|22,=b_trt|6,bffc4|; jump if not trapped|9567
# getarg (XR)
# getarg W0
# getarg bffc4
        .data
l_0154: .long b_trt
        .text
        movq l_0154,W0
        cmpq (XR),W0
        jne  bffc4
# ||sub|7,xl|8,wa||; else restore name base,offset|9568
# getarg WA
# getarg XL
        subq WA,XL
# ||mov|9,(xs)|8,wc||; save next code word over pdblk ptr|9569
# getarg WC
# getarg (XT)
        movq WC,(XT)
# ||jsr|6,acess|||; access value|9570
# getarg acess
        call acess
        decq rcode
        js   call_32
# ||ppm|6,exfal|||; fail if access fails|9571
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0155
        jmp  exfal
l_0155:
call_32:
# ||mov|8,wc|9,(xs)||; restore next code word|9572
# getarg (XT)
# getarg WC
        movq (XT),WC
# |bffc4|mov|9,(xs)|7,xr||; store value on stack (over pdblk)|9576
bffc4:
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|7,xr|8,wc||; copy next code word|9577
# getarg WC
# getarg XR
        movq WC,XR
# ||mov|7,xl|9,(xr)||; load entry address|9578
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to routine for next code word|9579
# getarg XL
        jmp  *XL
# |bffc5|mov|11,-(xs)|8,wa||; store name offset (base is set)|9583
bffc5:
# getarg WA
        push WA
# ||lcw|7,xr|||; get next code word|9584
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9585
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9586
# |b_icl|ent|2,bl_ic|||; entry point (icblk)|9595
	.align	2
	.byte	bl_ic
b_icl:
# ||mov|11,-(xs)|7,xr||; stack result|9596
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9597
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9598
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9599
# |b_kvt|ent|2,bl_kv|||; entry point (kvblk)|9605
	.align	2
	.byte	bl_kv
b_kvt:
# ||ejc|||||9606
# |b_nml|ent|2,bl_nm|||; entry point (nmblk)|9617
	.align	2
	.byte	bl_nm
b_nml:
# ||mov|11,-(xs)|7,xr||; stack result|9618
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9619
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9620
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9621
# |b_pdt|ent|2,bl_pd|||; entry point (pdblk)|9627
	.align	2
	.byte	bl_pd
b_pdt:
# ||ejc|||||9628
# |b_pfc|ent|2,bl_pf|||; entry point (pfblk)|9654
	.align	2
	.byte	bl_pf
b_pfc:
# ||mov|3,bpfpf|7,xl||; save pfblk ptr (need not be reloc)|9655
# getarg XL
# getarg bpfpf
        movq XL,bpfpf
# ||mov|7,xr|7,xl||; copy for the moment|9656
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|13,pfvbl(xr)||; point to vrblk for function|9657
# getarg pfvbl(,XR,8)
# getarg XL
        movq pfvbl(,XR,8),XL
# |bpf01|mov|8,wb|7,xl||; save pointer|9661
bpf01:
# getarg XL
# getarg WB
        movq XL,WB
# ||mov|7,xl|13,vrval(xl)||; load value|9662
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,bpf01|; loop if trblk|9663
# getarg (XL)
# getarg W0
# getarg bpf01
        movq l_0154,W0
        cmpq (XL),W0
        je   bpf01
# ||mov|3,bpfsv|7,xl||; save old value|9667
# getarg XL
# getarg bpfsv
        movq XL,bpfsv
# ||mov|7,xl|8,wb||; point back to block with value|9668
# getarg WB
# getarg XL
        movq WB,XL
# ||mov|13,vrval(xl)|21,=nulls||; set value to null|9669
# getarg W0
# getarg vrval(,XL,8)
        movq l_0054,W0
        movq W0,vrval(,XL,8)
# ||mov|8,wa|13,fargs(xr)||; load number of arguments|9670
# getarg fargs(,XR,8)
# getarg WA
        movq fargs(,XR,8),WA
# ||add|7,xr|19,*pfarg||; point to pfarg entries|9671
# getarg W0
# getarg XR
        .data
l_0156: .long 8*pfarg
        .text
        movq l_0156,W0
        addq W0,XR
# ||bze|8,wa|6,bpf04||; jump if no arguments|9672
# getarg WA
# getarg bpf04
        or   WA,WA
        jz   bpf04
# ||mov|7,xt|7,xs||; ptr to last arg|9673
# getarg XT
# getarg XT
        movq XT,XT
# ||wtb|8,wa|||; convert no. of args to bytes offset|9674
# getarg WA
        sal  WA,3
# ||add|7,xt|8,wa||; point before first arg|9675
# getarg WA
# getarg XT
        addq WA,XT
# ||mov|3,bpfxt|7,xt||; remember arg pointer|9676
# getarg XT
# getarg bpfxt
        movq XT,bpfxt
# ||ejc|||||9677
# |bpf02|mov|7,xl|10,(xr)+||; load vrblk ptr for next argument|9683
bpf02:
# getarg (XR)
# getarg XL
        movq (XR),XL
        add  $8,XR
# |bpf03|mov|8,wc|7,xl||; save pointer|9687
bpf03:
# getarg XL
# getarg WC
        movq XL,WC
# ||mov|7,xl|13,vrval(xl)||; load next value|9688
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,bpf03|; loop back if trblk|9689
# getarg (XL)
# getarg W0
# getarg bpf03
        movq l_0154,W0
        cmpq (XL),W0
        je   bpf03
# ||mov|8,wa|7,xl||; keep old value|9693
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xt|3,bpfxt||; point before next stacked arg|9694
# getarg bpfxt
# getarg XT
        movq bpfxt,XT
# ||mov|8,wb|11,-(xt)||; load argument (new value)|9695
# getarg (XT)
# getarg WB
        sub  $8,XT
        movq (XT),WB
# ||mov|9,(xt)|8,wa||; save old value|9696
# getarg WA
# getarg (XT)
        movq WA,(XT)
# ||mov|3,bpfxt|7,xt||; keep arg ptr for next time|9697
# getarg XT
# getarg bpfxt
        movq XT,bpfxt
# ||mov|7,xl|8,wc||; point back to block with value|9698
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|13,vrval(xl)|8,wb||; set new value|9699
# getarg WB
# getarg vrval(,XL,8)
        movq WB,vrval(,XL,8)
# ||bne|7,xs|3,bpfxt|6,bpf02|; loop if not all done|9700
# getarg XT
# getarg bpfxt
# getarg bpf02
        cmpq XT,bpfxt
        jne  bpf02
# |bpf04|mov|7,xl|3,bpfpf||; restore pfblk pointer|9704
bpf04:
# getarg bpfpf
# getarg XL
        movq bpfpf,XL
# ||mov|8,wa|13,pfnlo(xl)||; load number of locals|9705
# getarg pfnlo(,XL,8)
# getarg WA
        movq pfnlo(,XL,8),WA
# ||bze|8,wa|6,bpf07||; jump if no locals|9706
# getarg WA
# getarg bpf07
        or   WA,WA
        jz   bpf07
# ||mov|8,wb|21,=nulls||; get null constant|9707
# getarg W0
# getarg WB
        movq l_0054,W0
        movq W0,WB
# ||lct|8,wa|8,wa||; set local counter|9708
# |bpf05|mov|7,xl|10,(xr)+||; load vrblk ptr for next local|9712
bpf05:
# getarg (XR)
# getarg XL
        movq (XR),XL
        add  $8,XR
# |bpf06|mov|8,wc|7,xl||; save pointer|9716
bpf06:
# getarg XL
# getarg WC
        movq XL,WC
# ||mov|7,xl|13,vrval(xl)||; load next value|9717
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,bpf06|; loop back if trblk|9718
# getarg (XL)
# getarg W0
# getarg bpf06
        movq l_0154,W0
        cmpq (XL),W0
        je   bpf06
# ||mov|11,-(xs)|7,xl||; stack old value|9722
# getarg XL
        push XL
# ||mov|7,xl|8,wc||; point back to block with value|9723
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|13,vrval(xl)|8,wb||; set null as new value|9724
# getarg WB
# getarg vrval(,XL,8)
        movq WB,vrval(,XL,8)
# ||bct|8,wa|6,bpf05||; loop till all locals processed|9725
# getarg WA
# getarg bpf05
        decq WA
        jnz  bpf05
# ||ejc|||||9726
# |bpf07|zer|7,xr|||; zero reg xr in case|9735
bpf07:
# getarg XR
        xor  XR,XR
# ||bze|3,kvpfl|6,bpf7c||; skip if profiling is off|9736
# getarg kvpfl
# getarg bpf7c
        xor  W0,W0
        cmpq kvpfl,W0
        jz   bpf7c
# ||beq|3,kvpfl|18,=num02|6,bpf7a|; branch on type of profile|9737
# getarg kvpfl
# getarg W0
# getarg bpf7a
        movq l_0130,W0
        cmpq kvpfl,W0
        je   bpf7a
# ||jsr|6,systm|||; get current time|9741
# getarg systm
        call systm
# ||sti|3,pfetm|||; save for a sec|9742
# getarg pfetm
        mov  IA,pfetm
# ||sbi|3,pfstm|||; find time used by caller|9743
# getarg pfstm
        sub  pfstm,IA
        xor  W0,W0
        seto reg_fl
# ||jsr|6,icbld|||; build into an icblk|9744
# getarg icbld
        call icbld
# ||ldi|3,pfetm|||; reload current time|9745
# getarg pfetm
        mov  pfetm,IA
# ||brn|6,bpf7b|||; merge|9746
# getarg bpf7b
        jmp  bpf7b
# |bpf7a|ldi|3,pfstm|||; get start time of calling stmt|9750
bpf7a:
# getarg pfstm
        mov  pfstm,IA
# ||jsr|6,icbld|||; assemble an icblk round it|9751
# getarg icbld
        call icbld
# ||jsr|6,systm|||; get now time|9752
# getarg systm
        call systm
# |bpf7b|sti|3,pfstm|||; set start time of 1st func stmt|9756
bpf7b:
# getarg pfstm
        mov  IA,pfstm
# ||mnz|3,pffnc|||; flag function entry|9757
# getarg pffnc
        mov  XS,pffnc
# |bpf7c|mov|11,-(xs)|7,xr||; stack icblk ptr (or zero)|9761
bpf7c:
# getarg XR
        push XR
# ||mov|8,wa|3,r_cod||; load old code block pointer|9762
# getarg r_cod
# getarg WA
        movq r_cod,WA
# ||scp|8,wb|||; get code pointer|9764
# getarg WB
        scp_ WB
# ||sub|8,wb|8,wa||; make code pointer into offset|9765
# getarg WA
# getarg WB
        subq WA,WB
# ||mov|7,xl|3,bpfpf||; recall pfblk pointer|9766
# getarg bpfpf
# getarg XL
        movq bpfpf,XL
# ||mov|11,-(xs)|3,bpfsv||; stack old value of function name|9767
# getarg bpfsv
        push bpfsv
# ||mov|11,-(xs)|8,wa||; stack code block pointer|9768
# getarg WA
        push WA
# ||mov|11,-(xs)|8,wb||; stack code offset|9769
# getarg WB
        push WB
# ||mov|11,-(xs)|3,flprt||; stack old flprt|9770
# getarg flprt
        push flprt
# ||mov|11,-(xs)|3,flptr||; stack old failure pointer|9771
# getarg flptr
        push flptr
# ||mov|11,-(xs)|7,xl||; stack pointer to pfblk|9772
# getarg XL
        push XL
# ||zer|11,-(xs)|||; dummy zero entry for fail return|9773
        push $0
# ||chk||||; check for stack overflow|9774
        chk_
        or   W0,W0
        jne  sec06
# ||mov|3,flptr|7,xs||; set new fail return value|9775
# getarg XT
# getarg flptr
        movq XT,flptr
# ||mov|3,flprt|7,xs||; set new flprt|9776
# getarg XT
# getarg flprt
        movq XT,flprt
# ||mov|8,wa|3,kvtra||; load trace value|9777
# getarg kvtra
# getarg WA
        movq kvtra,WA
# ||add|8,wa|3,kvftr||; add ftrace value|9778
# getarg kvftr
# getarg WA
        addq kvftr,WA
# ||bnz|8,wa|6,bpf09||; jump if tracing possible|9779
# getarg WA
# getarg WA
# getarg bpf09
        or   WA,WA
        jnz  bpf09
# ||icv|3,kvfnc|||; else bump fnclevel|9780
# getarg kvfnc
        incq kvfnc
# |bpf08|mov|7,xr|13,pfcod(xl)||; point to vrblk of entry label|9784
bpf08:
# getarg pfcod(,XL,8)
# getarg XR
        movq pfcod(,XL,8),XR
# ||mov|7,xr|13,vrlbl(xr)||; point to target code|9785
# getarg vrlbl(,XR,8)
# getarg XR
        movq vrlbl(,XR,8),XR
# ||beq|7,xr|21,=stndl|6,bpf17|; test for undefined label|9786
# getarg XR
# getarg W0
# getarg bpf17
        .data
l_0157: .long stndl
        .text
        movq l_0157,W0
        cmpq XR,W0
        je   bpf17
# ||bne|9,(xr)|22,=b_trt|6,bpf8a|; jump if not trapped|9787
# getarg (XR)
# getarg W0
# getarg bpf8a
        movq l_0154,W0
        cmpq (XR),W0
        jne  bpf8a
# ||mov|7,xr|13,trlbl(xr)||; else load ptr to real label code|9788
# getarg trlbl(,XR,8)
# getarg XR
        movq trlbl(,XR,8),XR
# |bpf8a|bri|9,(xr)|||; off to execute function|9789
bpf8a:
# getarg (XR)
        jmp  *(XR)
# |bpf09|mov|7,xr|13,pfctr(xl)||; load possible call trace trblk|9793
bpf09:
# getarg pfctr(,XL,8)
# getarg XR
        movq pfctr(,XL,8),XR
# ||mov|7,xl|13,pfvbl(xl)||; load vrblk pointer for function|9794
# getarg pfvbl(,XL,8)
# getarg XL
        movq pfvbl(,XL,8),XL
# ||mov|8,wa|19,*vrval||; set name offset for variable|9795
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||bze|3,kvtra|6,bpf10||; jump if trace mode is off|9796
# getarg kvtra
# getarg bpf10
        xor  W0,W0
        cmpq kvtra,W0
        jz   bpf10
# ||bze|7,xr|6,bpf10||; or if there is no call trace|9797
# getarg XR
# getarg bpf10
        or   XR,XR
        jz   bpf10
# ||dcv|3,kvtra|||; decrement trace count|9801
# getarg kvtra
        decq kvtra
# ||bze|13,trfnc(xr)|6,bpf11||; jump if print trace|9802
# getarg trfnc(,XR,8)
# getarg bpf11
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   bpf11
# ||jsr|6,trxeq|||; execute function type trace|9803
# getarg trxeq
        call trxeq
# ||ejc|||||9804
# |bpf10|bze|3,kvftr|6,bpf16||; jump if ftrace is off|9810
bpf10:
# getarg kvftr
# getarg bpf16
        xor  W0,W0
        cmpq kvftr,W0
        jz   bpf16
# ||dcv|3,kvftr|||; else decrement ftrace|9811
# getarg kvftr
        decq kvftr
# |bpf11|jsr|6,prtsn|||; print statement number|9815
bpf11:
# getarg prtsn
        call prtsn
# ||jsr|6,prtnm|||; print function name|9816
# getarg prtnm
        call prtnm
# ||mov|8,wa|18,=ch_pp||; load left paren|9817
# getarg W0
# getarg WA
        .data
l_0158: .long ch_pp
        .text
        movq l_0158,W0
        movq W0,WA
# ||jsr|6,prtch|||; print left paren|9818
# getarg prtch
        call prtch
# ||mov|7,xl|13,num01(xs)||; recover pfblk pointer|9819
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||bze|13,fargs(xl)|6,bpf15||; skip if no arguments|9820
# getarg fargs(,XL,8)
# getarg bpf15
        xor  W0,W0
        cmpq fargs(,XL,8),W0
        jz   bpf15
# ||zer|8,wb|||; else set argument counter|9821
# getarg WB
        xor  WB,WB
# ||brn|6,bpf13|||; jump into loop|9822
# getarg bpf13
        jmp  bpf13
# |bpf12|mov|8,wa|18,=ch_cm||; load comma|9826
bpf12:
# getarg W0
# getarg WA
        .data
l_0159: .long ch_cm
        .text
        movq l_0159,W0
        movq W0,WA
# ||jsr|6,prtch|||; print to separate from last arg|9827
# getarg prtch
        call prtch
# |bpf13|mov|9,(xs)|8,wb||; save arg ctr (over failoffs is ok)|9831
bpf13:
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||wtb|8,wb|||; convert to byte offset|9832
# getarg WB
        sal  WB,3
# ||add|7,xl|8,wb||; point to next argument pointer|9833
# getarg WB
# getarg XL
        addq WB,XL
# ||mov|7,xr|13,pfarg(xl)||; load next argument vrblk ptr|9834
# getarg pfarg(,XL,8)
# getarg XR
        movq pfarg(,XL,8),XR
# ||sub|7,xl|8,wb||; restore pfblk pointer|9835
# getarg WB
# getarg XL
        subq WB,XL
# ||mov|7,xr|13,vrval(xr)||; load next value|9836
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||jsr|6,prtvl|||; print argument value|9837
# getarg prtvl
        call prtvl
# ||ejc|||||9838
# ||mov|8,wb|9,(xs)||; restore argument counter|9842
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||icv|8,wb|||; increment argument counter|9843
# getarg WB
        incq WB
# ||blt|8,wb|13,fargs(xl)|6,bpf12|; loop if more to print|9844
# getarg WB
# getarg fargs(,XL,8)
# getarg bpf12
        cmpq WB,fargs(,XL,8)
        jb   bpf12
# |bpf15|mov|8,wa|18,=ch_rp||; load right paren|9848
bpf15:
# getarg W0
# getarg WA
        .data
l_0160: .long ch_rp
        .text
        movq l_0160,W0
        movq W0,WA
# ||jsr|6,prtch|||; print to terminate output|9849
# getarg prtch
        call prtch
# ||jsr|6,prtnl|||; terminate print line|9850
# getarg prtnl
        call prtnl
# |bpf16|icv|3,kvfnc|||; increment fnclevel|9854
bpf16:
# getarg kvfnc
        incq kvfnc
# ||mov|7,xl|3,r_fnc||; load ptr to possible trblk|9855
# getarg r_fnc
# getarg XL
        movq r_fnc,XL
# ||jsr|6,ktrex|||; call keyword trace routine|9856
# getarg ktrex
        call ktrex
# ||mov|7,xl|13,num01(xs)||; restore pfblk pointer|9860
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||brn|6,bpf08|||; jump back to execute function|9861
# getarg bpf08
        jmp  bpf08
# |bpf17|mov|3,flptr|13,num02(xs)||; reset so exfal can return to evalx|9865
bpf17:
# getarg num02(,XT,8)
# getarg W0
# getarg flptr
        movq num02(,XT,8),W0
        movq W0,flptr
# ||erb|1,286|26,function call to undefined entry label|||9866
        movq $286,rcode
        jmp  err_
# ||ejc|||||9869
# |b_rcl|ent|2,bl_rc|||; entry point (rcblk)|9878
	.align	2
	.byte	bl_rc
b_rcl:
# ||mov|11,-(xs)|7,xr||; stack result|9879
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9880
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9881
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9883
# |b_scl|ent|2,bl_sc|||; entry point (scblk)|9892
	.align	2
	.byte	bl_sc
b_scl:
# ||mov|11,-(xs)|7,xr||; stack result|9893
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9894
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9895
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9896
# |b_tbt|ent|2,bl_tb|||; entry point (tbblk)|9902
	.align	2
	.byte	bl_tb
b_tbt:
# ||ejc|||||9903
# |b_tet|ent|2,bl_te|||; entry point (teblk)|9909
	.align	2
	.byte	bl_te
b_tet:
# ||ejc|||||9910
# |b_vct|ent|2,bl_vc|||; entry point (vcblk)|9916
	.align	2
	.byte	bl_vc
b_vct:
# ||ejc|||||9917
# |b_vr_|ent|2,bl__i|||; mark start of vrblk entry points|9924
	.align	2
	.byte	bl__i
b_vr_:
# |b_vra|ent|2,bl__i|||; entry point|9933
	.align	2
	.byte	bl__i
b_vra:
# ||mov|7,xl|7,xr||; copy name base (vrget = 0)|9934
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; set name offset|9935
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||jsr|6,acess|||; access value|9936
# getarg acess
        call acess
        decq rcode
        js   call_33
# ||ppm|6,exfal|||; fail if access fails|9937
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0161
        jmp  exfal
l_0161:
call_33:
# ||mov|11,-(xs)|7,xr||; stack result|9938
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|9939
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|9940
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9941
# |b_vre|ent||||; entry point|9949
	.align	2
	nop
b_vre:
# ||erb|1,042|26,attempt to change value of protected variable|||9950
        movq $42,rcode
        jmp  err_
# ||ejc|||||9951
# |b_vrg|ent||||; entry point|9960
	.align	2
	nop
b_vrg:
# ||mov|7,xr|13,vrlbo(xr)||; load code pointer|9961
# getarg vrlbo(,XR,8)
# getarg XR
        movq vrlbo(,XR,8),XR
# ||mov|7,xl|9,(xr)||; load entry address|9962
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to routine for next code word|9963
# getarg XL
        jmp  *XL
# ||ejc|||||9964
# |b_vrl|ent||||; entry point|9973
	.align	2
	nop
b_vrl:
# ||mov|11,-(xs)|13,vrval(xr)||; load value onto stack (vrget = 0)|9974
# getarg vrval(,XR,8)
        push vrval(,XR,8)
# ||lcw|7,xr|||; get next code word|9975
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9976
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9977
# |b_vrs|ent||||; entry point|9986
	.align	2
	nop
b_vrs:
# ||mov|13,vrvlo(xr)|9,(xs)||; store value, leave on stack|9987
# getarg (XT)
# getarg W0
# getarg vrvlo(,XR,8)
        movq (XT),W0
        movq W0,vrvlo(,XR,8)
# ||lcw|7,xr|||; get next code word|9988
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|9989
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||9990
# |b_vrt|ent||||; entry point|9998
	.align	2
	nop
b_vrt:
# ||sub|7,xr|19,*vrtra||; point back to start of vrblk|9999
# getarg W0
# getarg XR
        movq l_0111,W0
        subq W0,XR
# ||mov|7,xl|7,xr||; copy vrblk pointer|10000
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; set name offset|10001
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||mov|7,xr|13,vrlbl(xl)||; load pointer to trblk|10002
# getarg vrlbl(,XL,8)
# getarg XR
        movq vrlbl(,XL,8),XR
# ||bze|3,kvtra|6,bvrt2||; jump if trace is off|10003
# getarg kvtra
# getarg bvrt2
        xor  W0,W0
        cmpq kvtra,W0
        jz   bvrt2
# ||dcv|3,kvtra|||; else decrement trace count|10004
# getarg kvtra
        decq kvtra
# ||bze|13,trfnc(xr)|6,bvrt1||; jump if print trace case|10005
# getarg trfnc(,XR,8)
# getarg bvrt1
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   bvrt1
# ||jsr|6,trxeq|||; else execute full trace|10006
# getarg trxeq
        call trxeq
# ||brn|6,bvrt2|||; merge to jump to label|10007
# getarg bvrt2
        jmp  bvrt2
# |bvrt1|jsr|6,prtsn|||; print statement number|10011
bvrt1:
# getarg prtsn
        call prtsn
# ||mov|7,xr|7,xl||; copy vrblk pointer|10012
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|8,wa|18,=ch_cl||; colon|10013
# getarg W0
# getarg WA
        .data
l_0162: .long ch_cl
        .text
        movq l_0162,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|10014
# getarg prtch
        call prtch
# ||mov|8,wa|18,=ch_pp||; left paren|10015
# getarg W0
# getarg WA
        movq l_0158,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|10016
# getarg prtch
        call prtch
# ||jsr|6,prtvn|||; print label name|10017
# getarg prtvn
        call prtvn
# ||mov|8,wa|18,=ch_rp||; right paren|10018
# getarg W0
# getarg WA
        movq l_0160,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|10019
# getarg prtch
        call prtch
# ||jsr|6,prtnl|||; terminate line|10020
# getarg prtnl
        call prtnl
# ||mov|7,xr|13,vrlbl(xl)||; point back to trblk|10021
# getarg vrlbl(,XL,8)
# getarg XR
        movq vrlbl(,XL,8),XR
# |bvrt2|mov|7,xr|13,trlbl(xr)||; load pointer to actual code|10025
bvrt2:
# getarg trlbl(,XR,8)
# getarg XR
        movq trlbl(,XR,8),XR
# ||bri|9,(xr)|||; execute statement at label|10026
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||10027
# |b_vrv|ent||||; entry point|10038
	.align	2
	nop
b_vrv:
# ||mov|8,wb|9,(xs)||; load value (leave copy on stack)|10039
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||sub|7,xr|19,*vrsto||; point to vrblk|10040
# getarg W0
# getarg XR
        .data
l_0163: .long 8*vrsto
        .text
        movq l_0163,W0
        subq W0,XR
# ||mov|7,xl|7,xr||; copy vrblk pointer|10041
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; set offset|10042
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||jsr|6,asign|||; call assignment routine|10043
# getarg asign
        call asign
        decq rcode
        js   call_34
# ||ppm|6,exfal|||; fail if assignment fails|10044
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0164
        jmp  exfal
l_0164:
call_34:
# ||lcw|7,xr|||; else get next code word|10045
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|10046
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||10047
# |b_xnt|ent|2,bl_xn|||; entry point (xnblk)|10053
	.align	2
	.byte	bl_xn
b_xnt:
# ||ejc|||||10054
# |b_xrt|ent|2,bl_xr|||; entry point (xrblk)|10060
	.align	2
	.byte	bl_xr
b_xrt:
# |b_yyy|ent|2,bl__i|||; last block routine entry point|10064
	.align	2
	.byte	bl__i
b_yyy:
# ||ttl|27,s p i t b o l -- pattern matching routines||||10065
# |p_aaa|ent|2,bl__i|||; entry to mark first pattern|10074
	.align	2
	.byte	bl__i
p_aaa:
# ||ejc|||||10104
# ||ejc|||||10158
# ||ejc|||||10209
# ||ejc|||||10237
# ||ejc|||||10285
# ||ejc|||||10325
# ||ejc|||||10362
# ||ejc|||||10396
# ||ejc|||||10446
# ||ejc|||||10486
# |p_aba|ent|2,bl_p0|||; p0blk|10495
	.align	2
	.byte	bl_p0
p_aba:
# ||mov|11,-(xs)|8,wb||; stack cursor|10496
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack dummy node ptr|10497
# getarg XR
        push XR
# ||mov|11,-(xs)|3,pmhbs||; stack old stack base ptr|10498
# getarg pmhbs
        push pmhbs
# ||mov|11,-(xs)|21,=ndabb||; stack ptr to node ndabb|10499
# getarg W0
        .data
l_0165: .long ndabb
        .text
        movq l_0165,W0
        push W0
# ||mov|3,pmhbs|7,xs||; store new stack base ptr|10500
# getarg XT
# getarg pmhbs
        movq XT,pmhbs
# ||brn|6,succp|||; succeed|10501
# getarg succp
        jmp  succp
# ||ejc|||||10502
# |p_abb|ent||||; entry point|10508
	.align	2
	nop
p_abb:
# ||mov|3,pmhbs|8,wb||; restore history stack base ptr|10509
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,flpop|||; fail and pop dummy node ptr|10510
# getarg flpop
        jmp  flpop
# ||ejc|||||10511
# |p_abc|ent|2,bl_p0|||; p0blk|10517
	.align	2
	.byte	bl_p0
p_abc:
# ||mov|7,xt|3,pmhbs||; keep p_abb stack base|10518
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wa|13,num03(xt)||; load initial cursor|10519
# getarg num03(,XT,8)
# getarg WA
        movq num03(,XT,8),WA
# ||mov|3,pmhbs|13,num01(xt)||; restore outer stack base ptr|10520
# getarg num01(,XT,8)
# getarg W0
# getarg pmhbs
        movq num01(,XT,8),W0
        movq W0,pmhbs
# ||beq|7,xt|7,xs|6,pabc1|; jump if no history stack entries|10521
# getarg XT
# getarg XT
# getarg pabc1
        cmpq XT,XT
        je   pabc1
# ||mov|11,-(xs)|7,xt||; else save inner pmhbs entry|10522
# getarg XT
        push XT
# ||mov|11,-(xs)|21,=ndabd||; stack ptr to special node ndabd|10523
# getarg W0
        .data
l_0166: .long ndabd
        .text
        movq l_0166,W0
        push W0
# ||brn|6,pabc2|||; merge|10524
# getarg pabc2
        jmp  pabc2
# |pabc1|add|7,xs|19,*num04||; remove ndabb entry and cursor|10528
pabc1:
# getarg W0
# getarg XT
        .data
l_0167: .long 8*num04
        .text
        movq l_0167,W0
        addq W0,XT
# |pabc2|bne|8,wa|8,wb|6,succp|; allow further attempt if non-null|10532
pabc2:
# getarg WA
# getarg WB
# getarg succp
        cmpq WA,WB
        jne  succp
# ||mov|7,xr|13,pthen(xr)||; bypass alternative node so as to ...|10533
# getarg pthen(,XR,8)
# getarg XR
        movq pthen(,XR,8),XR
# ||brn|6,succp|||; ... refuse further match attempts|10534
# getarg succp
        jmp  succp
# ||ejc|||||10535
# |p_abd|ent||||; entry point|10541
	.align	2
	nop
p_abd:
# ||mov|3,pmhbs|8,wb||; restore inner stack base ptr|10542
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,failp|||; and fail|10543
# getarg failp
        jmp  failp
# ||ejc|||||10544
# |p_abo|ent|2,bl_p0|||; p0blk|10550
	.align	2
	.byte	bl_p0
p_abo:
# ||brn|6,exfal|||; signal statement failure|10551
# getarg exfal
        jmp  exfal
# ||ejc|||||10552
# |p_alt|ent|2,bl_p1|||; p1blk|10558
	.align	2
	.byte	bl_p1
p_alt:
# ||mov|11,-(xs)|8,wb||; stack cursor|10559
# getarg WB
        push WB
# ||mov|11,-(xs)|13,parm1(xr)||; stack pointer to alternative|10560
# getarg parm1(,XR,8)
        push parm1(,XR,8)
# ||chk||||; check for stack overflow|10561
        chk_
        or   W0,W0
        jne  sec06
# ||brn|6,succp|||; if all ok, then succeed|10562
# getarg succp
        jmp  succp
# ||ejc|||||10563
# |p_ans|ent|2,bl_p1|||; p1blk|10569
	.align	2
	.byte	bl_p1
p_ans:
# ||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|10570
# getarg WB
# getarg pmssl
# getarg failp
        cmpq WB,pmssl
        je   failp
# ||mov|7,xl|3,r_pms||; else point to subject string|10571
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|10572
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|8,wa|9,(xl)||; load current character|10573
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||bne|8,wa|13,parm1(xr)|6,failp|; fail if no match|10574
# getarg WA
# getarg parm1(,XR,8)
# getarg failp
        cmpq WA,parm1(,XR,8)
        jne  failp
# ||icv|8,wb|||; else bump cursor|10575
# getarg WB
        incq WB
# ||brn|6,succp|||; and succeed|10576
# getarg succp
        jmp  succp
# ||ejc|||||10577
# |p_any|ent|2,bl_p2|||; p2blk|10584
	.align	2
	.byte	bl_p2
p_any:
# |pany1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|10588
pany1:
# getarg WB
# getarg pmssl
# getarg failp
        cmpq WB,pmssl
        je   failp
# ||mov|7,xl|3,r_pms||; else point to subject string|10589
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; get char ptr to current character|10590
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|8,wa|9,(xl)||; load current character|10591
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||mov|7,xl|13,parm1(xr)||; point to ctblk|10592
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# ||wtb|8,wa|||; change to byte offset|10593
# getarg WA
        sal  WA,3
# ||add|7,xl|8,wa||; point to entry in ctblk|10594
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|8,wa|13,ctchs(xl)||; load word from ctblk|10595
# getarg ctchs(,XL,8)
# getarg WA
        movq ctchs(,XL,8),WA
# ||anb|8,wa|13,parm2(xr)||; and with selected bit|10596
# getarg WA
# getarg parm2(,XR,8)
        and  WA,parm2(,XR,8)
# ||zrb|8,wa|6,failp||; fail if no match|10597
# getarg WA
# getarg WA
# getarg failp
        or   WA,WA
        jz   failp
# ||icv|8,wb|||; else bump cursor|10598
# getarg WB
        incq WB
# ||brn|6,succp|||; and succeed|10599
# getarg succp
        jmp  succp
# ||ejc|||||10600
# |p_ayd|ent|2,bl_p1|||; p1blk|10606
	.align	2
	.byte	bl_p1
p_ayd:
# ||jsr|6,evals|||; evaluate string argument|10607
# getarg evals
        call evals
        decq rcode
        js   call_35
# ||err|1,043|26,any evaluated argument is not a string|||10608
# getarg 043
        decq rcode
        jns  l_0168
        movq $43,rcode
        jmp  err_
l_0168:
# ||ppm|6,failp|||; fail if evaluation failure|10609
# getarg failp
# getarg failp
        decq rcode
        jns  l_0169
        jmp  failp
l_0169:
# ||ppm|6,pany1|||; merge multi-char case if ok|10610
# getarg pany1
# getarg pany1
        decq rcode
        jns  l_0170
        jmp  pany1
l_0170:
call_35:
# ||ejc|||||10611
# |p_arb|ent|2,bl_p0|||; p0blk|10620
	.align	2
	.byte	bl_p0
p_arb:
# ||mov|7,xr|13,pthen(xr)||; load successor pointer|10621
# getarg pthen(,XR,8)
# getarg XR
        movq pthen(,XR,8),XR
# ||mov|11,-(xs)|8,wb||; stack dummy cursor|10622
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack successor pointer|10623
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wb||; stack cursor|10624
# getarg WB
        push WB
# ||mov|11,-(xs)|21,=ndarc||; stack ptr to special node ndarc|10625
# getarg W0
        .data
l_0171: .long ndarc
        .text
        movq l_0171,W0
        push W0
# ||bri|9,(xr)|||; execute next node matching null|10626
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||10627
# |p_arc|ent||||; entry point|10633
	.align	2
	nop
p_arc:
# ||beq|8,wb|3,pmssl|6,flpop|; fail and pop stack to successor|10634
# getarg WB
# getarg pmssl
# getarg flpop
        cmpq WB,pmssl
        je   flpop
# ||icv|8,wb|||; else bump cursor|10635
# getarg WB
        incq WB
# ||mov|11,-(xs)|8,wb||; stack updated cursor|10636
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; restack pointer to ndarc node|10637
# getarg XR
        push XR
# ||mov|7,xr|13,num02(xs)||; load successor pointer|10638
# getarg num02(,XT,8)
# getarg XR
        movq num02(,XT,8),XR
# ||bri|9,(xr)|||; off to reexecute successor node|10639
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||10640
# |p_bal|ent|2,bl_p0|||; p0blk|10649
	.align	2
	.byte	bl_p0
p_bal:
# ||zer|8,wc|||; zero parentheses level counter|10650
# getarg WC
        xor  WC,WC
# ||mov|7,xl|3,r_pms||; point to subject string|10651
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|10652
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||brn|6,pbal2|||; jump into scan loop|10653
# getarg pbal2
        jmp  pbal2
# |pbal1|lch|8,wa|10,(xl)+||; load next character, bump pointer|10657
pbal1:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||icv|8,wb|||; push cursor for character|10658
# getarg WB
        incq WB
# ||beq|8,wa|18,=ch_pp|6,pbal3|; jump if left paren|10659
# getarg WA
# getarg W0
# getarg pbal3
        movq l_0158,W0
        cmpq WA,W0
        je   pbal3
# ||beq|8,wa|18,=ch_rp|6,pbal4|; jump if right paren|10660
# getarg WA
# getarg W0
# getarg pbal4
        movq l_0160,W0
        cmpq WA,W0
        je   pbal4
# ||bze|8,wc|6,pbal5||; else succeed if at outer level|10661
# getarg WC
# getarg pbal5
        or   WC,WC
        jz   pbal5
# |pbal2|bne|8,wb|3,pmssl|6,pbal1|; loop back unless end of string|10665
pbal2:
# getarg WB
# getarg pmssl
# getarg pbal1
        cmpq WB,pmssl
        jne  pbal1
# ||brn|6,failp|||; in which case, fail|10666
# getarg failp
        jmp  failp
# |pbal3|icv|8,wc|||; bump paren level|10670
pbal3:
# getarg WC
        incq WC
# ||brn|6,pbal2|||; loop back to check end of string|10671
# getarg pbal2
        jmp  pbal2
# |pbal4|bze|8,wc|6,failp||; fail if no matching left paren|10675
pbal4:
# getarg WC
# getarg failp
        or   WC,WC
        jz   failp
# ||dcv|8,wc|||; else decrement level counter|10676
# getarg WC
        decq WC
# ||bnz|8,wc|6,pbal2||; loop back if not at outer level|10677
# getarg WC
# getarg WC
# getarg pbal2
        or   WC,WC
        jnz  pbal2
# |pbal5|mov|11,-(xs)|8,wb||; stack cursor|10681
pbal5:
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack ptr to bal node for extend|10682
# getarg XR
        push XR
# ||brn|6,succp|||; and succeed|10683
# getarg succp
        jmp  succp
# ||ejc|||||10684
# |p_bkd|ent|2,bl_p1|||; p1blk|10690
	.align	2
	.byte	bl_p1
p_bkd:
# ||jsr|6,evals|||; evaluate string expression|10691
# getarg evals
        call evals
        decq rcode
        js   call_36
# ||err|1,044|26,break evaluated argument is not a string|||10692
# getarg 044
        decq rcode
        jns  l_0172
        movq $44,rcode
        jmp  err_
l_0172:
# ||ppm|6,failp|||; fail if evaluation fails|10693
# getarg failp
# getarg failp
        decq rcode
        jns  l_0173
        jmp  failp
l_0173:
# ||ppm|6,pbrk1|||; merge with multi-char case if ok|10694
# getarg pbrk1
# getarg pbrk1
        decq rcode
        jns  l_0174
        jmp  pbrk1
l_0174:
call_36:
# ||ejc|||||10695
# |p_bks|ent|2,bl_p1|||; p1blk|10701
	.align	2
	.byte	bl_p1
p_bks:
# ||mov|8,wc|3,pmssl||; get subject string length|10702
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; get number of characters left|10703
# getarg WB
# getarg WC
        subq WB,WC
# ||bze|8,wc|6,failp||; fail if no characters left|10704
# getarg WC
# getarg failp
        or   WC,WC
        jz   failp
# ||lct|8,wc|8,wc||; set counter for chars left|10705
# ||mov|7,xl|3,r_pms||; point to subject string|10706
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|10707
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# |pbks1|lch|8,wa|10,(xl)+||; load next char, bump pointer|10711
pbks1:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||beq|8,wa|13,parm1(xr)|6,succp|; succeed if break character found|10712
# getarg WA
# getarg parm1(,XR,8)
# getarg succp
        cmpq WA,parm1(,XR,8)
        je   succp
# ||icv|8,wb|||; else push cursor|10713
# getarg WB
        incq WB
# ||bct|8,wc|6,pbks1||; loop back if more to go|10714
# getarg WC
# getarg pbks1
        decq WC
        jnz  pbks1
# ||brn|6,failp|||; fail if end of string, no break chr|10715
# getarg failp
        jmp  failp
# ||ejc|||||10716
# |p_brk|ent|2,bl_p2|||; p2blk|10723
	.align	2
	.byte	bl_p2
p_brk:
# |pbrk1|mov|8,wc|3,pmssl||; load subject string length|10727
pbrk1:
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; get number of characters left|10728
# getarg WB
# getarg WC
        subq WB,WC
# ||bze|8,wc|6,failp||; fail if no characters left|10729
# getarg WC
# getarg failp
        or   WC,WC
        jz   failp
# ||lct|8,wc|8,wc||; set counter for characters left|10730
# ||mov|7,xl|3,r_pms||; else point to subject string|10731
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|10732
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|3,psave|7,xr||; save node pointer|10733
# getarg XR
# getarg psave
        movq XR,psave
# |pbrk2|lch|8,wa|10,(xl)+||; load next char, bump pointer|10737
pbrk2:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||mov|7,xr|13,parm1(xr)||; load pointer to ctblk|10738
# getarg parm1(,XR,8)
# getarg XR
        movq parm1(,XR,8),XR
# ||wtb|8,wa|||; convert to byte offset|10739
# getarg WA
        sal  WA,3
# ||add|7,xr|8,wa||; point to ctblk entry|10740
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|8,wa|13,ctchs(xr)||; load ctblk word|10741
# getarg ctchs(,XR,8)
# getarg WA
        movq ctchs(,XR,8),WA
# ||mov|7,xr|3,psave||; restore node pointer|10742
# getarg psave
# getarg XR
        movq psave,XR
# ||anb|8,wa|13,parm2(xr)||; and with selected bit|10743
# getarg WA
# getarg parm2(,XR,8)
        and  WA,parm2(,XR,8)
# ||nzb|8,wa|6,succp||; succeed if break character found|10744
# getarg WA
# getarg WA
# getarg succp
        or   WA,WA
        jnz  succp
# ||icv|8,wb|||; else push cursor|10745
# getarg WB
        incq WB
# ||bct|8,wc|6,pbrk2||; loop back unless end of string|10746
# getarg WC
# getarg pbrk2
        decq WC
        jnz  pbrk2
# ||brn|6,failp|||; fail if end of string, no break chr|10747
# getarg failp
        jmp  failp
# ||ejc|||||10748
# |p_bkx|ent|2,bl_p0|||; p0blk|10758
	.align	2
	.byte	bl_p0
p_bkx:
# ||icv|8,wb|||; step cursor past previous break chr|10759
# getarg WB
        incq WB
# ||brn|6,succp|||; succeed to rematch break|10760
# getarg succp
        jmp  succp
# ||ejc|||||10761
# |p_bxd|ent|2,bl_p1|||; p1blk|10772
	.align	2
	.byte	bl_p1
p_bxd:
# ||jsr|6,evals|||; evaluate string argument|10773
# getarg evals
        call evals
        decq rcode
        js   call_37
# ||err|1,045|26,breakx evaluated argument is not a string|||10774
# getarg 045
        decq rcode
        jns  l_0175
        movq $45,rcode
        jmp  err_
l_0175:
# ||ppm|6,failp|||; fail if evaluation fails|10775
# getarg failp
# getarg failp
        decq rcode
        jns  l_0176
        jmp  failp
l_0176:
# ||ppm|6,pbrk1|||; merge with break if all ok|10776
# getarg pbrk1
# getarg pbrk1
        decq rcode
        jns  l_0177
        jmp  pbrk1
l_0177:
call_37:
# ||ejc|||||10777
# |p_cas|ent|2,bl_p2|||; p2blk|10784
	.align	2
	.byte	bl_p2
p_cas:
# ||mov|11,-(xs)|7,xr||; save node pointer|10785
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wb||; save cursor|10786
# getarg WB
        push WB
# ||mov|7,xl|13,parm1(xr)||; load name base|10787
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# ||mti|8,wb|||; load cursor as integer|10788
# getarg WB
        mov  WB,IA
# ||mov|8,wb|13,parm2(xr)||; load name offset|10789
# getarg parm2(,XR,8)
# getarg WB
        movq parm2(,XR,8),WB
# ||jsr|6,icbld|||; get icblk for cursor value|10790
# getarg icbld
        call icbld
# ||mov|8,wa|8,wb||; move name offset|10791
# getarg WB
# getarg WA
        movq WB,WA
# ||mov|8,wb|7,xr||; move value to assign|10792
# getarg XR
# getarg WB
        movq XR,WB
# ||jsr|6,asinp|||; perform assignment|10793
# getarg asinp
        call asinp
        decq rcode
        js   call_38
# ||ppm|6,flpop|||; fail on assignment failure|10794
# getarg flpop
# getarg flpop
        decq rcode
        jns  l_0178
        jmp  flpop
l_0178:
call_38:
# ||mov|8,wb|10,(xs)+||; else restore cursor|10795
# getarg WB
        pop  WB
# ||mov|7,xr|10,(xs)+||; restore node pointer|10796
# getarg XR
        pop  XR
# ||brn|6,succp|||; and succeed matching null|10797
# getarg succp
        jmp  succp
# ||ejc|||||10798
# |p_exa|ent|2,bl_p1|||; p1blk|10807
	.align	2
	.byte	bl_p1
p_exa:
# ||jsr|6,evalp|||; evaluate expression|10808
# getarg evalp
        call evalp
        decq rcode
        js   call_39
# ||ppm|6,failp|||; fail if evaluation fails|10809
# getarg failp
# getarg failp
        decq rcode
        jns  l_0179
        jmp  failp
l_0179:
call_39:
# ||blo|8,wa|22,=p_aaa|6,pexa1|; jump if result is not a pattern|10810
# getarg WA
# getarg W0
# getarg pexa1
        .data
l_0180: .long p_aaa
        .text
        movq l_0180,W0
        cmpq WA,W0
        jb   pexa1
# ||mov|11,-(xs)|8,wb||; stack dummy cursor|10814
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack ptr to p_exa node|10815
# getarg XR
        push XR
# ||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|10816
# getarg pmhbs
        push pmhbs
# ||mov|11,-(xs)|21,=ndexb||; stack ptr to special node ndexb|10817
# getarg W0
        .data
l_0181: .long ndexb
        .text
        movq l_0181,W0
        push W0
# ||mov|3,pmhbs|7,xs||; store new stack base pointer|10818
# getarg XT
# getarg pmhbs
        movq XT,pmhbs
# ||mov|7,xr|7,xl||; copy node pointer|10819
# getarg XL
# getarg XR
        movq XL,XR
# ||bri|9,(xr)|||; match first node in expression pat|10820
# getarg (XR)
        jmp  *(XR)
# |pexa1|beq|8,wa|22,=b_scl|6,pexa2|; jump if it is already a string|10824
pexa1:
# getarg WA
# getarg W0
# getarg pexa2
        movq l_0094,W0
        cmpq WA,W0
        je   pexa2
# ||mov|11,-(xs)|7,xl||; else stack result|10825
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; save node pointer|10826
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtstg|||; convert result to string|10827
# getarg gtstg
        call gtstg
        decq rcode
        js   call_40
# ||err|1,046|26,expression does not evaluate to pattern|||10828
# getarg 046
        decq rcode
        jns  l_0182
        movq $46,rcode
        jmp  err_
l_0182:
call_40:
# ||mov|8,wc|7,xr||; copy string pointer|10829
# getarg XR
# getarg WC
        movq XR,WC
# ||mov|7,xr|7,xl||; restore node pointer|10830
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|8,wc||; copy string pointer again|10831
# getarg WC
# getarg XL
        movq WC,XL
# |pexa2|bze|13,sclen(xl)|6,succp||; just succeed if null string|10835
pexa2:
# getarg sclen(,XL,8)
# getarg succp
        xor  W0,W0
        cmpq sclen(,XL,8),W0
        jz   succp
# ||brn|6,pstr1|||; else merge with string circuit|10836
# getarg pstr1
        jmp  pstr1
# ||ejc|||||10837
# |p_exb|ent||||; entry point|10846
	.align	2
	nop
p_exb:
# ||mov|3,pmhbs|8,wb||; restore outer level stack pointer|10847
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,flpop|||; fail and pop p_exa node ptr|10848
# getarg flpop
        jmp  flpop
# ||ejc|||||10849
# |p_exc|ent||||; entry point|10858
	.align	2
	nop
p_exc:
# ||mov|3,pmhbs|8,wb||; restore inner stack base pointer|10859
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,failp|||; and fail into expr pattern alternvs|10860
# getarg failp
        jmp  failp
# ||ejc|||||10861
# |p_fal|ent|2,bl_p0|||; p0blk|10867
	.align	2
	.byte	bl_p0
p_fal:
# ||brn|6,failp|||; just signal failure|10868
# getarg failp
        jmp  failp
# ||ejc|||||10869
# |p_fen|ent|2,bl_p0|||; p0blk|10878
	.align	2
	.byte	bl_p0
p_fen:
# ||mov|11,-(xs)|8,wb||; stack dummy cursor|10879
# getarg WB
        push WB
# ||mov|11,-(xs)|21,=ndabo||; stack ptr to abort node|10880
# getarg W0
        .data
l_0183: .long ndabo
        .text
        movq l_0183,W0
        push W0
# ||brn|6,succp|||; and succeed matching null|10881
# getarg succp
        jmp  succp
# ||ejc|||||10882
# |p_fna|ent|2,bl_p0|||; p0blk|10891
	.align	2
	.byte	bl_p0
p_fna:
# ||mov|11,-(xs)|3,pmhbs||; stack current history stack base|10892
# getarg pmhbs
        push pmhbs
# ||mov|11,-(xs)|21,=ndfnb||; stack indir ptr to p_fnb (failure)|10893
# getarg W0
        .data
l_0184: .long ndfnb
        .text
        movq l_0184,W0
        push W0
# ||mov|3,pmhbs|7,xs||; begin new history stack|10894
# getarg XT
# getarg pmhbs
        movq XT,pmhbs
# ||brn|6,succp|||; succeed|10895
# getarg succp
        jmp  succp
# ||ejc|||||10896
# |p_fnb|ent|2,bl_p0|||; p0blk|10902
	.align	2
	.byte	bl_p0
p_fnb:
# ||mov|3,pmhbs|8,wb||; restore outer pmhbs stack base|10903
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,failp|||; ...and fail|10904
# getarg failp
        jmp  failp
# ||ejc|||||10905
# |p_fnc|ent|2,bl_p0|||; p0blk|10911
	.align	2
	.byte	bl_p0
p_fnc:
# ||mov|7,xt|3,pmhbs||; get inner stack base ptr|10912
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|3,pmhbs|13,num01(xt)||; restore outer stack base|10913
# getarg num01(,XT,8)
# getarg W0
# getarg pmhbs
        movq num01(,XT,8),W0
        movq W0,pmhbs
# ||beq|7,xt|7,xs|6,pfnc1|; optimize if no alternatives|10914
# getarg XT
# getarg XT
# getarg pfnc1
        cmpq XT,XT
        je   pfnc1
# ||mov|11,-(xs)|7,xt||; else stack inner stack base|10915
# getarg XT
        push XT
# ||mov|11,-(xs)|21,=ndfnd||; stack ptr to ndfnd|10916
# getarg W0
        .data
l_0185: .long ndfnd
        .text
        movq l_0185,W0
        push W0
# ||brn|6,succp|||; succeed|10917
# getarg succp
        jmp  succp
# |pfnc1|add|7,xs|19,*num02||; pop off p_fnb entry|10921
pfnc1:
# getarg W0
# getarg XT
        movq l_0135,W0
        addq W0,XT
# ||brn|6,succp|||; succeed|10922
# getarg succp
        jmp  succp
# ||ejc|||||10923
# |p_fnd|ent|2,bl_p0|||; p0blk|10929
	.align	2
	.byte	bl_p0
p_fnd:
# ||mov|7,xs|8,wb||; pop stack to fence() history base|10930
# getarg WB
# getarg XT
        movq WB,XT
# ||brn|6,flpop|||; pop base entry and fail|10931
# getarg flpop
        jmp  flpop
# ||ejc|||||10932
# |p_ima|ent|2,bl_p0|||; p0blk|10941
	.align	2
	.byte	bl_p0
p_ima:
# ||mov|11,-(xs)|8,wb||; stack cursor|10942
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack dummy node pointer|10943
# getarg XR
        push XR
# ||mov|11,-(xs)|3,pmhbs||; stack old stack base pointer|10944
# getarg pmhbs
        push pmhbs
# ||mov|11,-(xs)|21,=ndimb||; stack ptr to special node ndimb|10945
# getarg W0
        .data
l_0186: .long ndimb
        .text
        movq l_0186,W0
        push W0
# ||mov|3,pmhbs|7,xs||; store new stack base pointer|10946
# getarg XT
# getarg pmhbs
        movq XT,pmhbs
# ||brn|6,succp|||; and succeed|10947
# getarg succp
        jmp  succp
# ||ejc|||||10948
# |p_imb|ent||||; entry point|10957
	.align	2
	nop
p_imb:
# ||mov|3,pmhbs|8,wb||; restore history stack base ptr|10958
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,flpop|||; fail and pop dummy node ptr|10959
# getarg flpop
        jmp  flpop
# ||ejc|||||10960
# |p_imc|ent|2,bl_p2|||; p2blk|10970
	.align	2
	.byte	bl_p2
p_imc:
# ||mov|7,xt|3,pmhbs||; load pointer to p_imb entry|10971
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wa|8,wb||; copy final cursor|10972
# getarg WB
# getarg WA
        movq WB,WA
# ||mov|8,wb|13,num03(xt)||; load initial cursor|10973
# getarg num03(,XT,8)
# getarg WB
        movq num03(,XT,8),WB
# ||mov|3,pmhbs|13,num01(xt)||; restore outer stack base pointer|10974
# getarg num01(,XT,8)
# getarg W0
# getarg pmhbs
        movq num01(,XT,8),W0
        movq W0,pmhbs
# ||beq|7,xt|7,xs|6,pimc1|; jump if no history stack entries|10975
# getarg XT
# getarg XT
# getarg pimc1
        cmpq XT,XT
        je   pimc1
# ||mov|11,-(xs)|7,xt||; else save inner pmhbs pointer|10976
# getarg XT
        push XT
# ||mov|11,-(xs)|21,=ndimd||; and a ptr to special node ndimd|10977
# getarg W0
        .data
l_0187: .long ndimd
        .text
        movq l_0187,W0
        push W0
# ||brn|6,pimc2|||; merge|10978
# getarg pimc2
        jmp  pimc2
# |pimc1|add|7,xs|19,*num04||; remove ndimb entry and cursor|10982
pimc1:
# getarg W0
# getarg XT
        movq l_0167,W0
        addq W0,XT
# |pimc2|mov|11,-(xs)|8,wa||; save current (final) cursor|10986
pimc2:
# getarg WA
        push WA
# ||mov|11,-(xs)|7,xr||; save current node pointer|10987
# getarg XR
        push XR
# ||mov|7,xl|3,r_pms||; point to subject string|10988
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||sub|8,wa|8,wb||; compute substring length|10989
# getarg WB
# getarg WA
        subq WB,WA
# ||jsr|6,sbstr|||; build substring|10990
# getarg sbstr
        call sbstr
# ||mov|8,wb|7,xr||; move result|10991
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|9,(xs)||; reload node pointer|10992
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|7,xl|13,parm1(xr)||; load name base|10993
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# ||mov|8,wa|13,parm2(xr)||; load name offset|10994
# getarg parm2(,XR,8)
# getarg WA
        movq parm2(,XR,8),WA
# ||jsr|6,asinp|||; perform assignment|10995
# getarg asinp
        call asinp
        decq rcode
        js   call_41
# ||ppm|6,flpop|||; fail if assignment fails|10996
# getarg flpop
# getarg flpop
        decq rcode
        jns  l_0188
        jmp  flpop
l_0188:
call_41:
# ||mov|7,xr|10,(xs)+||; else restore node pointer|10997
# getarg XR
        pop  XR
# ||mov|8,wb|10,(xs)+||; restore cursor|10998
# getarg WB
        pop  WB
# ||brn|6,succp|||; and succeed|10999
# getarg succp
        jmp  succp
# ||ejc|||||11000
# |p_imd|ent||||; entry point|11009
	.align	2
	nop
p_imd:
# ||mov|3,pmhbs|8,wb||; restore inner stack base pointer|11010
# getarg WB
# getarg pmhbs
        movq WB,pmhbs
# ||brn|6,failp|||; and fail|11011
# getarg failp
        jmp  failp
# ||ejc|||||11012
# |p_len|ent|2,bl_p1|||; p1blk|11018
	.align	2
	.byte	bl_p1
p_len:
# |plen1|add|8,wb|13,parm1(xr)||; push cursor indicated amount|11022
plen1:
# getarg parm1(,XR,8)
# getarg WB
        addq parm1(,XR,8),WB
# ||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|11023
# getarg WB
# getarg pmssl
# getarg succp
        cmpq WB,pmssl
        jbe  succp
# ||brn|6,failp|||; else fail|11024
# getarg failp
        jmp  failp
# ||ejc|||||11025
# |p_lnd|ent|2,bl_p1|||; p1blk|11031
	.align	2
	.byte	bl_p1
p_lnd:
# ||jsr|6,evali|||; evaluate integer argument|11032
# getarg evali
        call evali
        decq rcode
        js   call_42
# ||err|1,047|26,len evaluated argument is not integer|||11033
# getarg 047
        decq rcode
        jns  l_0189
        movq $47,rcode
        jmp  err_
l_0189:
# ||err|1,048|26,len evaluated argument is negative or too large|||11034
# getarg 048
        decq rcode
        jns  l_0190
        movq $48,rcode
        jmp  err_
l_0190:
# ||ppm|6,failp|||; fail if evaluation fails|11035
# getarg failp
# getarg failp
        decq rcode
        jns  l_0191
        jmp  failp
l_0191:
# ||ppm|6,plen1|||; merge with normal circuit if ok|11036
# getarg plen1
# getarg plen1
        decq rcode
        jns  l_0192
        jmp  plen1
l_0192:
call_42:
# ||ejc|||||11037
# |p_nad|ent|2,bl_p1|||; p1blk|11043
	.align	2
	.byte	bl_p1
p_nad:
# ||jsr|6,evals|||; evaluate string argument|11044
# getarg evals
        call evals
        decq rcode
        js   call_43
# ||err|1,049|26,notany evaluated argument is not a string|||11045
# getarg 049
        decq rcode
        jns  l_0193
        movq $49,rcode
        jmp  err_
l_0193:
# ||ppm|6,failp|||; fail if evaluation fails|11046
# getarg failp
# getarg failp
        decq rcode
        jns  l_0194
        jmp  failp
l_0194:
# ||ppm|6,pnay1|||; merge with multi-char case if ok|11047
# getarg pnay1
# getarg pnay1
        decq rcode
        jns  l_0195
        jmp  pnay1
l_0195:
call_43:
# ||ejc|||||11048
# |p_nas|ent|2,bl_p1|||; entry point|11054
	.align	2
	.byte	bl_p1
p_nas:
# ||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|11055
# getarg WB
# getarg pmssl
# getarg failp
        cmpq WB,pmssl
        je   failp
# ||mov|7,xl|3,r_pms||; else point to subject string|11056
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character in strin|11057
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|8,wa|9,(xl)||; load current character|11058
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||beq|8,wa|13,parm1(xr)|6,failp|; fail if match|11059
# getarg WA
# getarg parm1(,XR,8)
# getarg failp
        cmpq WA,parm1(,XR,8)
        je   failp
# ||icv|8,wb|||; else bump cursor|11060
# getarg WB
        incq WB
# ||brn|6,succp|||; and succeed|11061
# getarg succp
        jmp  succp
# ||ejc|||||11062
# |p_nay|ent|2,bl_p2|||; p2blk|11069
	.align	2
	.byte	bl_p2
p_nay:
# |pnay1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|11073
pnay1:
# getarg WB
# getarg pmssl
# getarg failp
        cmpq WB,pmssl
        je   failp
# ||mov|7,xl|3,r_pms||; else point to subject string|11074
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|11075
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|8,wa|9,(xl)||; load current character|11076
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||wtb|8,wa|||; convert to byte offset|11077
# getarg WA
        sal  WA,3
# ||mov|7,xl|13,parm1(xr)||; load pointer to ctblk|11078
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# ||add|7,xl|8,wa||; point to entry in ctblk|11079
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|8,wa|13,ctchs(xl)||; load entry from ctblk|11080
# getarg ctchs(,XL,8)
# getarg WA
        movq ctchs(,XL,8),WA
# ||anb|8,wa|13,parm2(xr)||; and with selected bit|11081
# getarg WA
# getarg parm2(,XR,8)
        and  WA,parm2(,XR,8)
# ||nzb|8,wa|6,failp||; fail if character is matched|11082
# getarg WA
# getarg WA
# getarg failp
        or   WA,WA
        jnz  failp
# ||icv|8,wb|||; else bump cursor|11083
# getarg WB
        incq WB
# ||brn|6,succp|||; and succeed|11084
# getarg succp
        jmp  succp
# ||ejc|||||11085
# |p_nth|ent|2,bl_p0|||; p0blk (dummy)|11098
	.align	2
	.byte	bl_p0
p_nth:
# ||mov|7,xt|3,pmhbs||; load pointer to base of stack|11099
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wa|13,num01(xt)||; load saved pmhbs (or pattern type)|11100
# getarg num01(,XT,8)
# getarg WA
        movq num01(,XT,8),WA
# ||ble|8,wa|18,=num02|6,pnth2|; jump if outer level (pattern type)|11101
# getarg WA
# getarg W0
# getarg pnth2
        movq l_0130,W0
        cmpq WA,W0
        jbe  pnth2
# ||mov|3,pmhbs|8,wa||; restore outer stack base pointer|11105
# getarg WA
# getarg pmhbs
        movq WA,pmhbs
# ||mov|7,xr|13,num02(xt)||; restore pointer to p_exa node|11106
# getarg num02(,XT,8)
# getarg XR
        movq num02(,XT,8),XR
# ||beq|7,xt|7,xs|6,pnth1|; jump if no history stack entries|11107
# getarg XT
# getarg XT
# getarg pnth1
        cmpq XT,XT
        je   pnth1
# ||mov|11,-(xs)|7,xt||; else stack inner stack base ptr|11108
# getarg XT
        push XT
# ||mov|11,-(xs)|21,=ndexc||; stack ptr to special node ndexc|11109
# getarg W0
        .data
l_0196: .long ndexc
        .text
        movq l_0196,W0
        push W0
# ||brn|6,succp|||; and succeed|11110
# getarg succp
        jmp  succp
# |pnth1|add|7,xs|19,*num04||; remove p_exb entry and node ptr|11114
pnth1:
# getarg W0
# getarg XT
        movq l_0167,W0
        addq W0,XT
# ||brn|6,succp|||; and succeed|11115
# getarg succp
        jmp  succp
# |pnth2|mov|3,pmssl|8,wb||; save final cursor in safe place|11119
pnth2:
# getarg WB
# getarg pmssl
        movq WB,pmssl
# ||bze|3,pmdfl|6,pnth6||; jump if no pattern assignments|11120
# getarg pmdfl
# getarg pnth6
        xor  W0,W0
        cmpq pmdfl,W0
        jz   pnth6
# ||ejc|||||11121
# |pnth3|dca|7,xt|||; point past cursor entry|11128
pnth3:
# getarg XT
        subq $8,XT
# ||mov|8,wa|11,-(xt)||; load node pointer|11129
# getarg (XT)
# getarg WA
        sub  $8,XT
        movq (XT),WA
# ||beq|8,wa|21,=ndpad|6,pnth4|; jump if ndpad entry|11130
# getarg WA
# getarg W0
# getarg pnth4
        .data
l_0197: .long ndpad
        .text
        movq l_0197,W0
        cmpq WA,W0
        je   pnth4
# ||bne|8,wa|21,=ndpab|6,pnth5|; jump if not ndpab entry|11131
# getarg WA
# getarg W0
# getarg pnth5
        .data
l_0198: .long ndpab
        .text
        movq l_0198,W0
        cmpq WA,W0
        jne  pnth5
# ||mov|11,-(xs)|13,num01(xt)||; stack initial cursor|11136
# getarg num01(,XT,8)
        push num01(,XT,8)
# ||chk||||; check for stack overflow|11137
        chk_
        or   W0,W0
        jne  sec06
# ||brn|6,pnth3|||; loop back if ok|11138
# getarg pnth3
        jmp  pnth3
# |pnth4|mov|8,wa|13,num01(xt)||; load final cursor|11143
pnth4:
# getarg num01(,XT,8)
# getarg WA
        movq num01(,XT,8),WA
# ||mov|8,wb|9,(xs)||; load initial cursor from stack|11144
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||mov|9,(xs)|7,xt||; save history stack scan ptr|11145
# getarg XT
# getarg (XT)
        movq XT,(XT)
# ||sub|8,wa|8,wb||; compute length of string|11146
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|3,r_pms||; point to subject string|11150
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||jsr|6,sbstr|||; construct substring|11151
# getarg sbstr
        call sbstr
# ||mov|8,wb|7,xr||; copy substring pointer|11152
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xt|9,(xs)||; reload history stack scan ptr|11153
# getarg (XT)
# getarg XT
        movq (XT),XT
# ||mov|7,xl|13,num02(xt)||; load pointer to p_pac node with nam|11154
# getarg num02(,XT,8)
# getarg XL
        movq num02(,XT,8),XL
# ||mov|8,wa|13,parm2(xl)||; load name offset|11155
# getarg parm2(,XL,8)
# getarg WA
        movq parm2(,XL,8),WA
# ||mov|7,xl|13,parm1(xl)||; load name base|11156
# getarg parm1(,XL,8)
# getarg XL
        movq parm1(,XL,8),XL
# ||jsr|6,asinp|||; perform assignment|11157
# getarg asinp
        call asinp
        decq rcode
        js   call_44
# ||ppm|6,exfal|||; match fails if name eval fails|11158
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0199
        jmp  exfal
l_0199:
call_44:
# ||mov|7,xt|10,(xs)+||; else restore history stack ptr|11159
# getarg XT
        pop  XT
# ||ejc|||||11160
# |pnth5|bne|7,xt|7,xs|6,pnth3|; loop if more entries to scan|11166
pnth5:
# getarg XT
# getarg XT
# getarg pnth3
        cmpq XT,XT
        jne  pnth3
# |pnth6|mov|7,xs|3,pmhbs||; wipe out history stack|11170
pnth6:
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wb|10,(xs)+||; load initial cursor|11171
# getarg WB
        pop  WB
# ||mov|8,wc|10,(xs)+||; load match type code|11172
# getarg WC
        pop  WC
# ||mov|8,wa|3,pmssl||; load final cursor value|11173
# getarg pmssl
# getarg WA
        movq pmssl,WA
# ||mov|7,xl|3,r_pms||; point to subject string|11174
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||zer|3,r_pms|||; clear subject string ptr for gbcol|11175
# getarg r_pms
        mov  $0,W0
        mov  W0,r_pms
# ||bze|8,wc|6,pnth7||; jump if call by name|11176
# getarg WC
# getarg pnth7
        or   WC,WC
        jz   pnth7
# ||beq|8,wc|18,=num02|6,pnth9|; exit if statement level call|11177
# getarg WC
# getarg W0
# getarg pnth9
        movq l_0130,W0
        cmpq WC,W0
        je   pnth9
# ||sub|8,wa|8,wb||; compute length of string|11181
# getarg WB
# getarg WA
        subq WB,WA
# ||jsr|6,sbstr|||; build substring|11182
# getarg sbstr
        call sbstr
# ||mov|11,-(xs)|7,xr||; stack result|11183
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|11184
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|11185
# getarg (XR)
        jmp  *(XR)
# |pnth7|mov|11,-(xs)|8,wb||; stack initial cursor|11189
pnth7:
# getarg WB
        push WB
# ||mov|11,-(xs)|8,wa||; stack final cursor|11190
# getarg WA
        push WA
# |pnth8|mov|11,-(xs)|7,xl||; stack subject pointer|11199
pnth8:
# getarg XL
        push XL
# |pnth9|lcw|7,xr|||; get next code word|11203
pnth9:
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|11204
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||11205
# |p_pos|ent|2,bl_p1|||; p1blk|11211
	.align	2
	.byte	bl_p1
p_pos:
# ||beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11229
# getarg WB
# getarg parm1(,XR,8)
# getarg succp
        cmpq WB,parm1(,XR,8)
        je   succp
# ||bnz|8,wb|6,failp||; don't look further if cursor not 0|11230
# getarg WB
# getarg WB
# getarg failp
        or   WB,WB
        jnz  failp
# ||mov|7,xt|3,pmhbs||; get history stack base ptr|11231
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||bne|7,xr|11,-(xt)|6,failp|; fail if pos is not first node|11232
# getarg XR
# getarg (XT)
# getarg failp
        sub  $8,XT
        cmpq XR,(XT)
        jne  failp
# |ppos2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11236
ppos2:
# getarg (XT)
# getarg W0
# getarg failp
        sub  $8,XT
        .data
l_0200: .long nduna
        .text
        movq l_0200,W0
        cmpq (XT),W0
        jne  failp
# ||mov|8,wb|13,parm1(xr)||; get desired cursor position|11237
# getarg parm1(,XR,8)
# getarg WB
        movq parm1(,XR,8),WB
# ||bgt|8,wb|3,pmssl|6,exfal|; abort if off end|11238
# getarg WB
# getarg pmssl
# getarg exfal
        cmpq WB,pmssl
        ja   exfal
# ||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11239
# getarg WB
# getarg num02(,XT,8)
        movq WB,num02(,XT,8)
# ||brn|6,succp|||; continue match with adjusted cursor|11240
# getarg succp
        jmp  succp
# ||ejc|||||11241
# |p_psd|ent|2,bl_p1|||; p1blk|11247
	.align	2
	.byte	bl_p1
p_psd:
# ||jsr|6,evali|||; evaluate integer argument|11248
# getarg evali
        call evali
        decq rcode
        js   call_45
# ||err|1,050|26,pos evaluated argument is not integer|||11249
# getarg 050
        decq rcode
        jns  l_0201
        movq $50,rcode
        jmp  err_
l_0201:
# ||err|1,051|26,pos evaluated argument is negative or too large|||11250
# getarg 051
        decq rcode
        jns  l_0202
        movq $51,rcode
        jmp  err_
l_0202:
# ||ppm|6,failp|||; fail if evaluation fails|11251
# getarg failp
# getarg failp
        decq rcode
        jns  l_0203
        jmp  failp
l_0203:
# ||ppm|6,ppos1|||; process expression case|11252
# getarg ppos1
# getarg ppos1
        decq rcode
        jns  l_0204
        jmp  ppos1
l_0204:
call_45:
# |ppos1|beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11254
ppos1:
# getarg WB
# getarg parm1(,XR,8)
# getarg succp
        cmpq WB,parm1(,XR,8)
        je   succp
# ||bnz|8,wb|6,failp||; don't look further if cursor not 0|11255
# getarg WB
# getarg WB
# getarg failp
        or   WB,WB
        jnz  failp
# ||bnz|3,evlif|6,failp||; fail if complex argument|11256
# getarg evlif
# getarg failp
        xor  W0,W0
        cmpq evlif,W0
        jnz  failp
# ||mov|7,xt|3,pmhbs||; get history stack base ptr|11257
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wa|3,evlio||; get original node ptr|11258
# getarg evlio
# getarg WA
        movq evlio,WA
# ||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11259
# getarg WA
# getarg (XT)
# getarg failp
        sub  $8,XT
        cmpq WA,(XT)
        jne  failp
# ||brn|6,ppos2|||; merge with integer argument code|11260
# getarg ppos2
        jmp  ppos2
# ||ejc|||||11261
# |p_paa|ent|2,bl_p0|||; p0blk|11270
	.align	2
	.byte	bl_p0
p_paa:
# ||mov|11,-(xs)|8,wb||; stack initial cursor|11271
# getarg WB
        push WB
# ||mov|11,-(xs)|21,=ndpab||; stack ptr to ndpab special node|11272
# getarg W0
        movq l_0198,W0
        push W0
# ||brn|6,succp|||; and succeed matching null|11273
# getarg succp
        jmp  succp
# ||ejc|||||11274
# |p_pab|ent||||; entry point|11283
	.align	2
	nop
p_pab:
# ||brn|6,failp|||; just fail (entry is already popped)|11284
# getarg failp
        jmp  failp
# ||ejc|||||11285
# |p_pac|ent|2,bl_p2|||; p2blk|11295
	.align	2
	.byte	bl_p2
p_pac:
# ||mov|11,-(xs)|8,wb||; stack dummy cursor value|11296
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack pointer to p_pac node|11297
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wb||; stack final cursor|11298
# getarg WB
        push WB
# ||mov|11,-(xs)|21,=ndpad||; stack ptr to special ndpad node|11299
# getarg W0
        movq l_0197,W0
        push W0
# ||mnz|3,pmdfl|||; set dot flag non-zero|11300
# getarg pmdfl
        mov  XS,pmdfl
# ||brn|6,succp|||; and succeed|11301
# getarg succp
        jmp  succp
# ||ejc|||||11302
# |p_pad|ent||||; entry point|11311
	.align	2
	nop
p_pad:
# ||brn|6,flpop|||; fail and remove p_pac node|11312
# getarg flpop
        jmp  flpop
# ||ejc|||||11313
# |p_rem|ent|2,bl_p0|||; p0blk|11319
	.align	2
	.byte	bl_p0
p_rem:
# ||mov|8,wb|3,pmssl||; point cursor to end of string|11320
# getarg pmssl
# getarg WB
        movq pmssl,WB
# ||brn|6,succp|||; and succeed|11321
# getarg succp
        jmp  succp
# ||ejc|||||11322
# |p_rpd|ent|2,bl_p1|||; p1blk|11340
	.align	2
	.byte	bl_p1
p_rpd:
# ||jsr|6,evali|||; evaluate integer argument|11341
# getarg evali
        call evali
        decq rcode
        js   call_46
# ||err|1,052|26,rpos evaluated argument is not integer|||11342
# getarg 052
        decq rcode
        jns  l_0205
        movq $52,rcode
        jmp  err_
l_0205:
# ||err|1,053|26,rpos evaluated argument is negative or too large|||11343
# getarg 053
        decq rcode
        jns  l_0206
        movq $53,rcode
        jmp  err_
l_0206:
# ||ppm|6,failp|||; fail if evaluation fails|11344
# getarg failp
# getarg failp
        decq rcode
        jns  l_0207
        jmp  failp
l_0207:
# ||ppm|6,prps1|||; merge with normal case if ok|11345
# getarg prps1
# getarg prps1
        decq rcode
        jns  l_0208
        jmp  prps1
l_0208:
call_46:
# |prps1|mov|8,wc|3,pmssl||; get length of string|11347
prps1:
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; get number of characters remaining|11348
# getarg WB
# getarg WC
        subq WB,WC
# ||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11349
# getarg WC
# getarg parm1(,XR,8)
# getarg succp
        cmpq WC,parm1(,XR,8)
        je   succp
# ||bnz|8,wb|6,failp||; don't look further if cursor not 0|11350
# getarg WB
# getarg WB
# getarg failp
        or   WB,WB
        jnz  failp
# ||bnz|3,evlif|6,failp||; fail if complex argument|11351
# getarg evlif
# getarg failp
        xor  W0,W0
        cmpq evlif,W0
        jnz  failp
# ||mov|7,xt|3,pmhbs||; get history stack base ptr|11352
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||mov|8,wa|3,evlio||; get original node ptr|11353
# getarg evlio
# getarg WA
        movq evlio,WA
# ||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11354
# getarg WA
# getarg (XT)
# getarg failp
        sub  $8,XT
        cmpq WA,(XT)
        jne  failp
# ||brn|6,prps2|||; merge with integer arg code|11355
# getarg prps2
        jmp  prps2
# ||ejc|||||11356
# |p_rps|ent|2,bl_p1|||; p1blk|11362
	.align	2
	.byte	bl_p1
p_rps:
# ||mov|8,wc|3,pmssl||; get length of string|11368
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; get number of characters remaining|11369
# getarg WB
# getarg WC
        subq WB,WC
# ||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11370
# getarg WC
# getarg parm1(,XR,8)
# getarg succp
        cmpq WC,parm1(,XR,8)
        je   succp
# ||bnz|8,wb|6,failp||; don't look further if cursor not 0|11371
# getarg WB
# getarg WB
# getarg failp
        or   WB,WB
        jnz  failp
# ||mov|7,xt|3,pmhbs||; get history stack base ptr|11372
# getarg pmhbs
# getarg XT
        movq pmhbs,XT
# ||bne|7,xr|11,-(xt)|6,failp|; fail if rpos is not first node|11373
# getarg XR
# getarg (XT)
# getarg failp
        sub  $8,XT
        cmpq XR,(XT)
        jne  failp
# |prps2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11377
prps2:
# getarg (XT)
# getarg W0
# getarg failp
        sub  $8,XT
        movq l_0200,W0
        cmpq (XT),W0
        jne  failp
# ||mov|8,wb|3,pmssl||; point to end of string|11378
# getarg pmssl
# getarg WB
        movq pmssl,WB
# ||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11379
# getarg WB
# getarg parm1(,XR,8)
# getarg failp
        cmpq WB,parm1(,XR,8)
        jb   failp
# ||sub|8,wb|13,parm1(xr)||; else set new cursor|11380
# getarg parm1(,XR,8)
# getarg WB
        subq parm1(,XR,8),WB
# ||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11381
# getarg WB
# getarg num02(,XT,8)
        movq WB,num02(,XT,8)
# ||brn|6,succp|||; continue match with adjusted cursor|11382
# getarg succp
        jmp  succp
# ||ejc|||||11383
# |p_rtb|ent|2,bl_p1|||; p1blk|11389
	.align	2
	.byte	bl_p1
p_rtb:
# |prtb1|mov|8,wc|8,wb||; save initial cursor|11393
prtb1:
# getarg WB
# getarg WC
        movq WB,WC
# ||mov|8,wb|3,pmssl||; point to end of string|11394
# getarg pmssl
# getarg WB
        movq pmssl,WB
# ||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11395
# getarg WB
# getarg parm1(,XR,8)
# getarg failp
        cmpq WB,parm1(,XR,8)
        jb   failp
# ||sub|8,wb|13,parm1(xr)||; else set new cursor|11396
# getarg parm1(,XR,8)
# getarg WB
        subq parm1(,XR,8),WB
# ||bge|8,wb|8,wc|6,succp|; and succeed if not too far already|11397
# getarg WB
# getarg WC
# getarg succp
        cmpq WB,WC
        jae  succp
# ||brn|6,failp|||; in which case, fail|11398
# getarg failp
        jmp  failp
# ||ejc|||||11399
# |p_rtd|ent|2,bl_p1|||; p1blk|11405
	.align	2
	.byte	bl_p1
p_rtd:
# ||jsr|6,evali|||; evaluate integer argument|11406
# getarg evali
        call evali
        decq rcode
        js   call_47
# ||err|1,054|26,rtab evaluated argument is not integer|||11407
# getarg 054
        decq rcode
        jns  l_0209
        movq $54,rcode
        jmp  err_
l_0209:
# ||err|1,055|26,rtab evaluated argument is negative or too large|||11408
# getarg 055
        decq rcode
        jns  l_0210
        movq $55,rcode
        jmp  err_
l_0210:
# ||ppm|6,failp|||; fail if evaluation fails|11409
# getarg failp
# getarg failp
        decq rcode
        jns  l_0211
        jmp  failp
l_0211:
# ||ppm|6,prtb1|||; merge with normal case if success|11410
# getarg prtb1
# getarg prtb1
        decq rcode
        jns  l_0212
        jmp  prtb1
l_0212:
call_47:
# ||ejc|||||11411
# |p_spd|ent|2,bl_p1|||; p1blk|11417
	.align	2
	.byte	bl_p1
p_spd:
# ||jsr|6,evals|||; evaluate string argument|11418
# getarg evals
        call evals
        decq rcode
        js   call_48
# ||err|1,056|26,span evaluated argument is not a string|||11419
# getarg 056
        decq rcode
        jns  l_0213
        movq $56,rcode
        jmp  err_
l_0213:
# ||ppm|6,failp|||; fail if evaluation fails|11420
# getarg failp
# getarg failp
        decq rcode
        jns  l_0214
        jmp  failp
l_0214:
# ||ppm|6,pspn1|||; merge with multi-char case if ok|11421
# getarg pspn1
# getarg pspn1
        decq rcode
        jns  l_0215
        jmp  pspn1
l_0215:
call_48:
# ||ejc|||||11422
# |p_spn|ent|2,bl_p2|||; p2blk|11429
	.align	2
	.byte	bl_p2
p_spn:
# |pspn1|mov|8,wc|3,pmssl||; copy subject string length|11433
pspn1:
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; calculate number of characters left|11434
# getarg WB
# getarg WC
        subq WB,WC
# ||bze|8,wc|6,failp||; fail if no characters left|11435
# getarg WC
# getarg failp
        or   WC,WC
        jz   failp
# ||mov|7,xl|3,r_pms||; point to subject string|11436
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|11437
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|3,psavc|8,wb||; save initial cursor|11438
# getarg WB
# getarg psavc
        movq WB,psavc
# ||mov|3,psave|7,xr||; save node pointer|11439
# getarg XR
# getarg psave
        movq XR,psave
# ||lct|8,wc|8,wc||; set counter for chars left|11440
# |pspn2|lch|8,wa|10,(xl)+||; load next character, bump pointer|11444
pspn2:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||wtb|8,wa|||; convert to byte offset|11445
# getarg WA
        sal  WA,3
# ||mov|7,xr|13,parm1(xr)||; point to ctblk|11446
# getarg parm1(,XR,8)
# getarg XR
        movq parm1(,XR,8),XR
# ||add|7,xr|8,wa||; point to ctblk entry|11447
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|8,wa|13,ctchs(xr)||; load ctblk entry|11448
# getarg ctchs(,XR,8)
# getarg WA
        movq ctchs(,XR,8),WA
# ||mov|7,xr|3,psave||; restore node pointer|11449
# getarg psave
# getarg XR
        movq psave,XR
# ||anb|8,wa|13,parm2(xr)||; and with selected bit|11450
# getarg WA
# getarg parm2(,XR,8)
        and  WA,parm2(,XR,8)
# ||zrb|8,wa|6,pspn3||; jump if no match|11451
# getarg WA
# getarg WA
# getarg pspn3
        or   WA,WA
        jz   pspn3
# ||icv|8,wb|||; else push cursor|11452
# getarg WB
        incq WB
# ||bct|8,wc|6,pspn2||; loop back unless end of string|11453
# getarg WC
# getarg pspn2
        decq WC
        jnz  pspn2
# |pspn3|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11457
pspn3:
# getarg WB
# getarg psavc
# getarg succp
        cmpq WB,psavc
        jne  succp
# ||brn|6,failp|||; else fail if null string matched|11458
# getarg failp
        jmp  failp
# ||ejc|||||11459
# |p_sps|ent|2,bl_p1|||; p1blk|11465
	.align	2
	.byte	bl_p1
p_sps:
# ||mov|8,wc|3,pmssl||; get subject string length|11466
# getarg pmssl
# getarg WC
        movq pmssl,WC
# ||sub|8,wc|8,wb||; calculate number of characters left|11467
# getarg WB
# getarg WC
        subq WB,WC
# ||bze|8,wc|6,failp||; fail if no characters left|11468
# getarg WC
# getarg failp
        or   WC,WC
        jz   failp
# ||mov|7,xl|3,r_pms||; else point to subject string|11469
# getarg r_pms
# getarg XL
        movq r_pms,XL
# ||plc|7,xl|8,wb||; point to current character|11470
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|3,psavc|8,wb||; save initial cursor|11471
# getarg WB
# getarg psavc
        movq WB,psavc
# ||lct|8,wc|8,wc||; set counter for characters left|11472
# |psps1|lch|8,wa|10,(xl)+||; load next character, bump pointer|11476
psps1:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||bne|8,wa|13,parm1(xr)|6,psps2|; jump if no match|11477
# getarg WA
# getarg parm1(,XR,8)
# getarg psps2
        cmpq WA,parm1(,XR,8)
        jne  psps2
# ||icv|8,wb|||; else push cursor|11478
# getarg WB
        incq WB
# ||bct|8,wc|6,psps1||; and loop unless end of string|11479
# getarg WC
# getarg psps1
        decq WC
        jnz  psps1
# |psps2|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11483
psps2:
# getarg WB
# getarg psavc
# getarg succp
        cmpq WB,psavc
        jne  succp
# ||brn|6,failp|||; fail if null string matched|11484
# getarg failp
        jmp  failp
# ||ejc|||||11485
# |p_str|ent|2,bl_p1|||; p1blk|11494
	.align	2
	.byte	bl_p1
p_str:
# ||mov|7,xl|13,parm1(xr)||; get pointer to string|11495
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# |pstr1|mov|3,psave|7,xr||; save node pointer|11499
pstr1:
# getarg XR
# getarg psave
        movq XR,psave
# ||mov|7,xr|3,r_pms||; load subject string pointer|11500
# getarg r_pms
# getarg XR
        movq r_pms,XR
# ||plc|7,xr|8,wb||; point to current character|11501
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# ||add|8,wb|13,sclen(xl)||; compute new cursor position|11502
# getarg sclen(,XL,8)
# getarg WB
        addq sclen(,XL,8),WB
# ||bgt|8,wb|3,pmssl|6,failp|; fail if past end of string|11503
# getarg WB
# getarg pmssl
# getarg failp
        cmpq WB,pmssl
        ja   failp
# ||mov|3,psavc|8,wb||; save updated cursor|11504
# getarg WB
# getarg psavc
        movq WB,psavc
# ||mov|8,wa|13,sclen(xl)||; get number of chars to compare|11505
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||plc|7,xl|||; point to chars of test string|11506
# getarg XL
        add  $cfp_f,XL
# ||cmc|6,failp|6,failp||; compare, fail if not equal|11507
# getarg failp
# getarg failp
        repe cmpsb
        xor  W0,W0
        mov  W0,XL
        mov  XL,XR
        jnz  failp
# ||mov|7,xr|3,psave||; if all matched, restore node ptr|11508
# getarg psave
# getarg XR
        movq psave,XR
# ||mov|8,wb|3,psavc||; restore updated cursor|11509
# getarg psavc
# getarg WB
        movq psavc,WB
# ||brn|6,succp|||; and succeed|11510
# getarg succp
        jmp  succp
# ||ejc|||||11511
# |p_suc|ent|2,bl_p0|||; p0blk|11520
	.align	2
	.byte	bl_p0
p_suc:
# ||mov|11,-(xs)|8,wb||; stack cursor|11521
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; stack pointer to this node|11522
# getarg XR
        push XR
# ||brn|6,succp|||; succeed matching null|11523
# getarg succp
        jmp  succp
# ||ejc|||||11524
# |p_tab|ent|2,bl_p1|||; p1blk|11530
	.align	2
	.byte	bl_p1
p_tab:
# |ptab1|bgt|8,wb|13,parm1(xr)|6,failp|; fail if too far already|11534
ptab1:
# getarg WB
# getarg parm1(,XR,8)
# getarg failp
        cmpq WB,parm1(,XR,8)
        ja   failp
# ||mov|8,wb|13,parm1(xr)||; else set new cursor position|11535
# getarg parm1(,XR,8)
# getarg WB
        movq parm1(,XR,8),WB
# ||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|11536
# getarg WB
# getarg pmssl
# getarg succp
        cmpq WB,pmssl
        jbe  succp
# ||brn|6,failp|||; else fail|11537
# getarg failp
        jmp  failp
# ||ejc|||||11538
# |p_tbd|ent|2,bl_p1|||; p1blk|11544
	.align	2
	.byte	bl_p1
p_tbd:
# ||jsr|6,evali|||; evaluate integer argument|11545
# getarg evali
        call evali
        decq rcode
        js   call_49
# ||err|1,057|26,tab evaluated argument is not integer|||11546
# getarg 057
        decq rcode
        jns  l_0216
        movq $57,rcode
        jmp  err_
l_0216:
# ||err|1,058|26,tab evaluated argument is negative or too large|||11547
# getarg 058
        decq rcode
        jns  l_0217
        movq $58,rcode
        jmp  err_
l_0217:
# ||ppm|6,failp|||; fail if evaluation fails|11548
# getarg failp
# getarg failp
        decq rcode
        jns  l_0218
        jmp  failp
l_0218:
# ||ppm|6,ptab1|||; merge with normal case if ok|11549
# getarg ptab1
# getarg ptab1
        decq rcode
        jns  l_0219
        jmp  ptab1
l_0219:
call_49:
# ||ejc|||||11550
# |p_una|ent||||; entry point|11556
	.align	2
	nop
p_una:
# ||mov|7,xr|8,wb||; copy initial pattern node pointer|11557
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|8,wb|9,(xs)||; get initial cursor|11558
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||beq|8,wb|3,pmssl|6,exfal|; match fails if at end of string|11559
# getarg WB
# getarg pmssl
# getarg exfal
        cmpq WB,pmssl
        je   exfal
# ||icv|8,wb|||; else increment cursor|11560
# getarg WB
        incq WB
# ||mov|9,(xs)|8,wb||; store incremented cursor|11561
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||mov|11,-(xs)|7,xr||; restack initial node ptr|11562
# getarg XR
        push XR
# ||mov|11,-(xs)|21,=nduna||; restack unanchored node|11563
# getarg W0
        movq l_0200,W0
        push W0
# ||bri|9,(xr)|||; rematch first node|11564
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||11565
# |p_yyy|ent|2,bl__i|||; mark last entry in pattern section|11573
	.align	2
	.byte	bl__i
p_yyy:
# ||ttl|27,s p i t b o l -- snobol4 built-in label routines||||11574
# ||ejc|||||11585
# |l_abo|ent||||; entry point|11589
	.align	2
	nop
l_abo:
# |labo1|mov|8,wa|3,kvert||; load error code|11593
labo1:
# getarg kvert
# getarg WA
        movq kvert,WA
# ||bze|8,wa|6,labo3||; jump if no error has occured|11594
# getarg WA
# getarg labo3
        or   WA,WA
        jz   labo3
# ||jsr|6,sysax|||; call after execution proc|11596
# getarg sysax
        call sysax
# ||mov|8,wc|3,kvstn||; current statement|11600
# getarg kvstn
# getarg WC
        movq kvstn,WC
# ||jsr|6,filnm|||; obtain file name for this statement|11601
# getarg filnm
        call filnm
# ||mov|7,xr|3,r_cod||; current code block|11604
# getarg r_cod
# getarg XR
        movq r_cod,XR
# ||mov|8,wc|13,cdsln(xr)||; line number|11605
# getarg cdsln(,XR,8)
# getarg WC
        movq cdsln(,XR,8),WC
# ||zer|8,wb|||; column number|11609
# getarg WB
        xor  WB,WB
# ||mov|7,xr|3,stage||;|11610
# getarg stage
# getarg XR
        movq stage,XR
# ||jsr|6,sysea|||; advise system of error|11611
# getarg sysea
        call sysea
        decq rcode
        js   call_50
# ||ppm|6,stpr4|||; if system does not want print|11612
# getarg stpr4
# getarg stpr4
        decq rcode
        jns  l_0220
        jmp  stpr4
l_0220:
call_50:
# ||jsr|6,prtpg|||; else eject printer|11614
# getarg prtpg
        call prtpg
# ||bze|7,xr|6,labo2||; did sysea request print|11616
# getarg XR
# getarg labo2
        or   XR,XR
        jz   labo2
# ||jsr|6,prtst|||; print text from sysea|11617
# getarg prtst
        call prtst
# |labo2|jsr|6,ermsg|||; print error message|11619
labo2:
# getarg ermsg
        call ermsg
# ||zer|7,xr|||; indicate no message to print|11620
# getarg XR
        xor  XR,XR
# ||brn|6,stopr|||; jump to routine to stop run|11621
# getarg stopr
        jmp  stopr
# |labo3|erb|1,036|26,goto abort with no preceding error|||11625
labo3:
        movq $36,rcode
        jmp  err_
# ||ejc|||||11626
# |l_cnt|ent||||; entry point|11630
	.align	2
	nop
l_cnt:
# |lcnt1|mov|7,xr|3,r_cnt||; load continuation code block ptr|11634
lcnt1:
# getarg r_cnt
# getarg XR
        movq r_cnt,XR
# ||bze|7,xr|6,lcnt3||; jump if no previous error|11635
# getarg XR
# getarg lcnt3
        or   XR,XR
        jz   lcnt3
# ||zer|3,r_cnt|||; clear flag|11636
# getarg r_cnt
        mov  $0,W0
        mov  W0,r_cnt
# ||mov|3,r_cod|7,xr||; else store as new code block ptr|11637
# getarg XR
# getarg r_cod
        movq XR,r_cod
# ||bne|9,(xr)|22,=b_cdc|6,lcnt2|; jump if not complex go|11638
# getarg (XR)
# getarg W0
# getarg lcnt2
        movq l_0012,W0
        cmpq (XR),W0
        jne  lcnt2
# ||mov|8,wa|3,stxoc||; get offset of error|11639
# getarg stxoc
# getarg WA
        movq stxoc,WA
# ||bge|8,wa|3,stxof|6,lcnt4|; jump if error in goto evaluation|11640
# getarg WA
# getarg stxof
# getarg lcnt4
        cmpq WA,stxof
        jae  lcnt4
# |lcnt2|add|7,xr|3,stxof||; add failure offset|11644
lcnt2:
# getarg stxof
# getarg XR
        addq stxof,XR
# ||lcp|7,xr|||; load code pointer|11645
# getarg XR
        lcp_ XR
# ||mov|7,xs|3,flptr||; reset stack pointer|11646
# getarg flptr
# getarg XT
        movq flptr,XT
# ||lcw|7,xr|||; get next code word|11647
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|11648
# getarg (XR)
        jmp  *(XR)
# |lcnt3|icv|3,errft|||; fatal error|11652
lcnt3:
# getarg errft
        incq errft
# ||erb|1,037|26,goto continue with no preceding error|||11653
        movq $37,rcode
        jmp  err_
# |lcnt4|icv|3,errft|||; fatal error|11658
lcnt4:
# getarg errft
        incq errft
# ||erb|1,332|26,goto continue with error in failure goto|||11659
        movq $332,rcode
        jmp  err_
# ||ejc|||||11660
# |l_end|ent||||; entry point|11664
	.align	2
	nop
l_end:
# |lend0|mov|7,xr|21,=endms||; point to message /normal term.../|11668
lend0:
# getarg W0
# getarg XR
        .data
l_0221: .long endms
        .text
        movq l_0221,W0
        movq W0,XR
# ||brn|6,stopr|||; jump to routine to stop run|11669
# getarg stopr
        jmp  stopr
# ||ejc|||||11670
# |l_frt|ent||||; entry point|11674
	.align	2
	nop
l_frt:
# ||mov|8,wa|21,=scfrt||; point to string /freturn/|11675
# getarg W0
# getarg WA
        .data
l_0222: .long scfrt
        .text
        movq l_0222,W0
        movq W0,WA
# ||brn|6,retrn|||; jump to common return routine|11676
# getarg retrn
        jmp  retrn
# ||ejc|||||11677
# |l_nrt|ent||||; entry point|11681
	.align	2
	nop
l_nrt:
# ||mov|8,wa|21,=scnrt||; point to string /nreturn/|11682
# getarg W0
# getarg WA
        .data
l_0223: .long scnrt
        .text
        movq l_0223,W0
        movq W0,WA
# ||brn|6,retrn|||; jump to common return routine|11683
# getarg retrn
        jmp  retrn
# ||ejc|||||11684
# |l_rtn|ent||||; entry point|11688
	.align	2
	nop
l_rtn:
# ||mov|8,wa|21,=scrtn||; point to string /return/|11689
# getarg W0
# getarg WA
        .data
l_0224: .long scrtn
        .text
        movq l_0224,W0
        movq W0,WA
# ||brn|6,retrn|||; jump to common return routine|11690
# getarg retrn
        jmp  retrn
# ||ejc|||||11691
# |l_scn|ent||||; entry point|11695
	.align	2
	nop
l_scn:
# ||mov|7,xr|3,r_cnt||; load continuation code block ptr|11696
# getarg r_cnt
# getarg XR
        movq r_cnt,XR
# ||bze|7,xr|6,lscn2||; jump if no previous error|11697
# getarg XR
# getarg lscn2
        or   XR,XR
        jz   lscn2
# ||zer|3,r_cnt|||; clear flag|11698
# getarg r_cnt
        mov  $0,W0
        mov  W0,r_cnt
# ||bne|3,kvert|18,=nm320|6,lscn1|; error must be user interrupt|11699
# getarg kvert
# getarg W0
# getarg lscn1
        .data
l_0225: .long nm320
        .text
        movq l_0225,W0
        cmpq kvert,W0
        jne  lscn1
# ||beq|3,kvert|18,=nm321|6,lscn2|; detect scontinue loop|11700
# getarg kvert
# getarg W0
# getarg lscn2
        .data
l_0226: .long nm321
        .text
        movq l_0226,W0
        cmpq kvert,W0
        je   lscn2
# ||mov|3,r_cod|7,xr||; else store as new code block ptr|11701
# getarg XR
# getarg r_cod
        movq XR,r_cod
# ||add|7,xr|3,stxoc||; add resume offset|11702
# getarg stxoc
# getarg XR
        addq stxoc,XR
# ||lcp|7,xr|||; load code pointer|11703
# getarg XR
        lcp_ XR
# ||lcw|7,xr|||; get next code word|11704
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|11705
# getarg (XR)
        jmp  *(XR)
# |lscn1|icv|3,errft|||; fatal error|11709
lscn1:
# getarg errft
        incq errft
# ||erb|1,331|26,goto scontinue with no user interrupt|||11710
        movq $331,rcode
        jmp  err_
# |lscn2|icv|3,errft|||; fatal error|11714
lscn2:
# getarg errft
        incq errft
# ||erb|1,321|26,goto scontinue with no preceding error|||11715
        movq $321,rcode
        jmp  err_
# ||ejc|||||11716
# |l_und|ent||||; entry point|11720
	.align	2
	nop
l_und:
# ||erb|1,038|26,goto undefined label|||11721
        movq $38,rcode
        jmp  err_
# ||ttl|27,s p i t b o l -- predefined snobol4 functions||||11722
# ||ejc|||||11747
# |s_any|ent||||; entry point|11801
	.align	2
	nop
s_any:
# ||mov|8,wb|22,=p_ans||; set pcode for single char case|11802
# getarg W0
# getarg WB
        .data
l_0227: .long p_ans
        .text
        movq l_0227,W0
        movq W0,WB
# ||mov|7,xl|22,=p_any||; pcode for multi-char case|11803
# getarg W0
# getarg XL
        .data
l_0228: .long p_any
        .text
        movq l_0228,W0
        movq W0,XL
# ||mov|8,wc|22,=p_ayd||; pcode for expression case|11804
# getarg W0
# getarg WC
        .data
l_0229: .long p_ayd
        .text
        movq l_0229,W0
        movq W0,WC
# ||jsr|6,patst|||; call common routine to build node|11805
# getarg patst
        call patst
        decq rcode
        js   call_51
# ||err|1,059|26,any argument is not a string or expression|||11806
# getarg 059
        decq rcode
        jns  l_0230
        movq $59,rcode
        jmp  err_
l_0230:
call_51:
# ||mov|11,-(xs)|7,xr||; stack result|11807
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|11808
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|11809
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||11810
# |s_app|ent||||; entry point|11836
	.align	2
	nop
s_app:
# ||bze|8,wa|6,sapp3||; jump if no arguments|11837
# getarg WA
# getarg sapp3
        or   WA,WA
        jz   sapp3
# ||dcv|8,wa|||; else get applied func arg count|11838
# getarg WA
        decq WA
# ||mov|8,wb|8,wa||; copy|11839
# getarg WA
# getarg WB
        movq WA,WB
# ||wtb|8,wb|||; convert to bytes|11840
# getarg WB
        sal  WB,3
# ||mov|7,xt|7,xs||; copy stack pointer|11841
# getarg XT
# getarg XT
        movq XT,XT
# ||add|7,xt|8,wb||; point to function argument on stack|11842
# getarg WB
# getarg XT
        addq WB,XT
# ||mov|7,xr|9,(xt)||; load function ptr (apply 1st arg)|11843
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||bze|8,wa|6,sapp2||; jump if no args for applied func|11844
# getarg WA
# getarg sapp2
        or   WA,WA
        jz   sapp2
# ||lct|8,wb|8,wa||; else set counter for loop|11845
# getarg WB
# getarg WA
        mov  WB,WA
# |sapp1|dca|7,xt|||; point to next argument|11849
sapp1:
# getarg XT
        subq $8,XT
# ||mov|13,num01(xt)|9,(xt)||; move argument up|11850
# getarg (XT)
# getarg W0
# getarg num01(,XT,8)
        movq (XT),W0
        movq W0,num01(,XT,8)
# ||bct|8,wb|6,sapp1||; loop till all moved|11851
# getarg WB
# getarg sapp1
        decq WB
        jnz  sapp1
# |sapp2|ica|7,xs|||; adjust stack ptr for apply 1st arg|11855
sapp2:
# getarg XT
        addq $8,XT
# ||jsr|6,gtnvr|||; get variable block addr for func|11856
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_52
# ||ppm|6,sapp3|||; jump if not natural variable|11857
# getarg sapp3
# getarg sapp3
        decq rcode
        jns  l_0231
        jmp  sapp3
l_0231:
call_52:
# ||mov|7,xl|13,vrfnc(xr)||; else point to function block|11858
# getarg vrfnc(,XR,8)
# getarg XL
        movq vrfnc(,XR,8),XL
# ||brn|6,cfunc|||; go call applied function|11859
# getarg cfunc
        jmp  cfunc
# |sapp3|erb|1,060|26,apply first arg is not natural variable name|||11863
sapp3:
        movq $60,rcode
        jmp  err_
# ||ejc|||||11864
# |s_abn|ent||||; entry point|11871
	.align	2
	nop
s_abn:
# ||zer|7,xr|||; set parm1 = 0 for the moment|11872
# getarg XR
        xor  XR,XR
# ||mov|8,wb|22,=p_alt||; set pcode for alternative node|11873
# getarg W0
# getarg WB
        movq l_0083,W0
        movq W0,WB
# ||jsr|6,pbild|||; build alternative node|11874
# getarg pbild
        call pbild
# ||mov|7,xl|7,xr||; save ptr to alternative pattern|11875
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wb|22,=p_abc||; pcode for p_abc|11876
# getarg W0
# getarg WB
        .data
l_0232: .long p_abc
        .text
        movq l_0232,W0
        movq W0,WB
# ||zer|7,xr|||; p0blk|11877
# getarg XR
        xor  XR,XR
# ||jsr|6,pbild|||; build p_abc node|11878
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|7,xl||; put alternative node as successor|11879
# getarg XL
# getarg pthen(,XR,8)
        movq XL,pthen(,XR,8)
# ||mov|8,wa|7,xl||; remember alternative node pointer|11880
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xl|7,xr||; copy p_abc node ptr|11881
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; load arbno argument|11882
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|9,(xs)|8,wa||; stack alternative node pointer|11883
# getarg WA
# getarg (XT)
        movq WA,(XT)
# ||jsr|6,gtpat|||; get arbno argument as pattern|11884
# getarg gtpat
        call gtpat
        decq rcode
        js   call_53
# ||err|1,061|26,arbno argument is not pattern|||11885
# getarg 061
        decq rcode
        jns  l_0233
        movq $61,rcode
        jmp  err_
l_0233:
call_53:
# ||jsr|6,pconc|||; concat arg with p_abc node|11886
# getarg pconc
        call pconc
# ||mov|7,xl|7,xr||; remember ptr to concd patterns|11887
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wb|22,=p_aba||; pcode for p_aba|11888
# getarg W0
# getarg WB
        .data
l_0234: .long p_aba
        .text
        movq l_0234,W0
        movq W0,WB
# ||zer|7,xr|||; p0blk|11889
# getarg XR
        xor  XR,XR
# ||jsr|6,pbild|||; build p_aba node|11890
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|7,xl||; concatenate nodes|11891
# getarg XL
# getarg pthen(,XR,8)
        movq XL,pthen(,XR,8)
# ||mov|7,xl|9,(xs)||; recall ptr to alternative node|11892
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|13,parm1(xl)|7,xr||; point alternative back to argument|11893
# getarg XR
# getarg parm1(,XL,8)
        movq XR,parm1(,XL,8)
# ||lcw|7,xr|||; get next code word|11894
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|11895
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||11896
# |s_arg|ent||||; entry point|11900
	.align	2
	nop
s_arg:
# ||jsr|6,gtsmi|||; get second arg as small integer|11901
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_54
# ||err|1,062|26,arg second argument is not integer|||11902
# getarg 062
        decq rcode
        jns  l_0235
        movq $62,rcode
        jmp  err_
l_0235:
# ||ppm|6,exfal|||; fail if out of range or negative|11903
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0236
        jmp  exfal
l_0236:
call_54:
# ||mov|8,wa|7,xr||; save argument number|11904
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xr|10,(xs)+||; load first argument|11905
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; locate vrblk|11906
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_55
# ||ppm|6,sarg1|||; jump if not natural variable|11907
# getarg sarg1
# getarg sarg1
        decq rcode
        jns  l_0237
        jmp  sarg1
l_0237:
call_55:
# ||mov|7,xr|13,vrfnc(xr)||; else load function block pointer|11908
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_pfc|6,sarg1|; jump if not program defined|11909
# getarg (XR)
# getarg W0
# getarg sarg1
        .data
l_0238: .long b_pfc
        .text
        movq l_0238,W0
        cmpq (XR),W0
        jne  sarg1
# ||bze|8,wa|6,exfal||; fail if arg number is zero|11910
# getarg WA
# getarg exfal
        or   WA,WA
        jz   exfal
# ||bgt|8,wa|13,fargs(xr)|6,exfal|; fail if arg number is too large|11911
# getarg WA
# getarg fargs(,XR,8)
# getarg exfal
        cmpq WA,fargs(,XR,8)
        ja   exfal
# ||wtb|8,wa|||; else convert to byte offset|11912
# getarg WA
        sal  WA,3
# ||add|7,xr|8,wa||; point to argument selected|11913
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|7,xr|13,pfagb(xr)||; load argument vrblk pointer|11914
# getarg pfagb(,XR,8)
# getarg XR
        movq pfagb(,XR,8),XR
# ||brn|6,exvnm|||; exit to build nmblk|11915
# getarg exvnm
        jmp  exvnm
# |sarg1|erb|1,063|26,arg first argument is not program function name|||11919
sarg1:
        movq $63,rcode
        jmp  err_
# ||ejc|||||11920
# |s_arr|ent||||; entry point|11924
	.align	2
	nop
s_arr:
# ||mov|7,xl|10,(xs)+||; load initial element value|11925
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; load first argument|11926
# getarg XR
        pop  XR
# ||jsr|6,gtint|||; convert first arg to integer|11927
# getarg gtint
        call gtint
        decq rcode
        js   call_56
# ||ppm|6,sar02|||; jump if not integer|11928
# getarg sar02
# getarg sar02
        decq rcode
        jns  l_0239
        jmp  sar02
l_0239:
call_56:
# ||ldi|13,icval(xr)|||; load integer value|11932
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||ile|6,sar10|||; jump if zero or neg (bad dimension)|11933
# getarg sar10
        mov  IA,W0
        or   W0,W0
        jle  sar10
# ||mfi|8,wa|6,sar11||; else convert to one word, test ovfl|11934
# getarg sar11
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   sar11
        mov  IA,WA
# ||jsr|6,vmake|||; create vector|11935
# getarg vmake
        call vmake
        decq rcode
        js   call_57
# ||ppm|6,sar11|||; fail if too large|11936
# getarg sar11
# getarg sar11
        decq rcode
        jns  l_0240
        jmp  sar11
l_0240:
call_57:
# ||brn|6,exsid|||; exit setting idval|11937
# getarg exsid
        jmp  exsid
# ||ejc|||||11938
# |sar02|mov|11,-(xs)|7,xr||; replace argument on stack|11944
sar02:
# getarg XR
        push XR
# ||jsr|6,xscni|||; initialize scan of first argument|11945
# getarg xscni
        call xscni
        decq rcode
        js   call_58
# ||err|1,064|26,array first argument is not integer or string|||11946
# getarg 064
        decq rcode
        jns  l_0241
        movq $64,rcode
        jmp  err_
l_0241:
# ||ppm|6,exnul|||; dummy (unused) null string exit|11947
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0242
        jmp  exnul
l_0242:
call_58:
# ||mov|11,-(xs)|3,r_xsc||; save prototype pointer|11948
# getarg r_xsc
        push r_xsc
# ||mov|11,-(xs)|7,xl||; save default value|11949
# getarg XL
        push XL
# ||zer|3,arcdm|||; zero count of dimensions|11950
# getarg arcdm
        mov  $0,W0
        mov  W0,arcdm
# ||zer|3,arptr|||; zero offset to indicate pass one|11951
# getarg arptr
        mov  $0,W0
        mov  W0,arptr
# ||ldi|4,intv1|||; load integer one|11952
# getarg intv1
        mov  intv1,IA
# ||sti|3,arnel|||; initialize element count|11953
# getarg arnel
        mov  IA,arnel
# |sar03|ldi|4,intv1|||; load one as default low bound|11960
sar03:
# getarg intv1
        mov  intv1,IA
# ||sti|3,arsvl|||; save as low bound|11961
# getarg arsvl
        mov  IA,arsvl
# ||mov|8,wc|18,=ch_cl||; set delimiter one = colon|11962
# getarg W0
# getarg WC
        movq l_0162,W0
        movq W0,WC
# ||mov|7,xl|18,=ch_cm||; set delimiter two = comma|11963
# getarg W0
# getarg XL
        movq l_0159,W0
        movq W0,XL
# ||zer|8,wa|||; retain blanks in prototype|11964
# getarg WA
        xor  WA,WA
# ||jsr|6,xscan|||; scan next bound|11965
# getarg xscan
        call xscan
# ||bne|8,wa|18,=num01|6,sar04|; jump if not colon|11966
# getarg WA
# getarg W0
# getarg sar04
        movq l_0060,W0
        cmpq WA,W0
        jne  sar04
# ||jsr|6,gtint|||; convert low bound|11970
# getarg gtint
        call gtint
        decq rcode
        js   call_59
# ||err|1,065|26,array first argument lower bound is not integer|||11971
# getarg 065
        decq rcode
        jns  l_0243
        movq $65,rcode
        jmp  err_
l_0243:
call_59:
# ||ldi|13,icval(xr)|||; load value of low bound|11972
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sti|3,arsvl|||; store low bound value|11973
# getarg arsvl
        mov  IA,arsvl
# ||mov|8,wc|18,=ch_cm||; set delimiter one = comma|11974
# getarg W0
# getarg WC
        movq l_0159,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; and delimiter two = comma|11975
# getarg WC
# getarg XL
        movq WC,XL
# ||zer|8,wa|||; retain blanks in prototype|11976
# getarg WA
        xor  WA,WA
# ||jsr|6,xscan|||; scan high bound|11977
# getarg xscan
        call xscan
# ||ejc|||||11978
# |sar04|jsr|6,gtint|||; convert high bound to integer|11984
sar04:
# getarg gtint
        call gtint
        decq rcode
        js   call_60
# ||err|1,066|26,array first argument upper bound is not integer|||11985
# getarg 066
        decq rcode
        jns  l_0244
        movq $66,rcode
        jmp  err_
l_0244:
call_60:
# ||ldi|13,icval(xr)|||; get high bound|11986
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sbi|3,arsvl|||; subtract lower bound|11987
# getarg arsvl
        sub  arsvl,IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,sar10|||; bad dimension if overflow|11988
# getarg sar10
        iov_ sar10
# ||ilt|6,sar10|||; bad dimension if negative|11989
# getarg sar10
        mov  IA,W0
        or   W0,W0
        jl   sar10
# ||adi|4,intv1|||; add 1 to get dimension|11990
# getarg intv1
        add  intv1,IA
        seto reg_fl
# ||iov|6,sar10|||; bad dimension if overflow|11991
# getarg sar10
        iov_ sar10
# ||mov|7,xl|3,arptr||; load offset (also pass indicator)|11992
# getarg arptr
# getarg XL
        movq arptr,XL
# ||bze|7,xl|6,sar05||; jump if first pass|11993
# getarg XL
# getarg sar05
        or   XL,XL
        jz   sar05
# ||add|7,xl|9,(xs)||; point to current location in arblk|11997
# getarg (XT)
# getarg XL
        addq (XT),XL
# ||sti|13,cfp_i(xl)|||; store dimension|11998
# getarg cfp_i(,XL,8)
        mov  IA,cfp_i(,XL,8)
# ||ldi|3,arsvl|||; load low bound|11999
# getarg arsvl
        mov  arsvl,IA
# ||sti|9,(xl)|||; store low bound|12000
# getarg (XL)
        mov  IA,(XL)
# ||add|3,arptr|19,*ardms||; bump offset to next bounds|12001
# getarg W0
# getarg arptr
        .data
l_0245: .long 8*ardms
        .text
        movq l_0245,W0
        addq W0,arptr
# ||brn|6,sar06|||; jump to check for end of bounds|12002
# getarg sar06
        jmp  sar06
# |sar05|icv|3,arcdm|||; bump dimension count|12006
sar05:
# getarg arcdm
        incq arcdm
# ||mli|3,arnel|||; multiply dimension by count so far|12007
# getarg arnel
        imul arnel,IA
        seto reg_fl
# ||iov|6,sar11|||; too large if overflow|12008
# getarg sar11
        iov_ sar11
# ||sti|3,arnel|||; else store updated element count|12009
# getarg arnel
        mov  IA,arnel
# |sar06|bnz|8,wa|6,sar03||; loop back unless end of bounds|12013
sar06:
# getarg WA
# getarg WA
# getarg sar03
        or   WA,WA
        jnz  sar03
# ||bnz|3,arptr|6,sar09||; jump if end of pass 2|12014
# getarg arptr
# getarg sar09
        xor  W0,W0
        cmpq arptr,W0
        jnz  sar09
# ||ejc|||||12015
# ||ldi|3,arnel|||; get number of elements|12021
# getarg arnel
        mov  arnel,IA
# ||mfi|8,wb|6,sar11||; get as addr integer, test ovflo|12022
# getarg sar11
# getarg WB
        mov  IA,W0
        or   W0,W0
        js   sar11
        mov  IA,WB
# ||wtb|8,wb|||; else convert to length in bytes|12023
# getarg WB
        sal  WB,3
# ||mov|8,wa|19,*arsi_||; set size of standard fields|12024
# getarg W0
# getarg WA
        .data
l_0246: .long 8*arsi_
        .text
        movq l_0246,W0
        movq W0,WA
# ||lct|8,wc|3,arcdm||; set dimension count to control loop|12025
# getarg WC
# getarg arcdm
        mov  WC,arcdm
# |sar07|add|8,wa|19,*ardms||; allow space for one set of bounds|12029
sar07:
# getarg W0
# getarg WA
        movq l_0245,W0
        addq W0,WA
# ||bct|8,wc|6,sar07||; loop back till all accounted for|12030
# getarg WC
# getarg sar07
        decq WC
        jnz  sar07
# ||mov|7,xl|8,wa||; save size (=arofs)|12031
# getarg WA
# getarg XL
        movq WA,XL
# ||add|8,wa|8,wb||; add space for elements|12035
# getarg WB
# getarg WA
        addq WB,WA
# ||ica|8,wa|||; allow for arpro prototype field|12036
# getarg WA
        addq $8,WA
# ||bgt|8,wa|3,mxlen|6,sar11|; fail if too large|12037
# getarg WA
# getarg mxlen
# getarg sar11
        cmpq WA,mxlen
        ja   sar11
# ||jsr|6,alloc|||; else allocate arblk|12038
# getarg alloc
        call alloc
# ||mov|8,wb|9,(xs)||; load default value|12039
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||mov|9,(xs)|7,xr||; save arblk pointer|12040
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|8,wc|8,wa||; save length in bytes|12041
# getarg WA
# getarg WC
        movq WA,WC
# ||btw|8,wa|||; convert length back to words|12042
# getarg WA
        shr  WA,3
# ||lct|8,wa|8,wa||; set counter to control loop|12043
# |sar08|mov|10,(xr)+|8,wb||; set one word|12047
sar08:
# getarg WB
        movq WB,W0
        stosq
# ||bct|8,wa|6,sar08||; loop till all set|12048
# getarg WA
# getarg sar08
        decq WA
        jnz  sar08
# ||ejc|||||12049
# ||mov|7,xr|10,(xs)+||; reload arblk pointer|12055
# getarg XR
        pop  XR
# ||mov|8,wb|9,(xs)||; load prototype|12056
# getarg (XT)
# getarg WB
        movq (XT),WB
# ||mov|9,(xr)|22,=b_art||; set type word|12057
# getarg W0
# getarg (XR)
        .data
l_0247: .long b_art
        .text
        movq l_0247,W0
        movq W0,(XR)
# ||mov|13,arlen(xr)|8,wc||; store length in bytes|12058
# getarg WC
# getarg arlen(,XR,8)
        movq WC,arlen(,XR,8)
# ||zer|13,idval(xr)|||; zero id till we get it built|12059
# getarg idval(,XR,8)
        mov  $0,W0
        mov  W0,idval(,XR,8)
# ||mov|13,arofs(xr)|7,xl||; set prototype field ptr|12060
# getarg XL
# getarg arofs(,XR,8)
        movq XL,arofs(,XR,8)
# ||mov|13,arndm(xr)|3,arcdm||; set number of dimensions|12061
# getarg arcdm
# getarg W0
# getarg arndm(,XR,8)
        movq arcdm,W0
        movq W0,arndm(,XR,8)
# ||mov|8,wc|7,xr||; save arblk pointer|12062
# getarg XR
# getarg WC
        movq XR,WC
# ||add|7,xr|7,xl||; point to prototype field|12063
# getarg XL
# getarg XR
        addq XL,XR
# ||mov|9,(xr)|8,wb||; store prototype ptr in arblk|12064
# getarg WB
# getarg (XR)
        movq WB,(XR)
# ||mov|3,arptr|19,*arlbd||; set offset for pass 2 bounds scan|12065
# getarg W0
# getarg arptr
        .data
l_0248: .long 8*arlbd
        .text
        movq l_0248,W0
        movq W0,arptr
# ||mov|3,r_xsc|8,wb||; reset string pointer for xscan|12066
# getarg WB
# getarg r_xsc
        movq WB,r_xsc
# ||mov|9,(xs)|8,wc||; store arblk pointer on stack|12067
# getarg WC
# getarg (XT)
        movq WC,(XT)
# ||zer|3,xsofs|||; reset offset ptr to start of string|12068
# getarg xsofs
        mov  $0,W0
        mov  W0,xsofs
# ||brn|6,sar03|||; jump back to rescan bounds|12069
# getarg sar03
        jmp  sar03
# |sar09|mov|7,xr|10,(xs)+||; reload pointer to arblk|12073
sar09:
# getarg XR
        pop  XR
# ||brn|6,exsid|||; exit setting idval|12074
# getarg exsid
        jmp  exsid
# |sar10|erb|1,067|26,array dimension is zero, negative or out of range|||12078
sar10:
        movq $67,rcode
        jmp  err_
# |sar11|erb|1,068|26,array size exceeds maximum permitted|||12082
sar11:
        movq $68,rcode
        jmp  err_
# ||ejc|||||12083
# |s_atn|ent||||; entry point|12088
	.align	2
	nop
s_atn:
# ||mov|7,xr|10,(xs)+||; get argument|12089
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|12090
# getarg gtrea
        call gtrea
        decq rcode
        js   call_61
# ||err|1,301|26,atan argument not numeric|||12091
# getarg 301
        decq rcode
        jns  l_0249
        movq $301,rcode
        jmp  err_
l_0249:
call_61:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|12092
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||atn||||; take arctangent|12093
        call atn_
# ||brn|6,exrea|||; overflow, out of range not possible|12094
# getarg exrea
        jmp  exrea
# ||ejc|||||12095
# ||ejc|||||12098
# |s_bsp|ent||||; entry point|12102
	.align	2
	nop
s_bsp:
# ||jsr|6,iofcb|||; call fcblk routine|12103
# getarg iofcb
        call iofcb
        decq rcode
        js   call_62
# ||err|1,316|26,backspace argument is not a suitable name|||12104
# getarg 316
        decq rcode
        jns  l_0250
        movq $316,rcode
        jmp  err_
l_0250:
# ||err|1,316|26,backspace argument is not a suitable name|||12105
# getarg 316
        decq rcode
        jns  l_0251
        movq $316,rcode
        jmp  err_
l_0251:
# ||err|1,317|26,backspace file does not exist|||12106
# getarg 317
        decq rcode
        jns  l_0252
        movq $317,rcode
        jmp  err_
l_0252:
call_62:
# ||jsr|6,sysbs|||; call backspace file function|12107
# getarg sysbs
        call sysbs
        decq rcode
        js   call_63
# ||err|1,317|26,backspace file does not exist|||12108
# getarg 317
        decq rcode
        jns  l_0253
        movq $317,rcode
        jmp  err_
l_0253:
# ||err|1,318|26,backspace file does not permit backspace|||12109
# getarg 318
        decq rcode
        jns  l_0254
        movq $318,rcode
        jmp  err_
l_0254:
# ||err|1,319|26,backspace caused non-recoverable error|||12110
# getarg 319
        decq rcode
        jns  l_0255
        movq $319,rcode
        jmp  err_
l_0255:
call_63:
# ||brn|6,exnul|||; return null as result|12111
# getarg exnul
        jmp  exnul
# ||ejc|||||12112
# |s_brk|ent||||; entry point|12145
	.align	2
	nop
s_brk:
# ||mov|8,wb|22,=p_bks||; set pcode for single char case|12146
# getarg W0
# getarg WB
        .data
l_0256: .long p_bks
        .text
        movq l_0256,W0
        movq W0,WB
# ||mov|7,xl|22,=p_brk||; pcode for multi-char case|12147
# getarg W0
# getarg XL
        .data
l_0257: .long p_brk
        .text
        movq l_0257,W0
        movq W0,XL
# ||mov|8,wc|22,=p_bkd||; pcode for expression case|12148
# getarg W0
# getarg WC
        .data
l_0258: .long p_bkd
        .text
        movq l_0258,W0
        movq W0,WC
# ||jsr|6,patst|||; call common routine to build node|12149
# getarg patst
        call patst
        decq rcode
        js   call_64
# ||err|1,069|26,break argument is not a string or expression|||12150
# getarg 069
        decq rcode
        jns  l_0259
        movq $69,rcode
        jmp  err_
l_0259:
call_64:
# ||mov|11,-(xs)|7,xr||; stack result|12151
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12152
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12153
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12154
# |s_bkx|ent||||; entry point|12161
	.align	2
	nop
s_bkx:
# ||mov|8,wb|22,=p_bks||; pcode for single char argument|12162
# getarg W0
# getarg WB
        movq l_0256,W0
        movq W0,WB
# ||mov|7,xl|22,=p_brk||; pcode for multi-char argument|12163
# getarg W0
# getarg XL
        movq l_0257,W0
        movq W0,XL
# ||mov|8,wc|22,=p_bxd||; pcode for expression case|12164
# getarg W0
# getarg WC
        .data
l_0260: .long p_bxd
        .text
        movq l_0260,W0
        movq W0,WC
# ||jsr|6,patst|||; call common routine to build node|12165
# getarg patst
        call patst
        decq rcode
        js   call_65
# ||err|1,070|26,breakx argument is not a string or expression|||12166
# getarg 070
        decq rcode
        jns  l_0261
        movq $70,rcode
        jmp  err_
l_0261:
call_65:
# ||mov|11,-(xs)|7,xr||; save ptr to break node|12170
# getarg XR
        push XR
# ||mov|8,wb|22,=p_bkx||; set pcode for breakx node|12171
# getarg W0
# getarg WB
        .data
l_0262: .long p_bkx
        .text
        movq l_0262,W0
        movq W0,WB
# ||jsr|6,pbild|||; build it|12172
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|9,(xs)||; set break node as successor|12173
# getarg (XT)
# getarg W0
# getarg pthen(,XR,8)
        movq (XT),W0
        movq W0,pthen(,XR,8)
# ||mov|8,wb|22,=p_alt||; set pcode for alternation node|12174
# getarg W0
# getarg WB
        movq l_0083,W0
        movq W0,WB
# ||jsr|6,pbild|||; build (parm1=alt=breakx node)|12175
# getarg pbild
        call pbild
# ||mov|8,wa|7,xr||; save ptr to alternation node|12176
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xr|9,(xs)||; point to break node|12177
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|13,pthen(xr)|8,wa||; set alternate node as successor|12178
# getarg WA
# getarg pthen(,XR,8)
        movq WA,pthen(,XR,8)
# ||lcw|7,xr|||; result on stack|12179
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|12180
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12181
# |s_chr|ent||||; entry point|12185
	.align	2
	nop
s_chr:
# ||jsr|6,gtsmi|||; convert arg to integer|12186
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_66
# ||err|1,281|26,char argument not integer|||12187
# getarg 281
        decq rcode
        jns  l_0263
        movq $281,rcode
        jmp  err_
l_0263:
# ||ppm|6,schr1|||; too big error exit|12188
# getarg schr1
# getarg schr1
        decq rcode
        jns  l_0264
        jmp  schr1
l_0264:
call_66:
# ||bge|8,wc|18,=cfp_a|6,schr1|; see if out of range of host set|12189
# getarg WC
# getarg W0
# getarg schr1
        movq l_0048,W0
        cmpq WC,W0
        jae  schr1
# ||mov|8,wa|18,=num01||; if not set scblk allocation|12190
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# ||mov|8,wb|8,wc||; save char code|12191
# getarg WC
# getarg WB
        movq WC,WB
# ||jsr|6,alocs|||; allocate 1 bau scblk|12192
# getarg alocs
        call alocs
# ||mov|7,xl|7,xr||; copy scblk pointer|12193
# getarg XR
# getarg XL
        movq XR,XL
# ||psc|7,xl|||; get set to stuff char|12194
# getarg XL
        add  $cfp_f,XL
# ||sch|8,wb|9,(xl)||; stuff it|12195
# getarg WB
        movb
# ||csc|7,xl|||; complete store character|12196
# ||zer|7,xl|||; clear slop in xl|12197
# getarg XL
        xor  XL,XL
# ||mov|11,-(xs)|7,xr||; stack result|12198
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12199
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12200
# getarg (XR)
        jmp  *(XR)
# |schr1|erb|1,282|26,char argument not in range|||12204
schr1:
        movq $282,rcode
        jmp  err_
# ||ejc|||||12205
# |s_chp|ent||||; entry point|12210
	.align	2
	nop
s_chp:
# ||mov|7,xr|10,(xs)+||; get argument|12211
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|12212
# getarg gtrea
        call gtrea
        decq rcode
        js   call_67
# ||err|1,302|26,chop argument not numeric|||12213
# getarg 302
        decq rcode
        jns  l_0265
        movq $302,rcode
        jmp  err_
l_0265:
call_67:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|12214
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||chp||||; truncate to integer valued real|12215
        call chp_
# ||brn|6,exrea|||; no overflow possible|12216
# getarg exrea
        jmp  exrea
# ||ejc|||||12217
# |s_clr|ent||||; entry point|12222
	.align	2
	nop
s_clr:
# ||jsr|6,xscni|||; initialize to scan argument|12223
# getarg xscni
        call xscni
        decq rcode
        js   call_68
# ||err|1,071|26,clear argument is not a string|||12224
# getarg 071
        decq rcode
        jns  l_0266
        movq $71,rcode
        jmp  err_
l_0266:
# ||ppm|6,sclr2|||; jump if null|12225
# getarg sclr2
# getarg sclr2
        decq rcode
        jns  l_0267
        jmp  sclr2
l_0267:
call_68:
# |sclr1|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12230
sclr1:
# getarg W0
# getarg WC
        movq l_0159,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; delimiter two = comma|12231
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12232
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan next variable name|12233
# getarg xscan
        call xscan
# ||jsr|6,gtnvr|||; locate vrblk|12234
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_69
# ||err|1,072|26,clear argument has null variable name|||12235
# getarg 072
        decq rcode
        jns  l_0268
        movq $72,rcode
        jmp  err_
l_0268:
call_69:
# ||zer|13,vrget(xr)|||; else flag by zeroing vrget field|12236
# getarg vrget(,XR,8)
        mov  $0,W0
        mov  W0,vrget(,XR,8)
# ||bnz|8,wa|6,sclr1||; loop back if stopped by comma|12237
# getarg WA
# getarg WA
# getarg sclr1
        or   WA,WA
        jnz  sclr1
# |sclr2|mov|8,wb|3,hshtb||; point to start of hash table|12241
sclr2:
# getarg hshtb
# getarg WB
        movq hshtb,WB
# |sclr3|beq|8,wb|3,hshte|6,exnul|; exit returning null if none left|12245
sclr3:
# getarg WB
# getarg hshte
# getarg exnul
        cmpq WB,hshte
        je   exnul
# ||mov|7,xr|8,wb||; else copy slot pointer|12246
# getarg WB
# getarg XR
        movq WB,XR
# ||ica|8,wb|||; bump slot pointer|12247
# getarg WB
        addq $8,WB
# ||sub|7,xr|19,*vrnxt||; set offset to merge into loop|12248
# getarg W0
# getarg XR
        movq l_0034,W0
        subq W0,XR
# |sclr4|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|12252
sclr4:
# getarg vrnxt(,XR,8)
# getarg XR
        movq vrnxt(,XR,8),XR
# ||bze|7,xr|6,sclr3||; jump for next bucket if chain end|12253
# getarg XR
# getarg sclr3
        or   XR,XR
        jz   sclr3
# ||bnz|13,vrget(xr)|6,sclr5||; jump if not flagged|12254
# getarg vrget(,XR,8)
# getarg sclr5
        xor  W0,W0
        cmpq vrget(,XR,8),W0
        jnz  sclr5
# ||ejc|||||12255
# ||jsr|6,setvr|||; for flagged var, restore vrget|12261
# getarg setvr
        call setvr
# ||brn|6,sclr4|||; and loop back for next vrblk|12262
# getarg sclr4
        jmp  sclr4
# |sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|; check for protected variable|12267
sclr5:
# getarg vrsto(,XR,8)
# getarg W0
# getarg sclr4
        .data
l_0269: .long b_vre
        .text
        movq l_0269,W0
        cmpq vrsto(,XR,8),W0
        je   sclr4
# ||mov|7,xl|7,xr||; copy vrblk pointer|12268
# getarg XR
# getarg XL
        movq XR,XL
# |sclr6|mov|8,wa|7,xl||; save block pointer|12272
sclr6:
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xl|13,vrval(xl)||; load next value field|12273
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,sclr6|; loop back if trapped|12274
# getarg (XL)
# getarg W0
# getarg sclr6
        movq l_0154,W0
        cmpq (XL),W0
        je   sclr6
# ||mov|7,xl|8,wa||; restore block pointer|12278
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|13,vrval(xl)|21,=nulls||; store null constant value|12279
# getarg W0
# getarg vrval(,XL,8)
        movq l_0054,W0
        movq W0,vrval(,XL,8)
# ||brn|6,sclr4|||; loop back for next vrblk|12280
# getarg sclr4
        jmp  sclr4
# ||ejc|||||12281
# |s_cod|ent||||; entry point|12285
	.align	2
	nop
s_cod:
# ||mov|7,xr|10,(xs)+||; load argument|12286
# getarg XR
        pop  XR
# ||jsr|6,gtcod|||; convert to code|12287
# getarg gtcod
        call gtcod
        decq rcode
        js   call_70
# ||ppm|6,exfal|||; fail if conversion is impossible|12288
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0270
        jmp  exfal
l_0270:
call_70:
# ||mov|11,-(xs)|7,xr||; stack result|12289
# getarg XR
        push XR
# ||zer|3,r_ccb|||; forget interim code block|12290
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||lcw|7,xr|||; get next code word|12291
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12292
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12293
# |s_col|ent||||; entry point|12297
	.align	2
	nop
s_col:
# ||mov|7,xr|10,(xs)+||; load argument|12298
# getarg XR
        pop  XR
# ||jsr|6,gtint|||; convert to integer|12299
# getarg gtint
        call gtint
        decq rcode
        js   call_71
# ||err|1,073|26,collect argument is not integer|||12300
# getarg 073
        decq rcode
        jns  l_0271
        movq $73,rcode
        jmp  err_
l_0271:
call_71:
# ||ldi|13,icval(xr)|||; load collect argument|12301
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sti|3,clsvi|||; save collect argument|12302
# getarg clsvi
        mov  IA,clsvi
# ||zer|8,wb|||; set no move up|12303
# getarg WB
        xor  WB,WB
# ||zer|3,r_ccb|||; forget interim code block|12304
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||zer|3,dnams|||; collect sediment too|12306
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# ||jsr|6,gbcol|||; perform garbage collection|12307
# getarg gbcol
        call gbcol
# ||mov|3,dnams|7,xr||; record new sediment size|12308
# getarg XR
# getarg dnams
        movq XR,dnams
# ||mov|8,wa|3,dname||; point to end of memory|12312
# getarg dname
# getarg WA
        movq dname,WA
# ||sub|8,wa|3,dnamp||; subtract next location|12313
# getarg dnamp
# getarg WA
        subq dnamp,WA
# ||btw|8,wa|||; convert bytes to words|12314
# getarg WA
        shr  WA,3
# ||mti|8,wa|||; convert words available as integer|12315
# getarg WA
        mov  WA,IA
# ||sbi|3,clsvi|||; subtract argument|12316
# getarg clsvi
        sub  clsvi,IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,exfal|||; fail if overflow|12317
# getarg exfal
        iov_ exfal
# ||ilt|6,exfal|||; fail if not enough|12318
# getarg exfal
        mov  IA,W0
        or   W0,W0
        jl   exfal
# ||adi|3,clsvi|||; else recompute available|12319
# getarg clsvi
        add  clsvi,IA
        seto reg_fl
# ||brn|6,exint|||; and exit with integer result|12320
# getarg exint
        jmp  exint
# ||ejc|||||12321
# |s_cnv|ent||||; entry point|12350
	.align	2
	nop
s_cnv:
# ||jsr|6,gtstg|||; convert second argument to string|12351
# getarg gtstg
        call gtstg
        decq rcode
        js   call_72
# ||ppm|6,scv29|||; error if second argument not string|12352
# getarg scv29
# getarg scv29
        decq rcode
        jns  l_0272
        jmp  scv29
l_0272:
call_72:
# ||bze|8,wa|6,scv29||; or if null string|12353
# getarg WA
# getarg scv29
        or   WA,WA
        jz   scv29
# ||jsr|6,flstg|||; fold lower case to upper case|12355
# getarg flstg
        call flstg
# ||mov|7,xl|9,(xs)||; load first argument|12357
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||bne|9,(xl)|22,=b_pdt|6,scv01|; jump if not program defined|12358
# getarg (XL)
# getarg W0
# getarg scv01
        movq l_0139,W0
        cmpq (XL),W0
        jne  scv01
# ||mov|7,xl|13,pddfp(xl)||; point to dfblk|12362
# getarg pddfp(,XL,8)
# getarg XL
        movq pddfp(,XL,8),XL
# ||mov|7,xl|13,dfnam(xl)||; load datatype name|12363
# getarg dfnam(,XL,8)
# getarg XL
        movq dfnam(,XL,8),XL
# ||jsr|6,ident|||; compare with second arg|12364
# getarg ident
        call ident
        decq rcode
        js   call_73
# ||ppm|6,exits|||; exit if ident with arg as result|12365
# getarg exits
# getarg exits
        decq rcode
        jns  l_0273
        jmp  exits
l_0273:
call_73:
# ||brn|6,exfal|||; else fail|12366
# getarg exfal
        jmp  exfal
# |scv01|mov|11,-(xs)|7,xr||; save string argument|12370
scv01:
# getarg XR
        push XR
# ||mov|7,xl|21,=svctb||; point to table of names to compare|12371
# getarg W0
# getarg XL
        .data
l_0274: .long svctb
        .text
        movq l_0274,W0
        movq W0,XL
# ||zer|8,wb|||; initialize counter|12372
# getarg WB
        xor  WB,WB
# ||mov|8,wc|8,wa||; save length of argument string|12373
# getarg WA
# getarg WC
        movq WA,WC
# |scv02|mov|7,xr|10,(xl)+||; load next table entry, bump pointer|12377
scv02:
# getarg XR
        lodsq
        movq W0,XR
# ||bze|7,xr|6,exfal||; fail if zero marking end of list|12378
# getarg XR
# getarg exfal
        or   XR,XR
        jz   exfal
# ||bne|8,wc|13,sclen(xr)|6,scv05|; jump if wrong length|12379
# getarg WC
# getarg sclen(,XR,8)
# getarg scv05
        cmpq WC,sclen(,XR,8)
        jne  scv05
# ||mov|3,cnvtp|7,xl||; else store table pointer|12380
# getarg XL
# getarg cnvtp
        movq XL,cnvtp
# ||plc|7,xr|||; point to chars of table entry|12381
# getarg XR
        add  $cfp_f,XR
# ||mov|7,xl|9,(xs)||; load pointer to string argument|12382
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||plc|7,xl|||; point to chars of string arg|12383
# getarg XL
        add  $cfp_f,XL
# ||mov|8,wa|8,wc||; set number of chars to compare|12384
# getarg WC
# getarg WA
        movq WC,WA
# ||cmc|6,scv04|6,scv04||; compare, jump if no match|12385
# getarg scv04
# getarg scv04
        repe cmpsb
        xor  W0,W0
        mov  W0,XL
        mov  XL,XR
        jnz  scv04
# ||ejc|||||12386
# |scv03|mov|7,xl|8,wb||; copy entry number|12392
scv03:
# getarg WB
# getarg XL
        movq WB,XL
# ||ica|7,xs|||; pop string arg off stack|12393
# getarg XT
        addq $8,XT
# ||mov|7,xr|10,(xs)+||; load first argument|12394
# getarg XR
        pop  XR
# ||bsw|7,xl|2,cnvtt||; jump to appropriate routine|12395
# getarg XL
        jmp  *l_0275(,XL,8)
        .data
l_0275:
# ||iff|1,0|6,scv06||; string|12413
# getarg scv06
        .long scv06
# ||iff|1,1|6,scv07||; integer|12413
# getarg scv07
        .long scv07
# ||iff|1,2|6,scv09||; name|12413
# getarg scv09
        .long scv09
# ||iff|1,3|6,scv10||; pattern|12413
# getarg scv10
        .long scv10
# ||iff|1,4|6,scv11||; array|12413
# getarg scv11
        .long scv11
# ||iff|1,5|6,scv19||; table|12413
# getarg scv19
        .long scv19
# ||iff|1,6|6,scv25||; expression|12413
# getarg scv25
        .long scv25
# ||iff|1,7|6,scv26||; code|12413
# getarg scv26
        .long scv26
# ||iff|1,8|6,scv27||; numeric|12413
# getarg scv27
        .long scv27
# ||iff|2,cnvrt|6,scv08||; real|12413
# getarg scv08
        .long scv08
# ||esw||||; end of switch table|12413
        .text
# |scv04|mov|7,xl|3,cnvtp||; restore table pointer, merge|12417
scv04:
# getarg cnvtp
# getarg XL
        movq cnvtp,XL
# |scv05|icv|8,wb|||; bump entry number|12421
scv05:
# getarg WB
        incq WB
# ||brn|6,scv02|||; loop back to check next entry|12422
# getarg scv02
        jmp  scv02
# |scv06|mov|11,-(xs)|7,xr||; replace string argument on stack|12426
scv06:
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert to string|12427
# getarg gtstg
        call gtstg
        decq rcode
        js   call_74
# ||ppm|6,exfal|||; fail if conversion not possible|12428
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0276
        jmp  exfal
l_0276:
call_74:
# ||mov|11,-(xs)|7,xr||; stack result|12429
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12430
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12431
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12432
# |scv07|jsr|6,gtint|||; convert to integer|12438
scv07:
# getarg gtint
        call gtint
        decq rcode
        js   call_75
# ||ppm|6,exfal|||; fail if conversion not possible|12439
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0277
        jmp  exfal
l_0277:
call_75:
# ||mov|11,-(xs)|7,xr||; stack result|12440
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12441
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12442
# getarg (XR)
        jmp  *(XR)
# |scv08|jsr|6,gtrea|||; convert to real|12448
scv08:
# getarg gtrea
        call gtrea
        decq rcode
        js   call_76
# ||ppm|6,exfal|||; fail if conversion not possible|12449
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0278
        jmp  exfal
l_0278:
call_76:
# ||mov|11,-(xs)|7,xr||; stack result|12450
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12451
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12452
# getarg (XR)
        jmp  *(XR)
# |scv09|beq|9,(xr)|22,=b_nml|6,exixr|; return if already a name|12457
scv09:
# getarg (XR)
# getarg W0
# getarg exixr
        movq l_0126,W0
        cmpq (XR),W0
        je   exixr
# ||jsr|6,gtnvr|||; else try string to name convert|12458
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_77
# ||ppm|6,exfal|||; fail if conversion not possible|12459
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0279
        jmp  exfal
l_0279:
call_77:
# ||brn|6,exvnm|||; else exit building nmblk for vrblk|12460
# getarg exvnm
        jmp  exvnm
# |scv10|jsr|6,gtpat|||; convert to pattern|12464
scv10:
# getarg gtpat
        call gtpat
        decq rcode
        js   call_78
# ||ppm|6,exfal|||; fail if conversion not possible|12465
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0280
        jmp  exfal
l_0280:
call_78:
# ||mov|11,-(xs)|7,xr||; stack result|12466
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12467
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12468
# getarg (XR)
        jmp  *(XR)
# |scv11|mov|11,-(xs)|7,xr||; save argument on stack|12477
scv11:
# getarg XR
        push XR
# ||zer|8,wa|||; use table chain block addresses|12478
# getarg WA
        xor  WA,WA
# ||jsr|6,gtarr|||; get an array|12479
# getarg gtarr
        call gtarr
        decq rcode
        js   call_79
# ||ppm|6,exfal|||; fail if empty table|12480
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0281
        jmp  exfal
l_0281:
# ||ppm|6,exfal|||; fail if not convertible|12481
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0282
        jmp  exfal
l_0282:
call_79:
# ||mov|7,xl|10,(xs)+||; reload original arg|12482
# getarg XL
        pop  XL
# ||bne|9,(xl)|22,=b_tbt|6,exsid|; exit if original not a table|12483
# getarg (XL)
# getarg W0
# getarg exsid
        movq l_0086,W0
        cmpq (XL),W0
        jne  exsid
# ||mov|11,-(xs)|7,xr||; sort the intermediate array|12484
# getarg XR
        push XR
# ||mov|11,-(xs)|21,=nulls||; on first column|12485
# getarg W0
        movq l_0054,W0
        push W0
# ||zer|8,wa|||; sort ascending|12486
# getarg WA
        xor  WA,WA
# ||jsr|6,sorta|||; do sort|12487
# getarg sorta
        call sorta
        decq rcode
        js   call_80
# ||ppm|6,exfal|||; if sort fails, so shall we|12488
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0283
        jmp  exfal
l_0283:
call_80:
# ||mov|8,wb|7,xr||; save array result|12489
# getarg XR
# getarg WB
        movq XR,WB
# ||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12490
# getarg ardim(,XR,8)
        mov  ardim(,XR,8),IA
# ||mfi|8,wa|||; get as one word integer|12491
# getarg WA
        mov  IA,WA
# ||lct|8,wa|8,wa||; copy to control loop|12492
# ||add|7,xr|19,*arvl2||; point to first element in array|12493
# getarg W0
# getarg XR
        .data
l_0284: .long 8*arvl2
        .text
        movq l_0284,W0
        addq W0,XR
# |scv12|mov|7,xl|9,(xr)||; get teblk address|12497
scv12:
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||mov|10,(xr)+|13,tesub(xl)||; replace with subscript|12498
# getarg tesub(,XL,8)
        movq tesub(,XL,8),W0
        stosq
# ||mov|10,(xr)+|13,teval(xl)||; replace with value|12499
# getarg teval(,XL,8)
        movq teval(,XL,8),W0
        stosq
# ||bct|8,wa|6,scv12||; loop till all copied over|12500
# getarg WA
# getarg scv12
        decq WA
        jnz  scv12
# ||mov|7,xr|8,wb||; retrieve array address|12501
# getarg WB
# getarg XR
        movq WB,XR
# ||brn|6,exsid|||; exit setting id field|12502
# getarg exsid
        jmp  exsid
# |scv19|mov|8,wa|9,(xr)||; load first word of block|12506
scv19:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||mov|11,-(xs)|7,xr||; replace arblk pointer on stack|12507
# getarg XR
        push XR
# ||beq|8,wa|22,=b_tbt|6,exits|; return arg if already a table|12508
# getarg WA
# getarg W0
# getarg exits
        movq l_0086,W0
        cmpq WA,W0
        je   exits
# ||bne|8,wa|22,=b_art|6,exfal|; else fail if not an array|12509
# getarg WA
# getarg W0
# getarg exfal
        movq l_0247,W0
        cmpq WA,W0
        jne  exfal
# ||ejc|||||12510
# ||bne|13,arndm(xr)|18,=num02|6,exfal|; fail if not 2-dim array|12516
# getarg arndm(,XR,8)
# getarg W0
# getarg exfal
        movq l_0130,W0
        cmpq arndm(,XR,8),W0
        jne  exfal
# ||ldi|13,ardm2(xr)|||; load dim 2|12517
# getarg ardm2(,XR,8)
        mov  ardm2(,XR,8),IA
# ||sbi|4,intv2|||; subtract 2 to compare|12518
# getarg intv2
        sub  intv2,IA
        xor  W0,W0
        seto reg_fl
# ||ine|6,exfal|||; fail if dim2 not 2|12519
# getarg exfal
        mov  IA,W0
        or   W0,W0
        jne  exfal
# ||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12523
# getarg ardim(,XR,8)
        mov  ardim(,XR,8),IA
# ||mfi|8,wa|||; get as one word integer|12524
# getarg WA
        mov  IA,WA
# ||lct|8,wb|8,wa||; copy to control loop|12525
# getarg WB
# getarg WA
        mov  WB,WA
# ||add|8,wa|18,=tbsi_||; add space for standard fields|12526
# getarg W0
# getarg WA
        .data
l_0285: .long tbsi_
        .text
        movq l_0285,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|12527
# getarg WA
        sal  WA,3
# ||jsr|6,alloc|||; allocate space for tbblk|12528
# getarg alloc
        call alloc
# ||mov|8,wc|7,xr||; copy tbblk pointer|12529
# getarg XR
# getarg WC
        movq XR,WC
# ||mov|11,-(xs)|7,xr||; save tbblk pointer|12530
# getarg XR
        push XR
# ||mov|10,(xr)+|22,=b_tbt||; store type word|12531
# getarg W0
        movq l_0086,W0
        movq W0,W0
        stosq
# ||zer|10,(xr)+|||; store zero for idval for now|12532
        mov  $0,W0
        stosq
# ||mov|10,(xr)+|8,wa||; store length|12533
# getarg WA
        movq WA,W0
        stosq
# ||mov|10,(xr)+|21,=nulls||; null initial lookup value|12534
# getarg W0
        movq l_0054,W0
        movq W0,W0
        stosq
# |scv20|mov|10,(xr)+|8,wc||; set bucket ptr to point to tbblk|12538
scv20:
# getarg WC
        movq WC,W0
        stosq
# ||bct|8,wb|6,scv20||; loop till all initialized|12539
# getarg WB
# getarg scv20
        decq WB
        jnz  scv20
# ||mov|8,wb|19,*arvl2||; set offset to first arblk element|12540
# getarg W0
# getarg WB
        movq l_0284,W0
        movq W0,WB
# |scv21|mov|7,xl|13,num01(xs)||; point to arblk|12544
scv21:
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||beq|8,wb|13,arlen(xl)|6,scv24|; jump if all moved|12545
# getarg WB
# getarg arlen(,XL,8)
# getarg scv24
        cmpq WB,arlen(,XL,8)
        je   scv24
# ||add|7,xl|8,wb||; else point to current location|12546
# getarg WB
# getarg XL
        addq WB,XL
# ||add|8,wb|19,*num02||; bump offset|12547
# getarg W0
# getarg WB
        movq l_0135,W0
        addq W0,WB
# ||mov|7,xr|9,(xl)||; load subscript name|12548
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||dca|7,xl|||; adjust ptr to merge (trval=1+1)|12549
# getarg XL
        subq $8,XL
# ||ejc|||||12550
# |scv22|mov|7,xl|13,trval(xl)||; point to next value|12556
scv22:
# getarg trval(,XL,8)
# getarg XL
        movq trval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,scv22|; loop back if trapped|12557
# getarg (XL)
# getarg W0
# getarg scv22
        movq l_0154,W0
        cmpq (XL),W0
        je   scv22
# |scv23|mov|11,-(xs)|7,xl||; stack value|12561
scv23:
# getarg XL
        push XL
# ||mov|7,xl|13,num01(xs)||; load tbblk pointer|12562
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||jsr|6,tfind|||; build teblk (note wb gt 0 by name)|12563
# getarg tfind
        call tfind
        decq rcode
        js   call_81
# ||ppm|6,exfal|||; fail if acess fails|12564
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0286
        jmp  exfal
l_0286:
call_81:
# ||mov|13,teval(xl)|10,(xs)+||; store value in teblk|12565
# getarg teval(,XL,8)
        pop  teval(,XL,8)
# ||brn|6,scv21|||; loop back for next element|12566
# getarg scv21
        jmp  scv21
# |scv24|mov|7,xr|10,(xs)+||; load tbblk pointer|12570
scv24:
# getarg XR
        pop  XR
# ||ica|7,xs|||; pop arblk pointer|12571
# getarg XT
        addq $8,XT
# ||brn|6,exsid|||; exit setting idval|12572
# getarg exsid
        jmp  exsid
# |scv25|zer|8,wb|||; by value|12577
scv25:
# getarg WB
        xor  WB,WB
# ||jsr|6,gtexp|||; convert to expression|12578
# getarg gtexp
        call gtexp
        decq rcode
        js   call_82
# ||ppm|6,exfal|||; fail if conversion not possible|12582
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0287
        jmp  exfal
l_0287:
call_82:
# ||zer|3,r_ccb|||; forget interim code block|12583
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||mov|11,-(xs)|7,xr||; stack result|12584
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12585
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12586
# getarg (XR)
        jmp  *(XR)
# |scv26|jsr|6,gtcod|||; convert to code|12590
scv26:
# getarg gtcod
        call gtcod
        decq rcode
        js   call_83
# ||ppm|6,exfal|||; fail if conversion is not possible|12591
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0288
        jmp  exfal
l_0288:
call_83:
# ||zer|3,r_ccb|||; forget interim code block|12592
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||mov|11,-(xs)|7,xr||; stack result|12593
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12594
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12595
# getarg (XR)
        jmp  *(XR)
# |scv27|jsr|6,gtnum|||; convert to numeric|12599
scv27:
# getarg gtnum
        call gtnum
        decq rcode
        js   call_84
# ||ppm|6,exfal|||; fail if unconvertible|12600
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0289
        jmp  exfal
l_0289:
call_84:
# |scv31|mov|11,-(xs)|7,xr||; stack result|12601
scv31:
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12602
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12603
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12604
# |scv29|erb|1,074|26,convert second argument is not a string|||12630
scv29:
        movq $74,rcode
        jmp  err_
# |s_cop|ent||||; entry point|12634
	.align	2
	nop
s_cop:
# ||jsr|6,copyb|||; copy the block|12635
# getarg copyb
        call copyb
        decq rcode
        js   call_85
# ||ppm|6,exits|||; return if no idval field|12636
# getarg exits
# getarg exits
        decq rcode
        jns  l_0290
        jmp  exits
l_0290:
call_85:
# ||brn|6,exsid|||; exit setting id value|12637
# getarg exsid
        jmp  exsid
# ||ejc|||||12638
# |s_cos|ent||||; entry point|12643
	.align	2
	nop
s_cos:
# ||mov|7,xr|10,(xs)+||; get argument|12644
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|12645
# getarg gtrea
        call gtrea
        decq rcode
        js   call_86
# ||err|1,303|26,cos argument not numeric|||12646
# getarg 303
        decq rcode
        jns  l_0291
        movq $303,rcode
        jmp  err_
l_0291:
call_86:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|12647
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||cos||||; take cosine|12648
        call cos_
# ||rno|6,exrea|||; if no overflow, return result in ra|12649
# getarg exrea
        rno_ exrea
# ||erb|1,322|26,cos argument is out of range|||12650
        movq $322,rcode
        jmp  err_
# ||ejc|||||12651
# |s_dat|ent||||; entry point|12656
	.align	2
	nop
s_dat:
# ||jsr|6,xscni|||; prepare to scan argument|12657
# getarg xscni
        call xscni
        decq rcode
        js   call_87
# ||err|1,075|26,data argument is not a string|||12658
# getarg 075
        decq rcode
        jns  l_0292
        movq $75,rcode
        jmp  err_
l_0292:
# ||err|1,076|26,data argument is null|||12659
# getarg 076
        decq rcode
        jns  l_0293
        movq $76,rcode
        jmp  err_
l_0293:
call_87:
# ||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12663
# getarg W0
# getarg WC
        movq l_0158,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; delimiter two = left paren|12664
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12665
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan datatype name|12666
# getarg xscan
        call xscan
# ||bnz|8,wa|6,sdat1||; skip if left paren found|12667
# getarg WA
# getarg WA
# getarg sdat1
        or   WA,WA
        jnz  sdat1
# ||erb|1,077|26,data argument is missing a left paren|||12668
        movq $77,rcode
        jmp  err_
# |sdat1|mov|8,wa|13,sclen(xr)||; get length|12673
sdat1:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||bze|8,wa|6,sdt1a||; avoid folding if null string|12674
# getarg WA
# getarg sdt1a
        or   WA,WA
        jz   sdt1a
# ||jsr|6,flstg|||; fold lower case to upper case|12675
# getarg flstg
        call flstg
# |sdt1a|mov|7,xl|7,xr||; save name ptr|12676
sdt1a:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|13,sclen(xr)||; get length|12680
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||ctb|8,wa|2,scsi_||; compute space needed|12681
# getarg WA
        add  ($cfp_b-1)+$cfp_b*scsi_,WA
        and  WA,-$8
# ||jsr|6,alost|||; request static store for name|12682
# getarg alost
        call alost
# ||mov|11,-(xs)|7,xr||; save datatype name|12683
# getarg XR
        push XR
# ||mvw||||; copy name to static|12684
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0294:
        or   WA,WA
        jz   l_0295
        movsq
        decq WA
        jmp  l_0294
l_0295:
        cld
# ||mov|7,xr|9,(xs)||; get name ptr|12685
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||zer|7,xl|||; scrub dud register|12686
# getarg XL
        xor  XL,XL
# ||jsr|6,gtnvr|||; locate vrblk for datatype name|12687
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_88
# ||err|1,078|26,data argument has null datatype name|||12688
# getarg 078
        decq rcode
        jns  l_0296
        movq $78,rcode
        jmp  err_
l_0296:
call_88:
# ||mov|3,datdv|7,xr||; save vrblk pointer for datatype|12689
# getarg XR
# getarg datdv
        movq XR,datdv
# ||mov|3,datxs|7,xs||; store starting stack value|12690
# getarg XT
# getarg datxs
        movq XT,datxs
# ||zer|8,wb|||; zero count of field names|12691
# getarg WB
        xor  WB,WB
# |sdat2|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12695
sdat2:
# getarg W0
# getarg WC
        movq l_0160,W0
        movq W0,WC
# ||mov|7,xl|18,=ch_cm||; delimiter two = comma|12696
# getarg W0
# getarg XL
        movq l_0159,W0
        movq W0,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12697
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan next field name|12698
# getarg xscan
        call xscan
# ||bnz|8,wa|6,sdat3||; jump if delimiter found|12699
# getarg WA
# getarg WA
# getarg sdat3
        or   WA,WA
        jnz  sdat3
# ||erb|1,079|26,data argument is missing a right paren|||12700
        movq $79,rcode
        jmp  err_
# |sdat3|jsr|6,gtnvr|||; locate vrblk for field name|12704
sdat3:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_89
# ||err|1,080|26,data argument has null field name|||12705
# getarg 080
        decq rcode
        jns  l_0297
        movq $80,rcode
        jmp  err_
l_0297:
call_89:
# ||mov|11,-(xs)|7,xr||; stack vrblk pointer|12706
# getarg XR
        push XR
# ||icv|8,wb|||; increment counter|12707
# getarg WB
        incq WB
# ||beq|8,wa|18,=num02|6,sdat2|; loop back if stopped by comma|12708
# getarg WA
# getarg W0
# getarg sdat2
        movq l_0130,W0
        cmpq WA,W0
        je   sdat2
# ||ejc|||||12709
# ||mov|8,wa|18,=dfsi_||; set size of dfblk standard fields|12715
# getarg W0
# getarg WA
        .data
l_0298: .long dfsi_
        .text
        movq l_0298,W0
        movq W0,WA
# ||add|8,wa|8,wb||; add number of fields|12716
# getarg WB
# getarg WA
        addq WB,WA
# ||wtb|8,wa|||; convert length to bytes|12717
# getarg WA
        sal  WA,3
# ||mov|8,wc|8,wb||; preserve no. of fields|12718
# getarg WB
# getarg WC
        movq WB,WC
# ||jsr|6,alost|||; allocate space for dfblk|12719
# getarg alost
        call alost
# ||mov|8,wb|8,wc||; get no of fields|12720
# getarg WC
# getarg WB
        movq WC,WB
# ||mov|7,xt|3,datxs||; point to start of stack|12721
# getarg datxs
# getarg XT
        movq datxs,XT
# ||mov|8,wc|9,(xt)||; load datatype name|12722
# getarg (XT)
# getarg WC
        movq (XT),WC
# ||mov|9,(xt)|7,xr||; save dfblk pointer on stack|12723
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|10,(xr)+|22,=b_dfc||; store type word|12724
# getarg W0
        .data
l_0299: .long b_dfc
        .text
        movq l_0299,W0
        movq W0,W0
        stosq
# ||mov|10,(xr)+|8,wb||; store number of fields (fargs)|12725
# getarg WB
        movq WB,W0
        stosq
# ||mov|10,(xr)+|8,wa||; store length (dflen)|12726
# getarg WA
        movq WA,W0
        stosq
# ||sub|8,wa|19,*pddfs||; compute pdblk length (for dfpdl)|12727
# getarg W0
# getarg WA
        .data
l_0300: .long 8*pddfs
        .text
        movq l_0300,W0
        subq W0,WA
# ||mov|10,(xr)+|8,wa||; store pdblk length (dfpdl)|12728
# getarg WA
        movq WA,W0
        stosq
# ||mov|10,(xr)+|8,wc||; store datatype name (dfnam)|12729
# getarg WC
        movq WC,W0
        stosq
# ||lct|8,wc|8,wb||; copy number of fields|12730
# getarg WC
# getarg WB
        mov  WC,WB
# |sdat4|mov|10,(xr)+|11,-(xt)||; move one field name vrblk pointer|12734
sdat4:
# getarg (XT)
        sub  $8,XT
        movq (XT),W0
        stosq
# ||bct|8,wc|6,sdat4||; loop till all moved|12735
# getarg WC
# getarg sdat4
        decq WC
        jnz  sdat4
# ||mov|8,wc|8,wa||; copy length of pdblk for later loop|12739
# getarg WA
# getarg WC
        movq WA,WC
# ||mov|7,xr|3,datdv||; point to vrblk|12740
# getarg datdv
# getarg XR
        movq datdv,XR
# ||mov|7,xt|3,datxs||; point back on stack|12741
# getarg datxs
# getarg XT
        movq datxs,XT
# ||mov|7,xl|9,(xt)||; load dfblk pointer|12742
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||jsr|6,dffnc|||; define function|12743
# getarg dffnc
        call dffnc
# ||ejc|||||12744
# |sdat5|mov|8,wa|19,*ffsi_||; set length of ffblk|12755
sdat5:
# getarg W0
# getarg WA
        .data
l_0301: .long 8*ffsi_
        .text
        movq l_0301,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for ffblk|12756
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_ffc||; set type word|12757
# getarg W0
# getarg (XR)
        .data
l_0302: .long b_ffc
        .text
        movq l_0302,W0
        movq W0,(XR)
# ||mov|13,fargs(xr)|18,=num01||; store fargs (always one)|12758
# getarg W0
# getarg fargs(,XR,8)
        movq l_0060,W0
        movq W0,fargs(,XR,8)
# ||mov|7,xt|3,datxs||; point back on stack|12759
# getarg datxs
# getarg XT
        movq datxs,XT
# ||mov|13,ffdfp(xr)|9,(xt)||; copy dfblk ptr to ffblk|12760
# getarg (XT)
# getarg W0
# getarg ffdfp(,XR,8)
        movq (XT),W0
        movq W0,ffdfp(,XR,8)
# ||dca|8,wc|||; decrement old dfpdl to get next ofs|12761
# getarg WC
        subq $8,WC
# ||mov|13,ffofs(xr)|8,wc||; set offset to this field|12762
# getarg WC
# getarg ffofs(,XR,8)
        movq WC,ffofs(,XR,8)
# ||zer|13,ffnxt(xr)|||; tentatively set zero forward ptr|12763
# getarg ffnxt(,XR,8)
        mov  $0,W0
        mov  W0,ffnxt(,XR,8)
# ||mov|7,xl|7,xr||; copy ffblk pointer for dffnc|12764
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; load vrblk pointer for field|12765
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|7,xr|13,vrfnc(xr)||; load current function pointer|12766
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_ffc|6,sdat6|; skip if not currently a field func|12767
# getarg (XR)
# getarg W0
# getarg sdat6
        movq l_0302,W0
        cmpq (XR),W0
        jne  sdat6
# ||mov|13,ffnxt(xl)|7,xr||; link new ffblk to previous chain|12772
# getarg XR
# getarg ffnxt(,XL,8)
        movq XR,ffnxt(,XL,8)
# |sdat6|mov|7,xr|10,(xs)+||; load vrblk pointer|12776
sdat6:
# getarg XR
        pop  XR
# ||jsr|6,dffnc|||; define field function|12777
# getarg dffnc
        call dffnc
# ||bne|7,xs|3,datxs|6,sdat5|; loop back till all done|12778
# getarg XT
# getarg datxs
# getarg sdat5
        cmpq XT,datxs
        jne  sdat5
# ||ica|7,xs|||; pop dfblk pointer|12779
# getarg XT
        addq $8,XT
# ||brn|6,exnul|||; return with null result|12780
# getarg exnul
        jmp  exnul
# ||ejc|||||12781
# |s_dtp|ent||||; entry point|12785
	.align	2
	nop
s_dtp:
# ||mov|7,xr|10,(xs)+||; load argument|12786
# getarg XR
        pop  XR
# ||jsr|6,dtype|||; get datatype|12787
# getarg dtype
        call dtype
# ||mov|11,-(xs)|7,xr||; stack result|12788
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12789
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12790
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12791
# |s_dte|ent||||; entry point|12795
	.align	2
	nop
s_dte:
# ||mov|7,xr|10,(xs)+||; load argument|12796
# getarg XR
        pop  XR
# ||jsr|6,gtint|||; convert to an integer|12797
# getarg gtint
        call gtint
        decq rcode
        js   call_90
# ||err|1,330|26,date argument is not integer|||12798
# getarg 330
        decq rcode
        jns  l_0303
        movq $330,rcode
        jmp  err_
l_0303:
call_90:
# ||jsr|6,sysdt|||; call system date routine|12799
# getarg sysdt
        call sysdt
# ||mov|8,wa|13,num01(xl)||; load length for sbstr|12800
# getarg num01(,XL,8)
# getarg WA
        movq num01(,XL,8),WA
# ||bze|8,wa|6,exnul||; return null if length is zero|12801
# getarg WA
# getarg exnul
        or   WA,WA
        jz   exnul
# ||zer|8,wb|||; set zero offset|12802
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; use sbstr to build scblk|12803
# getarg sbstr
        call sbstr
# ||mov|11,-(xs)|7,xr||; stack result|12804
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|12805
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|12806
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||12807
# |s_def|ent||||; entry point|12811
	.align	2
	nop
s_def:
# ||mov|7,xr|10,(xs)+||; load second argument|12812
# getarg XR
        pop  XR
# ||zer|3,deflb|||; zero label pointer in case null|12813
# getarg deflb
        mov  $0,W0
        mov  W0,deflb
# ||beq|7,xr|21,=nulls|6,sdf01|; jump if null second argument|12814
# getarg XR
# getarg W0
# getarg sdf01
        movq l_0054,W0
        cmpq XR,W0
        je   sdf01
# ||jsr|6,gtnvr|||; else find vrblk for label|12815
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_91
# ||ppm|6,sdf12|||; jump if not a variable name|12816
# getarg sdf12
# getarg sdf12
        decq rcode
        jns  l_0304
        jmp  sdf12
l_0304:
call_91:
# ||mov|3,deflb|7,xr||; else set specified entry|12817
# getarg XR
# getarg deflb
        movq XR,deflb
# |sdf01|jsr|6,xscni|||; prepare to scan first argument|12821
sdf01:
# getarg xscni
        call xscni
        decq rcode
        js   call_92
# ||err|1,081|26,define first argument is not a string|||12822
# getarg 081
        decq rcode
        jns  l_0305
        movq $81,rcode
        jmp  err_
l_0305:
# ||err|1,082|26,define first argument is null|||12823
# getarg 082
        decq rcode
        jns  l_0306
        movq $82,rcode
        jmp  err_
l_0306:
call_92:
# ||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12824
# getarg W0
# getarg WC
        movq l_0158,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; delimiter two = left paren|12825
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12826
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan out function name|12827
# getarg xscan
        call xscan
# ||bnz|8,wa|6,sdf02||; jump if left paren found|12828
# getarg WA
# getarg WA
# getarg sdf02
        or   WA,WA
        jnz  sdf02
# ||erb|1,083|26,define first argument is missing a left paren|||12829
        movq $83,rcode
        jmp  err_
# |sdf02|jsr|6,gtnvr|||; get variable name|12833
sdf02:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_93
# ||err|1,084|26,define first argument has null function name|||12834
# getarg 084
        decq rcode
        jns  l_0307
        movq $84,rcode
        jmp  err_
l_0307:
call_93:
# ||mov|3,defvr|7,xr||; save vrblk pointer for function nam|12835
# getarg XR
# getarg defvr
        movq XR,defvr
# ||zer|8,wb|||; zero count of arguments|12836
# getarg WB
        xor  WB,WB
# ||mov|3,defxs|7,xs||; save initial stack pointer|12837
# getarg XT
# getarg defxs
        movq XT,defxs
# ||bnz|3,deflb|6,sdf03||; jump if second argument given|12838
# getarg deflb
# getarg sdf03
        xor  W0,W0
        cmpq deflb,W0
        jnz  sdf03
# ||mov|3,deflb|7,xr||; else default is function name|12839
# getarg XR
# getarg deflb
        movq XR,deflb
# |sdf03|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12843
sdf03:
# getarg W0
# getarg WC
        movq l_0160,W0
        movq W0,WC
# ||mov|7,xl|18,=ch_cm||; delimiter two = comma|12844
# getarg W0
# getarg XL
        movq l_0159,W0
        movq W0,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12845
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan out next argument name|12846
# getarg xscan
        call xscan
# ||bnz|8,wa|6,sdf04||; skip if delimiter found|12847
# getarg WA
# getarg WA
# getarg sdf04
        or   WA,WA
        jnz  sdf04
# ||erb|1,085|26,null arg name or missing ) in define first arg.|||12848
        movq $85,rcode
        jmp  err_
# ||ejc|||||12849
# |sdf04|bne|7,xr|21,=nulls|6,sdf05|; skip if non-null|12855
sdf04:
# getarg XR
# getarg W0
# getarg sdf05
        movq l_0054,W0
        cmpq XR,W0
        jne  sdf05
# ||bze|8,wb|6,sdf06||; ignore null if case of no arguments|12856
# getarg WB
# getarg sdf06
        or   WB,WB
        jz   sdf06
# |sdf05|jsr|6,gtnvr|||; get vrblk pointer|12860
sdf05:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_94
# ||ppm|6,sdf03|||; loop back to ignore null name|12861
# getarg sdf03
# getarg sdf03
        decq rcode
        jns  l_0308
        jmp  sdf03
l_0308:
call_94:
# ||mov|11,-(xs)|7,xr||; stack argument vrblk pointer|12862
# getarg XR
        push XR
# ||icv|8,wb|||; increment counter|12863
# getarg WB
        incq WB
# ||beq|8,wa|18,=num02|6,sdf03|; loop back if stopped by a comma|12864
# getarg WA
# getarg W0
# getarg sdf03
        movq l_0130,W0
        cmpq WA,W0
        je   sdf03
# |sdf06|mov|3,defna|8,wb||; save number of arguments|12868
sdf06:
# getarg WB
# getarg defna
        movq WB,defna
# ||zer|8,wb|||; zero count of locals|12869
# getarg WB
        xor  WB,WB
# |sdf07|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12873
sdf07:
# getarg W0
# getarg WC
        movq l_0159,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; set delimiter two = comma|12874
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|12875
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan out next local name|12876
# getarg xscan
        call xscan
# ||bne|7,xr|21,=nulls|6,sdf08|; skip if non-null|12877
# getarg XR
# getarg W0
# getarg sdf08
        movq l_0054,W0
        cmpq XR,W0
        jne  sdf08
# ||bze|8,wa|6,sdf09||; exit scan if end of string|12878
# getarg WA
# getarg sdf09
        or   WA,WA
        jz   sdf09
# |sdf08|jsr|6,gtnvr|||; get vrblk pointer|12882
sdf08:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_95
# ||ppm|6,sdf07|||; loop back to ignore null name|12883
# getarg sdf07
# getarg sdf07
        decq rcode
        jns  l_0309
        jmp  sdf07
l_0309:
call_95:
# ||icv|8,wb|||; if ok, increment count|12884
# getarg WB
        incq WB
# ||mov|11,-(xs)|7,xr||; stack vrblk pointer|12885
# getarg XR
        push XR
# ||bnz|8,wa|6,sdf07||; loop back if stopped by a comma|12886
# getarg WA
# getarg WA
# getarg sdf07
        or   WA,WA
        jnz  sdf07
# ||ejc|||||12887
# |sdf09|mov|8,wa|8,wb||; copy count of locals|12893
sdf09:
# getarg WB
# getarg WA
        movq WB,WA
# ||add|8,wa|3,defna||; add number of arguments|12894
# getarg defna
# getarg WA
        addq defna,WA
# ||mov|8,wc|8,wa||; set sum args+locals as loop count|12895
# getarg WA
# getarg WC
        movq WA,WC
# ||add|8,wa|18,=pfsi_||; add space for standard fields|12896
# getarg W0
# getarg WA
        .data
l_0310: .long pfsi_
        .text
        movq l_0310,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|12897
# getarg WA
        sal  WA,3
# ||jsr|6,alloc|||; allocate space for pfblk|12898
# getarg alloc
        call alloc
# ||mov|7,xl|7,xr||; save pointer to pfblk|12899
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|10,(xr)+|22,=b_pfc||; store first word|12900
# getarg W0
        movq l_0238,W0
        movq W0,W0
        stosq
# ||mov|10,(xr)+|3,defna||; store number of arguments|12901
# getarg defna
        movq defna,W0
        stosq
# ||mov|10,(xr)+|8,wa||; store length (pflen)|12902
# getarg WA
        movq WA,W0
        stosq
# ||mov|10,(xr)+|3,defvr||; store vrblk ptr for function name|12903
# getarg defvr
        movq defvr,W0
        stosq
# ||mov|10,(xr)+|8,wb||; store number of locals|12904
# getarg WB
        movq WB,W0
        stosq
# ||zer|10,(xr)+|||; deal with label later|12905
        mov  $0,W0
        stosq
# ||zer|10,(xr)+|||; zero pfctr|12906
        mov  $0,W0
        stosq
# ||zer|10,(xr)+|||; zero pfrtr|12907
        mov  $0,W0
        stosq
# ||bze|8,wc|6,sdf11||; skip if no args or locals|12908
# getarg WC
# getarg sdf11
        or   WC,WC
        jz   sdf11
# ||mov|8,wa|7,xl||; keep pfblk pointer|12909
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xt|3,defxs||; point before arguments|12910
# getarg defxs
# getarg XT
        movq defxs,XT
# ||lct|8,wc|8,wc||; get count of args+locals for loop|12911
# |sdf10|mov|10,(xr)+|11,-(xt)||; store one entry and bump pointers|12915
sdf10:
# getarg (XT)
        sub  $8,XT
        movq (XT),W0
        stosq
# ||bct|8,wc|6,sdf10||; loop till all stored|12916
# getarg WC
# getarg sdf10
        decq WC
        jnz  sdf10
# ||mov|7,xl|8,wa||; recover pfblk pointer|12917
# getarg WA
# getarg XL
        movq WA,XL
# ||ejc|||||12918
# |sdf11|mov|7,xs|3,defxs||; pop stack|12924
sdf11:
# getarg defxs
# getarg XT
        movq defxs,XT
# ||mov|13,pfcod(xl)|3,deflb||; store label vrblk in pfblk|12925
# getarg deflb
# getarg W0
# getarg pfcod(,XL,8)
        movq deflb,W0
        movq W0,pfcod(,XL,8)
# ||mov|7,xr|3,defvr||; point back to vrblk for function|12926
# getarg defvr
# getarg XR
        movq defvr,XR
# ||jsr|6,dffnc|||; define function|12927
# getarg dffnc
        call dffnc
# ||brn|6,exnul|||; and exit returning null|12928
# getarg exnul
        jmp  exnul
# |sdf12|erb|1,086|26,define function entry point is not defined label|||12932
sdf12:
        movq $86,rcode
        jmp  err_
# ||ejc|||||12933
# |s_det|ent||||; entry point|12937
	.align	2
	nop
s_det:
# ||mov|7,xr|10,(xs)+||; load argument|12938
# getarg XR
        pop  XR
# ||jsr|6,gtvar|||; locate variable|12939
# getarg gtvar
        call gtvar
        decq rcode
        js   call_96
# ||err|1,087|26,detach argument is not appropriate name|||12940
# getarg 087
        decq rcode
        jns  l_0311
        movq $87,rcode
        jmp  err_
l_0311:
call_96:
# ||jsr|6,dtach|||; detach i/o association from name|12941
# getarg dtach
        call dtach
# ||brn|6,exnul|||; return null result|12942
# getarg exnul
        jmp  exnul
# ||ejc|||||12943
# |s_dif|ent||||; entry point|12947
	.align	2
	nop
s_dif:
# ||mov|7,xr|10,(xs)+||; load second argument|12948
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; load first argument|12949
# getarg XL
        pop  XL
# ||jsr|6,ident|||; call ident comparison routine|12950
# getarg ident
        call ident
        decq rcode
        js   call_97
# ||ppm|6,exfal|||; fail if ident|12951
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0312
        jmp  exfal
l_0312:
call_97:
# ||brn|6,exnul|||; return null if differ|12952
# getarg exnul
        jmp  exnul
# ||ejc|||||12953
# |s_dmp|ent||||; entry point|12957
	.align	2
	nop
s_dmp:
# ||jsr|6,gtsmi|||; load dump arg as small integer|12958
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_98
# ||err|1,088|26,dump argument is not integer|||12959
# getarg 088
        decq rcode
        jns  l_0313
        movq $88,rcode
        jmp  err_
l_0313:
# ||err|1,089|26,dump argument is negative or too large|||12960
# getarg 089
        decq rcode
        jns  l_0314
        movq $89,rcode
        jmp  err_
l_0314:
call_98:
# ||jsr|6,dumpr|||; else call dump routine|12961
# getarg dumpr
        call dumpr
# ||brn|6,exnul|||; and return null as result|12962
# getarg exnul
        jmp  exnul
# ||ejc|||||12963
# |s_dup|ent||||; entry point|12967
	.align	2
	nop
s_dup:
# ||jsr|6,gtsmi|||; get second argument as small integr|12968
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_99
# ||err|1,090|26,dupl second argument is not integer|||12969
# getarg 090
        decq rcode
        jns  l_0315
        movq $90,rcode
        jmp  err_
l_0315:
# ||ppm|6,sdup7|||; jump if negative or too big|12970
# getarg sdup7
# getarg sdup7
        decq rcode
        jns  l_0316
        jmp  sdup7
l_0316:
call_99:
# ||mov|8,wb|7,xr||; save duplication factor|12971
# getarg XR
# getarg WB
        movq XR,WB
# ||jsr|6,gtstg|||; get first arg as string|12972
# getarg gtstg
        call gtstg
        decq rcode
        js   call_100
# ||ppm|6,sdup4|||; jump if not a string|12973
# getarg sdup4
# getarg sdup4
        decq rcode
        jns  l_0317
        jmp  sdup4
l_0317:
call_100:
# ||mti|8,wa|||; acquire length as integer|12977
# getarg WA
        mov  WA,IA
# ||sti|3,dupsi|||; save for the moment|12978
# getarg dupsi
        mov  IA,dupsi
# ||mti|8,wb|||; get duplication factor as integer|12979
# getarg WB
        mov  WB,IA
# ||mli|3,dupsi|||; form product|12980
# getarg dupsi
        imul dupsi,IA
        seto reg_fl
# ||iov|6,sdup3|||; jump if overflow|12981
# getarg sdup3
        iov_ sdup3
# ||ieq|6,exnul|||; return null if result length = 0|12982
# getarg exnul
        mov  IA,W0
        or   W0,W0
        je   exnul
# ||mfi|8,wa|6,sdup3||; get as addr integer, check ovflo|12983
# getarg sdup3
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   sdup3
        mov  IA,WA
# |sdup1|mov|7,xl|7,xr||; save string pointer|12987
sdup1:
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,alocs|||; allocate space for string|12988
# getarg alocs
        call alocs
# ||mov|11,-(xs)|7,xr||; save as result pointer|12989
# getarg XR
        push XR
# ||mov|8,wc|7,xl||; save pointer to argument string|12990
# getarg XL
# getarg WC
        movq XL,WC
# ||psc|7,xr|||; prepare to store chars of result|12991
# getarg XR
        add  $cfp_f,XR
# ||lct|8,wb|8,wb||; set counter to control loop|12992
# |sdup2|mov|7,xl|8,wc||; point back to argument string|12996
sdup2:
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|8,wa|13,sclen(xl)||; get number of characters|12997
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||plc|7,xl|||; point to chars in argument string|12998
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move characters to result string|12999
        rep
        movsb
# ||bct|8,wb|6,sdup2||; loop till all duplications done|13000
# getarg WB
# getarg sdup2
        decq WB
        jnz  sdup2
# ||zer|7,xl|||; clear garbage value|13001
# getarg XL
        xor  XL,XL
# ||lcw|7,xr|||; get next code word|13002
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|13003
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||13004
# |sdup3|mov|8,wa|3,dname||; set impossible length for alocs|13010
sdup3:
# getarg dname
# getarg WA
        movq dname,WA
# ||brn|6,sdup1|||; merge back|13011
# getarg sdup1
        jmp  sdup1
# |sdup4|jsr|6,gtpat|||; convert argument to pattern|13015
sdup4:
# getarg gtpat
        call gtpat
        decq rcode
        js   call_101
# ||err|1,091|26,dupl first argument is not a string or pattern|||13016
# getarg 091
        decq rcode
        jns  l_0319
        movq $91,rcode
        jmp  err_
l_0319:
call_101:
# ||mov|11,-(xs)|7,xr||; store pattern on stack|13020
# getarg XR
        push XR
# ||mov|7,xr|21,=ndnth||; start off with null pattern|13021
# getarg W0
# getarg XR
        .data
l_0320: .long ndnth
        .text
        movq l_0320,W0
        movq W0,XR
# ||bze|8,wb|6,sdup6||; null pattern is result if dupfac=0|13022
# getarg WB
# getarg sdup6
        or   WB,WB
        jz   sdup6
# ||mov|11,-(xs)|8,wb||; preserve loop count|13023
# getarg WB
        push WB
# |sdup5|mov|7,xl|7,xr||; copy current value as right argumnt|13027
sdup5:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,num01(xs)||; get a new copy of left|13028
# getarg num01(,XT,8)
# getarg XR
        movq num01(,XT,8),XR
# ||jsr|6,pconc|||; concatenate|13029
# getarg pconc
        call pconc
# ||dcv|9,(xs)|||; count down|13030
# getarg (XT)
        decq (XT)
# ||bnz|9,(xs)|6,sdup5||; loop|13031
# getarg (XT)
# getarg sdup5
        xor  W0,W0
        cmpq (XT),W0
        jnz  sdup5
# ||ica|7,xs|||; pop loop count|13032
# getarg XT
        addq $8,XT
# |sdup6|mov|9,(xs)|7,xr||; store result on stack|13036
sdup6:
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||lcw|7,xr|||; get next code word|13037
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|13038
# getarg (XR)
        jmp  *(XR)
# |sdup7|ica|7,xs|||; pop first argument|13042
sdup7:
# getarg XT
        addq $8,XT
# ||brn|6,exfal|||; fail|13043
# getarg exfal
        jmp  exfal
# ||ejc|||||13044
# |s_ejc|ent||||; entry point|13048
	.align	2
	nop
s_ejc:
# ||jsr|6,iofcb|||; call fcblk routine|13049
# getarg iofcb
        call iofcb
        decq rcode
        js   call_102
# ||err|1,092|26,eject argument is not a suitable name|||13050
# getarg 092
        decq rcode
        jns  l_0321
        movq $92,rcode
        jmp  err_
l_0321:
# ||ppm|6,sejc1|||; null argument|13051
# getarg sejc1
# getarg sejc1
        decq rcode
        jns  l_0322
        jmp  sejc1
l_0322:
# ||err|1,093|26,eject file does not exist|||13052
# getarg 093
        decq rcode
        jns  l_0323
        movq $93,rcode
        jmp  err_
l_0323:
call_102:
# ||jsr|6,sysef|||; call eject file function|13053
# getarg sysef
        call sysef
        decq rcode
        js   call_103
# ||err|1,093|26,eject file does not exist|||13054
# getarg 093
        decq rcode
        jns  l_0324
        movq $93,rcode
        jmp  err_
l_0324:
# ||err|1,094|26,eject file does not permit page eject|||13055
# getarg 094
        decq rcode
        jns  l_0325
        movq $94,rcode
        jmp  err_
l_0325:
# ||err|1,095|26,eject caused non-recoverable output error|||13056
# getarg 095
        decq rcode
        jns  l_0326
        movq $95,rcode
        jmp  err_
l_0326:
call_103:
# ||brn|6,exnul|||; return null as result|13057
# getarg exnul
        jmp  exnul
# |sejc1|jsr|6,sysep|||; call routine to eject printer|13061
sejc1:
# getarg sysep
        call sysep
# ||brn|6,exnul|||; exit with null result|13062
# getarg exnul
        jmp  exnul
# ||ejc|||||13063
# |s_enf|ent||||; entry point|13067
	.align	2
	nop
s_enf:
# ||jsr|6,iofcb|||; call fcblk routine|13068
# getarg iofcb
        call iofcb
        decq rcode
        js   call_104
# ||err|1,096|26,endfile argument is not a suitable name|||13069
# getarg 096
        decq rcode
        jns  l_0327
        movq $96,rcode
        jmp  err_
l_0327:
# ||err|1,097|26,endfile argument is null|||13070
# getarg 097
        decq rcode
        jns  l_0328
        movq $97,rcode
        jmp  err_
l_0328:
# ||err|1,098|26,endfile file does not exist|||13071
# getarg 098
        decq rcode
        jns  l_0329
        movq $98,rcode
        jmp  err_
l_0329:
call_104:
# ||jsr|6,sysen|||; call endfile routine|13072
# getarg sysen
        call sysen
        decq rcode
        js   call_105
# ||err|1,098|26,endfile file does not exist|||13073
# getarg 098
        decq rcode
        jns  l_0330
        movq $98,rcode
        jmp  err_
l_0330:
# ||err|1,099|26,endfile file does not permit endfile|||13074
# getarg 099
        decq rcode
        jns  l_0331
        movq $99,rcode
        jmp  err_
l_0331:
# ||err|1,100|26,endfile caused non-recoverable output error|||13075
# getarg 100
        decq rcode
        jns  l_0332
        movq $100,rcode
        jmp  err_
l_0332:
call_105:
# ||mov|8,wb|7,xl||; remember vrblk ptr from iofcb call|13076
# getarg XL
# getarg WB
        movq XL,WB
# ||mov|7,xr|7,xl||; copy pointer|13077
# getarg XL
# getarg XR
        movq XL,XR
# |senf1|mov|7,xl|7,xr||; remember previous entry|13081
senf1:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,trval(xr)||; chain along|13082
# getarg trval(,XR,8)
# getarg XR
        movq trval(,XR,8),XR
# ||bne|9,(xr)|22,=b_trt|6,exnul|; skip out if chain end|13083
# getarg (XR)
# getarg W0
# getarg exnul
        movq l_0154,W0
        cmpq (XR),W0
        jne  exnul
# ||bne|13,trtyp(xr)|18,=trtfc|6,senf1|; loop if not found|13084
# getarg trtyp(,XR,8)
# getarg W0
# getarg senf1
        .data
l_0333: .long trtfc
        .text
        movq l_0333,W0
        cmpq trtyp(,XR,8),W0
        jne  senf1
# ||mov|13,trval(xl)|13,trval(xr)||; remove trtrf|13085
# getarg trval(,XR,8)
# getarg W0
# getarg trval(,XL,8)
        movq trval(,XR,8),W0
        movq W0,trval(,XL,8)
# ||mov|3,enfch|13,trtrf(xr)||; point to head of iochn|13086
# getarg trtrf(,XR,8)
# getarg W0
# getarg enfch
        movq trtrf(,XR,8),W0
        movq W0,enfch
# ||mov|8,wc|13,trfpt(xr)||; point to fcblk|13087
# getarg trfpt(,XR,8)
# getarg WC
        movq trfpt(,XR,8),WC
# ||mov|7,xr|8,wb||; filearg1 vrblk from iofcb|13088
# getarg WB
# getarg XR
        movq WB,XR
# ||jsr|6,setvr|||; reset it|13089
# getarg setvr
        call setvr
# ||mov|7,xl|20,=r_fcb||; ptr to head of fcblk chain|13090
# getarg W0
# getarg XL
        .data
l_0334: .long r_fcb
        .text
        movq l_0334,W0
        movq W0,XL
# ||sub|7,xl|19,*num02||; adjust ready to enter loop|13091
# getarg W0
# getarg XL
        movq l_0135,W0
        subq W0,XL
# |senf2|mov|7,xr|7,xl||; copy ptr|13095
senf2:
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|13,num02(xl)||; get next link|13096
# getarg num02(,XL,8)
# getarg XL
        movq num02(,XL,8),XL
# ||bze|7,xl|6,senf4||; stop if chain end|13097
# getarg XL
# getarg senf4
        or   XL,XL
        jz   senf4
# ||beq|13,num03(xl)|8,wc|6,senf3|; jump if fcblk found|13098
# getarg num03(,XL,8)
# getarg WC
# getarg senf3
        cmpq num03(,XL,8),WC
        je   senf3
# ||brn|6,senf2|||; loop|13099
# getarg senf2
        jmp  senf2
# |senf3|mov|13,num02(xr)|13,num02(xl)||; delete fcblk from chain|13103
senf3:
# getarg num02(,XL,8)
# getarg W0
# getarg num02(,XR,8)
        movq num02(,XL,8),W0
        movq W0,num02(,XR,8)
# |senf4|mov|7,xl|3,enfch||; get chain head|13107
senf4:
# getarg enfch
# getarg XL
        movq enfch,XL
# ||bze|7,xl|6,exnul||; finished if chain end|13108
# getarg XL
# getarg exnul
        or   XL,XL
        jz   exnul
# ||mov|3,enfch|13,trtrf(xl)||; chain along|13109
# getarg trtrf(,XL,8)
# getarg W0
# getarg enfch
        movq trtrf(,XL,8),W0
        movq W0,enfch
# ||mov|8,wa|13,ionmo(xl)||; name offset|13110
# getarg ionmo(,XL,8)
# getarg WA
        movq ionmo(,XL,8),WA
# ||mov|7,xl|13,ionmb(xl)||; name base|13111
# getarg ionmb(,XL,8)
# getarg XL
        movq ionmb(,XL,8),XL
# ||jsr|6,dtach|||; detach name|13112
# getarg dtach
        call dtach
# ||brn|6,senf4|||; loop till done|13113
# getarg senf4
        jmp  senf4
# ||ejc|||||13114
# |s_eqf|ent||||; entry point|13118
	.align	2
	nop
s_eqf:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13119
# getarg acomp
        call acomp
        decq rcode
        js   call_106
# ||err|1,101|26,eq first argument is not numeric|||13120
# getarg 101
        decq rcode
        jns  l_0335
        movq $101,rcode
        jmp  err_
l_0335:
# ||err|1,102|26,eq second argument is not numeric|||13121
# getarg 102
        decq rcode
        jns  l_0336
        movq $102,rcode
        jmp  err_
l_0336:
# ||ppm|6,exfal|||; fail if lt|13122
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0337
        jmp  exfal
l_0337:
# ||ppm|6,exnul|||; return null if eq|13123
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0338
        jmp  exnul
l_0338:
# ||ppm|6,exfal|||; fail if gt|13124
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0339
        jmp  exfal
l_0339:
call_106:
# ||ejc|||||13125
# |s_evl|ent||||; entry point|13129
	.align	2
	nop
s_evl:
# ||mov|7,xr|10,(xs)+||; load argument|13130
# getarg XR
        pop  XR
# ||lcw|8,wc|||; load next code word|13136
# getarg WC
        lcw_ WC
# ||bne|8,wc|21,=ofne_|6,sevl1|; jump if called by value|13137
# getarg WC
# getarg W0
# getarg sevl1
        movq l_0153,W0
        cmpq WC,W0
        jne  sevl1
# ||scp|7,xl|||; copy code pointer|13138
# getarg XL
        scp_ XL
# ||mov|8,wa|9,(xl)||; get next code word|13139
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||bne|8,wa|21,=ornm_|6,sevl2|; by name unless expression|13140
# getarg WA
# getarg W0
# getarg sevl2
        movq l_0110,W0
        cmpq WA,W0
        jne  sevl2
# ||bnz|13,num01(xs)|6,sevl2||; jump if by name|13141
# getarg num01(,XT,8)
# getarg sevl2
        xor  W0,W0
        cmpq num01(,XT,8),W0
        jnz  sevl2
# |sevl1|zer|8,wb|||; set flag for by value|13145
sevl1:
# getarg WB
        xor  WB,WB
# ||mov|11,-(xs)|8,wc||; save code word|13147
# getarg WC
        push WC
# ||jsr|6,gtexp|||; convert to expression|13148
# getarg gtexp
        call gtexp
        decq rcode
        js   call_107
# ||err|1,103|26,eval argument is not expression|||13149
# getarg 103
        decq rcode
        jns  l_0340
        movq $103,rcode
        jmp  err_
l_0340:
call_107:
# ||zer|3,r_ccb|||; forget interim code block|13150
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||zer|8,wb|||; set flag for by value|13151
# getarg WB
        xor  WB,WB
# ||jsr|6,evalx|||; evaluate expression by value|13155
# getarg evalx
        call evalx
        decq rcode
        js   call_108
# ||ppm|6,exfal|||; fail if evaluation fails|13156
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0341
        jmp  exfal
l_0341:
call_108:
# ||mov|7,xl|7,xr||; copy result|13157
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; reload next code word|13158
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|9,(xs)|7,xl||; stack result|13159
# getarg XL
# getarg (XT)
        movq XL,(XT)
# ||bri|9,(xr)|||; jump to execute next code word|13160
# getarg (XR)
        jmp  *(XR)
# |sevl2|mov|8,wb|18,=num01||; set flag for by name|13164
sevl2:
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||jsr|6,gtexp|||; convert to expression|13166
# getarg gtexp
        call gtexp
        decq rcode
        js   call_109
# ||err|1,103|26,eval argument is not expression|||13167
# getarg 103
        decq rcode
        jns  l_0342
        movq $103,rcode
        jmp  err_
l_0342:
call_109:
# ||zer|3,r_ccb|||; forget interim code block|13168
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||mov|8,wb|18,=num01||; set flag for by name|13169
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||jsr|6,evalx|||; evaluate expression by name|13171
# getarg evalx
        call evalx
        decq rcode
        js   call_110
# ||ppm|6,exfal|||; fail if evaluation fails|13172
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0343
        jmp  exfal
l_0343:
call_110:
# ||brn|6,exnam|||; exit with name|13173
# getarg exnam
        jmp  exnam
# ||ejc|||||13176
# |s_ext|ent||||; entry point|13180
	.align	2
	nop
s_ext:
# ||zer|8,wb|||; clear amount of static shift|13181
# getarg WB
        xor  WB,WB
# ||zer|3,r_ccb|||; forget interim code block|13182
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||zer|3,dnams|||; collect sediment too|13184
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# ||jsr|6,gbcol|||; compact memory by collecting|13185
# getarg gbcol
        call gbcol
# ||mov|3,dnams|7,xr||; record new sediment size|13186
# getarg XR
# getarg dnams
        movq XR,dnams
# ||jsr|6,gtstg|||;|13190
# getarg gtstg
        call gtstg
        decq rcode
        js   call_111
# ||err|1,288|26,exit second argument is not a string|||13191
# getarg 288
        decq rcode
        jns  l_0344
        movq $288,rcode
        jmp  err_
l_0344:
call_111:
# ||mov|7,xl|7,xr||; copy second arg string pointer|13192
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtstg|||; convert arg to string|13193
# getarg gtstg
        call gtstg
        decq rcode
        js   call_112
# ||err|1,104|26,exit first argument is not suitable integer or string|||13194
# getarg 104
        decq rcode
        jns  l_0345
        movq $104,rcode
        jmp  err_
l_0345:
call_112:
# ||mov|11,-(xs)|7,xl||; save second argument|13195
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; copy first arg string ptr|13196
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtint|||; check it is integer|13197
# getarg gtint
        call gtint
        decq rcode
        js   call_113
# ||ppm|6,sext1|||; skip if unconvertible|13198
# getarg sext1
# getarg sext1
        decq rcode
        jns  l_0346
        jmp  sext1
l_0346:
call_113:
# ||zer|7,xl|||; note it is integer|13199
# getarg XL
        xor  XL,XL
# ||ldi|13,icval(xr)|||; get integer arg|13200
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# |sext1|mov|8,wb|3,r_fcb||; get fcblk chain header|13204
sext1:
# getarg r_fcb
# getarg WB
        movq r_fcb,WB
# ||mov|7,xr|21,=headv||; point to v.v string|13205
# getarg W0
# getarg XR
        .data
l_0347: .long headv
        .text
        movq l_0347,W0
        movq W0,XR
# ||mov|8,wa|10,(xs)+||; provide second argument scblk|13206
# getarg WA
        pop  WA
# ||jsr|6,sysxi|||; call external routine|13207
# getarg sysxi
        call sysxi
        decq rcode
        js   call_114
# ||err|1,105|26,exit action not available in this implementation|||13208
# getarg 105
        decq rcode
        jns  l_0348
        movq $105,rcode
        jmp  err_
l_0348:
# ||err|1,106|26,exit action caused irrecoverable error|||13209
# getarg 106
        decq rcode
        jns  l_0349
        movq $106,rcode
        jmp  err_
l_0349:
call_114:
# ||ieq|6,exnul|||; return if argument 0|13210
# getarg exnul
        mov  IA,W0
        or   W0,W0
        je   exnul
# ||igt|6,sext2|||; skip if positive|13211
# getarg sext2
        mov  IA,W0
        or   W0,W0
        jg   sext2
# ||ngi||||; make positive|13212
        neg  IA
        seto reg_fl
# |sext2|mfi|8,wc|||; get value in work reg|13220
sext2:
# getarg WC
        mov  IA,WC
# ||add|8,wa|8,wc||; prepare to test for continue|13221
# getarg WC
# getarg WA
        addq WC,WA
# ||beq|8,wa|18,=num05|6,sext5|; continued execution if 4 plus 1|13222
# getarg WA
# getarg W0
# getarg sext5
        movq l_0072,W0
        cmpq WA,W0
        je   sext5
# ||zer|3,gbcnt|||; resuming execution so reset|13223
# getarg gbcnt
        mov  $0,W0
        mov  W0,gbcnt
# ||bge|8,wc|18,=num03|6,sext3|; skip if was 3 or 4|13224
# getarg WC
# getarg W0
# getarg sext3
        .data
l_0350: .long num03
        .text
        movq l_0350,W0
        cmpq WC,W0
        jae  sext3
# ||mov|11,-(xs)|8,wc||; save value|13225
# getarg WC
        push WC
# ||zer|8,wc|||; set to read options|13226
# getarg WC
        xor  WC,WC
# ||jsr|6,prpar|||; read syspp options|13227
# getarg prpar
        call prpar
# ||mov|8,wc|10,(xs)+||; restore value|13228
# getarg WC
        pop  WC
# |sext3|mnz|3,headp|||; assume no headers|13232
sext3:
# getarg headp
        mov  XS,headp
# ||bne|8,wc|18,=num01|6,sext4|; skip if not 1|13233
# getarg WC
# getarg W0
# getarg sext4
        movq l_0060,W0
        cmpq WC,W0
        jne  sext4
# ||zer|3,headp|||; request header printing|13234
# getarg headp
        mov  $0,W0
        mov  W0,headp
# |sext4|jsr|6,systm|||; get execution time start (sgd11)|13238
sext4:
# getarg systm
        call systm
# ||sti|3,timsx|||; save as initial time|13239
# getarg timsx
        mov  IA,timsx
# ||ldi|3,kvstc|||; reset to ensure ...|13240
# getarg kvstc
        mov  kvstc,IA
# ||sti|3,kvstl|||; ... correct execution stats|13241
# getarg kvstl
        mov  IA,kvstl
# ||jsr|6,stgcc|||; recompute countdown counters|13242
# getarg stgcc
        call stgcc
# ||brn|6,exnul|||; resume execution|13243
# getarg exnul
        jmp  exnul
# |sext5|mov|7,xr|21,=inton||; integer one|13251
sext5:
# getarg W0
# getarg XR
        movq l_0063,W0
        movq W0,XR
# ||brn|6,exixr|||; return as result|13252
# getarg exixr
        jmp  exixr
# ||ejc|||||13254
# |s_exp|ent||||; entry point|13259
	.align	2
	nop
s_exp:
# ||mov|7,xr|10,(xs)+||; get argument|13260
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|13261
# getarg gtrea
        call gtrea
        decq rcode
        js   call_115
# ||err|1,304|26,exp argument not numeric|||13262
# getarg 304
        decq rcode
        jns  l_0351
        movq $304,rcode
        jmp  err_
l_0351:
call_115:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|13263
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||etx||||; take exponential|13264
        call etx_
# ||rno|6,exrea|||; if no overflow, return result in ra|13265
# getarg exrea
        rno_ exrea
# ||erb|1,305|26,exp produced real overflow|||13266
        movq $305,rcode
        jmp  err_
# ||ejc|||||13267
# |s_fld|ent||||; entry point|13272
	.align	2
	nop
s_fld:
# ||jsr|6,gtsmi|||; get second argument (field number)|13273
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_116
# ||err|1,107|26,field second argument is not integer|||13274
# getarg 107
        decq rcode
        jns  l_0352
        movq $107,rcode
        jmp  err_
l_0352:
# ||ppm|6,exfal|||; fail if out of range|13275
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0353
        jmp  exfal
l_0353:
call_116:
# ||mov|8,wb|7,xr||; else save integer value|13276
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|10,(xs)+||; load first argument|13277
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; point to vrblk|13278
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_117
# ||ppm|6,sfld1|||; jump (error) if not variable name|13279
# getarg sfld1
# getarg sfld1
        decq rcode
        jns  l_0354
        jmp  sfld1
l_0354:
call_117:
# ||mov|7,xr|13,vrfnc(xr)||; else point to function block|13280
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_dfc|6,sfld1|; error if not datatype function|13281
# getarg (XR)
# getarg W0
# getarg sfld1
        movq l_0299,W0
        cmpq (XR),W0
        jne  sfld1
# ||bze|8,wb|6,exfal||; fail if argument number is zero|13285
# getarg WB
# getarg exfal
        or   WB,WB
        jz   exfal
# ||bgt|8,wb|13,fargs(xr)|6,exfal|; fail if too large|13286
# getarg WB
# getarg fargs(,XR,8)
# getarg exfal
        cmpq WB,fargs(,XR,8)
        ja   exfal
# ||wtb|8,wb|||; else convert to byte offset|13287
# getarg WB
        sal  WB,3
# ||add|7,xr|8,wb||; point to field name|13288
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|7,xr|13,dfflb(xr)||; load vrblk pointer|13289
# getarg dfflb(,XR,8)
# getarg XR
        movq dfflb(,XR,8),XR
# ||brn|6,exvnm|||; exit to build nmblk|13290
# getarg exvnm
        jmp  exvnm
# |sfld1|erb|1,108|26,field first argument is not datatype name|||13294
sfld1:
        movq $108,rcode
        jmp  err_
# ||ejc|||||13295
# |s_fnc|ent||||; entry point|13299
	.align	2
	nop
s_fnc:
# ||mov|8,wb|22,=p_fnc||; set pcode for p_fnc|13300
# getarg W0
# getarg WB
        .data
l_0355: .long p_fnc
        .text
        movq l_0355,W0
        movq W0,WB
# ||zer|7,xr|||; p0blk|13301
# getarg XR
        xor  XR,XR
# ||jsr|6,pbild|||; build p_fnc node|13302
# getarg pbild
        call pbild
# ||mov|7,xl|7,xr||; save pointer to it|13303
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; get argument|13304
# getarg XR
        pop  XR
# ||jsr|6,gtpat|||; convert to pattern|13305
# getarg gtpat
        call gtpat
        decq rcode
        js   call_118
# ||err|1,259|26,fence argument is not pattern|||13306
# getarg 259
        decq rcode
        jns  l_0356
        movq $259,rcode
        jmp  err_
l_0356:
call_118:
# ||jsr|6,pconc|||; concatenate to p_fnc node|13307
# getarg pconc
        call pconc
# ||mov|7,xl|7,xr||; save ptr to concatenated pattern|13308
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wb|22,=p_fna||; set for p_fna pcode|13309
# getarg W0
# getarg WB
        .data
l_0357: .long p_fna
        .text
        movq l_0357,W0
        movq W0,WB
# ||zer|7,xr|||; p0blk|13310
# getarg XR
        xor  XR,XR
# ||jsr|6,pbild|||; construct p_fna node|13311
# getarg pbild
        call pbild
# ||mov|13,pthen(xr)|7,xl||; set pattern as pthen|13312
# getarg XL
# getarg pthen(,XR,8)
        movq XL,pthen(,XR,8)
# ||mov|11,-(xs)|7,xr||; set as result|13313
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|13314
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute next code word|13315
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||13316
# |s_gef|ent||||; entry point|13320
	.align	2
	nop
s_gef:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13321
# getarg acomp
        call acomp
        decq rcode
        js   call_119
# ||err|1,109|26,ge first argument is not numeric|||13322
# getarg 109
        decq rcode
        jns  l_0358
        movq $109,rcode
        jmp  err_
l_0358:
# ||err|1,110|26,ge second argument is not numeric|||13323
# getarg 110
        decq rcode
        jns  l_0359
        movq $110,rcode
        jmp  err_
l_0359:
# ||ppm|6,exfal|||; fail if lt|13324
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0360
        jmp  exfal
l_0360:
# ||ppm|6,exnul|||; return null if eq|13325
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0361
        jmp  exnul
l_0361:
# ||ppm|6,exnul|||; return null if gt|13326
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0362
        jmp  exnul
l_0362:
call_119:
# ||ejc|||||13327
# |s_gtf|ent||||; entry point|13331
	.align	2
	nop
s_gtf:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13332
# getarg acomp
        call acomp
        decq rcode
        js   call_120
# ||err|1,111|26,gt first argument is not numeric|||13333
# getarg 111
        decq rcode
        jns  l_0363
        movq $111,rcode
        jmp  err_
l_0363:
# ||err|1,112|26,gt second argument is not numeric|||13334
# getarg 112
        decq rcode
        jns  l_0364
        movq $112,rcode
        jmp  err_
l_0364:
# ||ppm|6,exfal|||; fail if lt|13335
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0365
        jmp  exfal
l_0365:
# ||ppm|6,exfal|||; fail if eq|13336
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0366
        jmp  exfal
l_0366:
# ||ppm|6,exnul|||; return null if gt|13337
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0367
        jmp  exnul
l_0367:
call_120:
# ||ejc|||||13338
# |s_hst|ent||||; entry point|13342
	.align	2
	nop
s_hst:
# ||mov|8,wc|10,(xs)+||; get fifth arg|13343
# getarg WC
        pop  WC
# ||mov|8,wb|10,(xs)+||; get fourth arg|13344
# getarg WB
        pop  WB
# ||mov|7,xr|10,(xs)+||; get third arg|13345
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; get second arg|13346
# getarg XL
        pop  XL
# ||mov|8,wa|10,(xs)+||; get first arg|13347
# getarg WA
        pop  WA
# ||jsr|6,syshs|||; enter syshs routine|13348
# getarg syshs
        call syshs
        decq rcode
        js   call_121
# ||err|1,254|26,erroneous argument for host|||13349
# getarg 254
        decq rcode
        jns  l_0368
        movq $254,rcode
        jmp  err_
l_0368:
# ||err|1,255|26,error during execution of host|||13350
# getarg 255
        decq rcode
        jns  l_0369
        movq $255,rcode
        jmp  err_
l_0369:
# ||ppm|6,shst1|||; store host string|13351
# getarg shst1
# getarg shst1
        decq rcode
        jns  l_0370
        jmp  shst1
l_0370:
# ||ppm|6,exnul|||; return null result|13352
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0371
        jmp  exnul
l_0371:
# ||ppm|6,exixr|||; return xr|13353
# getarg exixr
# getarg exixr
        decq rcode
        jns  l_0372
        jmp  exixr
l_0372:
# ||ppm|6,exfal|||; fail return|13354
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0373
        jmp  exfal
l_0373:
# ||ppm|6,shst3|||; store actual string|13355
# getarg shst3
# getarg shst3
        decq rcode
        jns  l_0374
        jmp  shst3
l_0374:
# ||ppm|6,shst4|||; return copy of xr|13356
# getarg shst4
# getarg shst4
        decq rcode
        jns  l_0375
        jmp  shst4
l_0375:
call_121:
# |shst1|bze|7,xl|6,exnul||; null string if syshs uncooperative|13360
shst1:
# getarg XL
# getarg exnul
        or   XL,XL
        jz   exnul
# ||mov|8,wa|13,sclen(xl)||; length|13361
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||zer|8,wb|||; zero offset|13362
# getarg WB
        xor  WB,WB
# |shst2|jsr|6,sbstr|||; build copy of string|13366
shst2:
# getarg sbstr
        call sbstr
# ||mov|11,-(xs)|7,xr||; stack the result|13367
# getarg XR
        push XR
# ||lcw|7,xr|||; load next code word|13368
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|13369
# getarg (XR)
        jmp  *(XR)
# |shst3|zer|8,wb|||; treat xl like an scblk ptr|13373
shst3:
# getarg WB
        xor  WB,WB
# ||sub|8,wb|18,=cfp_f||; by creating a negative offset|13374
# getarg W0
# getarg WB
        .data
l_0376: .long cfp_f
        .text
        movq l_0376,W0
        subq W0,WB
# ||brn|6,shst2|||; join to copy string|13375
# getarg shst2
        jmp  shst2
# |shst4|mov|11,-(xs)|7,xr||; stack results|13379
shst4:
# getarg XR
        push XR
# ||jsr|6,copyb|||; make copy of block|13380
# getarg copyb
        call copyb
        decq rcode
        js   call_122
# ||ppm|6,exits|||; if not an aggregate structure|13381
# getarg exits
# getarg exits
        decq rcode
        jns  l_0377
        jmp  exits
l_0377:
call_122:
# ||brn|6,exsid|||; set current id value otherwise|13382
# getarg exsid
        jmp  exsid
# ||ejc|||||13383
# |s_idn|ent||||; entry point|13387
	.align	2
	nop
s_idn:
# ||mov|7,xr|10,(xs)+||; load second argument|13388
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; load first argument|13389
# getarg XL
        pop  XL
# ||jsr|6,ident|||; call ident comparison routine|13390
# getarg ident
        call ident
        decq rcode
        js   call_123
# ||ppm|6,exnul|||; return null if ident|13391
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0378
        jmp  exnul
l_0378:
call_123:
# ||brn|6,exfal|||; fail if differ|13392
# getarg exfal
        jmp  exfal
# ||ejc|||||13393
# |s_inp|ent||||; entry point|13397
	.align	2
	nop
s_inp:
# ||zer|8,wb|||; input flag|13398
# getarg WB
        xor  WB,WB
# ||jsr|6,ioput|||; call input/output assoc. routine|13399
# getarg ioput
        call ioput
        decq rcode
        js   call_124
# ||err|1,113|26,input third argument is not a string|||13400
# getarg 113
        decq rcode
        jns  l_0379
        movq $113,rcode
        jmp  err_
l_0379:
# ||err|1,114|26,inappropriate second argument for input|||13401
# getarg 114
        decq rcode
        jns  l_0380
        movq $114,rcode
        jmp  err_
l_0380:
# ||err|1,115|26,inappropriate first argument for input|||13402
# getarg 115
        decq rcode
        jns  l_0381
        movq $115,rcode
        jmp  err_
l_0381:
# ||err|1,116|26,inappropriate file specification for input|||13403
# getarg 116
        decq rcode
        jns  l_0382
        movq $116,rcode
        jmp  err_
l_0382:
# ||ppm|6,exfal|||; fail if file does not exist|13404
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0383
        jmp  exfal
l_0383:
# ||err|1,117|26,input file cannot be read|||13405
# getarg 117
        decq rcode
        jns  l_0384
        movq $117,rcode
        jmp  err_
l_0384:
# ||err|1,289|26,input channel currently in use|||13406
# getarg 289
        decq rcode
        jns  l_0385
        movq $289,rcode
        jmp  err_
l_0385:
call_124:
# ||brn|6,exnul|||; return null string|13407
# getarg exnul
        jmp  exnul
# ||ejc|||||13408
# |s_int|ent||||; entry point|13441
	.align	2
	nop
s_int:
# ||mov|7,xr|10,(xs)+||; load argument|13442
# getarg XR
        pop  XR
# ||jsr|6,gtnum|||; convert to numeric|13443
# getarg gtnum
        call gtnum
        decq rcode
        js   call_125
# ||ppm|6,exfal|||; fail if non-numeric|13444
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0386
        jmp  exfal
l_0386:
call_125:
# ||beq|8,wa|22,=b_icl|6,exnul|; return null if integer|13445
# getarg WA
# getarg W0
# getarg exnul
        movq l_0087,W0
        cmpq WA,W0
        je   exnul
# ||brn|6,exfal|||; fail if real|13446
# getarg exfal
        jmp  exfal
# ||ejc|||||13447
# |s_itm|ent||||; entry point|13454
	.align	2
	nop
s_itm:
# ||bnz|8,wa|6,sitm1||; jump if at least one arg|13458
# getarg WA
# getarg WA
# getarg sitm1
        or   WA,WA
        jnz  sitm1
# ||mov|11,-(xs)|21,=nulls||; else supply garbage null arg|13459
# getarg W0
        movq l_0054,W0
        push W0
# ||mov|8,wa|18,=num01||; and fix argument count|13460
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# |sitm1|scp|7,xr|||; get current code pointer|13464
sitm1:
# getarg XR
        scp_ XR
# ||mov|7,xl|9,(xr)||; load next code word|13465
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||dcv|8,wa|||; get number of subscripts|13466
# getarg WA
        decq WA
# ||mov|7,xr|8,wa||; copy for arref|13467
# getarg WA
# getarg XR
        movq WA,XR
# ||beq|7,xl|21,=ofne_|6,sitm2|; jump if called by name|13468
# getarg XL
# getarg W0
# getarg sitm2
        movq l_0153,W0
        cmpq XL,W0
        je   sitm2
# ||zer|8,wb|||; set code for call by value|13472
# getarg WB
        xor  WB,WB
# ||brn|6,arref|||; off to array reference routine|13473
# getarg arref
        jmp  arref
# |sitm2|mnz|8,wb|||; set code for call by name|13477
sitm2:
# getarg WB
        mov  XS,WB
# ||lcw|8,wa|||; load and ignore ofne_ call|13478
# getarg WA
        lcw_ WA
# ||brn|6,arref|||; off to array reference routine|13479
# getarg arref
        jmp  arref
# ||ejc|||||13480
# |s_lef|ent||||; entry point|13484
	.align	2
	nop
s_lef:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13485
# getarg acomp
        call acomp
        decq rcode
        js   call_126
# ||err|1,118|26,le first argument is not numeric|||13486
# getarg 118
        decq rcode
        jns  l_0387
        movq $118,rcode
        jmp  err_
l_0387:
# ||err|1,119|26,le second argument is not numeric|||13487
# getarg 119
        decq rcode
        jns  l_0388
        movq $119,rcode
        jmp  err_
l_0388:
# ||ppm|6,exnul|||; return null if lt|13488
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0389
        jmp  exnul
l_0389:
# ||ppm|6,exnul|||; return null if eq|13489
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0390
        jmp  exnul
l_0390:
# ||ppm|6,exfal|||; fail if gt|13490
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0391
        jmp  exfal
l_0391:
call_126:
# ||ejc|||||13491
# |s_len|ent||||; entry point|13495
	.align	2
	nop
s_len:
# ||mov|8,wb|22,=p_len||; set pcode for integer arg case|13496
# getarg W0
# getarg WB
        .data
l_0392: .long p_len
        .text
        movq l_0392,W0
        movq W0,WB
# ||mov|8,wa|22,=p_lnd||; set pcode for expr arg case|13497
# getarg W0
# getarg WA
        .data
l_0393: .long p_lnd
        .text
        movq l_0393,W0
        movq W0,WA
# ||jsr|6,patin|||; call common routine to build node|13498
# getarg patin
        call patin
        decq rcode
        js   call_127
# ||err|1,120|26,len argument is not integer or expression|||13499
# getarg 120
        decq rcode
        jns  l_0394
        movq $120,rcode
        jmp  err_
l_0394:
# ||err|1,121|26,len argument is negative or too large|||13500
# getarg 121
        decq rcode
        jns  l_0395
        movq $121,rcode
        jmp  err_
l_0395:
call_127:
# ||mov|11,-(xs)|7,xr||; stack result|13501
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|13502
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|13503
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||13504
# |s_leq|ent||||; entry point|13508
	.align	2
	nop
s_leq:
# ||jsr|6,lcomp|||; call string comparison routine|13509
# getarg lcomp
        call lcomp
        decq rcode
        js   call_128
# ||err|1,122|26,leq first argument is not a string|||13510
# getarg 122
        decq rcode
        jns  l_0396
        movq $122,rcode
        jmp  err_
l_0396:
# ||err|1,123|26,leq second argument is not a string|||13511
# getarg 123
        decq rcode
        jns  l_0397
        movq $123,rcode
        jmp  err_
l_0397:
# ||ppm|6,exfal|||; fail if llt|13512
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0398
        jmp  exfal
l_0398:
# ||ppm|6,exnul|||; return null if leq|13513
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0399
        jmp  exnul
l_0399:
# ||ppm|6,exfal|||; fail if lgt|13514
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0400
        jmp  exfal
l_0400:
call_128:
# ||ejc|||||13515
# |s_lge|ent||||; entry point|13519
	.align	2
	nop
s_lge:
# ||jsr|6,lcomp|||; call string comparison routine|13520
# getarg lcomp
        call lcomp
        decq rcode
        js   call_129
# ||err|1,124|26,lge first argument is not a string|||13521
# getarg 124
        decq rcode
        jns  l_0401
        movq $124,rcode
        jmp  err_
l_0401:
# ||err|1,125|26,lge second argument is not a string|||13522
# getarg 125
        decq rcode
        jns  l_0402
        movq $125,rcode
        jmp  err_
l_0402:
# ||ppm|6,exfal|||; fail if llt|13523
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0403
        jmp  exfal
l_0403:
# ||ppm|6,exnul|||; return null if leq|13524
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0404
        jmp  exnul
l_0404:
# ||ppm|6,exnul|||; return null if lgt|13525
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0405
        jmp  exnul
l_0405:
call_129:
# ||ejc|||||13526
# |s_lgt|ent||||; entry point|13530
	.align	2
	nop
s_lgt:
# ||jsr|6,lcomp|||; call string comparison routine|13531
# getarg lcomp
        call lcomp
        decq rcode
        js   call_130
# ||err|1,126|26,lgt first argument is not a string|||13532
# getarg 126
        decq rcode
        jns  l_0406
        movq $126,rcode
        jmp  err_
l_0406:
# ||err|1,127|26,lgt second argument is not a string|||13533
# getarg 127
        decq rcode
        jns  l_0407
        movq $127,rcode
        jmp  err_
l_0407:
# ||ppm|6,exfal|||; fail if llt|13534
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0408
        jmp  exfal
l_0408:
# ||ppm|6,exfal|||; fail if leq|13535
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0409
        jmp  exfal
l_0409:
# ||ppm|6,exnul|||; return null if lgt|13536
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0410
        jmp  exnul
l_0410:
call_130:
# ||ejc|||||13537
# |s_lle|ent||||; entry point|13541
	.align	2
	nop
s_lle:
# ||jsr|6,lcomp|||; call string comparison routine|13542
# getarg lcomp
        call lcomp
        decq rcode
        js   call_131
# ||err|1,128|26,lle first argument is not a string|||13543
# getarg 128
        decq rcode
        jns  l_0411
        movq $128,rcode
        jmp  err_
l_0411:
# ||err|1,129|26,lle second argument is not a string|||13544
# getarg 129
        decq rcode
        jns  l_0412
        movq $129,rcode
        jmp  err_
l_0412:
# ||ppm|6,exnul|||; return null if llt|13545
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0413
        jmp  exnul
l_0413:
# ||ppm|6,exnul|||; return null if leq|13546
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0414
        jmp  exnul
l_0414:
# ||ppm|6,exfal|||; fail if lgt|13547
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0415
        jmp  exfal
l_0415:
call_131:
# ||ejc|||||13548
# |s_llt|ent||||; entry point|13552
	.align	2
	nop
s_llt:
# ||jsr|6,lcomp|||; call string comparison routine|13553
# getarg lcomp
        call lcomp
        decq rcode
        js   call_132
# ||err|1,130|26,llt first argument is not a string|||13554
# getarg 130
        decq rcode
        jns  l_0416
        movq $130,rcode
        jmp  err_
l_0416:
# ||err|1,131|26,llt second argument is not a string|||13555
# getarg 131
        decq rcode
        jns  l_0417
        movq $131,rcode
        jmp  err_
l_0417:
# ||ppm|6,exnul|||; return null if llt|13556
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0418
        jmp  exnul
l_0418:
# ||ppm|6,exfal|||; fail if leq|13557
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0419
        jmp  exfal
l_0419:
# ||ppm|6,exfal|||; fail if lgt|13558
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0420
        jmp  exfal
l_0420:
call_132:
# ||ejc|||||13559
# |s_lne|ent||||; entry point|13563
	.align	2
	nop
s_lne:
# ||jsr|6,lcomp|||; call string comparison routine|13564
# getarg lcomp
        call lcomp
        decq rcode
        js   call_133
# ||err|1,132|26,lne first argument is not a string|||13565
# getarg 132
        decq rcode
        jns  l_0421
        movq $132,rcode
        jmp  err_
l_0421:
# ||err|1,133|26,lne second argument is not a string|||13566
# getarg 133
        decq rcode
        jns  l_0422
        movq $133,rcode
        jmp  err_
l_0422:
# ||ppm|6,exnul|||; return null if llt|13567
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0423
        jmp  exnul
l_0423:
# ||ppm|6,exfal|||; fail if leq|13568
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0424
        jmp  exfal
l_0424:
# ||ppm|6,exnul|||; return null if lgt|13569
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0425
        jmp  exnul
l_0425:
call_133:
# ||ejc|||||13570
# |s_lnf|ent||||; entry point|13575
	.align	2
	nop
s_lnf:
# ||mov|7,xr|10,(xs)+||; get argument|13576
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|13577
# getarg gtrea
        call gtrea
        decq rcode
        js   call_134
# ||err|1,306|26,ln argument not numeric|||13578
# getarg 306
        decq rcode
        jns  l_0426
        movq $306,rcode
        jmp  err_
l_0426:
call_134:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|13579
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||req|6,slnf1|||; overflow if argument is 0|13580
# getarg slnf1
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        je   slnf1
# ||rlt|6,slnf2|||; error if argument less than 0|13581
# getarg slnf2
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   slnf2
# ||lnf||||; take natural logarithm|13582
        call lnf_
# ||rno|6,exrea|||; if no overflow, return result in ra|13583
# getarg exrea
        rno_ exrea
# |slnf1|erb|1,307|26,ln produced real overflow|||13584
slnf1:
        movq $307,rcode
        jmp  err_
# |slnf2|erb|1,315|26,ln argument negative|||13588
slnf2:
        movq $315,rcode
        jmp  err_
# ||ejc|||||13589
# |s_loc|ent||||; entry point|13594
	.align	2
	nop
s_loc:
# ||jsr|6,gtsmi|||; get second argument (local number)|13595
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_135
# ||err|1,134|26,local second argument is not integer|||13596
# getarg 134
        decq rcode
        jns  l_0427
        movq $134,rcode
        jmp  err_
l_0427:
# ||ppm|6,exfal|||; fail if out of range|13597
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0428
        jmp  exfal
l_0428:
call_135:
# ||mov|8,wb|7,xr||; save local number|13598
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|10,(xs)+||; load first argument|13599
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; point to vrblk|13600
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_136
# ||ppm|6,sloc1|||; jump if not variable name|13601
# getarg sloc1
# getarg sloc1
        decq rcode
        jns  l_0429
        jmp  sloc1
l_0429:
call_136:
# ||mov|7,xr|13,vrfnc(xr)||; else load function pointer|13602
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_pfc|6,sloc1|; jump if not program defined|13603
# getarg (XR)
# getarg W0
# getarg sloc1
        movq l_0238,W0
        cmpq (XR),W0
        jne  sloc1
# ||bze|8,wb|6,exfal||; fail if second arg is zero|13607
# getarg WB
# getarg exfal
        or   WB,WB
        jz   exfal
# ||bgt|8,wb|13,pfnlo(xr)|6,exfal|; or too large|13608
# getarg WB
# getarg pfnlo(,XR,8)
# getarg exfal
        cmpq WB,pfnlo(,XR,8)
        ja   exfal
# ||add|8,wb|13,fargs(xr)||; else adjust offset to include args|13609
# getarg fargs(,XR,8)
# getarg WB
        addq fargs(,XR,8),WB
# ||wtb|8,wb|||; convert to bytes|13610
# getarg WB
        sal  WB,3
# ||add|7,xr|8,wb||; point to local pointer|13611
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|7,xr|13,pfagb(xr)||; load vrblk pointer|13612
# getarg pfagb(,XR,8)
# getarg XR
        movq pfagb(,XR,8),XR
# ||brn|6,exvnm|||; exit building nmblk|13613
# getarg exvnm
        jmp  exvnm
# |sloc1|erb|1,135|26,local first arg is not a program function name|||13617
sloc1:
        movq $135,rcode
        jmp  err_
# ||ejc|||||13620
# |s_lod|ent||||; entry point|13624
	.align	2
	nop
s_lod:
# ||jsr|6,gtstg|||; load library name|13625
# getarg gtstg
        call gtstg
        decq rcode
        js   call_137
# ||err|1,136|26,load second argument is not a string|||13626
# getarg 136
        decq rcode
        jns  l_0430
        movq $136,rcode
        jmp  err_
l_0430:
call_137:
# ||mov|7,xl|7,xr||; save library name|13627
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,xscni|||; prepare to scan first argument|13628
# getarg xscni
        call xscni
        decq rcode
        js   call_138
# ||err|1,137|26,load first argument is not a string|||13629
# getarg 137
        decq rcode
        jns  l_0431
        movq $137,rcode
        jmp  err_
l_0431:
# ||err|1,138|26,load first argument is null|||13630
# getarg 138
        decq rcode
        jns  l_0432
        movq $138,rcode
        jmp  err_
l_0432:
call_138:
# ||mov|11,-(xs)|7,xl||; stack library name|13631
# getarg XL
        push XL
# ||mov|8,wc|18,=ch_pp||; set delimiter one = left paren|13632
# getarg W0
# getarg WC
        movq l_0158,W0
        movq W0,WC
# ||mov|7,xl|8,wc||; set delimiter two = left paren|13633
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|13634
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan function name|13635
# getarg xscan
        call xscan
# ||mov|11,-(xs)|7,xr||; save ptr to function name|13636
# getarg XR
        push XR
# ||bnz|8,wa|6,slod1||; jump if left paren found|13637
# getarg WA
# getarg WA
# getarg slod1
        or   WA,WA
        jnz  slod1
# ||erb|1,139|26,load first argument is missing a left paren|||13638
        movq $139,rcode
        jmp  err_
# |slod1|jsr|6,gtnvr|||; locate vrblk|13642
slod1:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_139
# ||err|1,140|26,load first argument has null function name|||13643
# getarg 140
        decq rcode
        jns  l_0433
        movq $140,rcode
        jmp  err_
l_0433:
call_139:
# ||mov|3,lodfn|7,xr||; save vrblk pointer|13644
# getarg XR
# getarg lodfn
        movq XR,lodfn
# ||zer|3,lodna|||; zero count of arguments|13645
# getarg lodna
        mov  $0,W0
        mov  W0,lodna
# |slod2|mov|8,wc|18,=ch_rp||; delimiter one is right paren|13649
slod2:
# getarg W0
# getarg WC
        movq l_0160,W0
        movq W0,WC
# ||mov|7,xl|18,=ch_cm||; delimiter two is comma|13650
# getarg W0
# getarg XL
        movq l_0159,W0
        movq W0,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|13651
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan next argument name|13652
# getarg xscan
        call xscan
# ||icv|3,lodna|||; bump argument count|13653
# getarg lodna
        incq lodna
# ||bnz|8,wa|6,slod3||; jump if ok delimiter was found|13654
# getarg WA
# getarg WA
# getarg slod3
        or   WA,WA
        jnz  slod3
# ||erb|1,141|26,load first argument is missing a right paren|||13655
        movq $141,rcode
        jmp  err_
# ||ejc|||||13656
# |slod3|mov|8,wb|8,wa||; save scan mode|13665
slod3:
# getarg WA
# getarg WB
        movq WA,WB
# ||mov|8,wa|13,sclen(xr)||; datatype length|13666
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||bze|8,wa|6,sld3a||; bypass if null string|13667
# getarg WA
# getarg sld3a
        or   WA,WA
        jz   sld3a
# ||jsr|6,flstg|||; fold to upper case|13668
# getarg flstg
        call flstg
# |sld3a|mov|8,wa|8,wb||; restore scan mode|13669
sld3a:
# getarg WB
# getarg WA
        movq WB,WA
# ||mov|11,-(xs)|7,xr||; stack datatype name pointer|13670
# getarg XR
        push XR
# ||mov|8,wb|18,=num01||; set string code in case|13674
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||mov|7,xl|21,=scstr||; point to /string/|13675
# getarg W0
# getarg XL
        .data
l_0434: .long scstr
        .text
        movq l_0434,W0
        movq W0,XL
# ||jsr|6,ident|||; check for match|13676
# getarg ident
        call ident
        decq rcode
        js   call_140
# ||ppm|6,slod4|||; jump if match|13677
# getarg slod4
# getarg slod4
        decq rcode
        jns  l_0435
        jmp  slod4
l_0435:
call_140:
# ||mov|7,xr|9,(xs)||; else reload name|13678
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|8,wb|8,wb||; set code for integer (2)|13679
# getarg WB
# getarg WB
        addq WB,WB
# ||mov|7,xl|21,=scint||; point to /integer/|13680
# getarg W0
# getarg XL
        .data
l_0436: .long scint
        .text
        movq l_0436,W0
        movq W0,XL
# ||jsr|6,ident|||; check for match|13681
# getarg ident
        call ident
        decq rcode
        js   call_141
# ||ppm|6,slod4|||; jump if match|13682
# getarg slod4
# getarg slod4
        decq rcode
        jns  l_0437
        jmp  slod4
l_0437:
call_141:
# ||mov|7,xr|9,(xs)||; else reload string pointer|13685
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||icv|8,wb|||; set code for real (3)|13686
# getarg WB
        incq WB
# ||mov|7,xl|21,=screa||; point to /real/|13687
# getarg W0
# getarg XL
        .data
l_0438: .long screa
        .text
        movq l_0438,W0
        movq W0,XL
# ||jsr|6,ident|||; check for match|13688
# getarg ident
        call ident
        decq rcode
        js   call_142
# ||ppm|6,slod4|||; jump if match|13689
# getarg slod4
# getarg slod4
        decq rcode
        jns  l_0439
        jmp  slod4
l_0439:
call_142:
# ||mov|7,xr|9,(xs)||; reload string pointer|13692
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||icv|8,wb|||; code for file (4, or 3 if no reals)|13693
# getarg WB
        incq WB
# ||mov|7,xl|21,=scfil||; point to /file/|13694
# getarg W0
# getarg XL
        .data
l_0440: .long scfil
        .text
        movq l_0440,W0
        movq W0,XL
# ||jsr|6,ident|||; check for match|13695
# getarg ident
        call ident
        decq rcode
        js   call_143
# ||ppm|6,slod4|||; jump if match|13696
# getarg slod4
# getarg slod4
        decq rcode
        jns  l_0441
        jmp  slod4
l_0441:
call_143:
# ||zer|8,wb|||; else get code for no convert|13698
# getarg WB
        xor  WB,WB
# |slod4|mov|9,(xs)|8,wb||; store code on stack|13702
slod4:
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||beq|8,wa|18,=num02|6,slod2|; loop back if arg stopped by comma|13703
# getarg WA
# getarg W0
# getarg slod2
        movq l_0130,W0
        cmpq WA,W0
        je   slod2
# ||bze|8,wa|6,slod5||; jump if that was the result type|13704
# getarg WA
# getarg slod5
        or   WA,WA
        jz   slod5
# ||mov|8,wc|3,mxlen||; set dummy (impossible) delimiter 1|13708
# getarg mxlen
# getarg WC
        movq mxlen,WC
# ||mov|7,xl|8,wc||; and delimiter two|13709
# getarg WC
# getarg XL
        movq WC,XL
# ||mnz|8,wa|||; skip/trim blanks in prototype|13710
# getarg WA
        mov  XS,WA
# ||jsr|6,xscan|||; scan result name|13711
# getarg xscan
        call xscan
# ||zer|8,wa|||; set code for processing result|13712
# getarg WA
        xor  WA,WA
# ||brn|6,slod3|||; jump back to process result name|13713
# getarg slod3
        jmp  slod3
# ||ejc|||||13714
# |slod5|mov|8,wa|3,lodna||; get number of arguments|13720
slod5:
# getarg lodna
# getarg WA
        movq lodna,WA
# ||mov|8,wc|8,wa||; copy for later|13721
# getarg WA
# getarg WC
        movq WA,WC
# ||wtb|8,wa|||; convert length to bytes|13722
# getarg WA
        sal  WA,3
# ||add|8,wa|19,*efsi_||; add space for standard fields|13723
# getarg W0
# getarg WA
        .data
l_0442: .long 8*efsi_
        .text
        movq l_0442,W0
        addq W0,WA
# ||jsr|6,alloc|||; allocate efblk|13724
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_efc||; set type word|13725
# getarg W0
# getarg (XR)
        .data
l_0443: .long b_efc
        .text
        movq l_0443,W0
        movq W0,(XR)
# ||mov|13,fargs(xr)|8,wc||; set number of arguments|13726
# getarg WC
# getarg fargs(,XR,8)
        movq WC,fargs(,XR,8)
# ||zer|13,efuse(xr)|||; set use count (dffnc will set to 1)|13727
# getarg efuse(,XR,8)
        mov  $0,W0
        mov  W0,efuse(,XR,8)
# ||zer|13,efcod(xr)|||; zero code pointer for now|13728
# getarg efcod(,XR,8)
        mov  $0,W0
        mov  W0,efcod(,XR,8)
# ||mov|13,efrsl(xr)|10,(xs)+||; store result type code|13729
# getarg efrsl(,XR,8)
        pop  efrsl(,XR,8)
# ||mov|13,efvar(xr)|3,lodfn||; store function vrblk pointer|13730
# getarg lodfn
# getarg W0
# getarg efvar(,XR,8)
        movq lodfn,W0
        movq W0,efvar(,XR,8)
# ||mov|13,eflen(xr)|8,wa||; store efblk length|13731
# getarg WA
# getarg eflen(,XR,8)
        movq WA,eflen(,XR,8)
# ||mov|8,wb|7,xr||; save efblk pointer|13732
# getarg XR
# getarg WB
        movq XR,WB
# ||add|7,xr|8,wa||; point past end of efblk|13733
# getarg WA
# getarg XR
        addq WA,XR
# ||lct|8,wc|8,wc||; set number of arguments for loop|13734
# |slod6|mov|11,-(xr)|10,(xs)+||; store one type code from stack|13738
slod6:
# getarg (XR)
        sub  $8,XR
        pop  (XR)
# ||bct|8,wc|6,slod6||; loop till all stored|13739
# getarg WC
# getarg slod6
        decq WC
        jnz  slod6
# ||mov|7,xr|10,(xs)+||; load function string name|13743
# getarg XR
        pop  XR
# ||mov|8,wa|13,sclen(xr)||; function name length|13745
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||jsr|6,flstg|||; fold to upper case|13746
# getarg flstg
        call flstg
# ||mov|7,xl|9,(xs)||; load library name|13748
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|9,(xs)|8,wb||; store efblk pointer|13749
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||jsr|6,sysld|||; call function to load external func|13750
# getarg sysld
        call sysld
        decq rcode
        js   call_144
# ||err|1,142|26,load function does not exist|||13751
# getarg 142
        decq rcode
        jns  l_0444
        movq $142,rcode
        jmp  err_
l_0444:
# ||err|1,143|26,load function caused input error during load|||13752
# getarg 143
        decq rcode
        jns  l_0445
        movq $143,rcode
        jmp  err_
l_0445:
# ||err|1,328|26,load function - insufficient memory|||13753
# getarg 328
        decq rcode
        jns  l_0446
        movq $328,rcode
        jmp  err_
l_0446:
call_144:
# ||mov|7,xl|10,(xs)+||; recall efblk pointer|13754
# getarg XL
        pop  XL
# ||mov|13,efcod(xl)|7,xr||; store code pointer|13755
# getarg XR
# getarg efcod(,XL,8)
        movq XR,efcod(,XL,8)
# ||mov|7,xr|3,lodfn||; point to vrblk for function|13756
# getarg lodfn
# getarg XR
        movq lodfn,XR
# ||jsr|6,dffnc|||; perform function definition|13757
# getarg dffnc
        call dffnc
# ||brn|6,exnul|||; return null result|13758
# getarg exnul
        jmp  exnul
# ||ejc|||||13760
# |s_lpd|ent||||; entry point|13764
	.align	2
	nop
s_lpd:
# ||jsr|6,gtstg|||; get pad character|13765
# getarg gtstg
        call gtstg
        decq rcode
        js   call_145
# ||err|1,144|26,lpad third argument is not a string|||13766
# getarg 144
        decq rcode
        jns  l_0447
        movq $144,rcode
        jmp  err_
l_0447:
call_145:
# ||plc|7,xr|||; point to character (null is blank)|13767
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wb|9,(xr)||; load pad character|13768
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
# ||jsr|6,gtsmi|||; get pad length|13769
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_146
# ||err|1,145|26,lpad second argument is not integer|||13770
# getarg 145
        decq rcode
        jns  l_0448
        movq $145,rcode
        jmp  err_
l_0448:
# ||ppm|6,slpd4|||; skip if negative or large|13771
# getarg slpd4
# getarg slpd4
        decq rcode
        jns  l_0449
        jmp  slpd4
l_0449:
call_146:
# |slpd1|jsr|6,gtstg|||; get first argument (string to pad)|13775
slpd1:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_147
# ||err|1,146|26,lpad first argument is not a string|||13776
# getarg 146
        decq rcode
        jns  l_0450
        movq $146,rcode
        jmp  err_
l_0450:
call_147:
# ||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|13777
# getarg WA
# getarg WC
# getarg exixr
        cmpq WA,WC
        jae  exixr
# ||mov|7,xl|7,xr||; else move ptr to string to pad|13778
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|8,wc||; copy length|13786
# getarg WC
# getarg WA
        movq WC,WA
# ||jsr|6,alocs|||; allocate scblk for new string|13787
# getarg alocs
        call alocs
# ||mov|11,-(xs)|7,xr||; save as result|13788
# getarg XR
        push XR
# ||mov|8,wa|13,sclen(xl)||; load length of argument|13789
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||sub|8,wc|8,wa||; calculate number of pad characters|13790
# getarg WA
# getarg WC
        subq WA,WC
# ||psc|7,xr|||; point to chars in result string|13791
# getarg XR
        add  $cfp_f,XR
# ||lct|8,wc|8,wc||; set counter for pad loop|13792
# |slpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|13796
slpd2:
# getarg WB
        movb al
        stosb
# ||bct|8,wc|6,slpd2||; loop till all pad chars stored|13797
# getarg WC
# getarg slpd2
        decq WC
        jnz  slpd2
# ||csc|7,xr|||; complete store characters|13798
# ||bze|8,wa|6,slpd3||; exit if null string|13802
# getarg WA
# getarg slpd3
        or   WA,WA
        jz   slpd3
# ||plc|7,xl|||; else point to chars in argument|13803
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move characters to result string|13804
        rep
        movsb
# ||zer|7,xl|||; clear garbage xl|13805
# getarg XL
        xor  XL,XL
# |slpd3|lcw|7,xr|||; load next code word|13809
slpd3:
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|13810
# getarg (XR)
        jmp  *(XR)
# |slpd4|zer|8,wc|||; zero pad count|13814
slpd4:
# getarg WC
        xor  WC,WC
# ||brn|6,slpd1|||; merge|13815
# getarg slpd1
        jmp  slpd1
# ||ejc|||||13816
# |s_ltf|ent||||; entry point|13820
	.align	2
	nop
s_ltf:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13821
# getarg acomp
        call acomp
        decq rcode
        js   call_148
# ||err|1,147|26,lt first argument is not numeric|||13822
# getarg 147
        decq rcode
        jns  l_0452
        movq $147,rcode
        jmp  err_
l_0452:
# ||err|1,148|26,lt second argument is not numeric|||13823
# getarg 148
        decq rcode
        jns  l_0453
        movq $148,rcode
        jmp  err_
l_0453:
# ||ppm|6,exnul|||; return null if lt|13824
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0454
        jmp  exnul
l_0454:
# ||ppm|6,exfal|||; fail if eq|13825
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0455
        jmp  exfal
l_0455:
# ||ppm|6,exfal|||; fail if gt|13826
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0456
        jmp  exfal
l_0456:
call_148:
# ||ejc|||||13827
# |s_nef|ent||||; entry point|13831
	.align	2
	nop
s_nef:
# ||jsr|6,acomp|||; call arithmetic comparison routine|13832
# getarg acomp
        call acomp
        decq rcode
        js   call_149
# ||err|1,149|26,ne first argument is not numeric|||13833
# getarg 149
        decq rcode
        jns  l_0457
        movq $149,rcode
        jmp  err_
l_0457:
# ||err|1,150|26,ne second argument is not numeric|||13834
# getarg 150
        decq rcode
        jns  l_0458
        movq $150,rcode
        jmp  err_
l_0458:
# ||ppm|6,exnul|||; return null if lt|13835
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0459
        jmp  exnul
l_0459:
# ||ppm|6,exfal|||; fail if eq|13836
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0460
        jmp  exfal
l_0460:
# ||ppm|6,exnul|||; return null if gt|13837
# getarg exnul
# getarg exnul
        decq rcode
        jns  l_0461
        jmp  exnul
l_0461:
call_149:
# ||ejc|||||13838
# |s_nay|ent||||; entry point|13842
	.align	2
	nop
s_nay:
# ||mov|8,wb|22,=p_nas||; set pcode for single char arg|13843
# getarg W0
# getarg WB
        .data
l_0462: .long p_nas
        .text
        movq l_0462,W0
        movq W0,WB
# ||mov|7,xl|22,=p_nay||; pcode for multi-char arg|13844
# getarg W0
# getarg XL
        .data
l_0463: .long p_nay
        .text
        movq l_0463,W0
        movq W0,XL
# ||mov|8,wc|22,=p_nad||; set pcode for expr arg|13845
# getarg W0
# getarg WC
        .data
l_0464: .long p_nad
        .text
        movq l_0464,W0
        movq W0,WC
# ||jsr|6,patst|||; call common routine to build node|13846
# getarg patst
        call patst
        decq rcode
        js   call_150
# ||err|1,151|26,notany argument is not a string or expression|||13847
# getarg 151
        decq rcode
        jns  l_0465
        movq $151,rcode
        jmp  err_
l_0465:
call_150:
# ||mov|11,-(xs)|7,xr||; stack result|13848
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|13849
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|13850
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||13851
# |s_ops|ent||||; entry point|13855
	.align	2
	nop
s_ops:
# ||jsr|6,gtsmi|||; load third argument|13856
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_151
# ||err|1,152|26,opsyn third argument is not integer|||13857
# getarg 152
        decq rcode
        jns  l_0466
        movq $152,rcode
        jmp  err_
l_0466:
# ||err|1,153|26,opsyn third argument is negative or too large|||13858
# getarg 153
        decq rcode
        jns  l_0467
        movq $153,rcode
        jmp  err_
l_0467:
call_151:
# ||mov|8,wb|8,wc||; if ok, save third argumnet|13859
# getarg WC
# getarg WB
        movq WC,WB
# ||mov|7,xr|10,(xs)+||; load second argument|13860
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; locate variable block|13861
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_152
# ||err|1,154|26,opsyn second arg is not natural variable name|||13862
# getarg 154
        decq rcode
        jns  l_0468
        movq $154,rcode
        jmp  err_
l_0468:
call_152:
# ||mov|7,xl|13,vrfnc(xr)||; if ok, load function block pointer|13863
# getarg vrfnc(,XR,8)
# getarg XL
        movq vrfnc(,XR,8),XL
# ||bnz|8,wb|6,sops2||; jump if operator opsyn case|13864
# getarg WB
# getarg WB
# getarg sops2
        or   WB,WB
        jnz  sops2
# ||mov|7,xr|10,(xs)+||; load first argument|13868
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; get vrblk pointer|13869
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_153
# ||err|1,155|26,opsyn first arg is not natural variable name|||13870
# getarg 155
        decq rcode
        jns  l_0469
        movq $155,rcode
        jmp  err_
l_0469:
call_153:
# |sops1|jsr|6,dffnc|||; call function definer|13874
sops1:
# getarg dffnc
        call dffnc
# ||brn|6,exnul|||; exit with null result|13875
# getarg exnul
        jmp  exnul
# |sops2|jsr|6,gtstg|||; get operator name|13879
sops2:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_154
# ||ppm|6,sops5|||; jump if not string|13880
# getarg sops5
# getarg sops5
        decq rcode
        jns  l_0470
        jmp  sops5
l_0470:
call_154:
# ||bne|8,wa|18,=num01|6,sops5|; error if not one char long|13881
# getarg WA
# getarg W0
# getarg sops5
        movq l_0060,W0
        cmpq WA,W0
        jne  sops5
# ||plc|7,xr|||; else point to character|13882
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wc|9,(xr)||; load character name|13883
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
# ||ejc|||||13884
# ||mov|8,wa|20,=r_uub||; point to unop pointers in case|13892
# getarg W0
# getarg WA
        .data
l_0471: .long r_uub
        .text
        movq l_0471,W0
        movq W0,WA
# ||mov|7,xr|21,=opnsu||; point to names of unary operators|13893
# getarg W0
# getarg XR
        .data
l_0472: .long opnsu
        .text
        movq l_0472,W0
        movq W0,XR
# ||add|8,wb|18,=opbun||; add no. of undefined binary ops|13894
# getarg W0
# getarg WB
        .data
l_0473: .long opbun
        .text
        movq l_0473,W0
        addq W0,WB
# ||beq|8,wb|18,=opuun|6,sops3|; jump if unop (third arg was 1)|13895
# getarg WB
# getarg W0
# getarg sops3
        .data
l_0474: .long opuun
        .text
        movq l_0474,W0
        cmpq WB,W0
        je   sops3
# ||mov|8,wa|20,=r_uba||; else point to binary operator ptrs|13896
# getarg W0
# getarg WA
        .data
l_0475: .long r_uba
        .text
        movq l_0475,W0
        movq W0,WA
# ||mov|7,xr|21,=opsnb||; point to names of binary operators|13897
# getarg W0
# getarg XR
        .data
l_0476: .long opsnb
        .text
        movq l_0476,W0
        movq W0,XR
# ||mov|8,wb|18,=opbun||; set number of undefined binops|13898
# getarg W0
# getarg WB
        movq l_0473,W0
        movq W0,WB
# |sops3|lct|8,wb|8,wb||; set counter to control loop|13902
sops3:
# |sops4|beq|8,wc|9,(xr)|6,sops6|; jump if names match|13906
sops4:
# getarg WC
# getarg (XR)
# getarg sops6
        cmpq WC,(XR)
        je   sops6
# ||ica|8,wa|||; else push pointer to function ptr|13907
# getarg WA
        addq $8,WA
# ||ica|7,xr|||; bump pointer|13908
# getarg XR
        addq $8,XR
# ||bct|8,wb|6,sops4||; loop back till all checked|13909
# getarg WB
# getarg sops4
        decq WB
        jnz  sops4
# |sops5|erb|1,156|26,opsyn first arg is not correct operator name|||13913
sops5:
        movq $156,rcode
        jmp  err_
# |sops6|mov|7,xr|8,wa||; copy pointer to function block ptr|13917
sops6:
# getarg WA
# getarg XR
        movq WA,XR
# ||sub|7,xr|19,*vrfnc||; make it look like dummy vrblk|13918
# getarg W0
# getarg XR
        .data
l_0477: .long 8*vrfnc
        .text
        movq l_0477,W0
        subq W0,XR
# ||brn|6,sops1|||; merge back to define operator|13919
# getarg sops1
        jmp  sops1
# ||ejc|||||13920
# |s_oup|ent||||; entry point|13945
	.align	2
	nop
s_oup:
# ||mov|8,wb|18,=num03||; output flag|13946
# getarg W0
# getarg WB
        movq l_0350,W0
        movq W0,WB
# ||jsr|6,ioput|||; call input/output assoc. routine|13947
# getarg ioput
        call ioput
        decq rcode
        js   call_155
# ||err|1,157|26,output third argument is not a string|||13948
# getarg 157
        decq rcode
        jns  l_0478
        movq $157,rcode
        jmp  err_
l_0478:
# ||err|1,158|26,inappropriate second argument for output|||13949
# getarg 158
        decq rcode
        jns  l_0479
        movq $158,rcode
        jmp  err_
l_0479:
# ||err|1,159|26,inappropriate first argument for output|||13950
# getarg 159
        decq rcode
        jns  l_0480
        movq $159,rcode
        jmp  err_
l_0480:
# ||err|1,160|26,inappropriate file specification for output|||13951
# getarg 160
        decq rcode
        jns  l_0481
        movq $160,rcode
        jmp  err_
l_0481:
# ||ppm|6,exfal|||; fail if file does not exist|13952
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0482
        jmp  exfal
l_0482:
# ||err|1,161|26,output file cannot be written to|||13953
# getarg 161
        decq rcode
        jns  l_0483
        movq $161,rcode
        jmp  err_
l_0483:
# ||err|1,290|26,output channel currently in use|||13954
# getarg 290
        decq rcode
        jns  l_0484
        movq $290,rcode
        jmp  err_
l_0484:
call_155:
# ||brn|6,exnul|||; return null string|13955
# getarg exnul
        jmp  exnul
# ||ejc|||||13956
# |s_pos|ent||||; entry point|13960
	.align	2
	nop
s_pos:
# ||mov|8,wb|22,=p_pos||; set pcode for integer arg case|13961
# getarg W0
# getarg WB
        .data
l_0485: .long p_pos
        .text
        movq l_0485,W0
        movq W0,WB
# ||mov|8,wa|22,=p_psd||; set pcode for expression arg case|13962
# getarg W0
# getarg WA
        .data
l_0486: .long p_psd
        .text
        movq l_0486,W0
        movq W0,WA
# ||jsr|6,patin|||; call common routine to build node|13963
# getarg patin
        call patin
        decq rcode
        js   call_156
# ||err|1,162|26,pos argument is not integer or expression|||13964
# getarg 162
        decq rcode
        jns  l_0487
        movq $162,rcode
        jmp  err_
l_0487:
# ||err|1,163|26,pos argument is negative or too large|||13965
# getarg 163
        decq rcode
        jns  l_0488
        movq $163,rcode
        jmp  err_
l_0488:
call_156:
# ||mov|11,-(xs)|7,xr||; stack result|13966
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|13967
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|13968
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||13969
# |s_pro|ent||||; entry point|13973
	.align	2
	nop
s_pro:
# ||mov|7,xr|10,(xs)+||; load argument|13974
# getarg XR
        pop  XR
# ||mov|8,wb|13,tblen(xr)||; length if table, vector (=vclen)|13975
# getarg tblen(,XR,8)
# getarg WB
        movq tblen(,XR,8),WB
# ||btw|8,wb|||; convert to words|13976
# getarg WB
        shr  WB,3
# ||mov|8,wa|9,(xr)||; load type word of argument block|13977
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_art|6,spro4|; jump if array|13978
# getarg WA
# getarg W0
# getarg spro4
        movq l_0247,W0
        cmpq WA,W0
        je   spro4
# ||beq|8,wa|22,=b_tbt|6,spro1|; jump if table|13979
# getarg WA
# getarg W0
# getarg spro1
        movq l_0086,W0
        cmpq WA,W0
        je   spro1
# ||beq|8,wa|22,=b_vct|6,spro3|; jump if vector|13980
# getarg WA
# getarg W0
# getarg spro3
        movq l_0085,W0
        cmpq WA,W0
        je   spro3
# ||erb|1,164|26,prototype argument is not valid object|||13985
        movq $164,rcode
        jmp  err_
# |spro1|sub|8,wb|18,=tbsi_||; subtract standard fields|13989
spro1:
# getarg W0
# getarg WB
        movq l_0285,W0
        subq W0,WB
# |spro2|mti|8,wb|||; convert to integer|13993
spro2:
# getarg WB
        mov  WB,IA
# ||brn|6,exint|||; exit with integer result|13994
# getarg exint
        jmp  exint
# |spro3|sub|8,wb|18,=vcsi_||; subtract standard fields|13998
spro3:
# getarg W0
# getarg WB
        .data
l_0489: .long vcsi_
        .text
        movq l_0489,W0
        subq W0,WB
# ||brn|6,spro2|||; merge|13999
# getarg spro2
        jmp  spro2
# |spro4|add|7,xr|13,arofs(xr)||; point to prototype field|14003
spro4:
# getarg arofs(,XR,8)
# getarg XR
        addq arofs(,XR,8),XR
# ||mov|7,xr|9,(xr)||; load prototype|14004
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||mov|11,-(xs)|7,xr||; stack result|14005
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14006
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14007
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14017
# |s_rmd|ent||||; entry point|14021
	.align	2
	nop
s_rmd:
# ||jsr|6,arith|||; get two integers or two reals|14023
# getarg arith
        call arith
        decq rcode
        js   call_157
# ||err|1,166|26,remdr first argument is not numeric|||14024
# getarg 166
        decq rcode
        jns  l_0490
        movq $166,rcode
        jmp  err_
l_0490:
# ||err|1,165|26,remdr second argument is not numeric|||14025
# getarg 165
        decq rcode
        jns  l_0491
        movq $165,rcode
        jmp  err_
l_0491:
# ||ppm|6,srm06|||; if real|14026
# getarg srm06
# getarg srm06
        decq rcode
        jns  l_0492
        jmp  srm06
l_0492:
call_157:
# ||zer|8,wb|||; set positive flag|14043
# getarg WB
        xor  WB,WB
# ||ldi|13,icval(xr)|||; load left argument value|14044
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||ige|6,srm01|||; jump if positive|14045
# getarg srm01
        mov  IA,W0
        or   W0,W0
        jge  srm01
# ||mnz|8,wb|||; set negative flag|14046
# getarg WB
        mov  XS,WB
# |srm01|rmi|13,icval(xl)|||; get remainder|14047
srm01:
# getarg icval(,XL,8)
        mov  icval(,XL,8),W0
        call rmi__
# ||iov|6,srm05|||; error if overflow|14048
# getarg srm05
        iov_ srm05
# ||bze|8,wb|6,srm03||; if result should be positive|14052
# getarg WB
# getarg srm03
        or   WB,WB
        jz   srm03
# ||ile|6,exint|||; if should be negative, and is|14053
# getarg exint
        mov  IA,W0
        or   W0,W0
        jle  exint
# |srm02|ngi||||; adjust sign of result|14054
srm02:
        neg  IA
        seto reg_fl
# ||brn|6,exint|||; return result|14055
# getarg exint
        jmp  exint
# |srm03|ilt|6,srm02|||; should be pos, and result negative|14056
srm03:
# getarg srm02
        mov  IA,W0
        or   W0,W0
        jl   srm02
# ||brn|6,exint|||; should be positive, and is|14057
# getarg exint
        jmp  exint
# |srm04|erb|1,166|26,remdr first argument is not numeric|||14061
srm04:
        movq $166,rcode
        jmp  err_
# |srm05|erb|1,167|26,remdr caused integer overflow|||14065
srm05:
        movq $167,rcode
        jmp  err_
# |srm06|zer|8,wb|||; set positive flag|14072
srm06:
# getarg WB
        xor  WB,WB
# ||ldr|13,rcval(xr)|||; load left argument value|14073
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||rge|6,srm07|||; jump if positive|14074
# getarg srm07
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jge  srm07
# ||mnz|8,wb|||; set negative flag|14075
# getarg WB
        mov  XS,WB
# |srm07|dvr|13,rcval(xl)|||; compute n1/n2|14076
srm07:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call dvr_
# ||rov|6,srm10|||; jump if overflow|14077
# getarg srm10
        rov_ srm10
# ||chp||||; chop result|14078
        call chp_
# ||mlr|13,rcval(xl)|||; times n2|14079
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call mlr_
# ||sbr|13,rcval(xr)|||; compute difference|14080
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call sbr_
# ||bze|8,wb|6,srm09||; if result should be positive|14085
# getarg WB
# getarg srm09
        or   WB,WB
        jz   srm09
# ||rle|6,exrea|||; if should be negative, and is|14086
# getarg exrea
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jle  exrea
# |srm08|ngr||||; adjust sign of result|14087
srm08:
        call ngr_
# ||brn|6,exrea|||; return result|14088
# getarg exrea
        jmp  exrea
# |srm09|rlt|6,srm08|||; should be pos, and result negative|14089
srm09:
# getarg srm08
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   srm08
# ||brn|6,exrea|||; should be positive, and is|14090
# getarg exrea
        jmp  exrea
# |srm10|erb|1,312|26,remdr caused real overflow|||14094
srm10:
        movq $312,rcode
        jmp  err_
# ||ejc|||||14096
# |s_rpl|ent||||; entry point|14110
	.align	2
	nop
s_rpl:
# ||jsr|6,gtstg|||; load third argument as string|14111
# getarg gtstg
        call gtstg
        decq rcode
        js   call_158
# ||err|1,168|26,replace third argument is not a string|||14112
# getarg 168
        decq rcode
        jns  l_0493
        movq $168,rcode
        jmp  err_
l_0493:
call_158:
# ||mov|7,xl|7,xr||; save third arg ptr|14113
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtstg|||; get second argument|14114
# getarg gtstg
        call gtstg
        decq rcode
        js   call_159
# ||err|1,169|26,replace second argument is not a string|||14115
# getarg 169
        decq rcode
        jns  l_0494
        movq $169,rcode
        jmp  err_
l_0494:
call_159:
# ||bne|7,xr|3,r_ra2|6,srpl1|; jump if 2nd argument different|14119
# getarg XR
# getarg r_ra2
# getarg srpl1
        cmpq XR,r_ra2
        jne  srpl1
# ||beq|7,xl|3,r_ra3|6,srpl4|; jump if args same as last time|14120
# getarg XL
# getarg r_ra3
# getarg srpl4
        cmpq XL,r_ra3
        je   srpl4
# |srpl1|mov|8,wb|13,sclen(xl)||; load 3rd argument length|14124
srpl1:
# getarg sclen(,XL,8)
# getarg WB
        movq sclen(,XL,8),WB
# ||bne|8,wa|8,wb|6,srpl6|; jump if arguments not same length|14125
# getarg WA
# getarg WB
# getarg srpl6
        cmpq WA,WB
        jne  srpl6
# ||beq|7,xr|3,kvalp|6,srpl5|; jump if 2nd arg is alphabet string|14126
# getarg XR
# getarg kvalp
# getarg srpl5
        cmpq XR,kvalp
        je   srpl5
# ||bze|8,wb|6,srpl6||; jump if null 2nd argument|14127
# getarg WB
# getarg srpl6
        or   WB,WB
        jz   srpl6
# ||mov|3,r_ra3|7,xl||; save third arg for next time in|14128
# getarg XL
# getarg r_ra3
        movq XL,r_ra3
# ||mov|3,r_ra2|7,xr||; save second arg for next time in|14129
# getarg XR
# getarg r_ra2
        movq XR,r_ra2
# ||mov|7,xl|3,kvalp||; point to alphabet string|14130
# getarg kvalp
# getarg XL
        movq kvalp,XL
# ||mov|8,wa|13,sclen(xl)||; load alphabet scblk length|14131
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||mov|7,xr|3,r_rpt||; point to current table (if any)|14132
# getarg r_rpt
# getarg XR
        movq r_rpt,XR
# ||bnz|7,xr|6,srpl2||; jump if we already have a table|14133
# getarg XR
# getarg XR
# getarg srpl2
        or   XR,XR
        jnz  srpl2
# ||jsr|6,alocs|||; allocate new table|14137
# getarg alocs
        call alocs
# ||mov|8,wa|8,wc||; keep scblk length|14138
# getarg WC
# getarg WA
        movq WC,WA
# ||mov|3,r_rpt|7,xr||; save table pointer for next time|14139
# getarg XR
# getarg r_rpt
        movq XR,r_rpt
# |srpl2|ctb|8,wa|2,scsi_||; compute length of scblk|14143
srpl2:
# getarg WA
        add  ($cfp_b-1)+$cfp_b*scsi_,WA
        and  WA,-$8
# ||mvw||||; copy to get initial table values|14144
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0495:
        or   WA,WA
        jz   l_0496
        movsq
        decq WA
        jmp  l_0495
l_0496:
        cld
# ||ejc|||||14145
# ||mov|7,xl|3,r_ra2||; point to second argument|14153
# getarg r_ra2
# getarg XL
        movq r_ra2,XL
# ||lct|8,wb|8,wb||; number of chars to plug|14154
# ||zer|8,wc|||; zero char offset|14155
# getarg WC
        xor  WC,WC
# ||mov|7,xr|3,r_ra3||; point to 3rd arg|14156
# getarg r_ra3
# getarg XR
        movq r_ra3,XR
# ||plc|7,xr|||; get char ptr for 3rd arg|14157
# getarg XR
        add  $cfp_f,XR
# |srpl3|mov|7,xl|3,r_ra2||; point to 2nd arg|14161
srpl3:
# getarg r_ra2
# getarg XL
        movq r_ra2,XL
# ||plc|7,xl|8,wc||; point to next char|14162
# getarg XL
# getarg WC
        mov  WC,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||icv|8,wc|||; increment offset|14163
# getarg WC
        incq WC
# ||lch|8,wa|9,(xl)||; get next char|14164
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||mov|7,xl|3,r_rpt||; point to translate table|14165
# getarg r_rpt
# getarg XL
        movq r_rpt,XL
# ||psc|7,xl|8,wa||; convert char to offset into table|14166
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|8,wa|10,(xr)+||; get translated char|14167
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
        incq XR
# ||sch|8,wa|9,(xl)||; store in table|14168
# getarg WA
        movb
# ||csc|7,xl|||; complete store characters|14169
# ||bct|8,wb|6,srpl3||; loop till done|14170
# getarg WB
# getarg srpl3
        decq WB
        jnz  srpl3
# ||ejc|||||14171
# |srpl4|mov|7,xl|3,r_rpt||; replace table to use|14177
srpl4:
# getarg r_rpt
# getarg XL
        movq r_rpt,XL
# |srpl5|jsr|6,gtstg|||; get first argument|14182
srpl5:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_160
# ||err|1,170|26,replace first argument is not a string|||14183
# getarg 170
        decq rcode
        jns  l_0497
        movq $170,rcode
        jmp  err_
l_0497:
call_160:
# ||bze|8,wa|6,exnul||; return null if null argument|14192
# getarg WA
# getarg exnul
        or   WA,WA
        jz   exnul
# ||mov|11,-(xs)|7,xl||; stack replace table to use|14193
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; copy pointer|14194
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wc|8,wa||; save length|14195
# getarg WA
# getarg WC
        movq WA,WC
# ||ctb|8,wa|2,schar||; get scblk length|14196
# getarg WA
        add  ($cfp_b-1)+$cfp_b*schar,WA
        and  WA,-$8
# ||jsr|6,alloc|||; allocate space for copy|14197
# getarg alloc
        call alloc
# ||mov|8,wb|7,xr||; save address of copy|14198
# getarg XR
# getarg WB
        movq XR,WB
# ||mvw||||; move scblk contents to copy|14199
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0498:
        or   WA,WA
        jz   l_0499
        movsq
        decq WA
        jmp  l_0498
l_0499:
        cld
# ||mov|7,xr|10,(xs)+||; unstack replace table|14200
# getarg XR
        pop  XR
# ||plc|7,xr|||; point to chars of table|14201
# getarg XR
        add  $cfp_f,XR
# ||mov|7,xl|8,wb||; point to string to translate|14202
# getarg WB
# getarg XL
        movq WB,XL
# ||plc|7,xl|||; point to chars of string|14203
# getarg XL
        add  $cfp_f,XL
# ||mov|8,wa|8,wc||; set number of chars to translate|14204
# getarg WC
# getarg WA
        movq WC,WA
# ||trc||||; perform translation|14205
        xchg XL,XR
l_0500: movzbq (),W0
        addq W0,(,XL)
        mov  (W0),%al
        stosb
        decq WA
        jnz  l_0500
        xor  XL,XL
        xor  XR,XR
# |srpl8|mov|11,-(xs)|8,wb||; stack result|14206
srpl8:
# getarg WB
        push WB
# ||lcw|7,xr|||; load next code word|14207
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14208
# getarg (XR)
        jmp  *(XR)
# |srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||14212
srpl6:
        movq $171,rcode
        jmp  err_
# ||ejc|||||14227
# |s_rew|ent||||; entry point|14231
	.align	2
	nop
s_rew:
# ||jsr|6,iofcb|||; call fcblk routine|14232
# getarg iofcb
        call iofcb
        decq rcode
        js   call_161
# ||err|1,172|26,rewind argument is not a suitable name|||14233
# getarg 172
        decq rcode
        jns  l_0501
        movq $172,rcode
        jmp  err_
l_0501:
# ||err|1,173|26,rewind argument is null|||14234
# getarg 173
        decq rcode
        jns  l_0502
        movq $173,rcode
        jmp  err_
l_0502:
# ||err|1,174|26,rewind file does not exist|||14235
# getarg 174
        decq rcode
        jns  l_0503
        movq $174,rcode
        jmp  err_
l_0503:
call_161:
# ||jsr|6,sysrw|||; call system rewind function|14236
# getarg sysrw
        call sysrw
        decq rcode
        js   call_162
# ||err|1,174|26,rewind file does not exist|||14237
# getarg 174
        decq rcode
        jns  l_0504
        movq $174,rcode
        jmp  err_
l_0504:
# ||err|1,175|26,rewind file does not permit rewind|||14238
# getarg 175
        decq rcode
        jns  l_0505
        movq $175,rcode
        jmp  err_
l_0505:
# ||err|1,176|26,rewind caused non-recoverable error|||14239
# getarg 176
        decq rcode
        jns  l_0506
        movq $176,rcode
        jmp  err_
l_0506:
call_162:
# ||brn|6,exnul|||; exit with null result if no error|14240
# getarg exnul
        jmp  exnul
# ||ejc|||||14241
# |s_rvs|ent||||; entry point|14245
	.align	2
	nop
s_rvs:
# ||jsr|6,gtstg|||; load string argument|14247
# getarg gtstg
        call gtstg
        decq rcode
        js   call_163
# ||err|1,177|26,reverse argument is not a string|||14248
# getarg 177
        decq rcode
        jns  l_0507
        movq $177,rcode
        jmp  err_
l_0507:
call_163:
# ||bze|8,wa|6,exixr||; return argument if null|14254
# getarg WA
# getarg exixr
        or   WA,WA
        jz   exixr
# ||mov|7,xl|7,xr||; else save pointer to string arg|14255
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,alocs|||; allocate space for new scblk|14256
# getarg alocs
        call alocs
# ||mov|11,-(xs)|7,xr||; store scblk ptr on stack as result|14257
# getarg XR
        push XR
# ||psc|7,xr|||; prepare to store in new scblk|14258
# getarg XR
        add  $cfp_f,XR
# ||plc|7,xl|8,wc||; point past last char in argument|14259
# getarg XL
# getarg WC
        mov  WC,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lct|8,wc|8,wc||; set loop counter|14260
# |srvs1|lch|8,wb|11,-(xl)||; load next char from argument|14264
srvs1:
# getarg WB
        decq XL
        xor  W0,W0
        movb (XL),%al
        mov  W0,WB
# ||sch|8,wb|10,(xr)+||; store in result|14265
# getarg WB
        movb al
        stosb
# ||bct|8,wc|6,srvs1||; loop till all moved|14266
# getarg WC
# getarg srvs1
        decq WC
        jnz  srvs1
# |srvs4|csc|7,xr|||; complete store characters|14270
srvs4:
# ||zer|7,xl|||; clear garbage xl|14271
# getarg XL
        xor  XL,XL
# |srvs2|lcw|7,xr|||; load next code word|14272
srvs2:
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14273
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14297
# |s_rpd|ent||||; entry point|14301
	.align	2
	nop
s_rpd:
# ||jsr|6,gtstg|||; get pad character|14302
# getarg gtstg
        call gtstg
        decq rcode
        js   call_164
# ||err|1,178|26,rpad third argument is not a string|||14303
# getarg 178
        decq rcode
        jns  l_0508
        movq $178,rcode
        jmp  err_
l_0508:
call_164:
# ||plc|7,xr|||; point to character (null is blank)|14304
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wb|9,(xr)||; load pad character|14305
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
# ||jsr|6,gtsmi|||; get pad length|14306
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_165
# ||err|1,179|26,rpad second argument is not integer|||14307
# getarg 179
        decq rcode
        jns  l_0509
        movq $179,rcode
        jmp  err_
l_0509:
# ||ppm|6,srpd3|||; skip if negative or large|14308
# getarg srpd3
# getarg srpd3
        decq rcode
        jns  l_0510
        jmp  srpd3
l_0510:
call_165:
# |srpd1|jsr|6,gtstg|||; get first argument (string to pad)|14312
srpd1:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_166
# ||err|1,180|26,rpad first argument is not a string|||14313
# getarg 180
        decq rcode
        jns  l_0511
        movq $180,rcode
        jmp  err_
l_0511:
call_166:
# ||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|14314
# getarg WA
# getarg WC
# getarg exixr
        cmpq WA,WC
        jae  exixr
# ||mov|7,xl|7,xr||; else move ptr to string to pad|14315
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|8,wc||; copy length|14323
# getarg WC
# getarg WA
        movq WC,WA
# ||jsr|6,alocs|||; allocate scblk for new string|14324
# getarg alocs
        call alocs
# ||mov|11,-(xs)|7,xr||; save as result|14325
# getarg XR
        push XR
# ||mov|8,wa|13,sclen(xl)||; load length of argument|14326
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||sub|8,wc|8,wa||; calculate number of pad characters|14327
# getarg WA
# getarg WC
        subq WA,WC
# ||psc|7,xr|||; point to chars in result string|14328
# getarg XR
        add  $cfp_f,XR
# ||lct|8,wc|8,wc||; set counter for pad loop|14329
# ||bze|8,wa|6,srpd2||; jump if argument is null|14333
# getarg WA
# getarg srpd2
        or   WA,WA
        jz   srpd2
# ||plc|7,xl|||; else point to argument chars|14334
# getarg XL
        add  $cfp_f,XL
# ||mvc||||; move characters to result string|14335
        rep
        movsb
# ||zer|7,xl|||; clear garbage xl|14336
# getarg XL
        xor  XL,XL
# |srpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|14340
srpd2:
# getarg WB
        movb al
        stosb
# ||bct|8,wc|6,srpd2||; loop till all pad chars stored|14341
# getarg WC
# getarg srpd2
        decq WC
        jnz  srpd2
# ||csc|7,xr|||; complete character storing|14342
# ||lcw|7,xr|||; load next code word|14343
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14344
# getarg (XR)
        jmp  *(XR)
# |srpd3|zer|8,wc|||; zero pad count|14348
srpd3:
# getarg WC
        xor  WC,WC
# ||brn|6,srpd1|||; merge|14349
# getarg srpd1
        jmp  srpd1
# ||ejc|||||14350
# |s_rtb|ent||||; entry point|14354
	.align	2
	nop
s_rtb:
# ||mov|8,wb|22,=p_rtb||; set pcode for integer arg case|14355
# getarg W0
# getarg WB
        .data
l_0513: .long p_rtb
        .text
        movq l_0513,W0
        movq W0,WB
# ||mov|8,wa|22,=p_rtd||; set pcode for expression arg case|14356
# getarg W0
# getarg WA
        .data
l_0514: .long p_rtd
        .text
        movq l_0514,W0
        movq W0,WA
# ||jsr|6,patin|||; call common routine to build node|14357
# getarg patin
        call patin
        decq rcode
        js   call_167
# ||err|1,181|26,rtab argument is not integer or expression|||14358
# getarg 181
        decq rcode
        jns  l_0515
        movq $181,rcode
        jmp  err_
l_0515:
# ||err|1,182|26,rtab argument is negative or too large|||14359
# getarg 182
        decq rcode
        jns  l_0516
        movq $182,rcode
        jmp  err_
l_0516:
call_167:
# ||mov|11,-(xs)|7,xr||; stack result|14360
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14361
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14362
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14363
# |s_set|ent||||; entry point|14368
	.align	2
	nop
s_set:
# ||mov|3,r_io2|10,(xs)+||; save third arg (whence)|14369
# getarg r_io2
        pop  r_io2
# ||mov|3,r_io1|10,(xs)+||; save second arg (offset)|14376
# getarg r_io1
        pop  r_io1
# ||jsr|6,iofcb|||; call fcblk routine|14378
# getarg iofcb
        call iofcb
        decq rcode
        js   call_168
# ||err|1,291|26,set first argument is not a suitable name|||14379
# getarg 291
        decq rcode
        jns  l_0517
        movq $291,rcode
        jmp  err_
l_0517:
# ||err|1,292|26,set first argument is null|||14380
# getarg 292
        decq rcode
        jns  l_0518
        movq $292,rcode
        jmp  err_
l_0518:
# ||err|1,295|26,set file does not exist|||14381
# getarg 295
        decq rcode
        jns  l_0519
        movq $295,rcode
        jmp  err_
l_0519:
call_168:
# ||mov|8,wb|3,r_io1||; load second arg|14384
# getarg r_io1
# getarg WB
        movq r_io1,WB
# ||mov|8,wc|3,r_io2||; load third arg|14386
# getarg r_io2
# getarg WC
        movq r_io2,WC
# ||jsr|6,sysst|||; call system set routine|14387
# getarg sysst
        call sysst
# ||err|1,293|26,inappropriate second argument to set|||14388
# getarg 293
        decq rcode
        jns  l_0520
        movq $293,rcode
        jmp  err_
l_0520:
# ||err|1,294|26,inappropriate third argument to set|||14389
# getarg 294
        decq rcode
        jns  l_0521
        movq $294,rcode
        jmp  err_
l_0521:
# ||err|1,295|26,set file does not exist|||14390
# getarg 295
        decq rcode
        jns  l_0522
        movq $295,rcode
        jmp  err_
l_0522:
# ||err|1,296|26,set file does not permit setting file pointer|||14391
# getarg 296
        decq rcode
        jns  l_0523
        movq $296,rcode
        jmp  err_
l_0523:
# ||err|1,297|26,set caused non-recoverable i/o error|||14392
# getarg 297
        decq rcode
        jns  l_0524
        movq $297,rcode
        jmp  err_
l_0524:
# ||brn|6,exint|||; otherwise return position|14397
# getarg exint
        jmp  exint
# ||ejc|||||14399
# |s_tab|ent||||; entry point|14404
	.align	2
	nop
s_tab:
# ||mov|8,wb|22,=p_tab||; set pcode for integer arg case|14405
# getarg W0
# getarg WB
        .data
l_0525: .long p_tab
        .text
        movq l_0525,W0
        movq W0,WB
# ||mov|8,wa|22,=p_tbd||; set pcode for expression arg case|14406
# getarg W0
# getarg WA
        .data
l_0526: .long p_tbd
        .text
        movq l_0526,W0
        movq W0,WA
# ||jsr|6,patin|||; call common routine to build node|14407
# getarg patin
        call patin
        decq rcode
        js   call_169
# ||err|1,183|26,tab argument is not integer or expression|||14408
# getarg 183
        decq rcode
        jns  l_0527
        movq $183,rcode
        jmp  err_
l_0527:
# ||err|1,184|26,tab argument is negative or too large|||14409
# getarg 184
        decq rcode
        jns  l_0528
        movq $184,rcode
        jmp  err_
l_0528:
call_169:
# ||mov|11,-(xs)|7,xr||; stack result|14410
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14411
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14412
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14413
# |s_rps|ent||||; entry point|14417
	.align	2
	nop
s_rps:
# ||mov|8,wb|22,=p_rps||; set pcode for integer arg case|14418
# getarg W0
# getarg WB
        .data
l_0529: .long p_rps
        .text
        movq l_0529,W0
        movq W0,WB
# ||mov|8,wa|22,=p_rpd||; set pcode for expression arg case|14419
# getarg W0
# getarg WA
        .data
l_0530: .long p_rpd
        .text
        movq l_0530,W0
        movq W0,WA
# ||jsr|6,patin|||; call common routine to build node|14420
# getarg patin
        call patin
        decq rcode
        js   call_170
# ||err|1,185|26,rpos argument is not integer or expression|||14421
# getarg 185
        decq rcode
        jns  l_0531
        movq $185,rcode
        jmp  err_
l_0531:
# ||err|1,186|26,rpos argument is negative or too large|||14422
# getarg 186
        decq rcode
        jns  l_0532
        movq $186,rcode
        jmp  err_
l_0532:
call_170:
# ||mov|11,-(xs)|7,xr||; stack result|14423
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14424
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14425
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14428
# |s_rsr|ent||||; entry point|14432
	.align	2
	nop
s_rsr:
# ||mnz|8,wa|||; mark as rsort|14433
# getarg WA
        mov  XS,WA
# ||jsr|6,sorta|||; call sort routine|14434
# getarg sorta
        call sorta
        decq rcode
        js   call_171
# ||ppm|6,exfal|||; if conversion fails, so shall we|14435
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0533
        jmp  exfal
l_0533:
call_171:
# ||brn|6,exsid|||; return, setting idval|14436
# getarg exsid
        jmp  exsid
# ||ejc|||||14438
# |s_stx|ent||||; entry point|14442
	.align	2
	nop
s_stx:
# ||mov|7,xr|10,(xs)+||; load argument|14443
# getarg XR
        pop  XR
# ||mov|8,wa|3,stxvr||; load old vrblk pointer|14444
# getarg stxvr
# getarg WA
        movq stxvr,WA
# ||zer|7,xl|||; load zero in case null arg|14445
# getarg XL
        xor  XL,XL
# ||beq|7,xr|21,=nulls|6,sstx1|; jump if null argument (reset call)|14446
# getarg XR
# getarg W0
# getarg sstx1
        movq l_0054,W0
        cmpq XR,W0
        je   sstx1
# ||jsr|6,gtnvr|||; else get specified vrblk|14447
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_172
# ||ppm|6,sstx2|||; jump if not natural variable|14448
# getarg sstx2
# getarg sstx2
        decq rcode
        jns  l_0534
        jmp  sstx2
l_0534:
call_172:
# ||mov|7,xl|13,vrlbl(xr)||; else load label|14449
# getarg vrlbl(,XR,8)
# getarg XL
        movq vrlbl(,XR,8),XL
# ||beq|7,xl|21,=stndl|6,sstx2|; jump if label is not defined|14450
# getarg XL
# getarg W0
# getarg sstx2
        movq l_0157,W0
        cmpq XL,W0
        je   sstx2
# ||bne|9,(xl)|22,=b_trt|6,sstx1|; jump if not trapped|14451
# getarg (XL)
# getarg W0
# getarg sstx1
        movq l_0154,W0
        cmpq (XL),W0
        jne  sstx1
# ||mov|7,xl|13,trlbl(xl)||; else load ptr to real label code|14452
# getarg trlbl(,XL,8)
# getarg XL
        movq trlbl(,XL,8),XL
# |sstx1|mov|3,stxvr|7,xr||; store new vrblk pointer (or null)|14456
sstx1:
# getarg XR
# getarg stxvr
        movq XR,stxvr
# ||mov|3,r_sxc|7,xl||; store new code ptr (or zero)|14457
# getarg XL
# getarg r_sxc
        movq XL,r_sxc
# ||beq|8,wa|21,=nulls|6,exnul|; return null if null result|14458
# getarg WA
# getarg W0
# getarg exnul
        movq l_0054,W0
        cmpq WA,W0
        je   exnul
# ||mov|7,xr|8,wa||; else copy vrblk pointer|14459
# getarg WA
# getarg XR
        movq WA,XR
# ||brn|6,exvnm|||; and return building nmblk|14460
# getarg exvnm
        jmp  exvnm
# |sstx2|erb|1,187|26,setexit argument is not label name or null|||14464
sstx2:
        movq $187,rcode
        jmp  err_
# |s_sin|ent||||; entry point|14469
	.align	2
	nop
s_sin:
# ||mov|7,xr|10,(xs)+||; get argument|14470
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|14471
# getarg gtrea
        call gtrea
        decq rcode
        js   call_173
# ||err|1,308|26,sin argument not numeric|||14472
# getarg 308
        decq rcode
        jns  l_0535
        movq $308,rcode
        jmp  err_
l_0535:
call_173:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|14473
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||sin||||; take sine|14474
        call sin_
# ||rno|6,exrea|||; if no overflow, return result in ra|14475
# getarg exrea
        rno_ exrea
# ||erb|1,323|26,sin argument is out of range|||14476
        movq $323,rcode
        jmp  err_
# ||ejc|||||14477
# |s_sqr|ent||||; entry point|14483
	.align	2
	nop
s_sqr:
# ||mov|7,xr|10,(xs)+||; get argument|14484
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|14485
# getarg gtrea
        call gtrea
        decq rcode
        js   call_174
# ||err|1,313|26,sqrt argument not numeric|||14486
# getarg 313
        decq rcode
        jns  l_0536
        movq $313,rcode
        jmp  err_
l_0536:
call_174:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|14487
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||rlt|6,ssqr1|||; negative number|14488
# getarg ssqr1
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   ssqr1
# ||sqr||||; take square root|14489
        call sqr_
# ||brn|6,exrea|||; no overflow possible, result in ra|14490
# getarg exrea
        jmp  exrea
# |ssqr1|erb|1,314|26,sqrt argument negative|||14494
ssqr1:
        movq $314,rcode
        jmp  err_
# ||ejc|||||14495
# ||ejc|||||14499
# |s_srt|ent||||; entry point|14503
	.align	2
	nop
s_srt:
# ||zer|8,wa|||; mark as sort|14504
# getarg WA
        xor  WA,WA
# ||jsr|6,sorta|||; call sort routine|14505
# getarg sorta
        call sorta
        decq rcode
        js   call_175
# ||ppm|6,exfal|||; if conversion fails, so shall we|14506
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0537
        jmp  exfal
l_0537:
call_175:
# ||brn|6,exsid|||; return, setting idval|14507
# getarg exsid
        jmp  exsid
# ||ejc|||||14509
# |s_spn|ent||||; entry point|14513
	.align	2
	nop
s_spn:
# ||mov|8,wb|22,=p_sps||; set pcode for single char arg|14514
# getarg W0
# getarg WB
        .data
l_0538: .long p_sps
        .text
        movq l_0538,W0
        movq W0,WB
# ||mov|7,xl|22,=p_spn||; set pcode for multi-char arg|14515
# getarg W0
# getarg XL
        .data
l_0539: .long p_spn
        .text
        movq l_0539,W0
        movq W0,XL
# ||mov|8,wc|22,=p_spd||; set pcode for expression arg|14516
# getarg W0
# getarg WC
        .data
l_0540: .long p_spd
        .text
        movq l_0540,W0
        movq W0,WC
# ||jsr|6,patst|||; call common routine to build node|14517
# getarg patst
        call patst
        decq rcode
        js   call_176
# ||err|1,188|26,span argument is not a string or expression|||14518
# getarg 188
        decq rcode
        jns  l_0541
        movq $188,rcode
        jmp  err_
l_0541:
call_176:
# ||mov|11,-(xs)|7,xr||; stack result|14519
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14520
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14521
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14522
# |s_si_|ent||||; entry point|14526
	.align	2
	nop
s_si_:
# ||jsr|6,gtstg|||; load string argument|14528
# getarg gtstg
        call gtstg
        decq rcode
        js   call_177
# ||err|1,189|26,size argument is not a string|||14529
# getarg 189
        decq rcode
        jns  l_0542
        movq $189,rcode
        jmp  err_
l_0542:
call_177:
# ||mti|8,wa|||; load length as integer|14537
# getarg WA
        mov  WA,IA
# ||brn|6,exint|||; exit with integer result|14538
# getarg exint
        jmp  exint
# ||ejc|||||14539
# |s_stt|ent||||; entry point|14543
	.align	2
	nop
s_stt:
# ||zer|7,xl|||; indicate stoptr case|14544
# getarg XL
        xor  XL,XL
# ||jsr|6,trace|||; call trace procedure|14545
# getarg trace
        call trace
        decq rcode
        js   call_178
# ||err|1,190|26,stoptr first argument is not appropriate name|||14546
# getarg 190
        decq rcode
        jns  l_0543
        movq $190,rcode
        jmp  err_
l_0543:
# ||err|1,191|26,stoptr second argument is not trace type|||14547
# getarg 191
        decq rcode
        jns  l_0544
        movq $191,rcode
        jmp  err_
l_0544:
call_178:
# ||brn|6,exnul|||; return null|14548
# getarg exnul
        jmp  exnul
# ||ejc|||||14549
# |s_sub|ent||||; entry point|14553
	.align	2
	nop
s_sub:
# ||jsr|6,gtsmi|||; load third argument|14554
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_179
# ||err|1,192|26,substr third argument is not integer|||14555
# getarg 192
        decq rcode
        jns  l_0545
        movq $192,rcode
        jmp  err_
l_0545:
# ||ppm|6,exfal|||; jump if negative or too large|14556
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0546
        jmp  exfal
l_0546:
call_179:
# ||mov|3,sbssv|7,xr||; save third argument|14557
# getarg XR
# getarg sbssv
        movq XR,sbssv
# ||jsr|6,gtsmi|||; load second argument|14558
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_180
# ||err|1,193|26,substr second argument is not integer|||14559
# getarg 193
        decq rcode
        jns  l_0547
        movq $193,rcode
        jmp  err_
l_0547:
# ||ppm|6,exfal|||; jump if out of range|14560
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0548
        jmp  exfal
l_0548:
call_180:
# ||mov|8,wc|7,xr||; save second argument|14561
# getarg XR
# getarg WC
        movq XR,WC
# ||bze|8,wc|6,exfal||; jump if second argument zero|14562
# getarg WC
# getarg exfal
        or   WC,WC
        jz   exfal
# ||dcv|8,wc|||; else decrement for ones origin|14563
# getarg WC
        decq WC
# ||jsr|6,gtstg|||; load first argument|14565
# getarg gtstg
        call gtstg
        decq rcode
        js   call_181
# ||err|1,194|26,substr first argument is not a string|||14566
# getarg 194
        decq rcode
        jns  l_0549
        movq $194,rcode
        jmp  err_
l_0549:
call_181:
# ||mov|8,wb|8,wc||; copy second arg to wb|14574
# getarg WC
# getarg WB
        movq WC,WB
# ||mov|8,wc|3,sbssv||; reload third argument|14575
# getarg sbssv
# getarg WC
        movq sbssv,WC
# ||bnz|8,wc|6,ssub2||; skip if third arg given|14576
# getarg WC
# getarg WC
# getarg ssub2
        or   WC,WC
        jnz  ssub2
# ||mov|8,wc|8,wa||; else get string length|14577
# getarg WA
# getarg WC
        movq WA,WC
# ||bgt|8,wb|8,wc|6,exfal|; fail if improper|14578
# getarg WB
# getarg WC
# getarg exfal
        cmpq WB,WC
        ja   exfal
# ||sub|8,wc|8,wb||; reduce by offset to start|14579
# getarg WB
# getarg WC
        subq WB,WC
# |ssub2|mov|7,xl|8,wa||; save string length|14583
ssub2:
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|8,wa|8,wc||; set length of substring|14584
# getarg WC
# getarg WA
        movq WC,WA
# ||add|8,wc|8,wb||; add 2nd arg to 3rd arg|14585
# getarg WB
# getarg WC
        addq WB,WC
# ||bgt|8,wc|7,xl|6,exfal|; jump if improper substring|14586
# getarg WC
# getarg XL
# getarg exfal
        cmpq WC,XL
        ja   exfal
# ||mov|7,xl|7,xr||; copy pointer to first arg|14587
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,sbstr|||; build substring|14588
# getarg sbstr
        call sbstr
# ||mov|11,-(xs)|7,xr||; stack result|14589
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14590
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14591
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14592
# |s_tbl|ent||||; entry point|14596
	.align	2
	nop
s_tbl:
# ||mov|7,xl|10,(xs)+||; get initial lookup value|14597
# getarg XL
        pop  XL
# ||ica|7,xs|||; pop second argument|14598
# getarg XT
        addq $8,XT
# ||jsr|6,gtsmi|||; load argument|14599
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_182
# ||err|1,195|26,table argument is not integer|||14600
# getarg 195
        decq rcode
        jns  l_0550
        movq $195,rcode
        jmp  err_
l_0550:
# ||err|1,196|26,table argument is out of range|||14601
# getarg 196
        decq rcode
        jns  l_0551
        movq $196,rcode
        jmp  err_
l_0551:
call_182:
# ||bnz|8,wc|6,stbl1||; jump if non-zero|14602
# getarg WC
# getarg WC
# getarg stbl1
        or   WC,WC
        jnz  stbl1
# ||mov|8,wc|18,=tbnbk||; else supply default value|14603
# getarg W0
# getarg WC
        .data
l_0552: .long tbnbk
        .text
        movq l_0552,W0
        movq W0,WC
# |stbl1|jsr|6,tmake|||; make table|14607
stbl1:
# getarg tmake
        call tmake
# ||brn|6,exsid|||; exit setting idval|14608
# getarg exsid
        jmp  exsid
# ||ejc|||||14609
# |s_tan|ent||||; entry point|14614
	.align	2
	nop
s_tan:
# ||mov|7,xr|10,(xs)+||; get argument|14615
# getarg XR
        pop  XR
# ||jsr|6,gtrea|||; convert to real|14616
# getarg gtrea
        call gtrea
        decq rcode
        js   call_183
# ||err|1,309|26,tan argument not numeric|||14617
# getarg 309
        decq rcode
        jns  l_0553
        movq $309,rcode
        jmp  err_
l_0553:
call_183:
# ||ldr|13,rcval(xr)|||; load accumulator with argument|14618
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||tan||||; take tangent|14619
        call tan_
# ||rno|6,exrea|||; if no overflow, return result in ra|14620
# getarg exrea
        rno_ exrea
# ||erb|1,310|26,tan produced real overflow or argument is out of range|||14621
        movq $310,rcode
        jmp  err_
# ||ejc|||||14622
# |s_tim|ent||||; entry point|14627
	.align	2
	nop
s_tim:
# ||jsr|6,systm|||; get timer value|14628
# getarg systm
        call systm
# ||sbi|3,timsx|||; subtract starting time|14629
# getarg timsx
        sub  timsx,IA
        xor  W0,W0
        seto reg_fl
# ||brn|6,exint|||; exit with integer value|14630
# getarg exint
        jmp  exint
# ||ejc|||||14631
# |s_tra|ent||||; entry point|14635
	.align	2
	nop
s_tra:
# ||beq|13,num03(xs)|21,=nulls|6,str02|; jump if first argument is null|14636
# getarg num03(,XT,8)
# getarg W0
# getarg str02
        movq l_0054,W0
        cmpq num03(,XT,8),W0
        je   str02
# ||mov|7,xr|10,(xs)+||; load fourth argument|14637
# getarg XR
        pop  XR
# ||zer|7,xl|||; tentatively set zero pointer|14638
# getarg XL
        xor  XL,XL
# ||beq|7,xr|21,=nulls|6,str01|; jump if 4th argument is null|14639
# getarg XR
# getarg W0
# getarg str01
        movq l_0054,W0
        cmpq XR,W0
        je   str01
# ||jsr|6,gtnvr|||; else point to vrblk|14640
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_184
# ||ppm|6,str03|||; jump if not variable name|14641
# getarg str03
# getarg str03
        decq rcode
        jns  l_0554
        jmp  str03
l_0554:
call_184:
# ||mov|7,xl|7,xr||; else save vrblk in trfnc|14642
# getarg XR
# getarg XL
        movq XR,XL
# |str01|mov|7,xr|10,(xs)+||; load third argument (tag)|14646
str01:
# getarg XR
        pop  XR
# ||zer|8,wb|||; set zero as trtyp value for now|14647
# getarg WB
        xor  WB,WB
# ||jsr|6,trbld|||; build trblk for trace call|14648
# getarg trbld
        call trbld
# ||mov|7,xl|7,xr||; move trblk pointer for trace|14649
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,trace|||; call trace procedure|14650
# getarg trace
        call trace
        decq rcode
        js   call_185
# ||err|1,198|26,trace first argument is not appropriate name|||14651
# getarg 198
        decq rcode
        jns  l_0555
        movq $198,rcode
        jmp  err_
l_0555:
# ||err|1,199|26,trace second argument is not trace type|||14652
# getarg 199
        decq rcode
        jns  l_0556
        movq $199,rcode
        jmp  err_
l_0556:
call_185:
# ||brn|6,exnul|||; return null|14653
# getarg exnul
        jmp  exnul
# |str02|jsr|6,systt|||; call it|14657
str02:
# getarg systt
        call systt
# ||add|7,xs|19,*num04||; pop trace arguments|14658
# getarg W0
# getarg XT
        movq l_0167,W0
        addq W0,XT
# ||brn|6,exnul|||; return|14659
# getarg exnul
        jmp  exnul
# |str03|erb|1,197|26,trace fourth arg is not function name or null|||14663
str03:
        movq $197,rcode
        jmp  err_
# ||ejc|||||14664
# |s_trm|ent||||; entry point|14668
	.align	2
	nop
s_trm:
# ||jsr|6,gtstg|||; load argument as string|14670
# getarg gtstg
        call gtstg
        decq rcode
        js   call_186
# ||err|1,200|26,trim argument is not a string|||14671
# getarg 200
        decq rcode
        jns  l_0557
        movq $200,rcode
        jmp  err_
l_0557:
call_186:
# ||bze|8,wa|6,exnul||; return null if argument is null|14677
# getarg WA
# getarg exnul
        or   WA,WA
        jz   exnul
# ||mov|7,xl|7,xr||; copy string pointer|14678
# getarg XR
# getarg XL
        movq XR,XL
# ||ctb|8,wa|2,schar||; get block length|14679
# getarg WA
        add  ($cfp_b-1)+$cfp_b*schar,WA
        and  WA,-$8
# ||jsr|6,alloc|||; allocate copy same size|14680
# getarg alloc
        call alloc
# ||mov|8,wb|7,xr||; save pointer to copy|14681
# getarg XR
# getarg WB
        movq XR,WB
# ||mvw||||; copy old string block to new|14682
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0558:
        or   WA,WA
        jz   l_0559
        movsq
        decq WA
        jmp  l_0558
l_0559:
        cld
# ||mov|7,xr|8,wb||; restore ptr to new block|14683
# getarg WB
# getarg XR
        movq WB,XR
# ||jsr|6,trimr|||; trim blanks (wb is non-zero)|14684
# getarg trimr
        call trimr
# ||mov|11,-(xs)|7,xr||; stack result|14685
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14686
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14687
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14730
# |s_unl|ent||||; entry point|14734
	.align	2
	nop
s_unl:
# ||mov|7,xr|10,(xs)+||; load argument|14735
# getarg XR
        pop  XR
# ||jsr|6,gtnvr|||; point to vrblk|14736
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_187
# ||err|1,201|26,unload argument is not natural variable name|||14737
# getarg 201
        decq rcode
        jns  l_0560
        movq $201,rcode
        jmp  err_
l_0560:
call_187:
# ||mov|7,xl|21,=stndf||; get ptr to undefined function|14738
# getarg W0
# getarg XL
        .data
l_0561: .long stndf
        .text
        movq l_0561,W0
        movq W0,XL
# ||jsr|6,dffnc|||; undefine named function|14739
# getarg dffnc
        call dffnc
# ||brn|6,exnul|||; return null as result|14740
# getarg exnul
        jmp  exnul
# ||ttl|27,s p i t b o l -- utility routines||||14762
# ||ejc|||||14784
# |arref|rtn|||||14800
arref:
# ||mov|8,wa|7,xr||; copy number of subscripts|14801
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xt|7,xs||; point to stack front|14802
# getarg XT
# getarg XT
        movq XT,XT
# ||wtb|7,xr|||; convert to byte offset|14803
# getarg XR
        sal  XR,3
# ||add|7,xt|7,xr||; point to array operand on stack|14804
# getarg XR
# getarg XT
        addq XR,XT
# ||ica|7,xt|||; final value for stack popping|14805
# getarg XT
        addq $8,XT
# ||mov|3,arfxs|7,xt||; keep for later|14806
# getarg XT
# getarg arfxs
        movq XT,arfxs
# ||mov|7,xr|11,-(xt)||; load array operand pointer|14807
# getarg (XT)
# getarg XR
        sub  $8,XT
        movq (XT),XR
# ||mov|3,r_arf|7,xr||; keep array pointer|14808
# getarg XR
# getarg r_arf
        movq XR,r_arf
# ||mov|7,xr|7,xt||; save pointer to subscripts|14809
# getarg XT
# getarg XR
        movq XT,XR
# ||mov|7,xl|3,r_arf||; point xl to possible vcblk or tbblk|14810
# getarg r_arf
# getarg XL
        movq r_arf,XL
# ||mov|8,wc|9,(xl)||; load first word|14811
# getarg (XL)
# getarg WC
        movq (XL),WC
# ||beq|8,wc|22,=b_art|6,arf01|; jump if arblk|14812
# getarg WC
# getarg W0
# getarg arf01
        movq l_0247,W0
        cmpq WC,W0
        je   arf01
# ||beq|8,wc|22,=b_vct|6,arf07|; jump if vcblk|14813
# getarg WC
# getarg W0
# getarg arf07
        movq l_0085,W0
        cmpq WC,W0
        je   arf07
# ||beq|8,wc|22,=b_tbt|6,arf10|; jump if tbblk|14814
# getarg WC
# getarg W0
# getarg arf10
        movq l_0086,W0
        cmpq WC,W0
        je   arf10
# ||erb|1,235|26,subscripted operand is not table or array|||14815
        movq $235,rcode
        jmp  err_
# |arf01|bne|8,wa|13,arndm(xl)|6,arf09|; jump if wrong number of dims|14819
arf01:
# getarg WA
# getarg arndm(,XL,8)
# getarg arf09
        cmpq WA,arndm(,XL,8)
        jne  arf09
# ||ldi|4,intv0|||; get initial subscript of zero|14820
# getarg intv0
        mov  intv0,IA
# ||mov|7,xt|7,xr||; point before subscripts|14821
# getarg XR
# getarg XT
        movq XR,XT
# ||zer|8,wa|||; initial offset to bounds|14822
# getarg WA
        xor  WA,WA
# ||brn|6,arf03|||; jump into loop|14823
# getarg arf03
        jmp  arf03
# |arf02|mli|13,ardm2(xr)|||; multiply total by next dimension|14827
arf02:
# getarg ardm2(,XR,8)
        imul ardm2(,XR,8),IA
        seto reg_fl
# |arf03|mov|7,xr|11,-(xt)||; load next subscript|14831
arf03:
# getarg (XT)
# getarg XR
        sub  $8,XT
        movq (XT),XR
# ||sti|3,arfsi|||; save current subscript|14832
# getarg arfsi
        mov  IA,arfsi
# ||ldi|13,icval(xr)|||; load integer value in case|14833
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||beq|9,(xr)|22,=b_icl|6,arf04|; jump if it was an integer|14834
# getarg (XR)
# getarg W0
# getarg arf04
        movq l_0087,W0
        cmpq (XR),W0
        je   arf04
# ||ejc|||||14835
# ||jsr|6,gtint|||; convert to integer|14840
# getarg gtint
        call gtint
        decq rcode
        js   call_188
# ||ppm|6,arf12|||; jump if not integer|14841
# getarg arf12
# getarg arf12
        decq rcode
        jns  l_0562
        jmp  arf12
l_0562:
call_188:
# ||ldi|13,icval(xr)|||; if ok, load integer value|14842
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# |arf04|mov|7,xr|3,r_arf||; point to array|14846
arf04:
# getarg r_arf
# getarg XR
        movq r_arf,XR
# ||add|7,xr|8,wa||; offset to next bounds|14847
# getarg WA
# getarg XR
        addq WA,XR
# ||sbi|13,arlbd(xr)|||; subtract low bound to compare|14848
# getarg arlbd(,XR,8)
        sub  arlbd(,XR,8),IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,arf13|||; out of range fail if overflow|14849
# getarg arf13
        iov_ arf13
# ||ilt|6,arf13|||; out of range fail if too small|14850
# getarg arf13
        mov  IA,W0
        or   W0,W0
        jl   arf13
# ||sbi|13,ardim(xr)|||; subtract dimension|14851
# getarg ardim(,XR,8)
        sub  ardim(,XR,8),IA
        xor  W0,W0
        seto reg_fl
# ||ige|6,arf13|||; out of range fail if too large|14852
# getarg arf13
        mov  IA,W0
        or   W0,W0
        jge  arf13
# ||adi|13,ardim(xr)|||; else restore subscript offset|14853
# getarg ardim(,XR,8)
        add  ardim(,XR,8),IA
        seto reg_fl
# ||adi|3,arfsi|||; add to current total|14854
# getarg arfsi
        add  arfsi,IA
        seto reg_fl
# ||add|8,wa|19,*ardms||; point to next bounds|14855
# getarg W0
# getarg WA
        movq l_0245,W0
        addq W0,WA
# ||bne|7,xt|7,xs|6,arf02|; loop back if more to go|14856
# getarg XT
# getarg XT
# getarg arf02
        cmpq XT,XT
        jne  arf02
# ||mfi|8,wa|||; get as one word integer|14860
# getarg WA
        mov  IA,WA
# ||wtb|8,wa|||; convert to offset|14861
# getarg WA
        sal  WA,3
# ||mov|7,xl|3,r_arf||; point to arblk|14862
# getarg r_arf
# getarg XL
        movq r_arf,XL
# ||add|8,wa|13,arofs(xl)||; add offset past bounds|14863
# getarg arofs(,XL,8)
# getarg WA
        addq arofs(,XL,8),WA
# ||ica|8,wa|||; adjust for arpro field|14864
# getarg WA
        addq $8,WA
# ||bnz|8,wb|6,arf08||; exit with name if name call|14865
# getarg WB
# getarg WB
# getarg arf08
        or   WB,WB
        jnz  arf08
# |arf05|jsr|6,acess|||; get value|14869
arf05:
# getarg acess
        call acess
        decq rcode
        js   call_189
# ||ppm|6,arf13|||; fail if acess fails|14870
# getarg arf13
# getarg arf13
        decq rcode
        jns  l_0563
        jmp  arf13
l_0563:
call_189:
# |arf06|mov|7,xs|3,arfxs||; pop stack entries|14874
arf06:
# getarg arfxs
# getarg XT
        movq arfxs,XT
# ||zer|3,r_arf|||; finished with array pointer|14875
# getarg r_arf
        mov  $0,W0
        mov  W0,r_arf
# ||mov|11,-(xs)|7,xr||; stack result|14876
# getarg XR
        push XR
# ||lcw|7,xr|||; get next code word|14877
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|14878
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||14879
# |arf07|bne|8,wa|18,=num01|6,arf09|; error if more than 1 subscript|14885
arf07:
# getarg WA
# getarg W0
# getarg arf09
        movq l_0060,W0
        cmpq WA,W0
        jne  arf09
# ||mov|7,xr|9,(xs)||; else load subscript|14886
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||jsr|6,gtint|||; convert to integer|14887
# getarg gtint
        call gtint
        decq rcode
        js   call_190
# ||ppm|6,arf12|||; error if not integer|14888
# getarg arf12
# getarg arf12
        decq rcode
        jns  l_0564
        jmp  arf12
l_0564:
call_190:
# ||ldi|13,icval(xr)|||; else load integer value|14889
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sbi|4,intv1|||; subtract for ones offset|14890
# getarg intv1
        sub  intv1,IA
        xor  W0,W0
        seto reg_fl
# ||mfi|8,wa|6,arf13||; get subscript as one word|14891
# getarg arf13
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   arf13
        mov  IA,WA
# ||add|8,wa|18,=vcvls||; add offset for standard fields|14892
# getarg W0
# getarg WA
        .data
l_0565: .long vcvls
        .text
        movq l_0565,W0
        addq W0,WA
# ||wtb|8,wa|||; convert offset to bytes|14893
# getarg WA
        sal  WA,3
# ||bge|8,wa|13,vclen(xl)|6,arf13|; fail if out of range subscript|14894
# getarg WA
# getarg vclen(,XL,8)
# getarg arf13
        cmpq WA,vclen(,XL,8)
        jae  arf13
# ||bze|8,wb|6,arf05||; back to get value if value call|14895
# getarg WB
# getarg arf05
        or   WB,WB
        jz   arf05
# |arf08|mov|7,xs|3,arfxs||; pop stack entries|14899
arf08:
# getarg arfxs
# getarg XT
        movq arfxs,XT
# ||zer|3,r_arf|||; finished with array pointer|14900
# getarg r_arf
        mov  $0,W0
        mov  W0,r_arf
# ||brn|6,exnam|||; else exit with name|14901
# getarg exnam
        jmp  exnam
# |arf09|erb|1,236|26,array referenced with wrong number of subscripts|||14905
arf09:
        movq $236,rcode
        jmp  err_
# |arf10|bne|8,wa|18,=num01|6,arf11|; error if more than 1 subscript|14909
arf10:
# getarg WA
# getarg W0
# getarg arf11
        movq l_0060,W0
        cmpq WA,W0
        jne  arf11
# ||mov|7,xr|9,(xs)||; else load subscript|14910
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||jsr|6,tfind|||; call table search routine|14911
# getarg tfind
        call tfind
        decq rcode
        js   call_191
# ||ppm|6,arf13|||; fail if failed|14912
# getarg arf13
# getarg arf13
        decq rcode
        jns  l_0566
        jmp  arf13
l_0566:
call_191:
# ||bnz|8,wb|6,arf08||; exit with name if name call|14913
# getarg WB
# getarg WB
# getarg arf08
        or   WB,WB
        jnz  arf08
# ||brn|6,arf06|||; else exit with value|14914
# getarg arf06
        jmp  arf06
# |arf11|erb|1,237|26,table referenced with more than one subscript|||14918
arf11:
        movq $237,rcode
        jmp  err_
# |arf12|erb|1,238|26,array subscript is not integer|||14922
arf12:
        movq $238,rcode
        jmp  err_
# |arf13|zer|3,r_arf|||; finished with array pointer|14926
arf13:
# getarg r_arf
        mov  $0,W0
        mov  W0,r_arf
# ||brn|6,exfal|||; fail|14927
# getarg exfal
        jmp  exfal
# ||ejc|||||14928
# |cfunc|rtn|||||14945
cfunc:
# ||blt|8,wa|13,fargs(xl)|6,cfnc1|; jump if too few arguments|14946
# getarg WA
# getarg fargs(,XL,8)
# getarg cfnc1
        cmpq WA,fargs(,XL,8)
        jb   cfnc1
# ||beq|8,wa|13,fargs(xl)|6,cfnc3|; jump if correct number of args|14947
# getarg WA
# getarg fargs(,XL,8)
# getarg cfnc3
        cmpq WA,fargs(,XL,8)
        je   cfnc3
# ||mov|8,wb|8,wa||; copy actual number|14951
# getarg WA
# getarg WB
        movq WA,WB
# ||sub|8,wb|13,fargs(xl)||; get number of extra args|14952
# getarg fargs(,XL,8)
# getarg WB
        subq fargs(,XL,8),WB
# ||wtb|8,wb|||; convert to bytes|14953
# getarg WB
        sal  WB,3
# ||add|7,xs|8,wb||; pop off unwanted arguments|14954
# getarg WB
# getarg XT
        addq WB,XT
# ||brn|6,cfnc3|||; jump to go off to function|14955
# getarg cfnc3
        jmp  cfnc3
# |cfnc1|mov|8,wb|13,fargs(xl)||; load required number of arguments|14959
cfnc1:
# getarg fargs(,XL,8)
# getarg WB
        movq fargs(,XL,8),WB
# ||beq|8,wb|18,=nini9|6,cfnc3|; jump if case of var num of args|14960
# getarg WB
# getarg W0
# getarg cfnc3
        movq l_0076,W0
        cmpq WB,W0
        je   cfnc3
# ||sub|8,wb|8,wa||; calculate number missing|14961
# getarg WA
# getarg WB
        subq WA,WB
# ||lct|8,wb|8,wb||; set counter to control loop|14962
# |cfnc2|mov|11,-(xs)|21,=nulls||; stack a null argument|14966
cfnc2:
# getarg W0
        movq l_0054,W0
        push W0
# ||bct|8,wb|6,cfnc2||; loop till proper number stacked|14967
# getarg WB
# getarg cfnc2
        decq WB
        jnz  cfnc2
# |cfnc3|bri|9,(xl)|||; jump through fcode field|14971
cfnc3:
# getarg (XL)
        jmp  *(XL)
# ||ejc|||||14972
# |exfal|rtn|||||14981
exfal:
# ||mov|7,xs|3,flptr||; pop stack|14982
# getarg flptr
# getarg XT
        movq flptr,XT
# ||mov|7,xr|9,(xs)||; load failure offset|14983
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,r_cod||; point to failure code location|14984
# getarg r_cod
# getarg XR
        addq r_cod,XR
# ||lcp|7,xr|||; set code pointer|14985
# getarg XR
        lcp_ XR
# ||lcw|7,xr|||; load next code word|14986
# getarg XR
        lcw_ XR
# ||mov|7,xl|9,(xr)||; load entry address|14987
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute next code word|14988
# getarg XL
        jmp  *XL
# ||ejc|||||14989
# |exint|rtn|||||15000
exint:
# ||zer|7,xl|||; clear dud value|15001
# getarg XL
        xor  XL,XL
# ||jsr|6,icbld|||; build icblk|15002
# getarg icbld
        call icbld
# ||ejc|||||15003
# |exixr|rtn|||||15012
exixr:
# ||mov|11,-(xs)|7,xr||; stack result|15014
# getarg XR
        push XR
# |exits|rtn|||||15023
exits:
# ||lcw|7,xr|||; load next code word|15024
# getarg XR
        lcw_ XR
# ||mov|7,xl|9,(xr)||; load entry address|15025
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute next code word|15026
# getarg XL
        jmp  *XL
# ||ejc|||||15027
# |exnam|rtn|||||15038
exnam:
# ||mov|11,-(xs)|7,xl||; stack name base|15039
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wa||; stack name offset|15040
# getarg WA
        push WA
# ||lcw|7,xr|||; load next code word|15041
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|15042
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||15043
# |exnul|rtn|||||15052
exnul:
# ||mov|11,-(xs)|21,=nulls||; stack null value|15053
# getarg W0
        movq l_0054,W0
        push W0
# ||lcw|7,xr|||; load next code word|15054
# getarg XR
        lcw_ XR
# ||mov|7,xl|9,(xr)||; load entry address|15055
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute next code word|15056
# getarg XL
        jmp  *XL
# ||ejc|||||15057
# |exrea|rtn|||||15069
exrea:
# ||zer|7,xl|||; clear dud value|15070
# getarg XL
        xor  XL,XL
# ||jsr|6,rcbld|||; build rcblk|15071
# getarg rcbld
        call rcbld
# ||brn|6,exixr|||; jump to exit with result in xr|15072
# getarg exixr
        jmp  exixr
# ||ejc|||||15074
# |exsid|rtn|||||15087
exsid:
# ||mov|8,wa|3,curid||; load current id value|15088
# getarg curid
# getarg WA
        movq curid,WA
# ||bne|8,wa|3,mxint|6,exsi1|; jump if no overflow|15089
# getarg WA
# getarg mxint
# getarg exsi1
        cmpq WA,mxint
        jne  exsi1
# ||zer|8,wa|||; else reset for wraparound|15090
# getarg WA
        xor  WA,WA
# |exsi1|icv|8,wa|||; bump id value|15094
exsi1:
# getarg WA
        incq WA
# ||mov|3,curid|8,wa||; store for next time|15095
# getarg WA
# getarg curid
        movq WA,curid
# ||mov|13,idval(xr)|8,wa||; store id value|15096
# getarg WA
# getarg idval(,XR,8)
        movq WA,idval(,XR,8)
# ||brn|6,exixr|||; exit with result in (xr)|15097
# getarg exixr
        jmp  exixr
# ||ejc|||||15098
# |exvnm|rtn|||||15109
exvnm:
# ||mov|7,xl|7,xr||; copy name base pointer|15110
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*nmsi_||; set size of nmblk|15111
# getarg W0
# getarg WA
        movq l_0125,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate nmblk|15112
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_nml||; store type word|15113
# getarg W0
# getarg (XR)
        movq l_0126,W0
        movq W0,(XR)
# ||mov|13,nmbas(xr)|7,xl||; store name base|15114
# getarg XL
# getarg nmbas(,XR,8)
        movq XL,nmbas(,XR,8)
# ||mov|13,nmofs(xr)|19,*vrval||; store name offset|15115
# getarg W0
# getarg nmofs(,XR,8)
        movq l_0121,W0
        movq W0,nmofs(,XR,8)
# ||brn|6,exixr|||; exit with result in xr|15116
# getarg exixr
        jmp  exixr
# ||ejc|||||15117
# |flpop|rtn|||||15127
flpop:
# ||add|7,xs|19,*num02||; pop two entries off stack|15128
# getarg W0
# getarg XT
        movq l_0135,W0
        addq W0,XT
# ||ejc|||||15129
# |failp|rtn|||||15141
failp:
# ||mov|7,xr|10,(xs)+||; load alternative node pointer|15142
# getarg XR
        pop  XR
# ||mov|8,wb|10,(xs)+||; restore old cursor|15143
# getarg WB
        pop  WB
# ||mov|7,xl|9,(xr)||; load pcode entry pointer|15144
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute code for node|15145
# getarg XL
        jmp  *XL
# ||ejc|||||15146
# |indir|rtn|||||15155
indir:
# ||mov|7,xr|10,(xs)+||; load argument|15156
# getarg XR
        pop  XR
# ||beq|9,(xr)|22,=b_nml|6,indr2|; jump if a name|15157
# getarg (XR)
# getarg W0
# getarg indr2
        movq l_0126,W0
        cmpq (XR),W0
        je   indr2
# ||jsr|6,gtnvr|||; else convert to variable|15158
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_192
# ||err|1,239|26,indirection operand is not name|||15159
# getarg 239
        decq rcode
        jns  l_0567
        movq $239,rcode
        jmp  err_
l_0567:
call_192:
# ||bze|8,wb|6,indr1||; skip if by value|15160
# getarg WB
# getarg indr1
        or   WB,WB
        jz   indr1
# ||mov|11,-(xs)|7,xr||; else stack vrblk ptr|15161
# getarg XR
        push XR
# ||mov|11,-(xs)|19,*vrval||; stack name offset|15162
# getarg W0
        movq l_0121,W0
        push W0
# ||lcw|7,xr|||; load next code word|15163
# getarg XR
        lcw_ XR
# ||mov|7,xl|9,(xr)||; load entry address|15164
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute next code word|15165
# getarg XL
        jmp  *XL
# |indr1|bri|9,(xr)|||; jump through vrget field of vrblk|15169
indr1:
# getarg (XR)
        jmp  *(XR)
# |indr2|mov|7,xl|13,nmbas(xr)||; load name base|15173
indr2:
# getarg nmbas(,XR,8)
# getarg XL
        movq nmbas(,XR,8),XL
# ||mov|8,wa|13,nmofs(xr)||; load name offset|15174
# getarg nmofs(,XR,8)
# getarg WA
        movq nmofs(,XR,8),WA
# ||bnz|8,wb|6,exnam||; exit if called by name|15175
# getarg WB
# getarg WB
# getarg exnam
        or   WB,WB
        jnz  exnam
# ||jsr|6,acess|||; else get value first|15176
# getarg acess
        call acess
        decq rcode
        js   call_193
# ||ppm|6,exfal|||; fail if access fails|15177
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0568
        jmp  exfal
l_0568:
call_193:
# ||brn|6,exixr|||; else return with value in xr|15178
# getarg exixr
        jmp  exixr
# ||ejc|||||15179
# |match|rtn|||||15189
match:
# ||mov|7,xr|10,(xs)+||; load pattern operand|15190
# getarg XR
        pop  XR
# ||jsr|6,gtpat|||; convert to pattern|15191
# getarg gtpat
        call gtpat
        decq rcode
        js   call_194
# ||err|1,240|26,pattern match right operand is not pattern|||15192
# getarg 240
        decq rcode
        jns  l_0569
        movq $240,rcode
        jmp  err_
l_0569:
call_194:
# ||mov|7,xl|7,xr||; if ok, save pattern pointer|15193
# getarg XR
# getarg XL
        movq XR,XL
# ||bnz|8,wb|6,mtch1||; jump if not match by name|15194
# getarg WB
# getarg WB
# getarg mtch1
        or   WB,WB
        jnz  mtch1
# ||mov|8,wa|9,(xs)||; else load name offset|15195
# getarg (XT)
# getarg WA
        movq (XT),WA
# ||mov|11,-(xs)|7,xl||; save pattern pointer|15196
# getarg XL
        push XL
# ||mov|7,xl|13,num02(xs)||; load name base|15197
# getarg num02(,XT,8)
# getarg XL
        movq num02(,XT,8),XL
# ||jsr|6,acess|||; access subject value|15198
# getarg acess
        call acess
        decq rcode
        js   call_195
# ||ppm|6,exfal|||; fail if access fails|15199
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0570
        jmp  exfal
l_0570:
call_195:
# ||mov|7,xl|9,(xs)||; restore pattern pointer|15200
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|9,(xs)|7,xr||; stack subject string val for merge|15201
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||zer|8,wb|||; restore type code|15202
# getarg WB
        xor  WB,WB
# |mtch1|jsr|6,gtstg|||; convert subject to string|15207
mtch1:
# getarg gtstg
        call gtstg
        decq rcode
        js   call_196
# ||err|1,241|26,pattern match left operand is not a string|||15208
# getarg 241
        decq rcode
        jns  l_0571
        movq $241,rcode
        jmp  err_
l_0571:
call_196:
# ||mov|11,-(xs)|8,wb||; stack match type code|15209
# getarg WB
        push WB
# ||mov|3,r_pms|7,xr||; if ok, store subject string pointer|15217
# getarg XR
# getarg r_pms
        movq XR,r_pms
# ||mov|3,pmssl|8,wa||; and length|15218
# getarg WA
# getarg pmssl
        movq WA,pmssl
# ||zer|11,-(xs)|||; stack initial cursor (zero)|15219
        push $0
# ||zer|8,wb|||; set initial cursor|15220
# getarg WB
        xor  WB,WB
# ||mov|3,pmhbs|7,xs||; set history stack base ptr|15221
# getarg XT
# getarg pmhbs
        movq XT,pmhbs
# ||zer|3,pmdfl|||; reset pattern assignment flag|15222
# getarg pmdfl
        mov  $0,W0
        mov  W0,pmdfl
# ||mov|7,xr|7,xl||; set initial node pointer|15223
# getarg XL
# getarg XR
        movq XL,XR
# ||bnz|3,kvanc|6,mtch2||; jump if anchored|15224
# getarg kvanc
# getarg mtch2
        xor  W0,W0
        cmpq kvanc,W0
        jnz  mtch2
# ||mov|11,-(xs)|7,xr||; stack initial node pointer|15228
# getarg XR
        push XR
# ||mov|11,-(xs)|21,=nduna||; stack pointer to anchor move node|15229
# getarg W0
        movq l_0200,W0
        push W0
# ||bri|9,(xr)|||; start match of first node|15230
# getarg (XR)
        jmp  *(XR)
# |mtch2|zer|11,-(xs)|||; dummy cursor value|15234
mtch2:
        push $0
# ||mov|11,-(xs)|21,=ndabo||; stack pointer to abort node|15235
# getarg W0
        movq l_0183,W0
        push W0
# ||bri|9,(xr)|||; start match of first node|15236
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||15237
# |retrn|rtn|||||15250
retrn:
# ||bnz|3,kvfnc|6,rtn01||; jump if not level zero|15251
# getarg kvfnc
# getarg rtn01
        xor  W0,W0
        cmpq kvfnc,W0
        jnz  rtn01
# ||erb|1,242|26,function return from level zero|||15252
        movq $242,rcode
        jmp  err_
# |rtn01|mov|7,xs|3,flprt||; pop stack|15256
rtn01:
# getarg flprt
# getarg XT
        movq flprt,XT
# ||ica|7,xs|||; remove failure offset|15257
# getarg XT
        addq $8,XT
# ||mov|7,xr|10,(xs)+||; pop pfblk pointer|15258
# getarg XR
        pop  XR
# ||mov|3,flptr|10,(xs)+||; pop failure pointer|15259
# getarg flptr
        pop  flptr
# ||mov|3,flprt|10,(xs)+||; pop old flprt|15260
# getarg flprt
        pop  flprt
# ||mov|8,wb|10,(xs)+||; pop code pointer offset|15261
# getarg WB
        pop  WB
# ||mov|8,wc|10,(xs)+||; pop old code block pointer|15262
# getarg WC
        pop  WC
# ||add|8,wb|8,wc||; make old code pointer absolute|15263
# getarg WC
# getarg WB
        addq WC,WB
# ||lcp|8,wb|||; restore old code pointer|15264
# getarg WB
        lcp_ WB
# ||mov|3,r_cod|8,wc||; restore old code block pointer|15265
# getarg WC
# getarg r_cod
        movq WC,r_cod
# ||dcv|3,kvfnc|||; decrement function level|15266
# getarg kvfnc
        decq kvfnc
# ||mov|8,wb|3,kvtra||; load trace|15267
# getarg kvtra
# getarg WB
        movq kvtra,WB
# ||add|8,wb|3,kvftr||; add ftrace|15268
# getarg kvftr
# getarg WB
        addq kvftr,WB
# ||bze|8,wb|6,rtn06||; jump if no tracing possible|15269
# getarg WB
# getarg rtn06
        or   WB,WB
        jz   rtn06
# ||mov|11,-(xs)|8,wa||; save function return type|15273
# getarg WA
        push WA
# ||mov|11,-(xs)|7,xr||; save pfblk pointer|15274
# getarg XR
        push XR
# ||mov|3,kvrtn|8,wa||; set rtntype for trace function|15275
# getarg WA
# getarg kvrtn
        movq WA,kvrtn
# ||mov|7,xl|3,r_fnc||; load fnclevel trblk ptr (if any)|15276
# getarg r_fnc
# getarg XL
        movq r_fnc,XL
# ||jsr|6,ktrex|||; execute possible fnclevel trace|15277
# getarg ktrex
        call ktrex
# ||mov|7,xl|13,pfvbl(xr)||; load vrblk ptr (sgd13)|15278
# getarg pfvbl(,XR,8)
# getarg XL
        movq pfvbl(,XR,8),XL
# ||bze|3,kvtra|6,rtn02||; jump if trace is off|15279
# getarg kvtra
# getarg rtn02
        xor  W0,W0
        cmpq kvtra,W0
        jz   rtn02
# ||mov|7,xr|13,pfrtr(xr)||; else load return trace trblk ptr|15280
# getarg pfrtr(,XR,8)
# getarg XR
        movq pfrtr(,XR,8),XR
# ||bze|7,xr|6,rtn02||; jump if not return traced|15281
# getarg XR
# getarg rtn02
        or   XR,XR
        jz   rtn02
# ||dcv|3,kvtra|||; else decrement trace count|15282
# getarg kvtra
        decq kvtra
# ||bze|13,trfnc(xr)|6,rtn03||; jump if print trace|15283
# getarg trfnc(,XR,8)
# getarg rtn03
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   rtn03
# ||mov|8,wa|19,*vrval||; else set name offset|15284
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||mov|3,kvrtn|13,num01(xs)||; make sure rtntype is set right|15285
# getarg num01(,XT,8)
# getarg W0
# getarg kvrtn
        movq num01(,XT,8),W0
        movq W0,kvrtn
# ||jsr|6,trxeq|||; execute full trace|15286
# getarg trxeq
        call trxeq
# ||ejc|||||15287
# |rtn02|bze|3,kvftr|6,rtn05||; jump if ftrace is off|15293
rtn02:
# getarg kvftr
# getarg rtn05
        xor  W0,W0
        cmpq kvftr,W0
        jz   rtn05
# ||dcv|3,kvftr|||; else decrement ftrace|15294
# getarg kvftr
        decq kvftr
# |rtn03|jsr|6,prtsn|||; print statement number|15298
rtn03:
# getarg prtsn
        call prtsn
# ||mov|7,xr|13,num01(xs)||; load return type|15299
# getarg num01(,XT,8)
# getarg XR
        movq num01(,XT,8),XR
# ||jsr|6,prtst|||; print it|15300
# getarg prtst
        call prtst
# ||mov|8,wa|18,=ch_bl||; load blank|15301
# getarg W0
# getarg WA
        .data
l_0572: .long ch_bl
        .text
        movq l_0572,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|15302
# getarg prtch
        call prtch
# ||mov|7,xl|12,0(xs)||; load pfblk ptr|15303
# getarg 0(,XT,8)
# getarg XL
        movq 0(,XT,8),XL
# ||mov|7,xl|13,pfvbl(xl)||; load function vrblk ptr|15304
# getarg pfvbl(,XL,8)
# getarg XL
        movq pfvbl(,XL,8),XL
# ||mov|8,wa|19,*vrval||; set vrblk name offset|15305
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||bne|7,xr|21,=scfrt|6,rtn04|; jump if not freturn case|15306
# getarg XR
# getarg W0
# getarg rtn04
        movq l_0222,W0
        cmpq XR,W0
        jne  rtn04
# ||jsr|6,prtnm|||; print name|15310
# getarg prtnm
        call prtnm
# ||jsr|6,prtnl|||; terminate print line|15311
# getarg prtnl
        call prtnl
# ||brn|6,rtn05|||; merge|15312
# getarg rtn05
        jmp  rtn05
# |rtn04|jsr|6,prtnv|||; print name = value|15316
rtn04:
# getarg prtnv
        call prtnv
# |rtn05|mov|7,xr|10,(xs)+||; pop pfblk pointer|15320
rtn05:
# getarg XR
        pop  XR
# ||mov|8,wa|10,(xs)+||; pop return type string|15321
# getarg WA
        pop  WA
# |rtn06|mov|3,kvrtn|8,wa||; set rtntype keyword|15325
rtn06:
# getarg WA
# getarg kvrtn
        movq WA,kvrtn
# ||mov|7,xl|13,pfvbl(xr)||; load pointer to fn vrblk|15326
# getarg pfvbl(,XR,8)
# getarg XL
        movq pfvbl(,XR,8),XL
# ||ejc|||||15327
# |rtn07|mov|3,rtnbp|7,xl||; save block pointer|15332
rtn07:
# getarg XL
# getarg rtnbp
        movq XL,rtnbp
# ||mov|7,xl|13,vrval(xl)||; load value|15333
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,rtn07|; loop back if trapped|15334
# getarg (XL)
# getarg W0
# getarg rtn07
        movq l_0154,W0
        cmpq (XL),W0
        je   rtn07
# ||mov|3,rtnfv|7,xl||; else save function result value|15335
# getarg XL
# getarg rtnfv
        movq XL,rtnfv
# ||mov|3,rtnsv|10,(xs)+||; save original function value|15336
# getarg rtnsv
        pop  rtnsv
# ||mov|7,xl|10,(xs)+||; pop saved pointer|15340
# getarg XL
        pop  XL
# ||bze|7,xl|6,rtn7c||; no action if none|15341
# getarg XL
# getarg rtn7c
        or   XL,XL
        jz   rtn7c
# ||bze|3,kvpfl|6,rtn7c||; jump if no profiling|15342
# getarg kvpfl
# getarg rtn7c
        xor  W0,W0
        cmpq kvpfl,W0
        jz   rtn7c
# ||jsr|6,prflu|||; else profile last func stmt|15343
# getarg prflu
        call prflu
# ||beq|3,kvpfl|18,=num02|6,rtn7a|; branch on value of profile keywd|15344
# getarg kvpfl
# getarg W0
# getarg rtn7a
        movq l_0130,W0
        cmpq kvpfl,W0
        je   rtn7a
# ||ldi|3,pfstm|||; load current time|15350
# getarg pfstm
        mov  pfstm,IA
# ||sbi|13,icval(xl)|||; frig by subtracting saved amount|15351
# getarg icval(,XL,8)
        sub  icval(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||brn|6,rtn7b|||; and merge|15352
# getarg rtn7b
        jmp  rtn7b
# |rtn7a|ldi|13,icval(xl)|||; load saved time|15356
rtn7a:
# getarg icval(,XL,8)
        mov  icval(,XL,8),IA
# |rtn7b|sti|3,pfstm|||; store back correct start time|15360
rtn7b:
# getarg pfstm
        mov  IA,pfstm
# |rtn7c|mov|8,wb|13,fargs(xr)||; get number of args|15364
rtn7c:
# getarg fargs(,XR,8)
# getarg WB
        movq fargs(,XR,8),WB
# ||add|8,wb|13,pfnlo(xr)||; add number of locals|15366
# getarg pfnlo(,XR,8)
# getarg WB
        addq pfnlo(,XR,8),WB
# ||bze|8,wb|6,rtn10||; jump if no args/locals|15367
# getarg WB
# getarg rtn10
        or   WB,WB
        jz   rtn10
# ||lct|8,wb|8,wb||; else set loop counter|15368
# ||add|7,xr|13,pflen(xr)||; and point to end of pfblk|15369
# getarg pflen(,XR,8)
# getarg XR
        addq pflen(,XR,8),XR
# |rtn08|mov|7,xl|11,-(xr)||; load next vrblk pointer|15373
rtn08:
# getarg (XR)
# getarg XL
        sub  $8,XR
        movq (XR),XL
# |rtn09|mov|8,wa|7,xl||; save block pointer|15377
rtn09:
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xl|13,vrval(xl)||; load pointer to next value|15378
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,rtn09|; loop back if trapped|15379
# getarg (XL)
# getarg W0
# getarg rtn09
        movq l_0154,W0
        cmpq (XL),W0
        je   rtn09
# ||mov|7,xl|8,wa||; else restore last block pointer|15380
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|13,vrval(xl)|10,(xs)+||; restore old variable value|15381
# getarg vrval(,XL,8)
        pop  vrval(,XL,8)
# ||bct|8,wb|6,rtn08||; loop till all processed|15382
# getarg WB
# getarg rtn08
        decq WB
        jnz  rtn08
# |rtn10|mov|7,xl|3,rtnbp||; restore ptr to last function block|15386
rtn10:
# getarg rtnbp
# getarg XL
        movq rtnbp,XL
# ||mov|13,vrval(xl)|3,rtnsv||; restore old function value|15387
# getarg rtnsv
# getarg W0
# getarg vrval(,XL,8)
        movq rtnsv,W0
        movq W0,vrval(,XL,8)
# ||mov|7,xr|3,rtnfv||; reload function result|15388
# getarg rtnfv
# getarg XR
        movq rtnfv,XR
# ||mov|7,xl|3,r_cod||; point to new code block|15389
# getarg r_cod
# getarg XL
        movq r_cod,XL
# ||mov|3,kvlst|3,kvstn||; set lastno from stno|15390
# getarg kvstn
# getarg W0
# getarg kvlst
        movq kvstn,W0
        movq W0,kvlst
# ||mov|3,kvstn|13,cdstm(xl)||; reset proper stno value|15391
# getarg cdstm(,XL,8)
# getarg W0
# getarg kvstn
        movq cdstm(,XL,8),W0
        movq W0,kvstn
# ||mov|3,kvlln|3,kvlin||; set lastline from line|15393
# getarg kvlin
# getarg W0
# getarg kvlln
        movq kvlin,W0
        movq W0,kvlln
# ||mov|3,kvlin|13,cdsln(xl)||; reset proper line value|15394
# getarg cdsln(,XL,8)
# getarg W0
# getarg kvlin
        movq cdsln(,XL,8),W0
        movq W0,kvlin
# ||mov|8,wa|3,kvrtn||; load return type|15396
# getarg kvrtn
# getarg WA
        movq kvrtn,WA
# ||beq|8,wa|21,=scrtn|6,exixr|; exit with result in xr if return|15397
# getarg WA
# getarg W0
# getarg exixr
        movq l_0224,W0
        cmpq WA,W0
        je   exixr
# ||beq|8,wa|21,=scfrt|6,exfal|; fail if freturn|15398
# getarg WA
# getarg W0
# getarg exfal
        movq l_0222,W0
        cmpq WA,W0
        je   exfal
# ||ejc|||||15399
# ||beq|9,(xr)|22,=b_nml|6,rtn11|; jump if is a name|15405
# getarg (XR)
# getarg W0
# getarg rtn11
        movq l_0126,W0
        cmpq (XR),W0
        je   rtn11
# ||jsr|6,gtnvr|||; else try convert to variable name|15406
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_197
# ||err|1,243|26,function result in nreturn is not name|||15407
# getarg 243
        decq rcode
        jns  l_0573
        movq $243,rcode
        jmp  err_
l_0573:
call_197:
# ||mov|7,xl|7,xr||; if ok, copy vrblk (name base) ptr|15408
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; set name offset|15409
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||brn|6,rtn12|||; and merge|15410
# getarg rtn12
        jmp  rtn12
# |rtn11|mov|7,xl|13,nmbas(xr)||; load name base|15414
rtn11:
# getarg nmbas(,XR,8)
# getarg XL
        movq nmbas(,XR,8),XL
# ||mov|8,wa|13,nmofs(xr)||; load name offset|15415
# getarg nmofs(,XR,8)
# getarg WA
        movq nmofs(,XR,8),WA
# |rtn12|mov|7,xr|7,xl||; preserve xl|15419
rtn12:
# getarg XL
# getarg XR
        movq XL,XR
# ||lcw|8,wb|||; load next word|15420
# getarg WB
        lcw_ WB
# ||mov|7,xl|7,xr||; restore xl|15421
# getarg XR
# getarg XL
        movq XR,XL
# ||beq|8,wb|21,=ofne_|6,exnam|; exit if called by name|15422
# getarg WB
# getarg W0
# getarg exnam
        movq l_0153,W0
        cmpq WB,W0
        je   exnam
# ||mov|11,-(xs)|8,wb||; else save code word|15423
# getarg WB
        push WB
# ||jsr|6,acess|||; get value|15424
# getarg acess
        call acess
        decq rcode
        js   call_198
# ||ppm|6,exfal|||; fail if access fails|15425
# getarg exfal
# getarg exfal
        decq rcode
        jns  l_0574
        jmp  exfal
l_0574:
call_198:
# ||mov|7,xl|7,xr||; if ok, copy result|15426
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|9,(xs)||; reload next code word|15427
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|9,(xs)|7,xl||; store result on stack|15428
# getarg XL
# getarg (XT)
        movq XL,(XT)
# ||mov|7,xl|9,(xr)||; load routine address|15429
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to execute next code word|15430
# getarg XL
        jmp  *XL
# ||ejc|||||15431
# |stcov|rtn|||||15441
stcov:
# ||icv|3,errft|||; fatal error|15442
# getarg errft
        incq errft
# ||ldi|4,intvt|||; get 10|15443
# getarg intvt
        mov  intvt,IA
# ||adi|3,kvstl|||; add to former limit|15444
# getarg kvstl
        add  kvstl,IA
        seto reg_fl
# ||sti|3,kvstl|||; store as new stlimit|15445
# getarg kvstl
        mov  IA,kvstl
# ||ldi|4,intvt|||; get 10|15446
# getarg intvt
        mov  intvt,IA
# ||sti|3,kvstc|||; set as new count|15447
# getarg kvstc
        mov  IA,kvstc
# ||jsr|6,stgcc|||; recompute countdown counters|15448
# getarg stgcc
        call stgcc
# ||erb|1,244|26,statement count exceeds value of stlimit keyword|||15449
        movq $244,rcode
        jmp  err_
# ||ejc|||||15450
# |stmgo|rtn|||||15459
stmgo:
# ||mov|3,r_cod|7,xr||; set new code block pointer|15460
# getarg XR
# getarg r_cod
        movq XR,r_cod
# ||dcv|3,stmct|||; see if time to check something|15461
# getarg stmct
        decq stmct
# ||bze|3,stmct|6,stgo2||; jump if so|15462
# getarg stmct
# getarg stgo2
        xor  W0,W0
        cmpq stmct,W0
        jz   stgo2
# ||mov|3,kvlst|3,kvstn||; set lastno|15463
# getarg kvstn
# getarg W0
# getarg kvlst
        movq kvstn,W0
        movq W0,kvlst
# ||mov|3,kvstn|13,cdstm(xr)||; set stno|15464
# getarg cdstm(,XR,8)
# getarg W0
# getarg kvstn
        movq cdstm(,XR,8),W0
        movq W0,kvstn
# ||mov|3,kvlln|3,kvlin||; set lastline|15466
# getarg kvlin
# getarg W0
# getarg kvlln
        movq kvlin,W0
        movq W0,kvlln
# ||mov|3,kvlin|13,cdsln(xr)||; set line|15467
# getarg cdsln(,XR,8)
# getarg W0
# getarg kvlin
        movq cdsln(,XR,8),W0
        movq W0,kvlin
# ||add|7,xr|19,*cdcod||; point to first code word|15469
# getarg W0
# getarg XR
        movq l_0013,W0
        addq W0,XR
# ||lcp|7,xr|||; set code pointer|15470
# getarg XR
        lcp_ XR
# |stgo1|lcw|7,xr|||; load next code word|15474
stgo1:
# getarg XR
        lcw_ XR
# ||zer|7,xl|||; clear garbage xl|15475
# getarg XL
        xor  XL,XL
# ||bri|9,(xr)|||; execute it|15476
# getarg (XR)
        jmp  *(XR)
# |stgo2|bze|3,kvpfl|6,stgo3||; skip if no profiling|15480
stgo2:
# getarg kvpfl
# getarg stgo3
        xor  W0,W0
        cmpq kvpfl,W0
        jz   stgo3
# ||jsr|6,prflu|||; else profile the statement in kvstn|15481
# getarg prflu
        call prflu
# |stgo3|mov|3,kvlst|3,kvstn||; set lastno|15485
stgo3:
# getarg kvstn
# getarg W0
# getarg kvlst
        movq kvstn,W0
        movq W0,kvlst
# ||mov|3,kvstn|13,cdstm(xr)||; set stno|15486
# getarg cdstm(,XR,8)
# getarg W0
# getarg kvstn
        movq cdstm(,XR,8),W0
        movq W0,kvstn
# ||mov|3,kvlln|3,kvlin||; set lastline|15488
# getarg kvlin
# getarg W0
# getarg kvlln
        movq kvlin,W0
        movq W0,kvlln
# ||mov|3,kvlin|13,cdsln(xr)||; set line|15489
# getarg cdsln(,XR,8)
# getarg W0
# getarg kvlin
        movq cdsln(,XR,8),W0
        movq W0,kvlin
# ||add|7,xr|19,*cdcod||; point to first code word|15491
# getarg W0
# getarg XR
        movq l_0013,W0
        addq W0,XR
# ||lcp|7,xr|||; set code pointer|15492
# getarg XR
        lcp_ XR
# ||mov|11,-(xs)|3,stmcs||; save present count start on stack|15497
# getarg stmcs
        push stmcs
# ||dcv|3,polct|||; poll interval within stmct|15498
# getarg polct
        decq polct
# ||bnz|3,polct|6,stgo4||; jump if not poll time yet|15499
# getarg polct
# getarg stgo4
        xor  W0,W0
        cmpq polct,W0
        jnz  stgo4
# ||zer|8,wa|||; =0 for poll|15500
# getarg WA
        xor  WA,WA
# ||mov|8,wb|3,kvstn||; statement number|15501
# getarg kvstn
# getarg WB
        movq kvstn,WB
# ||mov|7,xl|7,xr||; make collectable|15502
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,syspl|||; allow interactive access|15503
# getarg syspl
        call syspl
        decq rcode
        js   call_199
# ||err|1,320|26,user interrupt|||15504
# getarg 320
        decq rcode
        jns  l_0575
        movq $320,rcode
        jmp  err_
l_0575:
# ||ppm||||; single step|15505
# getarg 
        decq rcode
        jns  l_0576
        movq $299,rcode
        jmp  err_
l_0576:
# ||ppm||||; expression evaluation|15506
# getarg 
        decq rcode
        jns  l_0577
        movq $299,rcode
        jmp  err_
l_0577:
call_199:
# ||mov|7,xr|7,xl||; restore code block pointer|15507
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|3,polcs|8,wa||; poll interval start value|15508
# getarg WA
# getarg polcs
        movq WA,polcs
# ||jsr|6,stgcc|||; recompute counter values|15509
# getarg stgcc
        call stgcc
# |stgo4|ldi|3,kvstc|||; get stmt count|15514
stgo4:
# getarg kvstc
        mov  kvstc,IA
# ||ilt|6,stgo5|||; omit counting if negative|15515
# getarg stgo5
        mov  IA,W0
        or   W0,W0
        jl   stgo5
# ||mti|10,(xs)+|||; reload start value of counter|15516
        pop  W0
        mov  W0,IA
# ||ngi||||; negate|15517
        neg  IA
        seto reg_fl
# ||adi|3,kvstc|||; stmt count minus counter|15518
# getarg kvstc
        add  kvstc,IA
        seto reg_fl
# ||sti|3,kvstc|||; replace it|15519
# getarg kvstc
        mov  IA,kvstc
# ||ile|6,stcov|||; fail if stlimit reached|15520
# getarg stcov
        mov  IA,W0
        or   W0,W0
        jle  stcov
# ||bze|3,r_stc|6,stgo5||; jump if no statement trace|15521
# getarg r_stc
# getarg stgo5
        xor  W0,W0
        cmpq r_stc,W0
        jz   stgo5
# ||zer|7,xr|||; clear garbage value in xr|15522
# getarg XR
        xor  XR,XR
# ||mov|7,xl|3,r_stc||; load pointer to stcount trblk|15523
# getarg r_stc
# getarg XL
        movq r_stc,XL
# ||jsr|6,ktrex|||; execute keyword trace|15524
# getarg ktrex
        call ktrex
# |stgo5|mov|3,stmct|3,stmcs||; reset counter|15528
stgo5:
# getarg stmcs
# getarg W0
# getarg stmct
        movq stmcs,W0
        movq W0,stmct
# ||brn|6,stgo1|||; fetch next code word|15529
# getarg stgo1
        jmp  stgo1
# ||ejc|||||15530
# |stopr|rtn|||||15540
stopr:
# ||bze|7,xr|6,stpra||; skip if sysax already called|15542
# getarg XR
# getarg stpra
        or   XR,XR
        jz   stpra
# ||jsr|6,sysax|||; call after execution proc|15543
# getarg sysax
        call sysax
# |stpra|add|3,dname|3,rsmem||; use the reserve memory|15544
stpra:
# getarg rsmem
# getarg W0
# getarg dname
        movq rsmem,W0
        addq W0,dname
# ||bne|7,xr|21,=endms|6,stpr0|; skip if not normal end message|15548
# getarg XR
# getarg W0
# getarg stpr0
        movq l_0221,W0
        cmpq XR,W0
        jne  stpr0
# ||bnz|3,exsts|6,stpr3||; skip if exec stats suppressed|15549
# getarg exsts
# getarg stpr3
        xor  W0,W0
        cmpq exsts,W0
        jnz  stpr3
# ||zer|3,erich|||; clear errors to int.ch. flag|15550
# getarg erich
        mov  $0,W0
        mov  W0,erich
# |stpr0|jsr|6,prtpg|||; eject printer|15554
stpr0:
# getarg prtpg
        call prtpg
# ||bze|7,xr|6,stpr1||; skip if no message|15555
# getarg XR
# getarg stpr1
        or   XR,XR
        jz   stpr1
# ||jsr|6,prtst|||; print message|15556
# getarg prtst
        call prtst
# |stpr1|jsr|6,prtis|||; print blank line|15560
stpr1:
# getarg prtis
        call prtis
# ||bnz|3,gbcfl|6,stpr5||; if in garbage collection, skip|15562
# getarg gbcfl
# getarg stpr5
        xor  W0,W0
        cmpq gbcfl,W0
        jnz  stpr5
# ||mov|7,xr|21,=stpm7||; point to message /in file xxx/|15563
# getarg W0
# getarg XR
        .data
l_0578: .long stpm7
        .text
        movq l_0578,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|15564
# getarg prtst
        call prtst
# ||mov|3,profs|18,=prtmf||; set column offset|15565
# getarg W0
# getarg profs
        .data
l_0579: .long prtmf
        .text
        movq l_0579,W0
        movq W0,profs
# ||mov|8,wc|3,kvstn||; get statement number|15566
# getarg kvstn
# getarg WC
        movq kvstn,WC
# ||jsr|6,filnm|||; get file name|15567
# getarg filnm
        call filnm
# ||mov|7,xr|7,xl||; prepare to print|15568
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,prtst|||; print file name|15569
# getarg prtst
        call prtst
# ||jsr|6,prtis|||; print to interactive channel|15570
# getarg prtis
        call prtis
# ||mov|7,xr|3,r_cod||; get code pointer|15577
# getarg r_cod
# getarg XR
        movq r_cod,XR
# ||mti|13,cdsln(xr)|||; get source line number|15578
# getarg cdsln(,XR,8)
        mov  cdsln(,XR,8),IA
# ||mov|7,xr|21,=stpm6||; point to message /in line xxx/|15579
# getarg W0
# getarg XR
        .data
l_0580: .long stpm6
        .text
        movq l_0580,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15580
# getarg prtmx
        call prtmx
# |stpr5|mti|3,kvstn|||; get statement number|15582
stpr5:
# getarg kvstn
        mov  kvstn,IA
# ||mov|7,xr|21,=stpm1||; point to message /in statement xxx/|15583
# getarg W0
# getarg XR
        .data
l_0581: .long stpm1
        .text
        movq l_0581,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15584
# getarg prtmx
        call prtmx
# ||jsr|6,systm|||; get current time|15585
# getarg systm
        call systm
# ||sbi|3,timsx|||; minus start time = elapsed exec tim|15586
# getarg timsx
        sub  timsx,IA
        xor  W0,W0
        seto reg_fl
# ||sti|3,stpti|||; save for later|15587
# getarg stpti
        mov  IA,stpti
# ||mov|7,xr|21,=stpm3||; point to msg /execution time msec /|15588
# getarg W0
# getarg XR
        .data
l_0582: .long stpm3
        .text
        movq l_0582,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15589
# getarg prtmx
        call prtmx
# ||ldi|3,kvstl|||; get statement limit|15590
# getarg kvstl
        mov  kvstl,IA
# ||ilt|6,stpr2|||; skip if negative|15591
# getarg stpr2
        mov  IA,W0
        or   W0,W0
        jl   stpr2
# ||sbi|3,kvstc|||; minus counter = course count|15592
# getarg kvstc
        sub  kvstc,IA
        xor  W0,W0
        seto reg_fl
# ||sti|3,stpsi|||; save|15593
# getarg stpsi
        mov  IA,stpsi
# ||mov|8,wa|3,stmcs||; refine with counter start value|15594
# getarg stmcs
# getarg WA
        movq stmcs,WA
# ||sub|8,wa|3,stmct||; minus current counter|15595
# getarg stmct
# getarg WA
        subq stmct,WA
# ||mti|8,wa|||; convert to integer|15596
# getarg WA
        mov  WA,IA
# ||adi|3,stpsi|||; add in course count|15597
# getarg stpsi
        add  stpsi,IA
        seto reg_fl
# ||sti|3,stpsi|||; save|15598
# getarg stpsi
        mov  IA,stpsi
# ||mov|7,xr|21,=stpm2||; point to message /stmts executed/|15599
# getarg W0
# getarg XR
        .data
l_0583: .long stpm2
        .text
        movq l_0583,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15600
# getarg prtmx
        call prtmx
# ||ldi|3,stpti|||; reload elapsed time|15603
# getarg stpti
        mov  stpti,IA
# ||mli|4,intth|||; *1000 (microsecs)|15604
# getarg intth
        imul intth,IA
        seto reg_fl
# ||iov|6,stpr2|||; jump if we cannot compute|15605
# getarg stpr2
        iov_ stpr2
# ||dvi|3,stpsi|||; divide by statement count|15606
# getarg stpsi
        mov  stpsi,W0
        call dvi__
# ||iov|6,stpr2|||; jump if overflow|15607
# getarg stpr2
        iov_ stpr2
# ||mov|7,xr|21,=stpm4||; point to msg (mcsec per statement /|15608
# getarg W0
# getarg XR
        .data
l_0584: .long stpm4
        .text
        movq l_0584,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15609
# getarg prtmx
        call prtmx
# ||ejc|||||15611
# |stpr2|mti|3,gbcnt|||; load count of collections|15617
stpr2:
# getarg gbcnt
        mov  gbcnt,IA
# ||mov|7,xr|21,=stpm5||; point to message /regenerations /|15618
# getarg W0
# getarg XR
        movq l_0070,W0
        movq W0,XR
# ||jsr|6,prtmx|||; print it|15619
# getarg prtmx
        call prtmx
# ||jsr|6,prtmm|||; print memory usage|15620
# getarg prtmm
        call prtmm
# ||jsr|6,prtis|||; one more blank for luck|15621
# getarg prtis
        call prtis
# |stpr3|jsr|6,prflr|||; print profile if wanted|15628
stpr3:
# getarg prflr
        call prflr
# ||mov|7,xr|3,kvdmp||; load dump keyword|15630
# getarg kvdmp
# getarg XR
        movq kvdmp,XR
# ||jsr|6,dumpr|||; execute dump if requested|15632
# getarg dumpr
        call dumpr
# ||mov|7,xl|3,r_fcb||; get fcblk chain head|15633
# getarg r_fcb
# getarg XL
        movq r_fcb,XL
# ||mov|8,wa|3,kvabe||; load abend value|15634
# getarg kvabe
# getarg WA
        movq kvabe,WA
# ||mov|8,wb|3,kvcod||; load code value|15635
# getarg kvcod
# getarg WB
        movq kvcod,WB
# ||jsr|6,sysej|||; exit to system|15636
# getarg sysej
        call sysej
# |stpr4|rtn|||||15641
stpr4:
# ||add|3,dname|3,rsmem||; use the reserve memory|15642
# getarg rsmem
# getarg W0
# getarg dname
        movq rsmem,W0
        addq W0,dname
# ||bze|3,exsts|6,stpr1||; if execution stats requested|15643
# getarg exsts
# getarg stpr1
        xor  W0,W0
        cmpq exsts,W0
        jz   stpr1
# ||brn|6,stpr3|||; check if dump or profile needed|15644
# getarg stpr3
        jmp  stpr3
# ||ejc|||||15647
# |succp|rtn|||||15660
succp:
# ||mov|7,xr|13,pthen(xr)||; load successor node|15661
# getarg pthen(,XR,8)
# getarg XR
        movq pthen(,XR,8),XR
# ||mov|7,xl|9,(xr)||; load node code entry address|15662
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; jump to match successor node|15663
# getarg XL
        jmp  *XL
# ||ejc|||||15664
# |sysab|rtn|||||15668
sysab:
# ||mov|7,xr|21,=endab||; point to message|15669
# getarg W0
# getarg XR
        .data
l_0585: .long endab
        .text
        movq l_0585,W0
        movq W0,XR
# ||mov|3,kvabe|18,=num01||; set abend flag|15670
# getarg W0
# getarg kvabe
        movq l_0060,W0
        movq W0,kvabe
# ||jsr|6,prtnl|||; skip to new line|15671
# getarg prtnl
        call prtnl
# ||brn|6,stopr|||; jump to pack up|15672
# getarg stopr
        jmp  stopr
# ||ejc|||||15673
# |systu|rtn|||||15677
systu:
# ||mov|7,xr|21,=endtu||; point to message|15678
# getarg W0
# getarg XR
        .data
l_0586: .long endtu
        .text
        movq l_0586,W0
        movq W0,XR
# ||mov|8,wa|4,strtu||; get chars /tu/|15679
# getarg strtu
# getarg WA
        movq strtu,WA
# ||mov|3,kvcod|8,wa||; put in kvcod|15680
# getarg WA
# getarg kvcod
        movq WA,kvcod
# ||mov|8,wa|3,timup||; check state of timeup switch|15681
# getarg timup
# getarg WA
        movq timup,WA
# ||mnz|3,timup|||; set switch|15682
# getarg timup
        mov  XS,timup
# ||bnz|8,wa|6,stopr||; stop run if already set|15683
# getarg WA
# getarg WA
# getarg stopr
        or   WA,WA
        jnz  stopr
# ||erb|1,245|26,translation/execution time expired|||15684
        movq $245,rcode
        jmp  err_
# ||ttl|27,s p i t b o l -- utility procedures||||15685
# ||ejc|||||15729
# |acess|prc|25,r|1,1||; entry point (recursive)|15749
acess:
# getarg 1
# ||mov|7,xr|7,xl||; copy name base|15750
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xr|8,wa||; point to variable location|15751
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|7,xr|9,(xr)||; load variable value|15752
# getarg (XR)
# getarg XR
        movq (XR),XR
# |acs02|bne|9,(xr)|22,=b_trt|6,acs18|; jump if not trapped|15756
acs02:
# getarg (XR)
# getarg W0
# getarg acs18
        movq l_0154,W0
        cmpq (XR),W0
        jne  acs18
# ||beq|7,xr|21,=trbkv|6,acs12|; jump if keyword variable|15760
# getarg XR
# getarg W0
# getarg acs12
        .data
l_0587: .long trbkv
        .text
        movq l_0587,W0
        cmpq XR,W0
        je   acs12
# ||bne|7,xr|21,=trbev|6,acs05|; jump if not expression variable|15761
# getarg XR
# getarg W0
# getarg acs05
        movq l_0119,W0
        cmpq XR,W0
        jne  acs05
# ||mov|7,xr|13,evexp(xl)||; load expression pointer|15765
# getarg evexp(,XL,8)
# getarg XR
        movq evexp(,XL,8),XR
# ||zer|8,wb|||; evaluate by value|15766
# getarg WB
        xor  WB,WB
# ||jsr|6,evalx|||; evaluate expression|15767
# getarg evalx
        call evalx
        decq rcode
        js   call_200
# ||ppm|6,acs04|||; jump if evaluation failure|15768
# getarg acs04
# getarg acs04
        decq rcode
        jns  l_0588
        jmp  acs04
l_0588:
call_200:
# ||brn|6,acs02|||; check value for more trblks|15769
# getarg acs02
        jmp  acs02
# ||ejc|||||15770
# |acs03|add|7,xs|19,*num03||; pop trblk ptr, name base and offset|15776
acs03:
# getarg W0
# getarg XT
        .data
l_0589: .long 8*num03
        .text
        movq l_0589,W0
        addq W0,XT
# ||mov|3,dnamp|7,xr||; pop unused scblk|15777
# getarg XR
# getarg dnamp
        movq XR,dnamp
# |acs04|exi|1,1|||; take alternate (failure) return|15781
acs04:
# getarg 1
        movq $1,rcode
        ret
# |acs05|mov|8,wb|13,trtyp(xr)||; load trap type code|15785
acs05:
# getarg trtyp(,XR,8)
# getarg WB
        movq trtyp(,XR,8),WB
# ||bnz|8,wb|6,acs10||; jump if not input association|15786
# getarg WB
# getarg WB
# getarg acs10
        or   WB,WB
        jnz  acs10
# ||bze|3,kvinp|6,acs09||; ignore input assoc if input is off|15787
# getarg kvinp
# getarg acs09
        xor  W0,W0
        cmpq kvinp,W0
        jz   acs09
# ||mov|11,-(xs)|7,xl||; stack name base|15791
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wa||; stack name offset|15792
# getarg WA
        push WA
# ||mov|11,-(xs)|7,xr||; stack trblk pointer|15793
# getarg XR
        push XR
# ||mov|3,actrm|3,kvtrm||; temp to hold trim keyword|15794
# getarg kvtrm
# getarg W0
# getarg actrm
        movq kvtrm,W0
        movq W0,actrm
# ||mov|7,xl|13,trfpt(xr)||; get file ctrl blk ptr or zero|15795
# getarg trfpt(,XR,8)
# getarg XL
        movq trfpt(,XR,8),XL
# ||bnz|7,xl|6,acs06||; jump if not standard input file|15796
# getarg XL
# getarg XL
# getarg acs06
        or   XL,XL
        jnz  acs06
# ||beq|13,trter(xr)|21,=v_ter|6,acs21|; jump if terminal|15797
# getarg trter(,XR,8)
# getarg W0
# getarg acs21
        .data
l_0590: .long v_ter
        .text
        movq l_0590,W0
        cmpq trter(,XR,8),W0
        je   acs21
# ||mov|8,wa|3,cswin||; length for read buffer|15801
# getarg cswin
# getarg WA
        movq cswin,WA
# ||jsr|6,alocs|||; build string of appropriate length|15802
# getarg alocs
        call alocs
# ||jsr|6,sysrd|||; read next standard input image|15803
# getarg sysrd
        call sysrd
        decq rcode
        js   call_201
# ||ppm|6,acs03|||; jump to fail exit if end of file|15804
# getarg acs03
# getarg acs03
        decq rcode
        jns  l_0591
        jmp  acs03
l_0591:
call_201:
# ||brn|6,acs07|||; else merge with other file case|15805
# getarg acs07
        jmp  acs07
# |acs06|mov|8,wa|7,xl||; fcblk ptr|15809
acs06:
# getarg XL
# getarg WA
        movq XL,WA
# ||jsr|6,sysil|||; get input record max length (to wa)|15810
# getarg sysil
        call sysil
# ||bnz|8,wc|6,acs6a||; jump if not binary file|15811
# getarg WC
# getarg WC
# getarg acs6a
        or   WC,WC
        jnz  acs6a
# ||mov|3,actrm|8,wc||; disable trim for binary file|15812
# getarg WC
# getarg actrm
        movq WC,actrm
# |acs6a|jsr|6,alocs|||; allocate string of correct size|15813
acs6a:
# getarg alocs
        call alocs
# ||mov|8,wa|7,xl||; fcblk ptr|15814
# getarg XL
# getarg WA
        movq XL,WA
# ||jsr|6,sysin|||; call system input routine|15815
# getarg sysin
        call sysin
        decq rcode
        js   call_202
# ||ppm|6,acs03|||; jump to fail exit if end of file|15816
# getarg acs03
# getarg acs03
        decq rcode
        jns  l_0592
        jmp  acs03
l_0592:
# ||ppm|6,acs22|||; error|15817
# getarg acs22
# getarg acs22
        decq rcode
        jns  l_0593
        jmp  acs22
l_0593:
# ||ppm|6,acs23|||; error|15818
# getarg acs23
# getarg acs23
        decq rcode
        jns  l_0594
        jmp  acs23
l_0594:
call_202:
# ||ejc|||||15819
# |acs07|mov|8,wb|3,actrm||; load trim indicator|15825
acs07:
# getarg actrm
# getarg WB
        movq actrm,WB
# ||jsr|6,trimr|||; trim record as required|15826
# getarg trimr
        call trimr
# ||mov|8,wb|7,xr||; copy result pointer|15827
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|9,(xs)||; reload pointer to trblk|15828
# getarg (XT)
# getarg XR
        movq (XT),XR
# |acs08|mov|7,xl|7,xr||; save pointer to this trblk|15832
acs08:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,trnxt(xr)||; load forward pointer|15833
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# ||beq|9,(xr)|22,=b_trt|6,acs08|; loop if this is another trblk|15834
# getarg (XR)
# getarg W0
# getarg acs08
        movq l_0154,W0
        cmpq (XR),W0
        je   acs08
# ||mov|13,trnxt(xl)|8,wb||; else store result at end of chain|15835
# getarg WB
# getarg trnxt(,XL,8)
        movq WB,trnxt(,XL,8)
# ||mov|7,xr|10,(xs)+||; restore initial trblk pointer|15836
# getarg XR
        pop  XR
# ||mov|8,wa|10,(xs)+||; restore name offset|15837
# getarg WA
        pop  WA
# ||mov|7,xl|10,(xs)+||; restore name base pointer|15838
# getarg XL
        pop  XL
# |acs09|mov|7,xr|13,trnxt(xr)||; load forward ptr to next value|15842
acs09:
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# ||brn|6,acs02|||; back to check if trapped|15843
# getarg acs02
        jmp  acs02
# |acs10|bne|8,wb|18,=trtac|6,acs09|; loop back if not access trace|15847
acs10:
# getarg WB
# getarg W0
# getarg acs09
        .data
l_0595: .long trtac
        .text
        movq l_0595,W0
        cmpq WB,W0
        jne  acs09
# ||bze|3,kvtra|6,acs09||; ignore access trace if trace off|15848
# getarg kvtra
# getarg acs09
        xor  W0,W0
        cmpq kvtra,W0
        jz   acs09
# ||dcv|3,kvtra|||; else decrement trace count|15849
# getarg kvtra
        decq kvtra
# ||bze|13,trfnc(xr)|6,acs11||; jump if print trace|15850
# getarg trfnc(,XR,8)
# getarg acs11
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   acs11
# ||ejc|||||15851
# ||jsr|6,trxeq|||; call routine to execute trace|15857
# getarg trxeq
        call trxeq
# ||brn|6,acs09|||; jump for next trblk|15858
# getarg acs09
        jmp  acs09
# |acs11|jsr|6,prtsn|||; print statement number|15862
acs11:
# getarg prtsn
        call prtsn
# ||jsr|6,prtnv|||; print name = value|15863
# getarg prtnv
        call prtnv
# ||brn|6,acs09|||; jump back for next trblk|15864
# getarg acs09
        jmp  acs09
# |acs12|mov|7,xr|13,kvnum(xl)||; load keyword number|15868
acs12:
# getarg kvnum(,XL,8)
# getarg XR
        movq kvnum(,XL,8),XR
# ||bge|7,xr|18,=k_v__|6,acs14|; jump if not one word value|15869
# getarg XR
# getarg W0
# getarg acs14
        .data
l_0596: .long k_v__
        .text
        movq l_0596,W0
        cmpq XR,W0
        jae  acs14
# ||mti|15,kvabe(xr)|||; else load value as integer|15870
# getarg (XR)
        mov  (XR),IA
# |acs13|jsr|6,icbld|||; build icblk|15874
acs13:
# getarg icbld
        call icbld
# ||brn|6,acs18|||; jump to exit|15875
# getarg acs18
        jmp  acs18
# |acs14|bge|7,xr|18,=k_s__|6,acs15|; jump if special case|15879
acs14:
# getarg XR
# getarg W0
# getarg acs15
        .data
l_0597: .long k_s__
        .text
        movq l_0597,W0
        cmpq XR,W0
        jae  acs15
# ||sub|7,xr|18,=k_v__||; else get offset|15880
# getarg W0
# getarg XR
        movq l_0596,W0
        subq W0,XR
# ||wtb|7,xr|||; convert to byte offset|15881
# getarg XR
        sal  XR,3
# ||add|7,xr|21,=ndabo||; point to pattern value|15882
# getarg W0
# getarg XR
        movq l_0183,W0
        addq W0,XR
# ||brn|6,acs18|||; jump to exit|15883
# getarg acs18
        jmp  acs18
# |acs15|mov|7,xl|3,kvrtn||; load rtntype in case|15887
acs15:
# getarg kvrtn
# getarg XL
        movq kvrtn,XL
# ||ldi|3,kvstl|||; load stlimit in case|15888
# getarg kvstl
        mov  kvstl,IA
# ||sub|7,xr|18,=k_s__||; get case number|15889
# getarg W0
# getarg XR
        movq l_0597,W0
        subq W0,XR
# ||bsw|7,xr|2,k__n_||; switch on keyword number|15890
# getarg XR
        jmp  *l_0598(,XR,8)
        .data
l_0598:
# ||iff|2,k__al|6,acs16||; jump if alphabet|15904
# getarg acs16
        .long acs16
# ||iff|2,k__rt|6,acs17||; rtntype|15904
# getarg acs17
        .long acs17
# ||iff|2,k__sc|6,acs19||; stcount|15904
# getarg acs19
        .long acs19
# ||iff|2,k__et|6,acs20||; errtext|15904
# getarg acs20
        .long acs20
# ||iff|2,k__fl|6,acs26||; file|15904
# getarg acs26
        .long acs26
# ||iff|2,k__lf|6,acs27||; lastfile|15904
# getarg acs27
        .long acs27
# ||iff|2,k__sl|6,acs13||; stlimit|15904
# getarg acs13
        .long acs13
# ||iff|2,k__lc|6,acs24||; lcase|15904
# getarg acs24
        .long acs24
# ||iff|2,k__uc|6,acs25||; ucase|15904
# getarg acs25
        .long acs25
# ||esw||||; end switch on keyword number|15904
        .text
# ||ejc|||||15905
# |acs24|mov|7,xr|21,=lcase||; load pointer to lcase string|15912
acs24:
# getarg W0
# getarg XR
        .data
l_0599: .long lcase
        .text
        movq l_0599,W0
        movq W0,XR
# ||brn|6,acs18|||; common return|15913
# getarg acs18
        jmp  acs18
# |acs25|mov|7,xr|21,=ucase||; load pointer to ucase string|15917
acs25:
# getarg W0
# getarg XR
        .data
l_0600: .long ucase
        .text
        movq l_0600,W0
        movq W0,XR
# ||brn|6,acs18|||; common return|15918
# getarg acs18
        jmp  acs18
# |acs26|mov|8,wc|3,kvstn||; load current stmt number|15924
acs26:
# getarg kvstn
# getarg WC
        movq kvstn,WC
# ||brn|6,acs28|||; merge to obtain file name|15925
# getarg acs28
        jmp  acs28
# |acs27|mov|8,wc|3,kvlst||; load last stmt number|15929
acs27:
# getarg kvlst
# getarg WC
        movq kvlst,WC
# |acs28|jsr|6,filnm|||; obtain file name for this stmt|15933
acs28:
# getarg filnm
        call filnm
# ||brn|6,acs17|||; merge to return string in xl|15934
# getarg acs17
        jmp  acs17
# |acs16|mov|7,xl|3,kvalp||; load pointer to alphabet string|15938
acs16:
# getarg kvalp
# getarg XL
        movq kvalp,XL
# |acs17|mov|7,xr|7,xl||; copy string ptr to proper reg|15942
acs17:
# getarg XL
# getarg XR
        movq XL,XR
# |acs18|exi||||; return to acess caller|15946
acs18:
# getarg 
        movq $0,rcode
        ret
# |acs19|ilt|6,acs29|||; if counting suppressed|15950
acs19:
# getarg acs29
        mov  IA,W0
        or   W0,W0
        jl   acs29
# ||mov|8,wa|3,stmcs||; refine with counter start value|15951
# getarg stmcs
# getarg WA
        movq stmcs,WA
# ||sub|8,wa|3,stmct||; minus current counter|15952
# getarg stmct
# getarg WA
        subq stmct,WA
# ||mti|8,wa|||; convert to integer|15953
# getarg WA
        mov  WA,IA
# ||adi|3,kvstl|||; add stlimit|15954
# getarg kvstl
        add  kvstl,IA
        seto reg_fl
# |acs29|sbi|3,kvstc|||; stcount = limit - left|15955
acs29:
# getarg kvstc
        sub  kvstc,IA
        xor  W0,W0
        seto reg_fl
# ||brn|6,acs13|||; merge back with integer result|15956
# getarg acs13
        jmp  acs13
# |acs20|mov|7,xr|3,r_etx||; get errtext string|15960
acs20:
# getarg r_etx
# getarg XR
        movq r_etx,XR
# ||brn|6,acs18|||; merge with result|15961
# getarg acs18
        jmp  acs18
# |acs21|mov|8,wa|18,=rilen||; buffer length|15965
acs21:
# getarg W0
# getarg WA
        .data
l_0601: .long rilen
        .text
        movq l_0601,W0
        movq W0,WA
# ||jsr|6,alocs|||; allocate buffer|15966
# getarg alocs
        call alocs
# ||jsr|6,sysri|||; read record|15967
# getarg sysri
        call sysri
        decq rcode
        js   call_203
# ||ppm|6,acs03|||; endfile|15968
# getarg acs03
# getarg acs03
        decq rcode
        jns  l_0602
        jmp  acs03
l_0602:
call_203:
# ||brn|6,acs07|||; merge with record read|15969
# getarg acs07
        jmp  acs07
# |acs22|mov|3,dnamp|7,xr||; pop unused scblk|15973
acs22:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||erb|1,202|26,input from file caused non-recoverable error|||15974
        movq $202,rcode
        jmp  err_
# |acs23|mov|3,dnamp|7,xr||; pop unused scblk|15976
acs23:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||erb|1,203|26,input file record has incorrect format|||15977
        movq $203,rcode
        jmp  err_
# ||enp||||; end procedure acess|15978
# ||ejc|||||15979
# |acomp|prc|25,n|1,5||; entry point|15995
acomp:
# getarg 5
        pop  prc_+8*0
# ||jsr|6,arith|||; load arithmetic operands|15996
# getarg arith
        call arith
        decq rcode
        js   call_204
# ||ppm|6,acmp7|||; jump if first arg non-numeric|15997
# getarg acmp7
# getarg acmp7
        decq rcode
        jns  l_0603
        jmp  acmp7
l_0603:
# ||ppm|6,acmp8|||; jump if second arg non-numeric|15998
# getarg acmp8
# getarg acmp8
        decq rcode
        jns  l_0604
        jmp  acmp8
l_0604:
# ||ppm|6,acmp4|||; jump if real arguments|16001
# getarg acmp4
# getarg acmp4
        decq rcode
        jns  l_0605
        jmp  acmp4
l_0605:
call_204:
# ||sbi|13,icval(xl)|||; subtract to compare|16006
# getarg icval(,XL,8)
        sub  icval(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,acmp3|||; jump if overflow|16007
# getarg acmp3
        iov_ acmp3
# ||ilt|6,acmp5|||; else jump if arg1 lt arg2|16008
# getarg acmp5
        mov  IA,W0
        or   W0,W0
        jl   acmp5
# ||ieq|6,acmp2|||; jump if arg1 eq arg2|16009
# getarg acmp2
        mov  IA,W0
        or   W0,W0
        je   acmp2
# |acmp1|exi|1,5|||; take gt exit|16013
acmp1:
# getarg 5
        movq $5,rcode
        mov  prc_+8*0,W0
        jmp  *W0
# |acmp2|exi|1,4|||; take eq exit|16017
acmp2:
# getarg 4
        movq $4,rcode
        mov  prc_+8*0,W0
        jmp  *W0
# ||ejc|||||16018
# |acmp3|ldi|13,icval(xl)|||; load second argument|16024
acmp3:
# getarg icval(,XL,8)
        mov  icval(,XL,8),IA
# ||ilt|6,acmp1|||; gt if negative|16025
# getarg acmp1
        mov  IA,W0
        or   W0,W0
        jl   acmp1
# ||brn|6,acmp5|||; else lt|16026
# getarg acmp5
        jmp  acmp5
# |acmp4|sbr|13,rcval(xl)|||; subtract to compare|16032
acmp4:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call sbr_
# ||rov|6,acmp6|||; jump if overflow|16033
# getarg acmp6
        rov_ acmp6
# ||rgt|6,acmp1|||; else jump if arg1 gt|16034
# getarg acmp1
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jg   acmp1
# ||req|6,acmp2|||; jump if arg1 eq arg2|16035
# getarg acmp2
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        je   acmp2
# |acmp5|exi|1,3|||; take lt exit|16040
acmp5:
# getarg 3
        movq $3,rcode
        mov  prc_+8*0,W0
        jmp  *W0
# |acmp6|ldr|13,rcval(xl)|||; reload arg2|16046
acmp6:
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call ldr_
# ||rlt|6,acmp1|||; gt if negative|16047
# getarg acmp1
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   acmp1
# ||brn|6,acmp5|||; else lt|16048
# getarg acmp5
        jmp  acmp5
# |acmp7|exi|1,1|||; take error exit|16053
acmp7:
# getarg 1
        movq $1,rcode
        mov  prc_+8*0,W0
        jmp  *W0
# |acmp8|exi|1,2|||; take error exit|16057
acmp8:
# getarg 2
        movq $2,rcode
        mov  prc_+8*0,W0
        jmp  *W0
# ||enp||||; end procedure acomp|16058
# ||ejc|||||16059
# |alloc|prc|25,e|1,0||; entry point|16071
alloc:
# getarg 0
# |aloc1|mov|7,xr|3,dnamp||; point to next available loc|16075
aloc1:
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||aov|8,wa|7,xr|6,aloc2|; point past allocated block|16076
# getarg WA
# getarg XR
# getarg aloc2
        add  WA,XR
        jc   aloc2
# ||bgt|7,xr|3,dname|6,aloc2|; jump if not enough room|16077
# getarg XR
# getarg dname
# getarg aloc2
        cmpq XR,dname
        ja   aloc2
# ||mov|3,dnamp|7,xr||; store new pointer|16078
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||sub|7,xr|8,wa||; point back to start of allocated bk|16079
# getarg WA
# getarg XR
        subq WA,XR
# ||exi||||; return to caller|16080
# getarg 
        ret
# |aloc2|mov|3,allsv|8,wb||; save wb|16084
aloc2:
# getarg WB
# getarg allsv
        movq WB,allsv
# |alc2a|zer|8,wb|||; set no upward move for gbcol|16085
alc2a:
# getarg WB
        xor  WB,WB
# ||jsr|6,gbcol|||; garbage collect|16086
# getarg gbcol
        call gbcol
# ||mov|8,wb|7,xr||; remember new sediment size|16088
# getarg XR
# getarg WB
        movq XR,WB
# |aloc3|mov|7,xr|3,dnamp||; point to first available loc|16093
aloc3:
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||aov|8,wa|7,xr|6,alc3a|; point past new block|16094
# getarg WA
# getarg XR
# getarg alc3a
        add  WA,XR
        jc   alc3a
# ||blo|7,xr|3,dname|6,aloc4|; jump if there is room now|16095
# getarg XR
# getarg dname
# getarg aloc4
        cmpq XR,dname
        jb   aloc4
# |alc3a|jsr|6,sysmm|||; try to get more memory|16099
alc3a:
# getarg sysmm
        call sysmm
# ||wtb|7,xr|||; convert to baus (sgd05)|16100
# getarg XR
        sal  XR,3
# ||add|3,dname|7,xr||; bump ptr by amount obtained|16101
# getarg XR
# getarg dname
        addq XR,dname
# ||bnz|7,xr|6,aloc3||; jump if got more core|16102
# getarg XR
# getarg XR
# getarg aloc3
        or   XR,XR
        jnz  aloc3
# ||bze|3,dnams|6,alc3b||; jump if there was no sediment|16104
# getarg dnams
# getarg alc3b
        xor  W0,W0
        cmpq dnams,W0
        jz   alc3b
# ||zer|3,dnams|||; try collecting the sediment|16105
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# ||brn|6,alc2a|||;|16106
# getarg alc2a
        jmp  alc2a
# |alc3b|add|3,dname|3,rsmem||; get the reserve memory|16110
alc3b:
# getarg rsmem
# getarg W0
# getarg dname
        movq rsmem,W0
        addq W0,dname
# ||zer|3,rsmem|||; only permissible once|16114
# getarg rsmem
        mov  $0,W0
        mov  W0,rsmem
# ||icv|3,errft|||; fatal error|16115
# getarg errft
        incq errft
# ||erb|1,204|26,memory overflow|||16116
        movq $204,rcode
        jmp  err_
# ||ejc|||||16117
# |aloc4|sti|3,allia|||; save ia|16121
aloc4:
# getarg allia
        mov  IA,allia
# ||mov|3,dnams|8,wb||; record new sediment size|16123
# getarg WB
# getarg dnams
        movq WB,dnams
# ||mov|8,wb|3,dname||; get dynamic end adrs|16125
# getarg dname
# getarg WB
        movq dname,WB
# ||sub|8,wb|3,dnamp||; compute free store|16126
# getarg dnamp
# getarg WB
        subq dnamp,WB
# ||btw|8,wb|||; convert bytes to words|16127
# getarg WB
        shr  WB,3
# ||mti|8,wb|||; put free store in ia|16128
# getarg WB
        mov  WB,IA
# ||mli|3,alfsf|||; multiply by free store factor|16129
# getarg alfsf
        imul alfsf,IA
        seto reg_fl
# ||iov|6,aloc5|||; jump if overflowed|16130
# getarg aloc5
        iov_ aloc5
# ||mov|8,wb|3,dname||; dynamic end adrs|16131
# getarg dname
# getarg WB
        movq dname,WB
# ||sub|8,wb|3,dnamb||; compute total amount of dynamic|16132
# getarg dnamb
# getarg WB
        subq dnamb,WB
# ||btw|8,wb|||; convert to words|16133
# getarg WB
        shr  WB,3
# ||mov|3,aldyn|8,wb||; store it|16134
# getarg WB
# getarg aldyn
        movq WB,aldyn
# ||sbi|3,aldyn|||; subtract from scaled up free store|16135
# getarg aldyn
        sub  aldyn,IA
        xor  W0,W0
        seto reg_fl
# ||igt|6,aloc5|||; jump if sufficient free store|16136
# getarg aloc5
        mov  IA,W0
        or   W0,W0
        jg   aloc5
# ||jsr|6,sysmm|||; try to get more store|16137
# getarg sysmm
        call sysmm
# ||wtb|7,xr|||; convert to baus (sgd05)|16138
# getarg XR
        sal  XR,3
# ||add|3,dname|7,xr||; adjust dynamic end adrs|16139
# getarg XR
# getarg dname
        addq XR,dname
# |aloc5|ldi|3,allia|||; recover ia|16143
aloc5:
# getarg allia
        mov  allia,IA
# ||mov|8,wb|3,allsv||; restore wb|16144
# getarg allsv
# getarg WB
        movq allsv,WB
# ||brn|6,aloc1|||; jump back to exit|16145
# getarg aloc1
        jmp  aloc1
# ||enp||||; end procedure alloc|16146
# ||ejc|||||16147
# |alocs|prc|25,e|1,0||; entry point|16207
alocs:
# getarg 0
# ||bgt|8,wa|3,kvmxl|6,alcs2|; jump if length exceeds maxlength|16208
# getarg WA
# getarg kvmxl
# getarg alcs2
        cmpq WA,kvmxl
        ja   alcs2
# ||mov|8,wc|8,wa||; else copy length|16209
# getarg WA
# getarg WC
        movq WA,WC
# ||ctb|8,wa|2,scsi_||; compute length of scblk in bytes|16210
# getarg WA
        add  ($cfp_b-1)+$cfp_b*scsi_,WA
        and  WA,-$8
# ||mov|7,xr|3,dnamp||; point to next available location|16211
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||aov|8,wa|7,xr|6,alcs0|; point past block|16212
# getarg WA
# getarg XR
# getarg alcs0
        add  WA,XR
        jc   alcs0
# ||blo|7,xr|3,dname|6,alcs1|; jump if there is room|16213
# getarg XR
# getarg dname
# getarg alcs1
        cmpq XR,dname
        jb   alcs1
# |alcs0|zer|7,xr|||; else clear garbage xr value|16217
alcs0:
# getarg XR
        xor  XR,XR
# ||jsr|6,alloc|||; and use standard allocator|16218
# getarg alloc
        call alloc
# ||add|7,xr|8,wa||; point past end of block to merge|16219
# getarg WA
# getarg XR
        addq WA,XR
# |alcs1|mov|3,dnamp|7,xr||; set updated storage pointer|16223
alcs1:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||zer|11,-(xr)|||; store zero chars in last word|16224
# getarg (XR)
        sub  $8,XR
        mov  $0,W0
        mov  W0,(XR)
# ||dca|8,wa|||; decrement length|16225
# getarg WA
        subq $8,WA
# ||sub|7,xr|8,wa||; point back to start of block|16226
# getarg WA
# getarg XR
        subq WA,XR
# ||mov|9,(xr)|22,=b_scl||; set type word|16227
# getarg W0
# getarg (XR)
        movq l_0094,W0
        movq W0,(XR)
# ||mov|13,sclen(xr)|8,wc||; store length in chars|16228
# getarg WC
# getarg sclen(,XR,8)
        movq WC,sclen(,XR,8)
# ||exi||||; return to alocs caller|16229
# getarg 
        ret
# |alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||16233
alcs2:
        movq $205,rcode
        jmp  err_
# ||enp||||; end procedure alocs|16234
# ||ejc|||||16235
# |alost|prc|25,e|1,0||; entry point|16248
alost:
# getarg 0
# |alst1|mov|7,xr|3,state||; point to current end of area|16252
alst1:
# getarg state
# getarg XR
        movq state,XR
# ||aov|8,wa|7,xr|6,alst2|; point beyond proposed block|16253
# getarg WA
# getarg XR
# getarg alst2
        add  WA,XR
        jc   alst2
# ||bge|7,xr|3,dnamb|6,alst2|; jump if overlap with dynamic area|16254
# getarg XR
# getarg dnamb
# getarg alst2
        cmpq XR,dnamb
        jae  alst2
# ||mov|3,state|7,xr||; else store new pointer|16255
# getarg XR
# getarg state
        movq XR,state
# ||sub|7,xr|8,wa||; point back to start of block|16256
# getarg WA
# getarg XR
        subq WA,XR
# ||exi||||; return to alost caller|16257
# getarg 
        ret
# |alst2|mov|3,alsta|8,wa||; save wa|16261
alst2:
# getarg WA
# getarg alsta
        movq WA,alsta
# ||bge|8,wa|19,*e_sts|6,alst3|; skip if requested chunk is large|16262
# getarg WA
# getarg W0
# getarg alst3
        movq l_0051,W0
        cmpq WA,W0
        jae  alst3
# ||mov|8,wa|19,*e_sts||; else set to get large enough chunk|16263
# getarg W0
# getarg WA
        movq l_0051,W0
        movq W0,WA
# |alst3|jsr|6,alloc|||; allocate block to ensure room|16267
alst3:
# getarg alloc
        call alloc
# ||mov|3,dnamp|7,xr||; and delete it|16268
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||mov|8,wb|8,wa||; copy move up amount|16269
# getarg WA
# getarg WB
        movq WA,WB
# ||jsr|6,gbcol|||; call gbcol to move dynamic area up|16270
# getarg gbcol
        call gbcol
# ||mov|3,dnams|7,xr||; remember new sediment size|16272
# getarg XR
# getarg dnams
        movq XR,dnams
# ||mov|8,wa|3,alsta||; restore wa|16274
# getarg alsta
# getarg WA
        movq alsta,WA
# ||brn|6,alst1|||; loop back to try again|16275
# getarg alst1
        jmp  alst1
# ||enp||||; end procedure alost|16276
# ||ejc|||||16277
# ||ejc|||||16351
# |arith|prc|25,n|1,3||; entry point|16360
arith:
# getarg 3
        pop  prc_+8*1
# ||mov|7,xl|10,(xs)+||; load right operand|16362
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; load left operand|16363
# getarg XR
        pop  XR
# ||mov|8,wa|9,(xl)||; get right operand type word|16364
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||beq|8,wa|22,=b_icl|6,arth1|; jump if integer|16365
# getarg WA
# getarg W0
# getarg arth1
        movq l_0087,W0
        cmpq WA,W0
        je   arth1
# ||beq|8,wa|22,=b_rcl|6,arth4|; jump if real|16368
# getarg WA
# getarg W0
# getarg arth4
        movq l_0101,W0
        cmpq WA,W0
        je   arth4
# ||mov|11,-(xs)|7,xr||; else replace left arg on stack|16370
# getarg XR
        push XR
# ||mov|7,xr|7,xl||; copy left arg pointer|16371
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,gtnum|||; convert to numeric|16372
# getarg gtnum
        call gtnum
        decq rcode
        js   call_205
# ||ppm|6,arth6|||; jump if unconvertible|16373
# getarg arth6
# getarg arth6
        decq rcode
        jns  l_0606
        jmp  arth6
l_0606:
call_205:
# ||mov|7,xl|7,xr||; else copy converted result|16374
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|9,(xl)||; get right operand type word|16375
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||mov|7,xr|10,(xs)+||; reload left argument|16376
# getarg XR
        pop  XR
# ||beq|8,wa|22,=b_rcl|6,arth4|; jump if right arg is real|16379
# getarg WA
# getarg W0
# getarg arth4
        movq l_0101,W0
        cmpq WA,W0
        je   arth4
# |arth1|bne|9,(xr)|22,=b_icl|6,arth3|; jump if left arg not integer|16384
arth1:
# getarg (XR)
# getarg W0
# getarg arth3
        movq l_0087,W0
        cmpq (XR),W0
        jne  arth3
# |arth2|ldi|13,icval(xr)|||; load left operand value|16388
arth2:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||exi||||; return to arith caller|16389
# getarg 
        movq $0,rcode
        mov  prc_+8*1,W0
        jmp  *W0
# |arth3|jsr|6,gtnum|||; convert left arg to numeric|16393
arth3:
# getarg gtnum
        call gtnum
        decq rcode
        js   call_206
# ||ppm|6,arth7|||; jump if not convertible|16394
# getarg arth7
# getarg arth7
        decq rcode
        jns  l_0607
        jmp  arth7
l_0607:
call_206:
# ||beq|8,wa|22,=b_icl|6,arth2|; jump back if integer-integer|16395
# getarg WA
# getarg W0
# getarg arth2
        movq l_0087,W0
        cmpq WA,W0
        je   arth2
# ||mov|11,-(xs)|7,xr||; put left arg back on stack|16401
# getarg XR
        push XR
# ||ldi|13,icval(xl)|||; load right argument value|16402
# getarg icval(,XL,8)
        mov  icval(,XL,8),IA
# ||itr||||; convert to real|16403
        call itr_
# ||jsr|6,rcbld|||; get real block for right arg, merge|16404
# getarg rcbld
        call rcbld
# ||mov|7,xl|7,xr||; copy right arg ptr|16405
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; load left argument|16406
# getarg XR
        pop  XR
# ||brn|6,arth5|||; merge for real-real case|16407
# getarg arth5
        jmp  arth5
# ||ejc|||||16408
# |arth4|beq|9,(xr)|22,=b_rcl|6,arth5|; jump if left arg real|16414
arth4:
# getarg (XR)
# getarg W0
# getarg arth5
        movq l_0101,W0
        cmpq (XR),W0
        je   arth5
# ||jsr|6,gtrea|||; else convert to real|16415
# getarg gtrea
        call gtrea
        decq rcode
        js   call_207
# ||ppm|6,arth7|||; error if unconvertible|16416
# getarg arth7
# getarg arth7
        decq rcode
        jns  l_0608
        jmp  arth7
l_0608:
call_207:
# |arth5|ldr|13,rcval(xr)|||; load left operand value|16420
arth5:
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||exi|1,3|||; take real-real exit|16421
# getarg 3
        movq $3,rcode
        mov  prc_+8*1,W0
        jmp  *W0
# |arth6|ica|7,xs|||; pop unwanted left arg|16426
arth6:
# getarg XT
        addq $8,XT
# ||exi|1,2|||; take appropriate error exit|16427
# getarg 2
        movq $2,rcode
        mov  prc_+8*1,W0
        jmp  *W0
# |arth7|exi|1,1|||; take appropriate error return|16431
arth7:
# getarg 1
        movq $1,rcode
        mov  prc_+8*1,W0
        jmp  *W0
# ||enp||||; end procedure arith|16432
# ||ejc|||||16433
# |asign|prc|25,r|1,1||; entry point (recursive)|16454
asign:
# getarg 1
# |asg01|add|7,xl|8,wa||; point to variable value|16458
asg01:
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|7,xr|9,(xl)||; load variable value|16459
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||beq|9,(xr)|22,=b_trt|6,asg02|; jump if trapped|16460
# getarg (XR)
# getarg W0
# getarg asg02
        movq l_0154,W0
        cmpq (XR),W0
        je   asg02
# ||mov|9,(xl)|8,wb||; else perform assignment|16461
# getarg WB
# getarg (XL)
        movq WB,(XL)
# ||zer|7,xl|||; clear garbage value in xl|16462
# getarg XL
        xor  XL,XL
# ||exi||||; and return to asign caller|16463
# getarg 
        movq $0,rcode
        ret
# |asg02|sub|7,xl|8,wa||; restore name base|16467
asg02:
# getarg WA
# getarg XL
        subq WA,XL
# ||beq|7,xr|21,=trbkv|6,asg14|; jump if keyword variable|16468
# getarg XR
# getarg W0
# getarg asg14
        movq l_0587,W0
        cmpq XR,W0
        je   asg14
# ||bne|7,xr|21,=trbev|6,asg04|; jump if not expression variable|16469
# getarg XR
# getarg W0
# getarg asg04
        movq l_0119,W0
        cmpq XR,W0
        jne  asg04
# ||mov|7,xr|13,evexp(xl)||; point to expression|16473
# getarg evexp(,XL,8)
# getarg XR
        movq evexp(,XL,8),XR
# ||mov|11,-(xs)|8,wb||; store value to assign on stack|16474
# getarg WB
        push WB
# ||mov|8,wb|18,=num01||; set for evaluation by name|16475
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||jsr|6,evalx|||; evaluate expression by name|16476
# getarg evalx
        call evalx
        decq rcode
        js   call_208
# ||ppm|6,asg03|||; jump if evaluation fails|16477
# getarg asg03
# getarg asg03
        decq rcode
        jns  l_0609
        jmp  asg03
l_0609:
call_208:
# ||mov|8,wb|10,(xs)+||; else reload value to assign|16478
# getarg WB
        pop  WB
# ||brn|6,asg01|||; loop back to perform assignment|16479
# getarg asg01
        jmp  asg01
# ||ejc|||||16480
# |asg03|ica|7,xs|||; remove stacked value entry|16486
asg03:
# getarg XT
        addq $8,XT
# ||exi|1,1|||; take failure exit|16487
# getarg 1
        movq $1,rcode
        ret
# |asg04|mov|11,-(xs)|7,xr||; save ptr to first trblk|16491
asg04:
# getarg XR
        push XR
# |asg05|mov|8,wc|7,xr||; save ptr to this trblk|16495
asg05:
# getarg XR
# getarg WC
        movq XR,WC
# ||mov|7,xr|13,trnxt(xr)||; point to next trblk|16496
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# ||beq|9,(xr)|22,=b_trt|6,asg05|; loop back if another trblk|16497
# getarg (XR)
# getarg W0
# getarg asg05
        movq l_0154,W0
        cmpq (XR),W0
        je   asg05
# ||mov|7,xr|8,wc||; else point back to last trblk|16498
# getarg WC
# getarg XR
        movq WC,XR
# ||mov|13,trval(xr)|8,wb||; store value at end of chain|16499
# getarg WB
# getarg trval(,XR,8)
        movq WB,trval(,XR,8)
# ||mov|7,xr|10,(xs)+||; restore ptr to first trblk|16500
# getarg XR
        pop  XR
# |asg06|mov|8,wb|13,trtyp(xr)||; load type code of trblk|16504
asg06:
# getarg trtyp(,XR,8)
# getarg WB
        movq trtyp(,XR,8),WB
# ||beq|8,wb|18,=trtvl|6,asg08|; jump if value trace|16505
# getarg WB
# getarg W0
# getarg asg08
        .data
l_0610: .long trtvl
        .text
        movq l_0610,W0
        cmpq WB,W0
        je   asg08
# ||beq|8,wb|18,=trtou|6,asg10|; jump if output association|16506
# getarg WB
# getarg W0
# getarg asg10
        movq l_0068,W0
        cmpq WB,W0
        je   asg10
# |asg07|mov|7,xr|13,trnxt(xr)||; point to next trblk on chain|16510
asg07:
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# ||beq|9,(xr)|22,=b_trt|6,asg06|; loop back if another trblk|16511
# getarg (XR)
# getarg W0
# getarg asg06
        movq l_0154,W0
        cmpq (XR),W0
        je   asg06
# ||exi||||; else end of chain, return to caller|16512
# getarg 
        movq $0,rcode
        ret
# |asg08|bze|3,kvtra|6,asg07||; ignore value trace if trace off|16516
asg08:
# getarg kvtra
# getarg asg07
        xor  W0,W0
        cmpq kvtra,W0
        jz   asg07
# ||dcv|3,kvtra|||; else decrement trace count|16517
# getarg kvtra
        decq kvtra
# ||bze|13,trfnc(xr)|6,asg09||; jump if print trace|16518
# getarg trfnc(,XR,8)
# getarg asg09
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   asg09
# ||jsr|6,trxeq|||; else execute function trace|16519
# getarg trxeq
        call trxeq
# ||brn|6,asg07|||; and loop back|16520
# getarg asg07
        jmp  asg07
# ||ejc|||||16521
# |asg09|jsr|6,prtsn|||; print statement number|16527
asg09:
# getarg prtsn
        call prtsn
# ||jsr|6,prtnv|||; print name = value|16528
# getarg prtnv
        call prtnv
# ||brn|6,asg07|||; loop back for next trblk|16529
# getarg asg07
        jmp  asg07
# |asg10|bze|3,kvoup|6,asg07||; ignore output assoc if output off|16533
asg10:
# getarg kvoup
# getarg asg07
        xor  W0,W0
        cmpq kvoup,W0
        jz   asg07
# |asg1b|mov|7,xl|7,xr||; copy trblk pointer|16534
asg1b:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,trnxt(xr)||; point to next trblk|16535
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# ||beq|9,(xr)|22,=b_trt|6,asg1b|; loop back if another trblk|16536
# getarg (XR)
# getarg W0
# getarg asg1b
        movq l_0154,W0
        cmpq (XR),W0
        je   asg1b
# ||mov|7,xr|7,xl||; else point back to last trblk|16537
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|11,-(xs)|13,trval(xr)||; stack value to output|16539
# getarg trval(,XR,8)
        push trval(,XR,8)
# ||jsr|6,gtstg|||; convert to string|16545
# getarg gtstg
        call gtstg
        decq rcode
        js   call_209
# ||ppm|6,asg12|||; get datatype name if unconvertible|16546
# getarg asg12
# getarg asg12
        decq rcode
        jns  l_0611
        jmp  asg12
l_0611:
call_209:
# |asg11|mov|8,wa|13,trfpt(xl)||; fcblk ptr|16550
asg11:
# getarg trfpt(,XL,8)
# getarg WA
        movq trfpt(,XL,8),WA
# ||bze|8,wa|6,asg13||; jump if standard output file|16551
# getarg WA
# getarg asg13
        or   WA,WA
        jz   asg13
# |asg1a|jsr|6,sysou|||; call system output routine|16555
asg1a:
# getarg sysou
        call sysou
        decq rcode
        js   call_210
# ||err|1,206|26,output caused file overflow|||16556
# getarg 206
        decq rcode
        jns  l_0612
        movq $206,rcode
        jmp  err_
l_0612:
# ||err|1,207|26,output caused non-recoverable error|||16557
# getarg 207
        decq rcode
        jns  l_0613
        movq $207,rcode
        jmp  err_
l_0613:
call_210:
# ||exi||||; else all done, return to caller|16558
# getarg 
        movq $0,rcode
        ret
# |asg12|jsr|6,dtype|||; call datatype routine|16562
asg12:
# getarg dtype
        call dtype
# ||brn|6,asg11|||; merge|16563
# getarg asg11
        jmp  asg11
# |asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|; jump if terminal output|16568
asg13:
# getarg trter(,XL,8)
# getarg W0
# getarg asg1a
        movq l_0590,W0
        cmpq trter(,XL,8),W0
        je   asg1a
# ||icv|8,wa|||; signal standard output|16569
# getarg WA
        incq WA
# ||brn|6,asg1a|||; use sysou to perform output|16570
# getarg asg1a
        jmp  asg1a
# ||ejc|||||16585
# |asg14|mov|7,xl|13,kvnum(xl)||; load keyword number|16591
asg14:
# getarg kvnum(,XL,8)
# getarg XL
        movq kvnum(,XL,8),XL
# ||beq|7,xl|18,=k_etx|6,asg19|; jump if errtext|16592
# getarg XL
# getarg W0
# getarg asg19
        .data
l_0614: .long k_etx
        .text
        movq l_0614,W0
        cmpq XL,W0
        je   asg19
# ||mov|7,xr|8,wb||; copy value to be assigned|16593
# getarg WB
# getarg XR
        movq WB,XR
# ||jsr|6,gtint|||; convert to integer|16594
# getarg gtint
        call gtint
        decq rcode
        js   call_211
# ||err|1,208|26,keyword value assigned is not integer|||16595
# getarg 208
        decq rcode
        jns  l_0615
        movq $208,rcode
        jmp  err_
l_0615:
call_211:
# ||ldi|13,icval(xr)|||; else load value|16596
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||beq|7,xl|18,=k_stl|6,asg16|; jump if special case of stlimit|16597
# getarg XL
# getarg W0
# getarg asg16
        .data
l_0616: .long k_stl
        .text
        movq l_0616,W0
        cmpq XL,W0
        je   asg16
# ||mfi|8,wa|6,asg18||; else get addr integer, test ovflow|16598
# getarg asg18
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   asg18
        mov  IA,WA
# ||bgt|8,wa|3,mxlen|6,asg18|; fail if too large|16599
# getarg WA
# getarg mxlen
# getarg asg18
        cmpq WA,mxlen
        ja   asg18
# ||beq|7,xl|18,=k_ert|6,asg17|; jump if special case of errtype|16600
# getarg XL
# getarg W0
# getarg asg17
        .data
l_0617: .long k_ert
        .text
        movq l_0617,W0
        cmpq XL,W0
        je   asg17
# ||beq|7,xl|18,=k_pfl|6,asg21|; jump if special case of profile|16603
# getarg XL
# getarg W0
# getarg asg21
        .data
l_0618: .long k_pfl
        .text
        movq l_0618,W0
        cmpq XL,W0
        je   asg21
# ||beq|7,xl|18,=k_mxl|6,asg24|; jump if special case of maxlngth|16605
# getarg XL
# getarg W0
# getarg asg24
        .data
l_0619: .long k_mxl
        .text
        movq l_0619,W0
        cmpq XL,W0
        je   asg24
# ||beq|7,xl|18,=k_fls|6,asg26|; jump if special case of fullscan|16606
# getarg XL
# getarg W0
# getarg asg26
        .data
l_0620: .long k_fls
        .text
        movq l_0620,W0
        cmpq XL,W0
        je   asg26
# ||blt|7,xl|18,=k_p__|6,asg15|; jump unless protected|16607
# getarg XL
# getarg W0
# getarg asg15
        .data
l_0621: .long k_p__
        .text
        movq l_0621,W0
        cmpq XL,W0
        jb   asg15
# ||erb|1,209|26,keyword in assignment is protected|||16608
        movq $209,rcode
        jmp  err_
# |asg15|mov|15,kvabe(xl)|8,wa||; store new value|16612
asg15:
# getarg WA
# getarg (XL)
        movq WA,(XL)
# ||exi||||; return to asign caller|16613
# getarg 
        movq $0,rcode
        ret
# |asg16|sbi|3,kvstl|||; subtract old limit|16620
asg16:
# getarg kvstl
        sub  kvstl,IA
        xor  W0,W0
        seto reg_fl
# ||adi|3,kvstc|||; add old counter|16621
# getarg kvstc
        add  kvstc,IA
        seto reg_fl
# ||sti|3,kvstc|||; store course counter value|16622
# getarg kvstc
        mov  IA,kvstc
# ||ldi|3,kvstl|||; check if counting suppressed|16623
# getarg kvstl
        mov  kvstl,IA
# ||ilt|6,asg25|||; do not refine if so|16624
# getarg asg25
        mov  IA,W0
        or   W0,W0
        jl   asg25
# ||mov|8,wa|3,stmcs||; refine with counter breakout|16625
# getarg stmcs
# getarg WA
        movq stmcs,WA
# ||sub|8,wa|3,stmct||; values|16626
# getarg stmct
# getarg WA
        subq stmct,WA
# ||mti|8,wa|||; convert to integer|16627
# getarg WA
        mov  WA,IA
# ||ngi||||; current-start value|16628
        neg  IA
        seto reg_fl
# ||adi|3,kvstc|||; add in course counter value|16629
# getarg kvstc
        add  kvstc,IA
        seto reg_fl
# ||sti|3,kvstc|||; save refined value|16630
# getarg kvstc
        mov  IA,kvstc
# |asg25|ldi|13,icval(xr)|||; reload new limit value|16631
asg25:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sti|3,kvstl|||; store new limit value|16632
# getarg kvstl
        mov  IA,kvstl
# ||jsr|6,stgcc|||; recompute countdown counters|16633
# getarg stgcc
        call stgcc
# ||exi||||; return to asign caller|16634
# getarg 
        movq $0,rcode
        ret
# |asg17|ble|8,wa|18,=nini9|6,error|; ok to signal if in range|16638
asg17:
# getarg WA
# getarg W0
# getarg error
        movq l_0076,W0
        cmpq WA,W0
        jbe  error
# |asg18|erb|1,210|26,keyword value assigned is negative or too large|||16642
asg18:
        movq $210,rcode
        jmp  err_
# |asg19|mov|11,-(xs)|8,wb||; stack value|16646
asg19:
# getarg WB
        push WB
# ||jsr|6,gtstg|||; convert to string|16647
# getarg gtstg
        call gtstg
        decq rcode
        js   call_212
# ||err|1,211|26,value assigned to keyword errtext not a string|||16648
# getarg 211
        decq rcode
        jns  l_0622
        movq $211,rcode
        jmp  err_
l_0622:
call_212:
# ||mov|3,r_etx|7,xr||; make assignment|16649
# getarg XR
# getarg r_etx
        movq XR,r_etx
# ||exi||||; return to caller|16650
# getarg 
        movq $0,rcode
        ret
# |asg21|bgt|8,wa|18,=num02|6,asg18|; moan if not 0,1, or 2|16664
asg21:
# getarg WA
# getarg W0
# getarg asg18
        movq l_0130,W0
        cmpq WA,W0
        ja   asg18
# ||bze|8,wa|6,asg15||; just assign if zero|16665
# getarg WA
# getarg asg15
        or   WA,WA
        jz   asg15
# ||bze|3,pfdmp|6,asg22||; branch if first assignment|16666
# getarg pfdmp
# getarg asg22
        xor  W0,W0
        cmpq pfdmp,W0
        jz   asg22
# ||beq|8,wa|3,pfdmp|6,asg23|; also if same value as before|16667
# getarg WA
# getarg pfdmp
# getarg asg23
        cmpq WA,pfdmp
        je   asg23
# ||erb|1,268|26,inconsistent value assigned to keyword profile|||16668
        movq $268,rcode
        jmp  err_
# |asg22|mov|3,pfdmp|8,wa||; note value on first assignment|16670
asg22:
# getarg WA
# getarg pfdmp
        movq WA,pfdmp
# |asg23|mov|3,kvpfl|8,wa||; store new value|16671
asg23:
# getarg WA
# getarg kvpfl
        movq WA,kvpfl
# ||jsr|6,stgcc|||; recompute countdown counts|16672
# getarg stgcc
        call stgcc
# ||jsr|6,systm|||; get the time|16673
# getarg systm
        call systm
# ||sti|3,pfstm|||; fudge some kind of start time|16674
# getarg pfstm
        mov  IA,pfstm
# ||exi||||; return to asign caller|16675
# getarg 
        movq $0,rcode
        ret
# |asg24|bge|8,wa|18,=mnlen|6,asg15|; if acceptable value|16680
asg24:
# getarg WA
# getarg W0
# getarg asg15
        .data
l_0623: .long mnlen
        .text
        movq l_0623,W0
        cmpq WA,W0
        jae  asg15
# ||erb|1,287|26,value assigned to keyword maxlngth is too small|||16681
        movq $287,rcode
        jmp  err_
# |asg26|bnz|8,wa|6,asg15||; if acceptable value|16685
asg26:
# getarg WA
# getarg WA
# getarg asg15
        or   WA,WA
        jnz  asg15
# ||erb|1,274|26,value assigned to keyword fullscan is zero|||16686
        movq $274,rcode
        jmp  err_
# ||enp||||; end procedure asign|16688
# ||ejc|||||16689
# |asinp|prc|25,r|1,1||; entry point, recursive|16705
asinp:
# getarg 1
# ||add|7,xl|8,wa||; point to variable|16706
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|7,xr|9,(xl)||; load current contents|16707
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||beq|9,(xr)|22,=b_trt|6,asnp1|; jump if trapped|16708
# getarg (XR)
# getarg W0
# getarg asnp1
        movq l_0154,W0
        cmpq (XR),W0
        je   asnp1
# ||mov|9,(xl)|8,wb||; else perform assignment|16709
# getarg WB
# getarg (XL)
        movq WB,(XL)
# ||zer|7,xl|||; clear garbage value in xl|16710
# getarg XL
        xor  XL,XL
# ||exi||||; return to asinp caller|16711
# getarg 
        movq $0,rcode
        ret
# |asnp1|sub|7,xl|8,wa||; restore base pointer|16715
asnp1:
# getarg WA
# getarg XL
        subq WA,XL
# ||mov|11,-(xs)|3,pmssl||; stack subject string length|16716
# getarg pmssl
        push pmssl
# ||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|16717
# getarg pmhbs
        push pmhbs
# ||mov|11,-(xs)|3,r_pms||; stack subject string pointer|16718
# getarg r_pms
        push r_pms
# ||mov|11,-(xs)|3,pmdfl||; stack dot flag|16719
# getarg pmdfl
        push pmdfl
# ||jsr|6,asign|||; call full-blown assignment routine|16720
# getarg asign
        call asign
        decq rcode
        js   call_213
# ||ppm|6,asnp2|||; jump if failure|16721
# getarg asnp2
# getarg asnp2
        decq rcode
        jns  l_0624
        jmp  asnp2
l_0624:
call_213:
# ||mov|3,pmdfl|10,(xs)+||; restore dot flag|16722
# getarg pmdfl
        pop  pmdfl
# ||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16723
# getarg r_pms
        pop  r_pms
# ||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16724
# getarg pmhbs
        pop  pmhbs
# ||mov|3,pmssl|10,(xs)+||; restore subject string length|16725
# getarg pmssl
        pop  pmssl
# ||exi||||; return to asinp caller|16726
# getarg 
        movq $0,rcode
        ret
# |asnp2|mov|3,pmdfl|10,(xs)+||; restore dot flag|16730
asnp2:
# getarg pmdfl
        pop  pmdfl
# ||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16731
# getarg r_pms
        pop  r_pms
# ||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16732
# getarg pmhbs
        pop  pmhbs
# ||mov|3,pmssl|10,(xs)+||; restore subject string length|16733
# getarg pmssl
        pop  pmssl
# ||exi|1,1|||; take failure exit|16734
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure asinp|16735
# ||ejc|||||16736
# |blkln|prc|25,e|1,0||; entry point|16754
blkln:
# getarg 0
# ||mov|7,xl|8,wa||; copy first word|16755
# getarg WA
# getarg XL
        movq WA,XL
# ||lei|7,xl|||; get entry id (bl_xx)|16756
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||bsw|7,xl|2,bl___|6,bln00|; switch on block type|16757
# getarg XL
# getarg bl___
# getarg bln00
        cmpq XL,bl___
        jge  bln00
        jmp  *l_0625(,XL,8)
        .data
l_0625:
# ||iff|2,bl_ar|6,bln01||; arblk|16797
# getarg bln01
        .long bln01
# ||iff|2,bl_cd|6,bln12||; cdblk|16797
# getarg bln12
        .long bln12
# ||iff|2,bl_ex|6,bln12||; exblk|16797
# getarg bln12
        .long bln12
# ||iff|2,bl_ic|6,bln07||; icblk|16797
# getarg bln07
        .long bln07
# ||iff|2,bl_nm|6,bln03||; nmblk|16797
# getarg bln03
        .long bln03
# ||iff|2,bl_p0|6,bln02||; p0blk|16797
# getarg bln02
        .long bln02
# ||iff|2,bl_p1|6,bln03||; p1blk|16797
# getarg bln03
        .long bln03
# ||iff|2,bl_p2|6,bln04||; p2blk|16797
# getarg bln04
        .long bln04
# ||iff|2,bl_rc|6,bln09||; rcblk|16797
# getarg bln09
        .long bln09
# ||iff|2,bl_sc|6,bln10||; scblk|16797
# getarg bln10
        .long bln10
# ||iff|2,bl_se|6,bln02||; seblk|16797
# getarg bln02
        .long bln02
# ||iff|2,bl_tb|6,bln01||; tbblk|16797
# getarg bln01
        .long bln01
# ||iff|2,bl_vc|6,bln01||; vcblk|16797
# getarg bln01
        .long bln01
# ||iff|1,13|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|1,14|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|1,15|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|2,bl_pd|6,bln08||; pdblk|16797
# getarg bln08
        .long bln08
# ||iff|2,bl_tr|6,bln05||; trblk|16797
# getarg bln05
        .long bln05
# ||iff|1,18|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|1,19|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|1,20|6,bln00|||16797
# getarg bln00
        .long bln00
# ||iff|2,bl_ct|6,bln06||; ctblk|16797
# getarg bln06
        .long bln06
# ||iff|2,bl_df|6,bln01||; dfblk|16797
# getarg bln01
        .long bln01
# ||iff|2,bl_ef|6,bln01||; efblk|16797
# getarg bln01
        .long bln01
# ||iff|2,bl_ev|6,bln03||; evblk|16797
# getarg bln03
        .long bln03
# ||iff|2,bl_ff|6,bln05||; ffblk|16797
# getarg bln05
        .long bln05
# ||iff|2,bl_kv|6,bln03||; kvblk|16797
# getarg bln03
        .long bln03
# ||iff|2,bl_pf|6,bln01||; pfblk|16797
# getarg bln01
        .long bln01
# ||iff|2,bl_te|6,bln04||; teblk|16797
# getarg bln04
        .long bln04
# ||esw||||; end of jump table on block type|16797
        .text
# ||ejc|||||16798
# |bln00|mov|8,wa|13,num01(xr)||; load length|16804
bln00:
# getarg num01(,XR,8)
# getarg WA
        movq num01(,XR,8),WA
# ||exi||||; return to blkln caller|16805
# getarg 
        ret
# |bln01|mov|8,wa|13,num02(xr)||; load length from third word|16809
bln01:
# getarg num02(,XR,8)
# getarg WA
        movq num02(,XR,8),WA
# ||exi||||; return to blkln caller|16810
# getarg 
        ret
# |bln02|mov|8,wa|19,*num02||; load length (two words)|16814
bln02:
# getarg W0
# getarg WA
        movq l_0135,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16815
# getarg 
        ret
# |bln03|mov|8,wa|19,*num03||; load length (three words)|16819
bln03:
# getarg W0
# getarg WA
        movq l_0589,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16820
# getarg 
        ret
# |bln04|mov|8,wa|19,*num04||; load length (four words)|16824
bln04:
# getarg W0
# getarg WA
        movq l_0167,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16825
# getarg 
        ret
# |bln05|mov|8,wa|19,*num05||; load length|16829
bln05:
# getarg W0
# getarg WA
        .data
l_0626: .long 8*num05
        .text
        movq l_0626,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16830
# getarg 
        ret
# ||ejc|||||16831
# |bln06|mov|8,wa|19,*ctsi_||; set size of ctblk|16837
bln06:
# getarg W0
# getarg WA
        .data
l_0627: .long 8*ctsi_
        .text
        movq l_0627,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16838
# getarg 
        ret
# |bln07|mov|8,wa|19,*icsi_||; set size of icblk|16842
bln07:
# getarg W0
# getarg WA
        .data
l_0628: .long 8*icsi_
        .text
        movq l_0628,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16843
# getarg 
        ret
# |bln08|mov|7,xl|13,pddfp(xr)||; point to dfblk|16847
bln08:
# getarg pddfp(,XR,8)
# getarg XL
        movq pddfp(,XR,8),XL
# ||mov|8,wa|13,dfpdl(xl)||; load pdblk length from dfblk|16848
# getarg dfpdl(,XL,8)
# getarg WA
        movq dfpdl(,XL,8),WA
# ||exi||||; return to blkln caller|16849
# getarg 
        ret
# |bln09|mov|8,wa|19,*rcsi_||; set size of rcblk|16855
bln09:
# getarg W0
# getarg WA
        .data
l_0629: .long 8*rcsi_
        .text
        movq l_0629,W0
        movq W0,WA
# ||exi||||; return to blkln caller|16856
# getarg 
        ret
# |bln10|mov|8,wa|13,sclen(xr)||; load length in characters|16861
bln10:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||ctb|8,wa|2,scsi_||; calculate length in bytes|16862
# getarg WA
        add  ($cfp_b-1)+$cfp_b*scsi_,WA
        and  WA,-$8
# ||exi||||; return to blkln caller|16863
# getarg 
        ret
# |bln12|mov|8,wa|13,num03(xr)||; load length from cdlen/exlen|16877
bln12:
# getarg num03(,XR,8)
# getarg WA
        movq num03(,XR,8),WA
# ||exi||||; return to blkln caller|16878
# getarg 
        ret
# ||enp||||; end procedure blkln|16880
# ||ejc|||||16881
# |copyb|prc|25,n|1,1||; entry point|16893
copyb:
# getarg 1
        pop  prc_+8*2
# ||mov|7,xr|9,(xs)||; load argument|16894
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||beq|7,xr|21,=nulls|6,cop10|; return argument if it is null|16895
# getarg XR
# getarg W0
# getarg cop10
        movq l_0054,W0
        cmpq XR,W0
        je   cop10
# ||mov|8,wa|9,(xr)||; else load type word|16896
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||mov|8,wb|8,wa||; copy type word|16897
# getarg WA
# getarg WB
        movq WA,WB
# ||jsr|6,blkln|||; get length of argument block|16898
# getarg blkln
        call blkln
# ||mov|7,xl|7,xr||; copy pointer|16899
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,alloc|||; allocate block of same size|16900
# getarg alloc
        call alloc
# ||mov|9,(xs)|7,xr||; store pointer to copy|16901
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mvw||||; copy contents of old block to new|16902
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0630:
        or   WA,WA
        jz   l_0631
        movsq
        decq WA
        jmp  l_0630
l_0631:
        cld
# ||zer|7,xl|||; clear garbage xl|16903
# getarg XL
        xor  XL,XL
# ||mov|7,xr|9,(xs)||; reload pointer to start of copy|16904
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||beq|8,wb|22,=b_tbt|6,cop05|; jump if table|16905
# getarg WB
# getarg W0
# getarg cop05
        movq l_0086,W0
        cmpq WB,W0
        je   cop05
# ||beq|8,wb|22,=b_vct|6,cop01|; jump if vector|16906
# getarg WB
# getarg W0
# getarg cop01
        movq l_0085,W0
        cmpq WB,W0
        je   cop01
# ||beq|8,wb|22,=b_pdt|6,cop01|; jump if program defined|16907
# getarg WB
# getarg W0
# getarg cop01
        movq l_0139,W0
        cmpq WB,W0
        je   cop01
# ||bne|8,wb|22,=b_art|6,cop10|; return copy if not array|16912
# getarg WB
# getarg W0
# getarg cop10
        movq l_0247,W0
        cmpq WB,W0
        jne  cop10
# ||add|7,xr|13,arofs(xr)||; point to prototype field|16916
# getarg arofs(,XR,8)
# getarg XR
        addq arofs(,XR,8),XR
# ||brn|6,cop02|||; jump to merge|16917
# getarg cop02
        jmp  cop02
# |cop01|add|7,xr|19,*pdfld||; point to pdfld = vcvls|16921
cop01:
# getarg W0
# getarg XR
        movq l_0019,W0
        addq W0,XR
# |cop02|mov|7,xl|9,(xr)||; load next pointer|16926
cop02:
# getarg (XR)
# getarg XL
        movq (XR),XL
# |cop03|bne|9,(xl)|22,=b_trt|6,cop04|; jump if not trapped|16930
cop03:
# getarg (XL)
# getarg W0
# getarg cop04
        movq l_0154,W0
        cmpq (XL),W0
        jne  cop04
# ||mov|7,xl|13,trval(xl)||; else point to next value|16931
# getarg trval(,XL,8)
# getarg XL
        movq trval(,XL,8),XL
# ||brn|6,cop03|||; and loop back|16932
# getarg cop03
        jmp  cop03
# ||ejc|||||16933
# |cop04|mov|10,(xr)+|7,xl||; store real value, bump pointer|16939
cop04:
# getarg XL
        movq XL,W0
        stosq
# ||bne|7,xr|3,dnamp|6,cop02|; loop back if more to go|16940
# getarg XR
# getarg dnamp
# getarg cop02
        cmpq XR,dnamp
        jne  cop02
# ||brn|6,cop09|||; else jump to exit|16941
# getarg cop09
        jmp  cop09
# |cop05|zer|13,idval(xr)|||; zero id to stop dump blowing up|16945
cop05:
# getarg idval(,XR,8)
        mov  $0,W0
        mov  W0,idval(,XR,8)
# ||mov|8,wa|19,*tesi_||; set size of teblk|16946
# getarg W0
# getarg WA
        movq l_0029,W0
        movq W0,WA
# ||mov|8,wc|19,*tbbuk||; set initial offset|16947
# getarg W0
# getarg WC
        .data
l_0632: .long 8*tbbuk
        .text
        movq l_0632,W0
        movq W0,WC
# |cop06|mov|7,xr|9,(xs)||; load table pointer|16951
cop06:
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||beq|8,wc|13,tblen(xr)|6,cop09|; jump to exit if all done|16952
# getarg WC
# getarg tblen(,XR,8)
# getarg cop09
        cmpq WC,tblen(,XR,8)
        je   cop09
# ||mov|8,wb|8,wc||; else copy offset|16953
# getarg WC
# getarg WB
        movq WC,WB
# ||sub|8,wb|19,*tenxt||; subtract link offset to merge|16954
# getarg W0
# getarg WB
        .data
l_0633: .long 8*tenxt
        .text
        movq l_0633,W0
        subq W0,WB
# ||add|7,xr|8,wb||; next bucket header less link offset|16955
# getarg WB
# getarg XR
        addq WB,XR
# ||ica|8,wc|||; bump offset|16956
# getarg WC
        addq $8,WC
# |cop07|mov|7,xl|13,tenxt(xr)||; load pointer to next teblk|16960
cop07:
# getarg tenxt(,XR,8)
# getarg XL
        movq tenxt(,XR,8),XL
# ||mov|13,tenxt(xr)|9,(xs)||; set end of chain pointer in case|16961
# getarg (XT)
# getarg W0
# getarg tenxt(,XR,8)
        movq (XT),W0
        movq W0,tenxt(,XR,8)
# ||beq|9,(xl)|22,=b_tbt|6,cop06|; back for next bucket if chain end|16962
# getarg (XL)
# getarg W0
# getarg cop06
        movq l_0086,W0
        cmpq (XL),W0
        je   cop06
# ||sub|7,xr|8,wb||; point to head of previous block|16963
# getarg WB
# getarg XR
        subq WB,XR
# ||mov|11,-(xs)|7,xr||; stack ptr to previous block|16964
# getarg XR
        push XR
# ||mov|8,wa|19,*tesi_||; set size of teblk|16965
# getarg W0
# getarg WA
        movq l_0029,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate new teblk|16966
# getarg alloc
        call alloc
# ||mov|11,-(xs)|7,xr||; stack ptr to new teblk|16967
# getarg XR
        push XR
# ||mvw||||; copy old teblk to new teblk|16968
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0634:
        or   WA,WA
        jz   l_0635
        movsq
        decq WA
        jmp  l_0634
l_0635:
        cld
# ||mov|7,xr|10,(xs)+||; restore pointer to new teblk|16969
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; restore pointer to previous block|16970
# getarg XL
        pop  XL
# ||add|7,xl|8,wb||; add offset back in|16971
# getarg WB
# getarg XL
        addq WB,XL
# ||mov|13,tenxt(xl)|7,xr||; link new block to previous|16972
# getarg XR
# getarg tenxt(,XL,8)
        movq XR,tenxt(,XL,8)
# ||mov|7,xl|7,xr||; copy pointer to new block|16973
# getarg XR
# getarg XL
        movq XR,XL
# |cop08|mov|7,xl|13,teval(xl)||; load value|16977
cop08:
# getarg teval(,XL,8)
# getarg XL
        movq teval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,cop08|; loop back if trapped|16978
# getarg (XL)
# getarg W0
# getarg cop08
        movq l_0154,W0
        cmpq (XL),W0
        je   cop08
# ||mov|13,teval(xr)|7,xl||; store untrapped value in teblk|16979
# getarg XL
# getarg teval(,XR,8)
        movq XL,teval(,XR,8)
# ||zer|8,wb|||; zero offset within teblk|16980
# getarg WB
        xor  WB,WB
# ||brn|6,cop07|||; back for next teblk|16981
# getarg cop07
        jmp  cop07
# |cop09|mov|7,xr|10,(xs)+||; load pointer to block|16985
cop09:
# getarg XR
        pop  XR
# ||exi||||; return|16986
# getarg 
        movq $0,rcode
        mov  prc_+8*2,W0
        jmp  *W0
# |cop10|exi|1,1|||; return|16990
cop10:
# getarg 1
        movq $1,rcode
        mov  prc_+8*2,W0
        jmp  *W0
# ||ejc|||||16991
# ||enp||||; end procedure copyb|17009
# |cdgcg|prc|25,e|1,0||; entry point|17020
cdgcg:
# getarg 0
# ||mov|7,xl|13,cmopn(xr)||; get unary goto operator|17021
# getarg cmopn(,XR,8)
# getarg XL
        movq cmopn(,XR,8),XL
# ||mov|7,xr|13,cmrop(xr)||; point to goto operand|17022
# getarg cmrop(,XR,8)
# getarg XR
        movq cmrop(,XR,8),XR
# ||beq|7,xl|21,=opdvd|6,cdgc2|; jump if direct goto|17023
# getarg XL
# getarg W0
# getarg cdgc2
        .data
l_0636: .long opdvd
        .text
        movq l_0636,W0
        cmpq XL,W0
        je   cdgc2
# ||jsr|6,cdgnm|||; generate opnd by name if not direct|17024
# getarg cdgnm
        call cdgnm
# |cdgc1|mov|8,wa|7,xl||; goto operator|17028
cdgc1:
# getarg XL
# getarg WA
        movq XL,WA
# ||jsr|6,cdwrd|||; generate it|17029
# getarg cdwrd
        call cdwrd
# ||exi||||; return to caller|17030
# getarg 
        ret
# |cdgc2|jsr|6,cdgvl|||; generate operand by value|17034
cdgc2:
# getarg cdgvl
        call cdgvl
# ||brn|6,cdgc1|||; merge to return|17035
# getarg cdgc1
        jmp  cdgc1
# ||enp||||; end procedure cdgcg|17036
# ||ejc|||||17037
# |cdgex|prc|25,r|1,0||; entry point, recursive|17054
cdgex:
# getarg 0
# ||blo|9,(xl)|22,=b_vr_|6,cdgx1|; jump if not variable|17055
# getarg (XL)
# getarg W0
# getarg cdgx1
        .data
l_0637: .long b_vr_
        .text
        movq l_0637,W0
        cmpq (XL),W0
        jb   cdgx1
# ||mov|8,wa|19,*sesi_||; set size of seblk|17059
# getarg W0
# getarg WA
        .data
l_0638: .long 8*sesi_
        .text
        movq l_0638,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for seblk|17060
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_sel||; set type word|17061
# getarg W0
# getarg (XR)
        .data
l_0639: .long b_sel
        .text
        movq l_0639,W0
        movq W0,(XR)
# ||mov|13,sevar(xr)|7,xl||; store vrblk pointer|17062
# getarg XL
# getarg sevar(,XR,8)
        movq XL,sevar(,XR,8)
# ||exi||||; return to cdgex caller|17063
# getarg 
        ret
# |cdgx1|mov|7,xr|7,xl||; copy tree pointer|17067
cdgx1:
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|11,-(xs)|8,wc||; save wc|17068
# getarg WC
        push WC
# ||mov|7,xl|3,cwcof||; save current offset|17069
# getarg cwcof
# getarg XL
        movq cwcof,XL
# ||bze|8,wa|6,cdgx2||; jump if by value|17071
# getarg WA
# getarg cdgx2
        or   WA,WA
        jz   cdgx2
# ||mov|8,wa|9,(xr)||; get type word|17073
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||bne|8,wa|22,=b_cmt|6,cdgx2|; call by value if not cmblk|17074
# getarg WA
# getarg W0
# getarg cdgx2
        .data
l_0640: .long b_cmt
        .text
        movq l_0640,W0
        cmpq WA,W0
        jne  cdgx2
# ||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|; jump if cmblk only by value|17075
# getarg cmtyp(,XR,8)
# getarg W0
# getarg cdgx2
        .data
l_0641: .long c__nm
        .text
        movq l_0641,W0
        cmpq cmtyp(,XR,8),W0
        jae  cdgx2
# ||ejc|||||17076
# ||jsr|6,cdgnm|||; generate code by name|17082
# getarg cdgnm
        call cdgnm
# ||mov|8,wa|21,=ornm_||; load return by name word|17083
# getarg W0
# getarg WA
        movq l_0110,W0
        movq W0,WA
# ||brn|6,cdgx3|||; merge with value case|17084
# getarg cdgx3
        jmp  cdgx3
# |cdgx2|jsr|6,cdgvl|||; generate code by value|17088
cdgx2:
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=orvl_||; load return by value word|17089
# getarg W0
# getarg WA
        .data
l_0642: .long orvl_
        .text
        movq l_0642,W0
        movq W0,WA
# |cdgx3|jsr|6,cdwrd|||; generate return word|17093
cdgx3:
# getarg cdwrd
        call cdwrd
# ||jsr|6,exbld|||; build exblk|17094
# getarg exbld
        call exbld
# ||mov|8,wc|10,(xs)+||; restore wc|17095
# getarg WC
        pop  WC
# ||exi||||; return to cdgex caller|17096
# getarg 
        ret
# ||enp||||; end procedure cdgex|17097
# ||ejc|||||17098
# |cdgnm|prc|25,r|1,0||; entry point, recursive|17123
cdgnm:
# getarg 0
# ||mov|11,-(xs)|7,xl||; save entry xl|17124
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wb||; save entry wb|17125
# getarg WB
        push WB
# ||chk||||; check for stack overflow|17126
        chk_
        or   W0,W0
        jne  sec06
# ||mov|8,wa|9,(xr)||; load type word|17127
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_cmt|6,cgn04|; jump if cmblk|17128
# getarg WA
# getarg W0
# getarg cgn04
        movq l_0640,W0
        cmpq WA,W0
        je   cgn04
# ||bhi|8,wa|22,=b_vr_|6,cgn02|; jump if simple variable|17129
# getarg WA
# getarg W0
# getarg cgn02
        movq l_0637,W0
        cmpq WA,W0
        ja   cgn02
# |cgn01|erb|1,212|26,syntax error: value used where name is required|||17133
cgn01:
        movq $212,rcode
        jmp  err_
# |cgn02|mov|8,wa|21,=olvn_||; load variable load call|17137
cgn02:
# getarg W0
# getarg WA
        .data
l_0643: .long olvn_
        .text
        movq l_0643,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17138
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|7,xr||; copy vrblk pointer|17139
# getarg XR
# getarg WA
        movq XR,WA
# ||jsr|6,cdwrd|||; generate vrblk pointer|17140
# getarg cdwrd
        call cdwrd
# ||ejc|||||17141
# |cgn03|mov|8,wb|10,(xs)+||; restore entry wb|17147
cgn03:
# getarg WB
        pop  WB
# ||mov|7,xl|10,(xs)+||; restore entry xl|17148
# getarg XL
        pop  XL
# ||exi||||; return to cdgnm caller|17149
# getarg 
        ret
# |cgn04|mov|7,xl|7,xr||; copy cmblk pointer|17153
cgn04:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17154
# getarg cmtyp(,XR,8)
# getarg XR
        movq cmtyp(,XR,8),XR
# ||bge|7,xr|18,=c__nm|6,cgn01|; error if not name operand|17155
# getarg XR
# getarg W0
# getarg cgn01
        movq l_0641,W0
        cmpq XR,W0
        jae  cgn01
# ||bsw|7,xr|2,c__nm||; else switch on type|17156
# getarg XR
        jmp  *l_0644(,XR,8)
        .data
l_0644:
# ||iff|2,c_arr|6,cgn05||; array reference|17164
# getarg cgn05
        .long cgn05
# ||iff|2,c_fnc|6,cgn08||; function call|17164
# getarg cgn08
        .long cgn08
# ||iff|2,c_def|6,cgn09||; deferred expression|17164
# getarg cgn09
        .long cgn09
# ||iff|2,c_ind|6,cgn10||; indirect reference|17164
# getarg cgn10
        .long cgn10
# ||iff|2,c_key|6,cgn11||; keyword reference|17164
# getarg cgn11
        .long cgn11
# ||iff|2,c_ubo|6,cgn08||; undefined binary op|17164
# getarg cgn08
        .long cgn08
# ||iff|2,c_uuo|6,cgn08||; undefined unary op|17164
# getarg cgn08
        .long cgn08
# ||esw||||; end switch on cmblk type|17164
        .text
# |cgn05|mov|8,wb|19,*cmopn||; point to array operand|17168
cgn05:
# getarg W0
# getarg WB
        .data
l_0645: .long 8*cmopn
        .text
        movq l_0645,W0
        movq W0,WB
# |cgn06|jsr|6,cmgen|||; generate code for next operand|17172
cgn06:
# getarg cmgen
        call cmgen
# ||mov|8,wc|13,cmlen(xl)||; load length of cmblk|17173
# getarg cmlen(,XL,8)
# getarg WC
        movq cmlen(,XL,8),WC
# ||blt|8,wb|8,wc|6,cgn06|; loop till all generated|17174
# getarg WB
# getarg WC
# getarg cgn06
        cmpq WB,WC
        jb   cgn06
# ||mov|8,wa|21,=oaon_||; load one-subscript case call|17178
# getarg W0
# getarg WA
        .data
l_0646: .long oaon_
        .text
        movq l_0646,W0
        movq W0,WA
# ||beq|8,wc|19,*cmar1|6,cgn07|; jump to exit if one subscript case|17179
# getarg WC
# getarg W0
# getarg cgn07
        .data
l_0647: .long 8*cmar1
        .text
        movq l_0647,W0
        cmpq WC,W0
        je   cgn07
# ||mov|8,wa|21,=oamn_||; else load multi-subscript case call|17180
# getarg W0
# getarg WA
        .data
l_0648: .long oamn_
        .text
        movq l_0648,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate call|17181
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|8,wc||; copy cmblk length|17182
# getarg WC
# getarg WA
        movq WC,WA
# ||btw|8,wa|||; convert to words|17183
# getarg WA
        shr  WA,3
# ||sub|8,wa|18,=cmvls||; calculate number of subscripts|17184
# getarg W0
# getarg WA
        .data
l_0649: .long cmvls
        .text
        movq l_0649,W0
        subq W0,WA
# ||ejc|||||17185
# |cgn07|mnz|8,wc|||; set result non-constant|17191
cgn07:
# getarg WC
        mov  XS,WC
# ||jsr|6,cdwrd|||; generate word|17192
# getarg cdwrd
        call cdwrd
# ||brn|6,cgn03|||; back to exit|17193
# getarg cgn03
        jmp  cgn03
# |cgn08|mov|7,xr|7,xl||; copy cmblk pointer|17197
cgn08:
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,cdgvl|||; gen code by value for call|17198
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=ofne_||; get extra call for by name|17199
# getarg W0
# getarg WA
        movq l_0153,W0
        movq W0,WA
# ||brn|6,cgn07|||; back to generate and exit|17200
# getarg cgn07
        jmp  cgn07
# |cgn09|mov|7,xr|13,cmrop(xl)||; check if variable|17204
cgn09:
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||bhi|9,(xr)|22,=b_vr_|6,cgn02|; treat *variable as simple var|17205
# getarg (XR)
# getarg W0
# getarg cgn02
        movq l_0637,W0
        cmpq (XR),W0
        ja   cgn02
# ||mov|7,xl|7,xr||; copy ptr to expression tree|17206
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|18,=num01||; return name|17208
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# ||jsr|6,cdgex|||; else build exblk|17210
# getarg cdgex
        call cdgex
# ||mov|8,wa|21,=olex_||; set call to load expr by name|17211
# getarg W0
# getarg WA
        .data
l_0650: .long olex_
        .text
        movq l_0650,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17212
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|7,xr||; copy exblk pointer|17213
# getarg XR
# getarg WA
        movq XR,WA
# ||jsr|6,cdwrd|||; generate exblk pointer|17214
# getarg cdwrd
        call cdwrd
# ||brn|6,cgn03|||; back to exit|17215
# getarg cgn03
        jmp  cgn03
# |cgn10|mov|7,xr|13,cmrop(xl)||; get operand|17219
cgn10:
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; generate code by value for it|17220
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=oinn_||; load call for indirect by name|17221
# getarg W0
# getarg WA
        .data
l_0651: .long oinn_
        .text
        movq l_0651,W0
        movq W0,WA
# ||brn|6,cgn12|||; merge|17222
# getarg cgn12
        jmp  cgn12
# |cgn11|mov|7,xr|13,cmrop(xl)||; get operand|17226
cgn11:
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgnm|||; generate code by name for it|17227
# getarg cdgnm
        call cdgnm
# ||mov|8,wa|21,=okwn_||; load call for keyword by name|17228
# getarg W0
# getarg WA
        .data
l_0652: .long okwn_
        .text
        movq l_0652,W0
        movq W0,WA
# |cgn12|jsr|6,cdwrd|||; generate code for operator|17232
cgn12:
# getarg cdwrd
        call cdwrd
# ||brn|6,cgn03|||; exit|17233
# getarg cgn03
        jmp  cgn03
# ||enp||||; end procedure cdgnm|17234
# ||ejc|||||17235
# |cdgvl|prc|25,r|1,0||; entry point, recursive|17263
cdgvl:
# getarg 0
# ||mov|8,wa|9,(xr)||; load type word|17264
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_cmt|6,cgv01|; jump if cmblk|17265
# getarg WA
# getarg W0
# getarg cgv01
        movq l_0640,W0
        cmpq WA,W0
        je   cgv01
# ||blt|8,wa|22,=b_vra|6,cgv00|; jump if icblk, rcblk, scblk|17266
# getarg WA
# getarg W0
# getarg cgv00
        .data
l_0653: .long b_vra
        .text
        movq l_0653,W0
        cmpq WA,W0
        jb   cgv00
# ||bnz|13,vrlen(xr)|6,cgvl0||; jump if not system variable|17267
# getarg vrlen(,XR,8)
# getarg cgvl0
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  cgvl0
# ||mov|11,-(xs)|7,xr||; stack xr|17268
# getarg XR
        push XR
# ||mov|7,xr|13,vrsvp(xr)||; point to svblk|17269
# getarg vrsvp(,XR,8)
# getarg XR
        movq vrsvp(,XR,8),XR
# ||mov|8,wa|13,svbit(xr)||; get svblk property bits|17270
# getarg svbit(,XR,8)
# getarg WA
        movq svbit(,XR,8),WA
# ||mov|7,xr|10,(xs)+||; recover xr|17271
# getarg XR
        pop  XR
# ||anb|8,wa|4,btkwv||; check if constant keyword value|17272
# getarg WA
# getarg btkwv
        and  WA,btkwv
# ||beq|8,wa|4,btkwv|6,cgv00|; jump if constant keyword value|17273
# getarg WA
# getarg btkwv
# getarg cgv00
        cmpq WA,btkwv
        je   cgv00
# |cgvl0|mnz|8,wc|||; indicate non-constant value|17277
cgvl0:
# getarg WC
        mov  XS,WC
# |cgv00|mov|8,wa|7,xr||; copy ptr to var or constant|17282
cgv00:
# getarg XR
# getarg WA
        movq XR,WA
# ||jsr|6,cdwrd|||; generate as code word|17283
# getarg cdwrd
        call cdwrd
# ||exi||||; return to caller|17284
# getarg 
        ret
# ||ejc|||||17285
# |cgv01|mov|11,-(xs)|8,wb||; save entry wb|17291
cgv01:
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xl||; save entry xl|17292
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wc||; save entry constant flag|17293
# getarg WC
        push WC
# ||mov|11,-(xs)|3,cwcof||; save initial code offset|17294
# getarg cwcof
        push cwcof
# ||chk||||; check for stack overflow|17295
        chk_
        or   W0,W0
        jne  sec06
# ||mov|7,xl|7,xr||; copy cmblk pointer|17303
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17304
# getarg cmtyp(,XR,8)
# getarg XR
        movq cmtyp(,XR,8),XR
# ||mov|8,wc|3,cswno||; reset constant flag|17305
# getarg cswno
# getarg WC
        movq cswno,WC
# ||ble|7,xr|18,=c_pr_|6,cgv02|; jump if not predicate value|17306
# getarg XR
# getarg W0
# getarg cgv02
        .data
l_0654: .long c_pr_
        .text
        movq l_0654,W0
        cmpq XR,W0
        jbe  cgv02
# ||mnz|8,wc|||; else force non-constant case|17307
# getarg WC
        mov  XS,WC
# |cgv02|bsw|7,xr|2,c__nv||; switch to appropriate generator|17311
cgv02:
# getarg XR
        jmp  *l_0655(,XR,8)
        .data
l_0655:
# ||iff|2,c_arr|6,cgv03||; array reference|17331
# getarg cgv03
        .long cgv03
# ||iff|2,c_fnc|6,cgv05||; function call|17331
# getarg cgv05
        .long cgv05
# ||iff|2,c_def|6,cgv14||; deferred expression|17331
# getarg cgv14
        .long cgv14
# ||iff|2,c_ind|6,cgv31||; indirect reference|17331
# getarg cgv31
        .long cgv31
# ||iff|2,c_key|6,cgv27||; keyword reference|17331
# getarg cgv27
        .long cgv27
# ||iff|2,c_ubo|6,cgv29||; undefined binop|17331
# getarg cgv29
        .long cgv29
# ||iff|2,c_uuo|6,cgv30||; undefined unop|17331
# getarg cgv30
        .long cgv30
# ||iff|2,c_bvl|6,cgv18||; binops with val opds|17331
# getarg cgv18
        .long cgv18
# ||iff|2,c_uvl|6,cgv19||; unops with valu opnd|17331
# getarg cgv19
        .long cgv19
# ||iff|2,c_alt|6,cgv18||; alternation|17331
# getarg cgv18
        .long cgv18
# ||iff|2,c_cnc|6,cgv24||; concatenation|17331
# getarg cgv24
        .long cgv24
# ||iff|2,c_cnp|6,cgv24||; concatenation (not pattern match)|17331
# getarg cgv24
        .long cgv24
# ||iff|2,c_unm|6,cgv27||; unops with name opnd|17331
# getarg cgv27
        .long cgv27
# ||iff|2,c_bvn|6,cgv26||; binary _ and .|17331
# getarg cgv26
        .long cgv26
# ||iff|2,c_ass|6,cgv21||; assignment|17331
# getarg cgv21
        .long cgv21
# ||iff|2,c_int|6,cgv31||; interrogation|17331
# getarg cgv31
        .long cgv31
# ||iff|2,c_neg|6,cgv28||; negation|17331
# getarg cgv28
        .long cgv28
# ||iff|2,c_sel|6,cgv15||; selection|17331
# getarg cgv15
        .long cgv15
# ||iff|2,c_pmt|6,cgv18||; pattern match|17331
# getarg cgv18
        .long cgv18
# ||esw||||; end switch on cmblk type|17331
        .text
# ||ejc|||||17332
# |cgv03|mov|8,wb|19,*cmopn||; set offset to array operand|17338
cgv03:
# getarg W0
# getarg WB
        movq l_0645,W0
        movq W0,WB
# |cgv04|jsr|6,cmgen|||; gen value code for next operand|17342
cgv04:
# getarg cmgen
        call cmgen
# ||mov|8,wc|13,cmlen(xl)||; load cmblk length|17343
# getarg cmlen(,XL,8)
# getarg WC
        movq cmlen(,XL,8),WC
# ||blt|8,wb|8,wc|6,cgv04|; loop back if more to go|17344
# getarg WB
# getarg WC
# getarg cgv04
        cmpq WB,WC
        jb   cgv04
# ||mov|8,wa|21,=oaov_||; set one subscript call in case|17348
# getarg W0
# getarg WA
        .data
l_0656: .long oaov_
        .text
        movq l_0656,W0
        movq W0,WA
# ||beq|8,wc|19,*cmar1|6,cgv32|; jump to exit if 1-sub case|17349
# getarg WC
# getarg W0
# getarg cgv32
        movq l_0647,W0
        cmpq WC,W0
        je   cgv32
# ||mov|8,wa|21,=oamv_||; else set call for multi-subscripts|17350
# getarg W0
# getarg WA
        .data
l_0657: .long oamv_
        .text
        movq l_0657,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate call|17351
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|8,wc||; copy length of cmblk|17352
# getarg WC
# getarg WA
        movq WC,WA
# ||sub|8,wa|19,*cmvls||; subtract standard length|17353
# getarg W0
# getarg WA
        .data
l_0658: .long 8*cmvls
        .text
        movq l_0658,W0
        subq W0,WA
# ||btw|8,wa|||; get number of words|17354
# getarg WA
        shr  WA,3
# ||brn|6,cgv32|||; jump to generate subscript count|17355
# getarg cgv32
        jmp  cgv32
# |cgv05|mov|8,wb|19,*cmvls||; set offset to first argument|17359
cgv05:
# getarg W0
# getarg WB
        movq l_0658,W0
        movq W0,WB
# |cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|; jump if all generated|17363
cgv06:
# getarg WB
# getarg cmlen(,XL,8)
# getarg cgv07
        cmpq WB,cmlen(,XL,8)
        je   cgv07
# ||jsr|6,cmgen|||; else gen value code for next arg|17364
# getarg cmgen
        call cmgen
# ||brn|6,cgv06|||; back to generate next argument|17365
# getarg cgv06
        jmp  cgv06
# |cgv07|sub|8,wb|19,*cmvls||; get number of arg ptrs (bytes)|17369
cgv07:
# getarg W0
# getarg WB
        movq l_0658,W0
        subq W0,WB
# ||btw|8,wb|||; convert bytes to words|17370
# getarg WB
        shr  WB,3
# ||mov|7,xr|13,cmopn(xl)||; load function vrblk pointer|17371
# getarg cmopn(,XL,8)
# getarg XR
        movq cmopn(,XL,8),XR
# ||bnz|13,vrlen(xr)|6,cgv12||; jump if not system function|17372
# getarg vrlen(,XR,8)
# getarg cgv12
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  cgv12
# ||mov|7,xl|13,vrsvp(xr)||; load svblk ptr if system var|17373
# getarg vrsvp(,XR,8)
# getarg XL
        movq vrsvp(,XR,8),XL
# ||mov|8,wa|13,svbit(xl)||; load bit mask|17374
# getarg svbit(,XL,8)
# getarg WA
        movq svbit(,XL,8),WA
# ||anb|8,wa|4,btffc||; test for fast function call allowed|17375
# getarg WA
# getarg btffc
        and  WA,btffc
# ||zrb|8,wa|6,cgv12||; jump if not|17376
# getarg WA
# getarg WA
# getarg cgv12
        or   WA,WA
        jz   cgv12
# ||ejc|||||17377
# ||mov|8,wa|13,svbit(xl)||; reload bit indicators|17383
# getarg svbit(,XL,8)
# getarg WA
        movq svbit(,XL,8),WA
# ||anb|8,wa|4,btpre||; test for preevaluation ok|17384
# getarg WA
# getarg btpre
        and  WA,btpre
# ||nzb|8,wa|6,cgv08||; jump if preevaluation permitted|17385
# getarg WA
# getarg WA
# getarg cgv08
        or   WA,WA
        jnz  cgv08
# ||mnz|8,wc|||; else set result non-constant|17386
# getarg WC
        mov  XS,WC
# |cgv08|mov|7,xl|13,vrfnc(xr)||; load ptr to svfnc field|17390
cgv08:
# getarg vrfnc(,XR,8)
# getarg XL
        movq vrfnc(,XR,8),XL
# ||mov|8,wa|13,fargs(xl)||; load svnar field value|17391
# getarg fargs(,XL,8)
# getarg WA
        movq fargs(,XL,8),WA
# ||beq|8,wa|8,wb|6,cgv11|; jump if argument count is correct|17392
# getarg WA
# getarg WB
# getarg cgv11
        cmpq WA,WB
        je   cgv11
# ||bhi|8,wa|8,wb|6,cgv09|; jump if too few arguments given|17393
# getarg WA
# getarg WB
# getarg cgv09
        cmpq WA,WB
        ja   cgv09
# ||sub|8,wb|8,wa||; get number of extra args|17397
# getarg WA
# getarg WB
        subq WA,WB
# ||lct|8,wb|8,wb||; set as count to control loop|17398
# ||mov|8,wa|21,=opop_||; set pop call|17399
# getarg W0
# getarg WA
        .data
l_0659: .long opop_
        .text
        movq l_0659,W0
        movq W0,WA
# ||brn|6,cgv10|||; jump to common loop|17400
# getarg cgv10
        jmp  cgv10
# |cgv09|sub|8,wa|8,wb||; get number of missing arguments|17404
cgv09:
# getarg WB
# getarg WA
        subq WB,WA
# ||lct|8,wb|8,wa||; load as count to control loop|17405
# getarg WB
# getarg WA
        mov  WB,WA
# ||mov|8,wa|21,=nulls||; load ptr to null constant|17406
# getarg W0
# getarg WA
        movq l_0054,W0
        movq W0,WA
# |cgv10|jsr|6,cdwrd|||; generate one call|17410
cgv10:
# getarg cdwrd
        call cdwrd
# ||bct|8,wb|6,cgv10||; loop till all generated|17411
# getarg WB
# getarg cgv10
        decq WB
        jnz  cgv10
# |cgv11|mov|8,wa|7,xl||; copy pointer to svfnc field|17415
cgv11:
# getarg XL
# getarg WA
        movq XL,WA
# ||brn|6,cgv36|||; jump to generate call|17416
# getarg cgv36
        jmp  cgv36
# ||ejc|||||17417
# |cgv12|mov|8,wa|21,=ofns_||; set one arg call in case|17423
cgv12:
# getarg W0
# getarg WA
        .data
l_0660: .long ofns_
        .text
        movq l_0660,W0
        movq W0,WA
# ||beq|8,wb|18,=num01|6,cgv13|; jump if one arg case|17424
# getarg WB
# getarg W0
# getarg cgv13
        movq l_0060,W0
        cmpq WB,W0
        je   cgv13
# ||mov|8,wa|21,=ofnc_||; else load call for more than 1 arg|17425
# getarg W0
# getarg WA
        .data
l_0661: .long ofnc_
        .text
        movq l_0661,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17426
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|8,wb||; copy argument count|17427
# getarg WB
# getarg WA
        movq WB,WA
# |cgv13|jsr|6,cdwrd|||; generate =o_fns or arg count|17431
cgv13:
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|7,xr||; copy vrblk pointer|17432
# getarg XR
# getarg WA
        movq XR,WA
# ||brn|6,cgv32|||; jump to generate vrblk ptr|17433
# getarg cgv32
        jmp  cgv32
# |cgv14|mov|7,xl|13,cmrop(xl)||; point to expression tree|17437
cgv14:
# getarg cmrop(,XL,8)
# getarg XL
        movq cmrop(,XL,8),XL
# ||zer|8,wa|||; return value|17439
# getarg WA
        xor  WA,WA
# ||jsr|6,cdgex|||; build exblk or seblk|17441
# getarg cdgex
        call cdgex
# ||mov|8,wa|7,xr||; copy block ptr|17442
# getarg XR
# getarg WA
        movq XR,WA
# ||jsr|6,cdwrd|||; generate ptr to exblk or seblk|17443
# getarg cdwrd
        call cdwrd
# ||brn|6,cgv34|||; jump to exit, constant test|17444
# getarg cgv34
        jmp  cgv34
# |cgv15|zer|11,-(xs)|||; zero ptr to chain of forward jumps|17448
cgv15:
        push $0
# ||zer|11,-(xs)|||; zero ptr to prev o_slc forward ptr|17449
        push $0
# ||mov|8,wb|19,*cmvls||; point to first alternative|17450
# getarg W0
# getarg WB
        movq l_0658,W0
        movq W0,WB
# ||mov|8,wa|21,=osla_||; set initial code word|17451
# getarg W0
# getarg WA
        .data
l_0662: .long osla_
        .text
        movq l_0662,W0
        movq W0,WA
# |cgv16|jsr|6,cdwrd|||; generate o_slc (o_sla first time)|17462
cgv16:
# getarg cdwrd
        call cdwrd
# ||mov|9,(xs)|3,cwcof||; set current loc as ptr to fill in|17463
# getarg cwcof
# getarg W0
# getarg (XT)
        movq cwcof,W0
        movq W0,(XT)
# ||jsr|6,cdwrd|||; generate garbage word there for now|17464
# getarg cdwrd
        call cdwrd
# ||jsr|6,cmgen|||; gen value code for alternative|17465
# getarg cmgen
        call cmgen
# ||mov|8,wa|21,=oslb_||; load o_slb pointer|17466
# getarg W0
# getarg WA
        .data
l_0663: .long oslb_
        .text
        movq l_0663,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate o_slb call|17467
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|13,num01(xs)||; load old chain ptr|17468
# getarg num01(,XT,8)
# getarg WA
        movq num01(,XT,8),WA
# ||mov|13,num01(xs)|3,cwcof||; set current loc as new chain head|17469
# getarg cwcof
# getarg W0
# getarg num01(,XT,8)
        movq cwcof,W0
        movq W0,num01(,XT,8)
# ||jsr|6,cdwrd|||; generate forward chain link|17470
# getarg cdwrd
        call cdwrd
# ||ejc|||||17471
# ||mov|7,xr|9,(xs)||; load offset to word to plug|17477
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,r_ccb||; point to actual location to plug|17478
# getarg r_ccb
# getarg XR
        addq r_ccb,XR
# ||mov|9,(xr)|3,cwcof||; plug proper offset in|17479
# getarg cwcof
# getarg W0
# getarg (XR)
        movq cwcof,W0
        movq W0,(XR)
# ||mov|8,wa|21,=oslc_||; load o_slc ptr for next alternative|17480
# getarg W0
# getarg WA
        .data
l_0664: .long oslc_
        .text
        movq l_0664,W0
        movq W0,WA
# ||mov|7,xr|8,wb||; copy offset (destroy garbage xr)|17481
# getarg WB
# getarg XR
        movq WB,XR
# ||ica|7,xr|||; bump extra time for test|17482
# getarg XR
        addq $8,XR
# ||blt|7,xr|13,cmlen(xl)|6,cgv16|; loop back if not last alternative|17483
# getarg XR
# getarg cmlen(,XL,8)
# getarg cgv16
        cmpq XR,cmlen(,XL,8)
        jb   cgv16
# ||mov|8,wa|21,=osld_||; get header call|17487
# getarg W0
# getarg WA
        .data
l_0665: .long osld_
        .text
        movq l_0665,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate o_sld call|17488
# getarg cdwrd
        call cdwrd
# ||jsr|6,cmgen|||; generate code for last alternative|17489
# getarg cmgen
        call cmgen
# ||ica|7,xs|||; pop offset ptr|17490
# getarg XT
        addq $8,XT
# ||mov|7,xr|10,(xs)+||; load chain ptr|17491
# getarg XR
        pop  XR
# |cgv17|add|7,xr|3,r_ccb||; make next ptr absolute|17495
cgv17:
# getarg r_ccb
# getarg XR
        addq r_ccb,XR
# ||mov|8,wa|9,(xr)||; load forward ptr|17496
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||mov|9,(xr)|3,cwcof||; plug required offset|17497
# getarg cwcof
# getarg W0
# getarg (XR)
        movq cwcof,W0
        movq W0,(XR)
# ||mov|7,xr|8,wa||; copy forward ptr|17498
# getarg WA
# getarg XR
        movq WA,XR
# ||bnz|8,wa|6,cgv17||; loop back if more to go|17499
# getarg WA
# getarg WA
# getarg cgv17
        or   WA,WA
        jnz  cgv17
# ||brn|6,cgv33|||; else jump to exit (not constant)|17500
# getarg cgv33
        jmp  cgv33
# |cgv18|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17504
cgv18:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen value code for left operand|17505
# getarg cdgvl
        call cdgvl
# |cgv19|mov|7,xr|13,cmrop(xl)||; load right (only) operand ptr|17509
cgv19:
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value|17510
# getarg cdgvl
        call cdgvl
# ||ejc|||||17511
# |cgv20|mov|8,wa|13,cmopn(xl)||; load operator call pointer|17517
cgv20:
# getarg cmopn(,XL,8)
# getarg WA
        movq cmopn(,XL,8),WA
# ||brn|6,cgv36|||; jump to generate it with cons test|17518
# getarg cgv36
        jmp  cgv36
# |cgv21|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17522
cgv21:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||blo|9,(xr)|22,=b_vr_|6,cgv22|; jump if not variable|17523
# getarg (XR)
# getarg W0
# getarg cgv22
        movq l_0637,W0
        cmpq (XR),W0
        jb   cgv22
# ||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17527
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; generate code by value|17528
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|13,cmlop(xl)||; reload left operand vrblk ptr|17529
# getarg cmlop(,XL,8)
# getarg WA
        movq cmlop(,XL,8),WA
# ||add|8,wa|19,*vrsto||; point to vrsto field|17530
# getarg W0
# getarg WA
        movq l_0163,W0
        addq W0,WA
# ||brn|6,cgv32|||; jump to generate store ptr|17531
# getarg cgv32
        jmp  cgv32
# |cgv22|jsr|6,expap|||; test for pattern match on left side|17535
cgv22:
# getarg expap
        call expap
        decq rcode
        js   call_214
# ||ppm|6,cgv23|||; jump if not pattern match|17536
# getarg cgv23
# getarg cgv23
        decq rcode
        jns  l_0666
        jmp  cgv23
l_0666:
call_214:
# ||mov|13,cmlop(xl)|13,cmrop(xr)||; save pattern ptr in safe place|17540
# getarg cmrop(,XR,8)
# getarg W0
# getarg cmlop(,XL,8)
        movq cmrop(,XR,8),W0
        movq W0,cmlop(,XL,8)
# ||mov|7,xr|13,cmlop(xr)||; load subject ptr|17541
# getarg cmlop(,XR,8)
# getarg XR
        movq cmlop(,XR,8),XR
# ||jsr|6,cdgnm|||; gen code by name for subject|17542
# getarg cdgnm
        call cdgnm
# ||mov|7,xr|13,cmlop(xl)||; load pattern ptr|17543
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value for pattern|17544
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=opmn_||; load match by name call|17545
# getarg W0
# getarg WA
        .data
l_0667: .long opmn_
        .text
        movq l_0667,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17546
# getarg cdwrd
        call cdwrd
# ||mov|7,xr|13,cmrop(xl)||; load replacement value ptr|17547
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value|17548
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=orpl_||; load replace call|17549
# getarg W0
# getarg WA
        .data
l_0668: .long orpl_
        .text
        movq l_0668,W0
        movq W0,WA
# ||brn|6,cgv32|||; jump to gen and exit (not constant)|17550
# getarg cgv32
        jmp  cgv32
# |cgv23|mnz|8,wc|||; inhibit pre-evaluation|17554
cgv23:
# getarg WC
        mov  XS,WC
# ||jsr|6,cdgnm|||; gen code by name for left side|17555
# getarg cdgnm
        call cdgnm
# ||brn|6,cgv31|||; merge with unop circuit|17556
# getarg cgv31
        jmp  cgv31
# ||ejc|||||17557
# |cgv24|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17563
cgv24:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||bne|9,(xr)|22,=b_cmt|6,cgv18|; ordinary binop if not cmblk|17564
# getarg (XR)
# getarg W0
# getarg cgv18
        movq l_0640,W0
        cmpq (XR),W0
        jne  cgv18
# ||mov|8,wb|13,cmtyp(xr)||; load cmblk type code|17565
# getarg cmtyp(,XR,8)
# getarg WB
        movq cmtyp(,XR,8),WB
# ||beq|8,wb|18,=c_int|6,cgv25|; special case if interrogation|17566
# getarg WB
# getarg W0
# getarg cgv25
        .data
l_0669: .long c_int
        .text
        movq l_0669,W0
        cmpq WB,W0
        je   cgv25
# ||beq|8,wb|18,=c_neg|6,cgv25|; or negation|17567
# getarg WB
# getarg W0
# getarg cgv25
        .data
l_0670: .long c_neg
        .text
        movq l_0670,W0
        cmpq WB,W0
        je   cgv25
# ||bne|8,wb|18,=c_fnc|6,cgv18|; else ordinary binop if not function|17568
# getarg WB
# getarg W0
# getarg cgv18
        .data
l_0671: .long c_fnc
        .text
        movq l_0671,W0
        cmpq WB,W0
        jne  cgv18
# ||mov|7,xr|13,cmopn(xr)||; else load function vrblk ptr|17569
# getarg cmopn(,XR,8)
# getarg XR
        movq cmopn(,XR,8),XR
# ||bnz|13,vrlen(xr)|6,cgv18||; ordinary binop if not system var|17570
# getarg vrlen(,XR,8)
# getarg cgv18
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  cgv18
# ||mov|7,xr|13,vrsvp(xr)||; else point to svblk|17571
# getarg vrsvp(,XR,8)
# getarg XR
        movq vrsvp(,XR,8),XR
# ||mov|8,wa|13,svbit(xr)||; load bit indicators|17572
# getarg svbit(,XR,8)
# getarg WA
        movq svbit(,XR,8),WA
# ||anb|8,wa|4,btprd||; test for predicate function|17573
# getarg WA
# getarg btprd
        and  WA,btprd
# ||zrb|8,wa|6,cgv18||; ordinary binop if not|17574
# getarg WA
# getarg WA
# getarg cgv18
        or   WA,WA
        jz   cgv18
# |cgv25|mov|7,xr|13,cmlop(xl)||; reload left arg|17578
cgv25:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value|17579
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=opop_||; load pop call|17580
# getarg W0
# getarg WA
        movq l_0659,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17581
# getarg cdwrd
        call cdwrd
# ||mov|7,xr|13,cmrop(xl)||; load right operand|17582
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value as result code|17583
# getarg cdgvl
        call cdgvl
# ||brn|6,cgv33|||; exit (not constant)|17584
# getarg cgv33
        jmp  cgv33
# |cgv26|mov|7,xr|13,cmlop(xl)||; load left operand|17588
cgv26:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value, merge|17589
# getarg cdgvl
        call cdgvl
# |cgv27|mov|7,xr|13,cmrop(xl)||; load right operand ptr|17593
cgv27:
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgnm|||; gen code by name for right arg|17594
# getarg cdgnm
        call cdgnm
# ||mov|7,xr|13,cmopn(xl)||; get operator code word|17595
# getarg cmopn(,XL,8)
# getarg XR
        movq cmopn(,XL,8),XR
# ||bne|9,(xr)|22,=o_kwv|6,cgv20|; gen call unless keyword value|17596
# getarg (XR)
# getarg W0
# getarg cgv20
        .data
l_0672: .long o_kwv
        .text
        movq l_0672,W0
        cmpq (XR),W0
        jne  cgv20
# ||ejc|||||17597
# ||bnz|8,wc|6,cgv20||; gen call if non-constant (not var)|17606
# getarg WC
# getarg WC
# getarg cgv20
        or   WC,WC
        jnz  cgv20
# ||mnz|8,wc|||; else set non-constant in case|17607
# getarg WC
        mov  XS,WC
# ||mov|7,xr|13,cmrop(xl)||; load ptr to operand vrblk|17608
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||bnz|13,vrlen(xr)|6,cgv20||; gen (non-constant) if not sys var|17609
# getarg vrlen(,XR,8)
# getarg cgv20
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  cgv20
# ||mov|7,xr|13,vrsvp(xr)||; else load ptr to svblk|17610
# getarg vrsvp(,XR,8)
# getarg XR
        movq vrsvp(,XR,8),XR
# ||mov|8,wa|13,svbit(xr)||; load bit mask|17611
# getarg svbit(,XR,8)
# getarg WA
        movq svbit(,XR,8),WA
# ||anb|8,wa|4,btckw||; test for constant keyword|17612
# getarg WA
# getarg btckw
        and  WA,btckw
# ||zrb|8,wa|6,cgv20||; go gen if not constant|17613
# getarg WA
# getarg WA
# getarg cgv20
        or   WA,WA
        jz   cgv20
# ||zer|8,wc|||; else set result constant|17614
# getarg WC
        xor  WC,WC
# ||brn|6,cgv20|||; and jump back to generate call|17615
# getarg cgv20
        jmp  cgv20
# |cgv28|mov|8,wa|21,=onta_||; get initial word|17619
cgv28:
# getarg W0
# getarg WA
        .data
l_0673: .long onta_
        .text
        movq l_0673,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17620
# getarg cdwrd
        call cdwrd
# ||mov|8,wb|3,cwcof||; save next offset|17621
# getarg cwcof
# getarg WB
        movq cwcof,WB
# ||jsr|6,cdwrd|||; generate gunk word for now|17622
# getarg cdwrd
        call cdwrd
# ||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17623
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen code by value|17624
# getarg cdgvl
        call cdgvl
# ||mov|8,wa|21,=ontb_||; load end of evaluation call|17625
# getarg W0
# getarg WA
        .data
l_0674: .long ontb_
        .text
        movq l_0674,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17626
# getarg cdwrd
        call cdwrd
# ||mov|7,xr|8,wb||; copy offset to word to plug|17627
# getarg WB
# getarg XR
        movq WB,XR
# ||add|7,xr|3,r_ccb||; point to actual word to plug|17628
# getarg r_ccb
# getarg XR
        addq r_ccb,XR
# ||mov|9,(xr)|3,cwcof||; plug word with current offset|17629
# getarg cwcof
# getarg W0
# getarg (XR)
        movq cwcof,W0
        movq W0,(XR)
# ||mov|8,wa|21,=ontc_||; load final call|17630
# getarg W0
# getarg WA
        .data
l_0675: .long ontc_
        .text
        movq l_0675,W0
        movq W0,WA
# ||brn|6,cgv32|||; jump to generate it (not constant)|17631
# getarg cgv32
        jmp  cgv32
# |cgv29|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17635
cgv29:
# getarg cmlop(,XL,8)
# getarg XR
        movq cmlop(,XL,8),XR
# ||jsr|6,cdgvl|||; generate code by value|17636
# getarg cdgvl
        call cdgvl
# ||ejc|||||17637
# |cgv30|mov|8,wb|18,=c_uo_||; set unop code + 1|17643
cgv30:
# getarg W0
# getarg WB
        .data
l_0676: .long c_uo_
        .text
        movq l_0676,W0
        movq W0,WB
# ||sub|8,wb|13,cmtyp(xl)||; set number of args (1 or 2)|17644
# getarg cmtyp(,XL,8)
# getarg WB
        subq cmtyp(,XL,8),WB
# ||mov|7,xr|13,cmrop(xl)||; load right (only) operand pointer|17648
# getarg cmrop(,XL,8)
# getarg XR
        movq cmrop(,XL,8),XR
# ||jsr|6,cdgvl|||; gen value code for right operand|17649
# getarg cdgvl
        call cdgvl
# ||mov|7,xr|13,cmopn(xl)||; load pointer to operator dv|17650
# getarg cmopn(,XL,8)
# getarg XR
        movq cmopn(,XL,8),XR
# ||mov|7,xr|13,dvopn(xr)||; load pointer offset|17651
# getarg dvopn(,XR,8)
# getarg XR
        movq dvopn(,XR,8),XR
# ||wtb|7,xr|||; convert word offset to bytes|17652
# getarg XR
        sal  XR,3
# ||add|7,xr|20,=r_uba||; point to proper function ptr|17653
# getarg W0
# getarg XR
        movq l_0475,W0
        addq W0,XR
# ||sub|7,xr|19,*vrfnc||; set standard function offset|17654
# getarg W0
# getarg XR
        movq l_0477,W0
        subq W0,XR
# ||brn|6,cgv12|||; merge with function call circuit|17655
# getarg cgv12
        jmp  cgv12
# |cgv31|mnz|8,wc|||; set non constant|17659
cgv31:
# getarg WC
        mov  XS,WC
# ||brn|6,cgv19|||; merge|17660
# getarg cgv19
        jmp  cgv19
# |cgv32|jsr|6,cdwrd|||; generate word, merge|17664
cgv32:
# getarg cdwrd
        call cdwrd
# |cgv33|mnz|8,wc|||; indicate result is not constant|17668
cgv33:
# getarg WC
        mov  XS,WC
# |cgv34|ica|7,xs|||; pop initial code offset|17672
cgv34:
# getarg XT
        addq $8,XT
# ||mov|8,wa|10,(xs)+||; restore old constant flag|17673
# getarg WA
        pop  WA
# ||mov|7,xl|10,(xs)+||; restore entry xl|17674
# getarg XL
        pop  XL
# ||mov|8,wb|10,(xs)+||; restore entry wb|17675
# getarg WB
        pop  WB
# ||bnz|8,wc|6,cgv35||; jump if not constant|17676
# getarg WC
# getarg WC
# getarg cgv35
        or   WC,WC
        jnz  cgv35
# ||mov|8,wc|8,wa||; else restore entry constant flag|17677
# getarg WA
# getarg WC
        movq WA,WC
# |cgv35|exi||||; return to cdgvl caller|17681
cgv35:
# getarg 
        ret
# |cgv36|jsr|6,cdwrd|||; generate word|17685
cgv36:
# getarg cdwrd
        call cdwrd
# ||bnz|8,wc|6,cgv34||; jump to exit if not constant|17686
# getarg WC
# getarg WC
# getarg cgv34
        or   WC,WC
        jnz  cgv34
# ||ejc|||||17687
# ||mov|8,wa|21,=orvl_||; load call to return value|17693
# getarg W0
# getarg WA
        movq l_0642,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17694
# getarg cdwrd
        call cdwrd
# ||mov|7,xl|9,(xs)||; load initial code offset|17695
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||jsr|6,exbld|||; build exblk for expression|17696
# getarg exbld
        call exbld
# ||zer|8,wb|||; set to evaluate by value|17697
# getarg WB
        xor  WB,WB
# ||jsr|6,evalx|||; evaluate expression|17698
# getarg evalx
        call evalx
        decq rcode
        js   call_215
# ||ppm||||; should not fail|17699
# getarg 
        decq rcode
        jns  l_0677
        movq $299,rcode
        jmp  err_
l_0677:
call_215:
# ||mov|8,wa|9,(xr)||; load type word of result|17700
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||blo|8,wa|22,=p_aaa|6,cgv37|; jump if not pattern|17701
# getarg WA
# getarg W0
# getarg cgv37
        movq l_0180,W0
        cmpq WA,W0
        jb   cgv37
# ||mov|8,wa|21,=olpt_||; else load special pattern load call|17702
# getarg W0
# getarg WA
        .data
l_0678: .long olpt_
        .text
        movq l_0678,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|17703
# getarg cdwrd
        call cdwrd
# |cgv37|mov|8,wa|7,xr||; copy constant pointer|17707
cgv37:
# getarg XR
# getarg WA
        movq XR,WA
# ||jsr|6,cdwrd|||; generate ptr|17708
# getarg cdwrd
        call cdwrd
# ||zer|8,wc|||; set result constant|17709
# getarg WC
        xor  WC,WC
# ||brn|6,cgv34|||; jump back to exit|17710
# getarg cgv34
        jmp  cgv34
# ||enp||||; end procedure cdgvl|17711
# ||ejc|||||17712
# |cdwrd|prc|25,e|1,0||; entry point|17730
cdwrd:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save entry xr|17731
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wa||; save code word to be generated|17732
# getarg WA
        push WA
# |cdwd1|mov|7,xr|3,r_ccb||; load ptr to ccblk being built|17736
cdwd1:
# getarg r_ccb
# getarg XR
        movq r_ccb,XR
# ||bnz|7,xr|6,cdwd2||; jump if block allocated|17737
# getarg XR
# getarg XR
# getarg cdwd2
        or   XR,XR
        jnz  cdwd2
# ||mov|8,wa|19,*e_cbs||; load initial length|17741
# getarg W0
# getarg WA
        .data
l_0679: .long 8*e_cbs
        .text
        movq l_0679,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate ccblk|17742
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_cct||; store type word|17743
# getarg W0
# getarg (XR)
        .data
l_0680: .long b_cct
        .text
        movq l_0680,W0
        movq W0,(XR)
# ||mov|3,cwcof|19,*cccod||; set initial offset|17744
# getarg W0
# getarg cwcof
        .data
l_0681: .long 8*cccod
        .text
        movq l_0681,W0
        movq W0,cwcof
# ||mov|13,cclen(xr)|8,wa||; store block length|17745
# getarg WA
# getarg cclen(,XR,8)
        movq WA,cclen(,XR,8)
# ||zer|13,ccsln(xr)|||; zero line number|17747
# getarg ccsln(,XR,8)
        mov  $0,W0
        mov  W0,ccsln(,XR,8)
# ||mov|3,r_ccb|7,xr||; store ptr to new block|17749
# getarg XR
# getarg r_ccb
        movq XR,r_ccb
# |cdwd2|mov|8,wa|3,cwcof||; load current offset|17753
cdwd2:
# getarg cwcof
# getarg WA
        movq cwcof,WA
# ||add|8,wa|19,*num05||; adjust for test (five words)|17755
# getarg W0
# getarg WA
        movq l_0626,W0
        addq W0,WA
# ||blo|8,wa|13,cclen(xr)|6,cdwd4|; jump if room in this block|17759
# getarg WA
# getarg cclen(,XR,8)
# getarg cdwd4
        cmpq WA,cclen(,XR,8)
        jb   cdwd4
# ||bge|8,wa|3,mxlen|6,cdwd5|; jump if already at max size|17763
# getarg WA
# getarg mxlen
# getarg cdwd5
        cmpq WA,mxlen
        jae  cdwd5
# ||add|8,wa|19,*e_cbs||; else get new size|17764
# getarg W0
# getarg WA
        movq l_0679,W0
        addq W0,WA
# ||mov|11,-(xs)|7,xl||; save entry xl|17765
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; copy pointer|17766
# getarg XR
# getarg XL
        movq XR,XL
# ||blt|8,wa|3,mxlen|6,cdwd3|; jump if not too large|17767
# getarg WA
# getarg mxlen
# getarg cdwd3
        cmpq WA,mxlen
        jb   cdwd3
# ||mov|8,wa|3,mxlen||; else reset to max allowed size|17768
# getarg mxlen
# getarg WA
        movq mxlen,WA
# ||ejc|||||17769
# |cdwd3|jsr|6,alloc|||; allocate new block|17775
cdwd3:
# getarg alloc
        call alloc
# ||mov|3,r_ccb|7,xr||; store pointer to new block|17776
# getarg XR
# getarg r_ccb
        movq XR,r_ccb
# ||mov|10,(xr)+|22,=b_cct||; store type word in new block|17777
# getarg W0
        movq l_0680,W0
        movq W0,W0
        stosq
# ||mov|10,(xr)+|8,wa||; store block length|17778
# getarg WA
        movq WA,W0
        stosq
# ||mov|10,(xr)+|13,ccsln(xl)||; copy source line number word|17780
# getarg ccsln(,XL,8)
        movq ccsln(,XL,8),W0
        stosq
# ||add|7,xl|19,*ccuse||; point to ccuse,cccod fields in old|17782
# getarg W0
# getarg XL
        .data
l_0682: .long 8*ccuse
        .text
        movq l_0682,W0
        addq W0,XL
# ||mov|8,wa|9,(xl)||; load ccuse value|17783
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||mvw||||; copy useful words from old block|17784
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0683:
        or   WA,WA
        jz   l_0684
        movsq
        decq WA
        jmp  l_0683
l_0684:
        cld
# ||mov|7,xl|10,(xs)+||; restore xl|17785
# getarg XL
        pop  XL
# ||brn|6,cdwd1|||; merge back to try again|17786
# getarg cdwd1
        jmp  cdwd1
# |cdwd4|mov|8,wa|3,cwcof||; load current offset|17790
cdwd4:
# getarg cwcof
# getarg WA
        movq cwcof,WA
# ||ica|8,wa|||; get new offset|17791
# getarg WA
        addq $8,WA
# ||mov|3,cwcof|8,wa||; store new offset|17792
# getarg WA
# getarg cwcof
        movq WA,cwcof
# ||mov|13,ccuse(xr)|8,wa||; store in ccblk for gbcol|17793
# getarg WA
# getarg ccuse(,XR,8)
        movq WA,ccuse(,XR,8)
# ||dca|8,wa|||; restore ptr to this word|17794
# getarg WA
        subq $8,WA
# ||add|7,xr|8,wa||; point to current entry|17795
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|8,wa|10,(xs)+||; reload word to generate|17796
# getarg WA
        pop  WA
# ||mov|9,(xr)|8,wa||; store word in block|17797
# getarg WA
# getarg (XR)
        movq WA,(XR)
# ||mov|7,xr|10,(xs)+||; restore entry xr|17798
# getarg XR
        pop  XR
# ||exi||||; return to caller|17799
# getarg 
        ret
# |cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||17803
cdwd5:
        movq $213,rcode
        jmp  err_
# ||enp||||; end procedure cdwrd|17804
# ||ejc|||||17805
# |cmgen|prc|25,r|1,0||; entry point, recursive|17818
cmgen:
# getarg 0
# ||mov|7,xr|7,xl||; copy cmblk pointer|17819
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xr|8,wb||; point to cmblk pointer|17820
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|7,xr|9,(xr)||; load cmblk pointer|17821
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||jsr|6,cdgvl|||; generate code by value|17822
# getarg cdgvl
        call cdgvl
# ||ica|8,wb|||; bump offset|17823
# getarg WB
        addq $8,WB
# ||exi||||; return to caller|17824
# getarg 
        ret
# ||enp||||; end procedure cmgen|17825
# ||ejc|||||17826
# ||ejc|||||17883
# ||ejc|||||17931
# |cmpil|prc|25,e|1,0||; entry point|17937
cmpil:
# getarg 0
# ||lct|8,wb|18,=cmnen||; set number of stack work locations|17938
# getarg WB
# getarg W0
        .data
l_0685: .long cmnen
        .text
        movq l_0685,W0
        mov  WB,W0
# |cmp00|zer|11,-(xs)|||; store a zero, make one entry|17942
cmp00:
        push $0
# ||bct|8,wb|6,cmp00||; loop back until all set|17943
# getarg WB
# getarg cmp00
        decq WB
        jnz  cmp00
# ||mov|3,cmpxs|7,xs||; save stack pointer for error sec|17944
# getarg XT
# getarg cmpxs
        movq XT,cmpxs
# ||sss|3,cmpss|||; save s-r stack pointer if any|17945
# |cmp01|mov|8,wb|3,scnpt||; set scan pointer offset|17949
cmp01:
# getarg scnpt
# getarg WB
        movq scnpt,WB
# ||mov|3,scnse|8,wb||; set start of element location|17950
# getarg WB
# getarg scnse
        movq WB,scnse
# ||mov|8,wa|21,=ocer_||; point to compile error call|17951
# getarg W0
# getarg WA
        .data
l_0686: .long ocer_
        .text
        movq l_0686,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate as temporary cdfal|17952
# getarg cdwrd
        call cdwrd
# ||blt|8,wb|3,scnil|6,cmp04|; jump if chars left on this image|17953
# getarg WB
# getarg scnil
# getarg cmp04
        cmpq WB,scnil
        jb   cmp04
# |cmpce|zer|7,xr|||; clear possible garbage xr value|17958
cmpce:
# getarg XR
        xor  XR,XR
# ||bnz|3,cnind|6,cmpc2||; if within include file|17960
# getarg cnind
# getarg cmpc2
        xor  W0,W0
        cmpq cnind,W0
        jnz  cmpc2
# ||bne|3,stage|18,=stgic|6,cmp02|; skip unless initial compile|17962
# getarg stage
# getarg W0
# getarg cmp02
        movq l_0053,W0
        cmpq stage,W0
        jne  cmp02
# |cmpc2|jsr|6,readr|||; read next input image|17963
cmpc2:
# getarg readr
        call readr
# ||bze|7,xr|6,cmp09||; jump if no input available|17964
# getarg XR
# getarg cmp09
        or   XR,XR
        jz   cmp09
# ||jsr|6,nexts|||; acquire next source image|17965
# getarg nexts
        call nexts
# ||mov|3,lstsn|3,cmpsn||; store stmt no for use by listr|17966
# getarg cmpsn
# getarg W0
# getarg lstsn
        movq cmpsn,W0
        movq W0,lstsn
# ||mov|3,cmpln|3,rdcln||; store line number at start of stmt|17967
# getarg rdcln
# getarg W0
# getarg cmpln
        movq rdcln,W0
        movq W0,cmpln
# ||zer|3,scnpt|||; reset scan pointer|17968
# getarg scnpt
        mov  $0,W0
        mov  W0,scnpt
# ||brn|6,cmp04|||; go process image|17969
# getarg cmp04
        jmp  cmp04
# |cmp02|mov|7,xr|3,r_cim||; get current image|17974
cmp02:
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||mov|8,wb|3,scnpt||; get current offset|17975
# getarg scnpt
# getarg WB
        movq scnpt,WB
# ||plc|7,xr|8,wb||; prepare to get chars|17976
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# |cmp03|bge|3,scnpt|3,scnil|6,cmp09|; end loop if end of image|17980
cmp03:
# getarg scnil
# getarg scnpt
# getarg W0
# getarg cmp09
        movq scnil,W0
        cmpq scnpt,W0
        jae  cmp09
# ||lch|8,wc|10,(xr)+||; get char|17981
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||icv|3,scnpt|||; advance offset|17982
# getarg scnpt
        incq scnpt
# ||bne|8,wc|18,=ch_sm|6,cmp03|; loop if not semi-colon|17983
# getarg WC
# getarg W0
# getarg cmp03
        .data
l_0687: .long ch_sm
        .text
        movq l_0687,W0
        cmpq WC,W0
        jne  cmp03
# ||ejc|||||17984
# |cmp04|mov|7,xr|3,r_cim||; point to current image|17992
cmp04:
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||mov|8,wb|3,scnpt||; load current offset|17993
# getarg scnpt
# getarg WB
        movq scnpt,WB
# ||mov|8,wa|8,wb||; copy for label scan|17994
# getarg WB
# getarg WA
        movq WB,WA
# ||plc|7,xr|8,wb||; point to first character|17995
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# ||lch|8,wc|10,(xr)+||; load first character|17996
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||beq|8,wc|18,=ch_sm|6,cmp12|; no label if semicolon|17997
# getarg WC
# getarg W0
# getarg cmp12
        movq l_0687,W0
        cmpq WC,W0
        je   cmp12
# ||beq|8,wc|18,=ch_as|6,cmpce|; loop back if comment card|17998
# getarg WC
# getarg W0
# getarg cmpce
        .data
l_0688: .long ch_as
        .text
        movq l_0688,W0
        cmpq WC,W0
        je   cmpce
# ||beq|8,wc|18,=ch_mn|6,cmp32|; jump if control card|17999
# getarg WC
# getarg W0
# getarg cmp32
        .data
l_0689: .long ch_mn
        .text
        movq l_0689,W0
        cmpq WC,W0
        je   cmp32
# ||mov|3,r_cmp|3,r_cim||; about to destroy r_cim|18000
# getarg r_cim
# getarg W0
# getarg r_cmp
        movq r_cim,W0
        movq W0,r_cmp
# ||mov|7,xl|20,=cmlab||; point to label work string|18001
# getarg W0
# getarg XL
        .data
l_0690: .long cmlab
        .text
        movq l_0690,W0
        movq W0,XL
# ||mov|3,r_cim|7,xl||; scane is to scan work string|18002
# getarg XL
# getarg r_cim
        movq XL,r_cim
# ||psc|7,xl|||; point to first character position|18003
# getarg XL
        add  $cfp_f,XL
# ||sch|8,wc|10,(xl)+||; store char just loaded|18004
# getarg WC
        movb
        inc  XL
# ||mov|8,wc|18,=ch_sm||; get a semicolon|18005
# getarg W0
# getarg WC
        movq l_0687,W0
        movq W0,WC
# ||sch|8,wc|9,(xl)||; store after first char|18006
# getarg WC
        movb
# ||csc|7,xl|||; finished character storing|18007
# ||zer|7,xl|||; clear pointer|18008
# getarg XL
        xor  XL,XL
# ||zer|3,scnpt|||; start at first character|18009
# getarg scnpt
        mov  $0,W0
        mov  W0,scnpt
# ||mov|11,-(xs)|3,scnil||; preserve image length|18010
# getarg scnil
        push scnil
# ||mov|3,scnil|18,=num02||; read 2 chars at most|18011
# getarg W0
# getarg scnil
        movq l_0130,W0
        movq W0,scnil
# ||jsr|6,scane|||; scan first char for type|18012
# getarg scane
        call scane
# ||mov|3,scnil|10,(xs)+||; restore image length|18013
# getarg scnil
        pop  scnil
# ||mov|8,wc|7,xl||; note return code|18014
# getarg XL
# getarg WC
        movq XL,WC
# ||mov|7,xl|3,r_cmp||; get old r_cim|18015
# getarg r_cmp
# getarg XL
        movq r_cmp,XL
# ||mov|3,r_cim|7,xl||; put it back|18016
# getarg XL
# getarg r_cim
        movq XL,r_cim
# ||mov|3,scnpt|8,wb||; reinstate offset|18017
# getarg WB
# getarg scnpt
        movq WB,scnpt
# ||bnz|3,scnbl|6,cmp12||; blank seen - cant be label|18018
# getarg scnbl
# getarg cmp12
        xor  W0,W0
        cmpq scnbl,W0
        jnz  cmp12
# ||mov|7,xr|7,xl||; point to current image|18019
# getarg XL
# getarg XR
        movq XL,XR
# ||plc|7,xr|8,wb||; point to first char again|18020
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# ||beq|8,wc|18,=t_var|6,cmp06|; ok if letter|18021
# getarg WC
# getarg W0
# getarg cmp06
        .data
l_0691: .long t_var
        .text
        movq l_0691,W0
        cmpq WC,W0
        je   cmp06
# ||beq|8,wc|18,=t_con|6,cmp06|; ok if digit|18022
# getarg WC
# getarg W0
# getarg cmp06
        .data
l_0692: .long t_con
        .text
        movq l_0692,W0
        cmpq WC,W0
        je   cmp06
# |cmple|mov|3,r_cim|3,r_cmp||; point to bad line|18026
cmple:
# getarg r_cmp
# getarg W0
# getarg r_cim
        movq r_cmp,W0
        movq W0,r_cim
# ||erb|1,214|26,bad label or misplaced continuation line|||18027
        movq $214,rcode
        jmp  err_
# |cmp05|beq|8,wc|18,=ch_sm|6,cmp07|; skip if semicolon|18031
cmp05:
# getarg WC
# getarg W0
# getarg cmp07
        movq l_0687,W0
        cmpq WC,W0
        je   cmp07
# ||icv|8,wa|||; bump offset|18032
# getarg WA
        incq WA
# ||beq|8,wa|3,scnil|6,cmp07|; jump if end of image (label end)|18033
# getarg WA
# getarg scnil
# getarg cmp07
        cmpq WA,scnil
        je   cmp07
# ||ejc|||||18034
# |cmp06|lch|8,wc|10,(xr)+||; else load next character|18040
cmp06:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||beq|8,wc|18,=ch_ht|6,cmp07|; jump if horizontal tab|18042
# getarg WC
# getarg W0
# getarg cmp07
        .data
l_0693: .long ch_ht
        .text
        movq l_0693,W0
        cmpq WC,W0
        je   cmp07
# ||bne|8,wc|18,=ch_bl|6,cmp05|; loop back if non-blank|18047
# getarg WC
# getarg W0
# getarg cmp05
        movq l_0572,W0
        cmpq WC,W0
        jne  cmp05
# |cmp07|mov|3,scnpt|8,wa||; save updated scan offset|18051
cmp07:
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||sub|8,wa|8,wb||; get length of label|18052
# getarg WB
# getarg WA
        subq WB,WA
# ||bze|8,wa|6,cmp12||; skip if label length zero|18053
# getarg WA
# getarg cmp12
        or   WA,WA
        jz   cmp12
# ||zer|7,xr|||; clear garbage xr value|18054
# getarg XR
        xor  XR,XR
# ||jsr|6,sbstr|||; build scblk for label name|18055
# getarg sbstr
        call sbstr
# ||jsr|6,gtnvr|||; locate/contruct vrblk|18056
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_216
# ||ppm||||; dummy (impossible) error return|18057
# getarg 
        decq rcode
        jns  l_0694
        movq $299,rcode
        jmp  err_
l_0694:
call_216:
# ||mov|13,cmlbl(xs)|7,xr||; store label pointer|18058
# getarg XR
# getarg cmlbl(,XT,8)
        movq XR,cmlbl(,XT,8)
# ||bnz|13,vrlen(xr)|6,cmp11||; jump if not system label|18059
# getarg vrlen(,XR,8)
# getarg cmp11
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  cmp11
# ||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|; jump if not end label|18060
# getarg vrsvp(,XR,8)
# getarg W0
# getarg cmp11
        .data
l_0695: .long v_end
        .text
        movq l_0695,W0
        cmpq vrsvp(,XR,8),W0
        jne  cmp11
# ||add|3,stage|18,=stgnd||; adjust stage appropriately|18064
# getarg W0
# getarg stage
        .data
l_0696: .long stgnd
        .text
        movq l_0696,W0
        addq W0,stage
# ||jsr|6,scane|||; scan out next element|18065
# getarg scane
        call scane
# ||beq|7,xl|18,=t_smc|6,cmp10|; jump if end of image|18066
# getarg XL
# getarg W0
# getarg cmp10
        .data
l_0697: .long t_smc
        .text
        movq l_0697,W0
        cmpq XL,W0
        je   cmp10
# ||bne|7,xl|18,=t_var|6,cmp08|; else error if not variable|18067
# getarg XL
# getarg W0
# getarg cmp08
        movq l_0691,W0
        cmpq XL,W0
        jne  cmp08
# ||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|; jump if not defined (error)|18071
# getarg vrlbl(,XR,8)
# getarg W0
# getarg cmp08
        movq l_0157,W0
        cmpq vrlbl(,XR,8),W0
        je   cmp08
# ||mov|13,cmtra(xs)|13,vrlbl(xr)||; else set initial entry pointer|18072
# getarg vrlbl(,XR,8)
# getarg W0
# getarg cmtra(,XT,8)
        movq vrlbl(,XR,8),W0
        movq W0,cmtra(,XT,8)
# ||jsr|6,scane|||; scan next element|18073
# getarg scane
        call scane
# ||beq|7,xl|18,=t_smc|6,cmp10|; jump if ok (end of image)|18074
# getarg XL
# getarg W0
# getarg cmp10
        movq l_0697,W0
        cmpq XL,W0
        je   cmp10
# |cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||18078
cmp08:
        movq $215,rcode
        jmp  err_
# |cmp09|zer|7,xr|||; clear garbage xr value|18082
cmp09:
# getarg XR
        xor  XR,XR
# ||add|3,stage|18,=stgnd||; adjust stage appropriately|18083
# getarg W0
# getarg stage
        movq l_0696,W0
        addq W0,stage
# ||beq|3,stage|18,=stgxe|6,cmp10|; jump if code call (ok)|18084
# getarg stage
# getarg W0
# getarg cmp10
        .data
l_0698: .long stgxe
        .text
        movq l_0698,W0
        cmpq stage,W0
        je   cmp10
# ||erb|1,216|26,syntax error: missing end line|||18085
        movq $216,rcode
        jmp  err_
# |cmp10|mov|8,wa|21,=ostp_||; set stop call pointer|18089
cmp10:
# getarg W0
# getarg WA
        .data
l_0699: .long ostp_
        .text
        movq l_0699,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate as statement call|18090
# getarg cdwrd
        call cdwrd
# ||brn|6,cmpse|||; jump to generate as failure|18091
# getarg cmpse
        jmp  cmpse
# ||ejc|||||18092
# |cmp11|bne|3,stage|18,=stgic|6,cmp12|; jump if code call - redef. ok|18098
cmp11:
# getarg stage
# getarg W0
# getarg cmp12
        movq l_0053,W0
        cmpq stage,W0
        jne  cmp12
# ||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|; else check for redefinition|18099
# getarg vrlbl(,XR,8)
# getarg W0
# getarg cmp12
        movq l_0157,W0
        cmpq vrlbl(,XR,8),W0
        je   cmp12
# ||zer|13,cmlbl(xs)|||; leave first label decln undisturbed|18100
# getarg cmlbl(,XT,8)
        mov  $0,W0
        mov  W0,cmlbl(,XT,8)
# ||erb|1,217|26,syntax error: duplicate label|||18101
        movq $217,rcode
        jmp  err_
# |cmp12|zer|8,wb|||; set flag for statement body|18108
cmp12:
# getarg WB
        xor  WB,WB
# ||jsr|6,expan|||; get tree for statement body|18109
# getarg expan
        call expan
# ||mov|13,cmstm(xs)|7,xr||; store for later use|18110
# getarg XR
# getarg cmstm(,XT,8)
        movq XR,cmstm(,XT,8)
# ||zer|13,cmsgo(xs)|||; clear success goto pointer|18111
# getarg cmsgo(,XT,8)
        mov  $0,W0
        mov  W0,cmsgo(,XT,8)
# ||zer|13,cmfgo(xs)|||; clear failure goto pointer|18112
# getarg cmfgo(,XT,8)
        mov  $0,W0
        mov  W0,cmfgo(,XT,8)
# ||zer|13,cmcgo(xs)|||; clear conditional goto flag|18113
# getarg cmcgo(,XT,8)
        mov  $0,W0
        mov  W0,cmcgo(,XT,8)
# ||jsr|6,scane|||; scan next element|18114
# getarg scane
        call scane
# ||beq|7,xl|18,=t_col|6,cmp13|; jump if colon (goto)|18115
# getarg XL
# getarg W0
# getarg cmp13
        .data
l_0700: .long t_col
        .text
        movq l_0700,W0
        cmpq XL,W0
        je   cmp13
# ||bnz|3,cswno|6,cmp18||; jump if not optimizing|18116
# getarg cswno
# getarg cmp18
        xor  W0,W0
        cmpq cswno,W0
        jnz  cmp18
# ||bnz|13,cmlbl(xs)|6,cmp18||; jump if label present|18117
# getarg cmlbl(,XT,8)
# getarg cmp18
        xor  W0,W0
        cmpq cmlbl(,XT,8),W0
        jnz  cmp18
# ||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18118
# getarg cmstm(,XT,8)
# getarg XR
        movq cmstm(,XT,8),XR
# ||mov|8,wa|9,(xr)||; load type word|18119
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_cmt|6,cmp18|; jump if cmblk|18120
# getarg WA
# getarg W0
# getarg cmp18
        movq l_0640,W0
        cmpq WA,W0
        je   cmp18
# ||bge|8,wa|22,=b_vra|6,cmp18|; jump if not icblk, scblk, or rcblk|18121
# getarg WA
# getarg W0
# getarg cmp18
        movq l_0653,W0
        cmpq WA,W0
        jae  cmp18
# ||mov|7,xl|3,r_ccb||; load ptr to ccblk|18122
# getarg r_ccb
# getarg XL
        movq r_ccb,XL
# ||mov|13,ccuse(xl)|19,*cccod||; reset use offset in ccblk|18123
# getarg W0
# getarg ccuse(,XL,8)
        movq l_0681,W0
        movq W0,ccuse(,XL,8)
# ||mov|3,cwcof|19,*cccod||; and in global|18124
# getarg W0
# getarg cwcof
        movq l_0681,W0
        movq W0,cwcof
# ||icv|3,cmpsn|||; bump statement number|18125
# getarg cmpsn
        incq cmpsn
# ||brn|6,cmp01|||; generate no code for statement|18126
# getarg cmp01
        jmp  cmp01
# |cmp13|mnz|3,scngo|||; set goto flag|18130
cmp13:
# getarg scngo
        mov  XS,scngo
# ||jsr|6,scane|||; scan next element|18131
# getarg scane
        call scane
# ||beq|7,xl|18,=t_smc|6,cmp31|; jump if no fields left|18132
# getarg XL
# getarg W0
# getarg cmp31
        movq l_0697,W0
        cmpq XL,W0
        je   cmp31
# ||beq|7,xl|18,=t_sgo|6,cmp14|; jump if s for success goto|18133
# getarg XL
# getarg W0
# getarg cmp14
        .data
l_0701: .long t_sgo
        .text
        movq l_0701,W0
        cmpq XL,W0
        je   cmp14
# ||beq|7,xl|18,=t_fgo|6,cmp16|; jump if f for failure goto|18134
# getarg XL
# getarg W0
# getarg cmp16
        .data
l_0702: .long t_fgo
        .text
        movq l_0702,W0
        cmpq XL,W0
        je   cmp16
# ||mnz|3,scnrs|||; set to rescan element not f,s|18138
# getarg scnrs
        mov  XS,scnrs
# ||jsr|6,scngf|||; scan out goto field|18139
# getarg scngf
        call scngf
# ||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already|18140
# getarg cmfgo(,XT,8)
# getarg cmp17
        xor  W0,W0
        cmpq cmfgo(,XT,8),W0
        jnz  cmp17
# ||mov|13,cmfgo(xs)|7,xr||; else set as fgoto|18141
# getarg XR
# getarg cmfgo(,XT,8)
        movq XR,cmfgo(,XT,8)
# ||brn|6,cmp15|||; merge with sgoto circuit|18142
# getarg cmp15
        jmp  cmp15
# |cmp14|jsr|6,scngf|||; scan success goto field|18146
cmp14:
# getarg scngf
        call scngf
# ||mov|13,cmcgo(xs)|18,=num01||; set conditional goto flag|18147
# getarg W0
# getarg cmcgo(,XT,8)
        movq l_0060,W0
        movq W0,cmcgo(,XT,8)
# |cmp15|bnz|13,cmsgo(xs)|6,cmp17||; error if sgoto already given|18151
cmp15:
# getarg cmsgo(,XT,8)
# getarg cmp17
        xor  W0,W0
        cmpq cmsgo(,XT,8),W0
        jnz  cmp17
# ||mov|13,cmsgo(xs)|7,xr||; else set sgoto|18152
# getarg XR
# getarg cmsgo(,XT,8)
        movq XR,cmsgo(,XT,8)
# ||brn|6,cmp13|||; loop back for next goto field|18153
# getarg cmp13
        jmp  cmp13
# |cmp16|jsr|6,scngf|||; scan goto field|18157
cmp16:
# getarg scngf
        call scngf
# ||mov|13,cmcgo(xs)|18,=num01||; set conditonal goto flag|18158
# getarg W0
# getarg cmcgo(,XT,8)
        movq l_0060,W0
        movq W0,cmcgo(,XT,8)
# ||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already given|18159
# getarg cmfgo(,XT,8)
# getarg cmp17
        xor  W0,W0
        cmpq cmfgo(,XT,8),W0
        jnz  cmp17
# ||mov|13,cmfgo(xs)|7,xr||; else store fgoto pointer|18160
# getarg XR
# getarg cmfgo(,XT,8)
        movq XR,cmfgo(,XT,8)
# ||brn|6,cmp13|||; loop back for next field|18161
# getarg cmp13
        jmp  cmp13
# ||ejc|||||18162
# |cmp17|erb|1,218|26,syntax error: duplicated goto field|||18168
cmp17:
        movq $218,rcode
        jmp  err_
# |cmp18|zer|3,scnse|||; stop positional error flags|18172
cmp18:
# getarg scnse
        mov  $0,W0
        mov  W0,scnse
# ||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18173
# getarg cmstm(,XT,8)
# getarg XR
        movq cmstm(,XT,8),XR
# ||zer|8,wb|||; collectable value for wb for cdgvl|18174
# getarg WB
        xor  WB,WB
# ||zer|8,wc|||; reset constant flag for cdgvl|18175
# getarg WC
        xor  WC,WC
# ||jsr|6,expap|||; test for pattern match|18176
# getarg expap
        call expap
        decq rcode
        js   call_217
# ||ppm|6,cmp19|||; jump if not pattern match|18177
# getarg cmp19
# getarg cmp19
        decq rcode
        jns  l_0703
        jmp  cmp19
l_0703:
call_217:
# ||mov|13,cmopn(xr)|21,=opms_||; else set pattern match pointer|18178
# getarg W0
# getarg cmopn(,XR,8)
        .data
l_0704: .long opms_
        .text
        movq l_0704,W0
        movq W0,cmopn(,XR,8)
# ||mov|13,cmtyp(xr)|18,=c_pmt||;|18179
# getarg W0
# getarg cmtyp(,XR,8)
        .data
l_0705: .long c_pmt
        .text
        movq l_0705,W0
        movq W0,cmtyp(,XR,8)
# |cmp19|jsr|6,cdgvl|||; generate code for body of statement|18183
cmp19:
# getarg cdgvl
        call cdgvl
# ||mov|7,xr|13,cmsgo(xs)||; load sgoto pointer|18184
# getarg cmsgo(,XT,8)
# getarg XR
        movq cmsgo(,XT,8),XR
# ||mov|8,wa|7,xr||; copy it|18185
# getarg XR
# getarg WA
        movq XR,WA
# ||bze|7,xr|6,cmp21||; jump if no success goto|18186
# getarg XR
# getarg cmp21
        or   XR,XR
        jz   cmp21
# ||zer|13,cmsoc(xs)|||; clear success offset fillin ptr|18187
# getarg cmsoc(,XT,8)
        mov  $0,W0
        mov  W0,cmsoc(,XT,8)
# ||bhi|7,xr|3,state|6,cmp20|; jump if complex goto|18188
# getarg XR
# getarg state
# getarg cmp20
        cmpq XR,state
        ja   cmp20
# ||add|8,wa|19,*vrtra||; point to vrtra field as required|18192
# getarg W0
# getarg WA
        movq l_0111,W0
        addq W0,WA
# ||jsr|6,cdwrd|||; generate success goto|18193
# getarg cdwrd
        call cdwrd
# ||brn|6,cmp22|||; jump to deal with fgoto|18194
# getarg cmp22
        jmp  cmp22
# |cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|; no code if same as fgoto|18198
cmp20:
# getarg XR
# getarg cmfgo(,XT,8)
# getarg cmp22
        cmpq XR,cmfgo(,XT,8)
        je   cmp22
# ||zer|8,wb|||; else set ok value for cdgvl in wb|18199
# getarg WB
        xor  WB,WB
# ||jsr|6,cdgcg|||; generate code for success goto|18200
# getarg cdgcg
        call cdgcg
# ||brn|6,cmp22|||; jump to deal with fgoto|18201
# getarg cmp22
        jmp  cmp22
# |cmp21|mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|18205
cmp21:
# getarg cwcof
# getarg W0
# getarg cmsoc(,XT,8)
        movq cwcof,W0
        movq W0,cmsoc(,XT,8)
# ||mov|8,wa|21,=ocer_||; point to compile error call|18206
# getarg W0
# getarg WA
        movq l_0686,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate as temporary value|18207
# getarg cdwrd
        call cdwrd
# ||ejc|||||18208
# |cmp22|mov|7,xr|13,cmfgo(xs)||; load failure goto pointer|18214
cmp22:
# getarg cmfgo(,XT,8)
# getarg XR
        movq cmfgo(,XT,8),XR
# ||mov|8,wa|7,xr||; copy it|18215
# getarg XR
# getarg WA
        movq XR,WA
# ||zer|13,cmffc(xs)|||; set no fill in required yet|18216
# getarg cmffc(,XT,8)
        mov  $0,W0
        mov  W0,cmffc(,XT,8)
# ||bze|7,xr|6,cmp23||; jump if no failure goto given|18217
# getarg XR
# getarg cmp23
        or   XR,XR
        jz   cmp23
# ||add|8,wa|19,*vrtra||; point to vrtra field in case|18218
# getarg W0
# getarg WA
        movq l_0111,W0
        addq W0,WA
# ||blo|7,xr|3,state|6,cmpse|; jump to gen if simple fgoto|18219
# getarg XR
# getarg state
# getarg cmpse
        cmpq XR,state
        jb   cmpse
# ||mov|8,wb|3,cwcof||; save offset to o_gof call|18223
# getarg cwcof
# getarg WB
        movq cwcof,WB
# ||mov|8,wa|21,=ogof_||; point to failure goto call|18224
# getarg W0
# getarg WA
        .data
l_0706: .long ogof_
        .text
        movq l_0706,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate|18225
# getarg cdwrd
        call cdwrd
# ||mov|8,wa|21,=ofif_||; point to fail in fail word|18226
# getarg W0
# getarg WA
        .data
l_0707: .long ofif_
        .text
        movq l_0707,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate|18227
# getarg cdwrd
        call cdwrd
# ||jsr|6,cdgcg|||; generate code for failure goto|18228
# getarg cdgcg
        call cdgcg
# ||mov|8,wa|8,wb||; copy offset to o_gof for cdfal|18229
# getarg WB
# getarg WA
        movq WB,WA
# ||mov|8,wb|22,=b_cdc||; set complex case cdtyp|18230
# getarg W0
# getarg WB
        movq l_0012,W0
        movq W0,WB
# ||brn|6,cmp25|||; jump to build cdblk|18231
# getarg cmp25
        jmp  cmp25
# |cmp23|mov|8,wa|21,=ounf_||; load unexpected failure call in cas|18235
cmp23:
# getarg W0
# getarg WA
        .data
l_0708: .long ounf_
        .text
        movq l_0708,W0
        movq W0,WA
# ||mov|8,wc|3,cswfl||; get -nofail flag|18236
# getarg cswfl
# getarg WC
        movq cswfl,WC
# ||orb|8,wc|13,cmcgo(xs)||; check if conditional goto|18237
# getarg WC
# getarg cmcgo(,XT,8)
        or   WC,cmcgo(,XT,8)
# ||zrb|8,wc|6,cmpse||; jump if -nofail and no cond. goto|18238
# getarg WC
# getarg WC
# getarg cmpse
        or   WC,WC
        jz   cmpse
# ||mnz|13,cmffc(xs)|||; else set fill in flag|18239
# getarg cmffc(,XT,8)
        mov  XS,cmffc(,XT,8)
# ||mov|8,wa|21,=ocer_||; and set compile error for temporary|18240
# getarg W0
# getarg WA
        movq l_0686,W0
        movq W0,WA
# |cmpse|mov|8,wb|22,=b_cds||; set cdtyp for simple case|18245
cmpse:
# getarg W0
# getarg WB
        movq l_0112,W0
        movq W0,WB
# ||ejc|||||18246
# |cmp25|mov|7,xr|3,r_ccb||; point to ccblk|18259
cmp25:
# getarg r_ccb
# getarg XR
        movq r_ccb,XR
# ||mov|7,xl|13,cmlbl(xs)||; get possible label pointer|18260
# getarg cmlbl(,XT,8)
# getarg XL
        movq cmlbl(,XT,8),XL
# ||bze|7,xl|6,cmp26||; skip if no label|18261
# getarg XL
# getarg cmp26
        or   XL,XL
        jz   cmp26
# ||zer|13,cmlbl(xs)|||; clear flag for next statement|18262
# getarg cmlbl(,XT,8)
        mov  $0,W0
        mov  W0,cmlbl(,XT,8)
# ||mov|13,vrlbl(xl)|7,xr||; put cdblk ptr in vrblk label field|18263
# getarg XR
# getarg vrlbl(,XL,8)
        movq XR,vrlbl(,XL,8)
# |cmp26|mov|9,(xr)|8,wb||; set type word for new cdblk|18267
cmp26:
# getarg WB
# getarg (XR)
        movq WB,(XR)
# ||mov|13,cdfal(xr)|8,wa||; set failure word|18268
# getarg WA
# getarg cdfal(,XR,8)
        movq WA,cdfal(,XR,8)
# ||mov|7,xl|7,xr||; copy pointer to ccblk|18269
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wb|13,ccuse(xr)||; load length gen (= new cdlen)|18270
# getarg ccuse(,XR,8)
# getarg WB
        movq ccuse(,XR,8),WB
# ||mov|8,wc|13,cclen(xr)||; load total ccblk length|18271
# getarg cclen(,XR,8)
# getarg WC
        movq cclen(,XR,8),WC
# ||add|7,xl|8,wb||; point past cdblk|18272
# getarg WB
# getarg XL
        addq WB,XL
# ||sub|8,wc|8,wb||; get length left for chop off|18273
# getarg WB
# getarg WC
        subq WB,WC
# ||mov|9,(xl)|22,=b_cct||; set type code for new ccblk at end|18274
# getarg W0
# getarg (XL)
        movq l_0680,W0
        movq W0,(XL)
# ||mov|13,ccuse(xl)|19,*cccod||; set initial code offset|18275
# getarg W0
# getarg ccuse(,XL,8)
        movq l_0681,W0
        movq W0,ccuse(,XL,8)
# ||mov|3,cwcof|19,*cccod||; reinitialise cwcof|18276
# getarg W0
# getarg cwcof
        movq l_0681,W0
        movq W0,cwcof
# ||mov|13,cclen(xl)|8,wc||; set new length|18277
# getarg WC
# getarg cclen(,XL,8)
        movq WC,cclen(,XL,8)
# ||mov|3,r_ccb|7,xl||; set new ccblk pointer|18278
# getarg XL
# getarg r_ccb
        movq XL,r_ccb
# ||zer|13,ccsln(xl)|||; initialize new line number|18280
# getarg ccsln(,XL,8)
        mov  $0,W0
        mov  W0,ccsln(,XL,8)
# ||mov|13,cdsln(xr)|3,cmpln||; set line number in old block|18281
# getarg cmpln
# getarg W0
# getarg cdsln(,XR,8)
        movq cmpln,W0
        movq W0,cdsln(,XR,8)
# ||mov|13,cdstm(xr)|3,cmpsn||; set statement number|18283
# getarg cmpsn
# getarg W0
# getarg cdstm(,XR,8)
        movq cmpsn,W0
        movq W0,cdstm(,XR,8)
# ||icv|3,cmpsn|||; bump statement number|18284
# getarg cmpsn
        incq cmpsn
# ||mov|7,xl|13,cmpcd(xs)||; load ptr to previous cdblk|18288
# getarg cmpcd(,XT,8)
# getarg XL
        movq cmpcd(,XT,8),XL
# ||bze|13,cmffp(xs)|6,cmp27||; jump if no failure fill in required|18289
# getarg cmffp(,XT,8)
# getarg cmp27
        xor  W0,W0
        cmpq cmffp(,XT,8),W0
        jz   cmp27
# ||mov|13,cdfal(xl)|7,xr||; else set failure ptr in previous|18290
# getarg XR
# getarg cdfal(,XL,8)
        movq XR,cdfal(,XL,8)
# |cmp27|mov|8,wa|13,cmsop(xs)||; load success offset|18294
cmp27:
# getarg cmsop(,XT,8)
# getarg WA
        movq cmsop(,XT,8),WA
# ||bze|8,wa|6,cmp28||; jump if no fill in required|18295
# getarg WA
# getarg cmp28
        or   WA,WA
        jz   cmp28
# ||add|7,xl|8,wa||; else point to fill in location|18296
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|9,(xl)|7,xr||; store forward pointer|18297
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||zer|7,xl|||; clear garbage xl value|18298
# getarg XL
        xor  XL,XL
# ||ejc|||||18299
# |cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||; copy failure fill in flag|18305
cmp28:
# getarg cmffc(,XT,8)
# getarg W0
# getarg cmffp(,XT,8)
        movq cmffc(,XT,8),W0
        movq W0,cmffp(,XT,8)
# ||mov|13,cmsop(xs)|13,cmsoc(xs)||; copy success fill in offset|18306
# getarg cmsoc(,XT,8)
# getarg W0
# getarg cmsop(,XT,8)
        movq cmsoc(,XT,8),W0
        movq W0,cmsop(,XT,8)
# ||mov|13,cmpcd(xs)|7,xr||; save ptr to this cdblk|18307
# getarg XR
# getarg cmpcd(,XT,8)
        movq XR,cmpcd(,XT,8)
# ||bnz|13,cmtra(xs)|6,cmp29||; jump if initial entry already set|18308
# getarg cmtra(,XT,8)
# getarg cmp29
        xor  W0,W0
        cmpq cmtra(,XT,8),W0
        jnz  cmp29
# ||mov|13,cmtra(xs)|7,xr||; else set ptr here as default|18309
# getarg XR
# getarg cmtra(,XT,8)
        movq XR,cmtra(,XT,8)
# |cmp29|blt|3,stage|18,=stgce|6,cmp01|; jump if not end line just done|18313
cmp29:
# getarg stage
# getarg W0
# getarg cmp01
        .data
l_0709: .long stgce
        .text
        movq l_0709,W0
        cmpq stage,W0
        jb   cmp01
# ||bze|3,cswls|6,cmp30||; skip if -nolist|18314
# getarg cswls
# getarg cmp30
        xor  W0,W0
        cmpq cswls,W0
        jz   cmp30
# ||jsr|6,listr|||; list last line|18315
# getarg listr
        call listr
# |cmp30|mov|7,xr|13,cmtra(xs)||; load initial entry cdblk pointer|18319
cmp30:
# getarg cmtra(,XT,8)
# getarg XR
        movq cmtra(,XT,8),XR
# ||add|7,xs|19,*cmnen||; pop work locations off stack|18320
# getarg W0
# getarg XT
        .data
l_0710: .long 8*cmnen
        .text
        movq l_0710,W0
        addq W0,XT
# ||exi||||; and return to cmpil caller|18321
# getarg 
        ret
# |cmp31|mov|8,wb|13,cmfgo(xs)||; get fail goto|18325
cmp31:
# getarg cmfgo(,XT,8)
# getarg WB
        movq cmfgo(,XT,8),WB
# ||orb|8,wb|13,cmsgo(xs)||; or in success goto|18326
# getarg WB
# getarg cmsgo(,XT,8)
        or   WB,cmsgo(,XT,8)
# ||bnz|8,wb|6,cmp18||; ok if non-null field|18327
# getarg WB
# getarg WB
# getarg cmp18
        or   WB,WB
        jnz  cmp18
# ||erb|1,219|26,syntax error: empty goto field|||18328
        movq $219,rcode
        jmp  err_
# |cmp32|icv|8,wb|||; point past ch_mn|18332
cmp32:
# getarg WB
        incq WB
# ||jsr|6,cncrd|||; process control card|18333
# getarg cncrd
        call cncrd
# ||zer|3,scnse|||; clear start of element loc.|18334
# getarg scnse
        mov  $0,W0
        mov  W0,scnse
# ||brn|6,cmpce|||; loop for next statement|18335
# getarg cmpce
        jmp  cmpce
# ||enp||||; end procedure cmpil|18336
# ||ejc|||||18337
# |cncrd|prc|25,e|1,0||; entry point|18348
cncrd:
# getarg 0
# ||mov|3,scnpt|8,wb||; offset for control card scan|18349
# getarg WB
# getarg scnpt
        movq WB,scnpt
# ||mov|8,wa|18,=ccnoc||; number of chars for comparison|18350
# getarg W0
# getarg WA
        .data
l_0711: .long ccnoc
        .text
        movq l_0711,W0
        movq W0,WA
# ||ctw|8,wa|1,0||; convert to word count|18351
# getarg WA
        add  ($8-1)+$cfp_c*0,WA
        shr  WA,log_cfp_c
# ||mov|3,cnswc|8,wa||; save word count|18352
# getarg WA
# getarg cnswc
        movq WA,cnswc
# |cnc01|bge|3,scnpt|3,scnil|6,cnc09|; return if end of image|18356
cnc01:
# getarg scnil
# getarg scnpt
# getarg W0
# getarg cnc09
        movq scnil,W0
        cmpq scnpt,W0
        jae  cnc09
# ||mov|7,xr|3,r_cim||; point to image|18357
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||plc|7,xr|3,scnpt||; char ptr for first char|18358
# getarg XR
# getarg scnpt
        add  $cfp_f,XR
        add  scnpt,XR
# ||lch|8,wa|10,(xr)+||; get first char|18359
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
        incq XR
# ||flc|8,wa|||; fold to lower case|18361
# getarg WA
        cmpb
        jb   l_0712
        cmpb
        ja   l_0712
        add  $32
l_0712:
# ||beq|8,wa|18,=ch_li|6,cnc07|; special case of -inxxx|18363
# getarg WA
# getarg W0
# getarg cnc07
        .data
l_0713: .long ch_li
        .text
        movq l_0713,W0
        cmpq WA,W0
        je   cnc07
# |cnc0a|mnz|3,scncc|||; set flag for scane|18364
cnc0a:
# getarg scncc
        mov  XS,scncc
# ||jsr|6,scane|||; scan card name|18365
# getarg scane
        call scane
# ||zer|3,scncc|||; clear scane flag|18366
# getarg scncc
        mov  $0,W0
        mov  W0,scncc
# ||bnz|7,xl|6,cnc06||; fail unless control card name|18367
# getarg XL
# getarg XL
# getarg cnc06
        or   XL,XL
        jnz  cnc06
# ||mov|8,wa|18,=ccnoc||; no. of chars to be compared|18368
# getarg W0
# getarg WA
        movq l_0711,W0
        movq W0,WA
# ||blt|13,sclen(xr)|8,wa|6,cnc08|; fail if too few chars|18370
# getarg sclen(,XR,8)
# getarg WA
# getarg cnc08
        cmpq sclen(,XR,8),WA
        jb   cnc08
# ||mov|7,xl|7,xr||; point to control card name|18374
# getarg XR
# getarg XL
        movq XR,XL
# ||zer|8,wb|||; zero offset for substring|18375
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; extract substring for comparison|18376
# getarg sbstr
        call sbstr
# ||mov|8,wa|13,sclen(xr)||; reload length|18378
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||jsr|6,flstg|||; fold to upper case|18379
# getarg flstg
        call flstg
# ||mov|3,cnscc|7,xr||; keep control card substring ptr|18381
# getarg XR
# getarg cnscc
        movq XR,cnscc
# ||mov|7,xr|21,=ccnms||; point to list of standard names|18382
# getarg W0
# getarg XR
        .data
l_0714: .long ccnms
        .text
        movq l_0714,W0
        movq W0,XR
# ||zer|8,wb|||; initialise name offset|18383
# getarg WB
        xor  WB,WB
# ||lct|8,wc|18,=cc_nc||; number of standard names|18384
# getarg WC
# getarg W0
        .data
l_0715: .long cc_nc
        .text
        movq l_0715,W0
        mov  WC,W0
# |cnc02|mov|7,xl|3,cnscc||; point to name|18388
cnc02:
# getarg cnscc
# getarg XL
        movq cnscc,XL
# ||lct|8,wa|3,cnswc||; counter for inner loop|18389
# getarg WA
# getarg cnswc
        mov  WA,cnswc
# ||brn|6,cnc04|||; jump into loop|18390
# getarg cnc04
        jmp  cnc04
# |cnc03|ica|7,xr|||; bump standard names ptr|18394
cnc03:
# getarg XR
        addq $8,XR
# ||ica|7,xl|||; bump name pointer|18395
# getarg XL
        addq $8,XL
# |cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|; comp. up to cfp_c chars at once|18399
cnc04:
# getarg (XR)
# getarg schar(,XL,8)
# getarg W0
# getarg cnc05
        movq (XR),W0
        cmpb schar(,XL,8),W0
        jnz  cnc05
# ||bct|8,wa|6,cnc03||; loop if more words to compare|18400
# getarg WA
# getarg cnc03
        decq WA
        jnz  cnc03
# ||ejc|||||18401
# ||mov|7,xl|8,wb||; get name offset|18407
# getarg WB
# getarg XL
        movq WB,XL
# ||bsw|7,xl|2,cc_nc|6,cnc08|; switch|18409
# getarg XL
# getarg cc_nc
# getarg cnc08
        cmpq XL,cc_nc
        jge  cnc08
        jmp  *l_0716(,XL,8)
        .data
l_0716:
# ||iff|2,cc_ca|6,cnc37||; -case|18448
# getarg cnc37
        .long cnc37
# ||iff|2,cc_do|6,cnc10||; -double|18448
# getarg cnc10
        .long cnc10
# ||iff|1,2|6,cnc08|||18448
# getarg cnc08
        .long cnc08
# ||iff|2,cc_du|6,cnc11||; -dump|18448
# getarg cnc11
        .long cnc11
# ||iff|2,cc_cp|6,cnc41||; -copy|18448
# getarg cnc41
        .long cnc41
# ||iff|2,cc_ej|6,cnc12||; -eject|18448
# getarg cnc12
        .long cnc12
# ||iff|2,cc_er|6,cnc13||; -errors|18448
# getarg cnc13
        .long cnc13
# ||iff|2,cc_ex|6,cnc14||; -execute|18448
# getarg cnc14
        .long cnc14
# ||iff|2,cc_fa|6,cnc15||; -fail|18448
# getarg cnc15
        .long cnc15
# ||iff|2,cc_in|6,cnc41||; -include|18448
# getarg cnc41
        .long cnc41
# ||iff|2,cc_ln|6,cnc44||; -line|18448
# getarg cnc44
        .long cnc44
# ||iff|2,cc_li|6,cnc16||; -list|18448
# getarg cnc16
        .long cnc16
# ||iff|2,cc_nr|6,cnc17||; -noerrors|18448
# getarg cnc17
        .long cnc17
# ||iff|2,cc_nx|6,cnc18||; -noexecute|18448
# getarg cnc18
        .long cnc18
# ||iff|2,cc_nf|6,cnc19||; -nofail|18448
# getarg cnc19
        .long cnc19
# ||iff|2,cc_nl|6,cnc20||; -nolist|18448
# getarg cnc20
        .long cnc20
# ||iff|2,cc_no|6,cnc21||; -noopt|18448
# getarg cnc21
        .long cnc21
# ||iff|2,cc_np|6,cnc22||; -noprint|18448
# getarg cnc22
        .long cnc22
# ||iff|2,cc_op|6,cnc24||; -optimise|18448
# getarg cnc24
        .long cnc24
# ||iff|2,cc_pr|6,cnc25||; -print|18448
# getarg cnc25
        .long cnc25
# ||iff|2,cc_si|6,cnc27||; -single|18448
# getarg cnc27
        .long cnc27
# ||iff|2,cc_sp|6,cnc28||; -space|18448
# getarg cnc28
        .long cnc28
# ||iff|2,cc_st|6,cnc31||; -stitle|18448
# getarg cnc31
        .long cnc31
# ||iff|2,cc_ti|6,cnc32||; -title|18448
# getarg cnc32
        .long cnc32
# ||iff|2,cc_tr|6,cnc36||; -trace|18448
# getarg cnc36
        .long cnc36
# ||esw||||; end switch|18448
        .text
# |cnc05|ica|7,xr|||; bump standard names ptr|18452
cnc05:
# getarg XR
        addq $8,XR
# ||bct|8,wa|6,cnc05||; loop|18453
# getarg WA
# getarg cnc05
        decq WA
        jnz  cnc05
# ||icv|8,wb|||; bump names offset|18454
# getarg WB
        incq WB
# ||bct|8,wc|6,cnc02||; continue if more names|18455
# getarg WC
# getarg cnc02
        decq WC
        jnz  cnc02
# ||brn|6,cnc08|||; ignore unrecognized control card|18457
# getarg cnc08
        jmp  cnc08
# |cnc06|erb|1,247|26,invalid control statement|||18462
cnc06:
        movq $247,rcode
        jmp  err_
# |cnc07|lch|8,wa|10,(xr)+||; get next char|18466
cnc07:
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
        incq XR
# ||flc|8,wa|||; fold to lower case|18468
# getarg WA
        cmpb
        jb   l_0717
        cmpb
        ja   l_0717
        add  $32
l_0717:
# ||bne|8,wa|18,=ch_ln|6,cnc0a|; if not letter n|18470
# getarg WA
# getarg W0
# getarg cnc0a
        .data
l_0718: .long ch_ln
        .text
        movq l_0718,W0
        cmpq WA,W0
        jne  cnc0a
# ||lch|8,wa|9,(xr)||; get third char|18471
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
# ||blt|8,wa|18,=ch_d0|6,cnc0a|; if not digit|18472
# getarg WA
# getarg W0
# getarg cnc0a
        .data
l_0719: .long ch_d0
        .text
        movq l_0719,W0
        cmpq WA,W0
        jb   cnc0a
# ||bgt|8,wa|18,=ch_d9|6,cnc0a|; if not digit|18473
# getarg WA
# getarg W0
# getarg cnc0a
        .data
l_0720: .long ch_d9
        .text
        movq l_0720,W0
        cmpq WA,W0
        ja   cnc0a
# ||add|3,scnpt|18,=num02||; bump offset past -in|18474
# getarg W0
# getarg scnpt
        movq l_0130,W0
        addq W0,scnpt
# ||jsr|6,scane|||; scan integer after -in|18475
# getarg scane
        call scane
# ||mov|11,-(xs)|7,xr||; stack scanned item|18476
# getarg XR
        push XR
# ||jsr|6,gtsmi|||; check if integer|18477
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_218
# ||ppm|6,cnc06|||; fail if not integer|18478
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0721
        jmp  cnc06
l_0721:
# ||ppm|6,cnc06|||; fail if negative or large|18479
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0722
        jmp  cnc06
l_0722:
call_218:
# ||mov|3,cswin|7,xr||; keep integer|18480
# getarg XR
# getarg cswin
        movq XR,cswin
# ||ejc|||||18481
# |cnc08|mov|8,wa|3,scnpt||; preserve in case xeq time compile|18487
cnc08:
# getarg scnpt
# getarg WA
        movq scnpt,WA
# ||jsr|6,scane|||; look for comma|18488
# getarg scane
        call scane
# ||beq|7,xl|18,=t_cma|6,cnc01|; loop if comma found|18489
# getarg XL
# getarg W0
# getarg cnc01
        .data
l_0723: .long t_cma
        .text
        movq l_0723,W0
        cmpq XL,W0
        je   cnc01
# ||mov|3,scnpt|8,wa||; restore scnpt in case xeq time|18490
# getarg WA
# getarg scnpt
        movq WA,scnpt
# |cnc09|exi||||; return|18494
cnc09:
# getarg 
        ret
# |cnc10|mnz|3,cswdb|||; set switch|18498
cnc10:
# getarg cswdb
        mov  XS,cswdb
# ||brn|6,cnc08|||; merge|18499
# getarg cnc08
        jmp  cnc08
# |cnc11|jsr|6,sysdm|||; call dumper|18505
cnc11:
# getarg sysdm
        call sysdm
# ||brn|6,cnc09|||; finished|18506
# getarg cnc09
        jmp  cnc09
# |cnc12|bze|3,cswls|6,cnc09||; return if -nolist|18510
cnc12:
# getarg cswls
# getarg cnc09
        xor  W0,W0
        cmpq cswls,W0
        jz   cnc09
# ||jsr|6,prtps|||; eject|18511
# getarg prtps
        call prtps
# ||jsr|6,listt|||; list title|18512
# getarg listt
        call listt
# ||brn|6,cnc09|||; finished|18513
# getarg cnc09
        jmp  cnc09
# |cnc13|zer|3,cswer|||; clear switch|18517
cnc13:
# getarg cswer
        mov  $0,W0
        mov  W0,cswer
# ||brn|6,cnc08|||; merge|18518
# getarg cnc08
        jmp  cnc08
# |cnc14|zer|3,cswex|||; clear switch|18522
cnc14:
# getarg cswex
        mov  $0,W0
        mov  W0,cswex
# ||brn|6,cnc08|||; merge|18523
# getarg cnc08
        jmp  cnc08
# |cnc15|mnz|3,cswfl|||; set switch|18527
cnc15:
# getarg cswfl
        mov  XS,cswfl
# ||brn|6,cnc08|||; merge|18528
# getarg cnc08
        jmp  cnc08
# |cnc16|mnz|3,cswls|||; set switch|18532
cnc16:
# getarg cswls
        mov  XS,cswls
# ||beq|3,stage|18,=stgic|6,cnc08|; done if compile time|18533
# getarg stage
# getarg W0
# getarg cnc08
        movq l_0053,W0
        cmpq stage,W0
        je   cnc08
# ||zer|3,lstpf|||; permit listing|18537
# getarg lstpf
        mov  $0,W0
        mov  W0,lstpf
# ||jsr|6,listr|||; list line|18538
# getarg listr
        call listr
# ||brn|6,cnc08|||; merge|18539
# getarg cnc08
        jmp  cnc08
# ||ejc|||||18540
# |cnc17|mnz|3,cswer|||; set switch|18546
cnc17:
# getarg cswer
        mov  XS,cswer
# ||brn|6,cnc08|||; merge|18547
# getarg cnc08
        jmp  cnc08
# |cnc18|mnz|3,cswex|||; set switch|18551
cnc18:
# getarg cswex
        mov  XS,cswex
# ||brn|6,cnc08|||; merge|18552
# getarg cnc08
        jmp  cnc08
# |cnc19|zer|3,cswfl|||; clear switch|18556
cnc19:
# getarg cswfl
        mov  $0,W0
        mov  W0,cswfl
# ||brn|6,cnc08|||; merge|18557
# getarg cnc08
        jmp  cnc08
# |cnc20|zer|3,cswls|||; clear switch|18561
cnc20:
# getarg cswls
        mov  $0,W0
        mov  W0,cswls
# ||brn|6,cnc08|||; merge|18562
# getarg cnc08
        jmp  cnc08
# |cnc21|mnz|3,cswno|||; set switch|18566
cnc21:
# getarg cswno
        mov  XS,cswno
# ||brn|6,cnc08|||; merge|18567
# getarg cnc08
        jmp  cnc08
# |cnc22|zer|3,cswpr|||; clear switch|18571
cnc22:
# getarg cswpr
        mov  $0,W0
        mov  W0,cswpr
# ||brn|6,cnc08|||; merge|18572
# getarg cnc08
        jmp  cnc08
# |cnc24|zer|3,cswno|||; clear switch|18576
cnc24:
# getarg cswno
        mov  $0,W0
        mov  W0,cswno
# ||brn|6,cnc08|||; merge|18577
# getarg cnc08
        jmp  cnc08
# |cnc25|mnz|3,cswpr|||; set switch|18581
cnc25:
# getarg cswpr
        mov  XS,cswpr
# ||brn|6,cnc08|||; merge|18582
# getarg cnc08
        jmp  cnc08
# ||ejc|||||18583
# |cnc27|zer|3,cswdb|||; clear switch|18589
cnc27:
# getarg cswdb
        mov  $0,W0
        mov  W0,cswdb
# ||brn|6,cnc08|||; merge|18590
# getarg cnc08
        jmp  cnc08
# |cnc28|bze|3,cswls|6,cnc09||; return if -nolist|18594
cnc28:
# getarg cswls
# getarg cnc09
        xor  W0,W0
        cmpq cswls,W0
        jz   cnc09
# ||jsr|6,scane|||; scan integer after -space|18595
# getarg scane
        call scane
# ||mov|8,wc|18,=num01||; 1 space in case|18596
# getarg W0
# getarg WC
        movq l_0060,W0
        movq W0,WC
# ||beq|7,xr|18,=t_smc|6,cnc29|; jump if no integer|18597
# getarg XR
# getarg W0
# getarg cnc29
        movq l_0697,W0
        cmpq XR,W0
        je   cnc29
# ||mov|11,-(xs)|7,xr||; stack it|18598
# getarg XR
        push XR
# ||jsr|6,gtsmi|||; check integer|18599
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_219
# ||ppm|6,cnc06|||; fail if not integer|18600
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0724
        jmp  cnc06
l_0724:
# ||ppm|6,cnc06|||; fail if negative or large|18601
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0725
        jmp  cnc06
l_0725:
call_219:
# ||bnz|8,wc|6,cnc29||; jump if non zero|18602
# getarg WC
# getarg WC
# getarg cnc29
        or   WC,WC
        jnz  cnc29
# ||mov|8,wc|18,=num01||; else 1 space|18603
# getarg W0
# getarg WC
        movq l_0060,W0
        movq W0,WC
# |cnc29|add|3,lstlc|8,wc||; bump line count|18607
cnc29:
# getarg WC
# getarg lstlc
        addq WC,lstlc
# ||lct|8,wc|8,wc||; convert to loop counter|18608
# ||blt|3,lstlc|3,lstnp|6,cnc30|; jump if fits on page|18609
# getarg lstnp
# getarg lstlc
# getarg W0
# getarg cnc30
        movq lstnp,W0
        cmpq lstlc,W0
        jb   cnc30
# ||jsr|6,prtps|||; eject|18610
# getarg prtps
        call prtps
# ||jsr|6,listt|||; list title|18611
# getarg listt
        call listt
# ||brn|6,cnc09|||; merge|18612
# getarg cnc09
        jmp  cnc09
# |cnc30|jsr|6,prtnl|||; print a blank|18616
cnc30:
# getarg prtnl
        call prtnl
# ||bct|8,wc|6,cnc30||; loop|18617
# getarg WC
# getarg cnc30
        decq WC
        jnz  cnc30
# ||brn|6,cnc09|||; merge|18618
# getarg cnc09
        jmp  cnc09
# ||ejc|||||18619
# |cnc31|mov|3,cnr_t|20,=r_stl||; ptr to r_stl|18625
cnc31:
# getarg W0
# getarg cnr_t
        .data
l_0726: .long r_stl
        .text
        movq l_0726,W0
        movq W0,cnr_t
# ||brn|6,cnc33|||; merge|18626
# getarg cnc33
        jmp  cnc33
# |cnc32|mov|3,r_stl|21,=nulls||; clear subtitle|18630
cnc32:
# getarg W0
# getarg r_stl
        movq l_0054,W0
        movq W0,r_stl
# ||mov|3,cnr_t|20,=r_ttl||; ptr to r_ttl|18631
# getarg W0
# getarg cnr_t
        .data
l_0727: .long r_ttl
        .text
        movq l_0727,W0
        movq W0,cnr_t
# |cnc33|mov|7,xr|21,=nulls||; null in case needed|18635
cnc33:
# getarg W0
# getarg XR
        movq l_0054,W0
        movq W0,XR
# ||mnz|3,cnttl|||; set flag for next listr call|18636
# getarg cnttl
        mov  XS,cnttl
# ||mov|8,wb|18,=ccofs||; offset to title/subtitle|18637
# getarg W0
# getarg WB
        .data
l_0728: .long ccofs
        .text
        movq l_0728,W0
        movq W0,WB
# ||mov|8,wa|3,scnil||; input image length|18638
# getarg scnil
# getarg WA
        movq scnil,WA
# ||blo|8,wa|8,wb|6,cnc34|; jump if no chars left|18639
# getarg WA
# getarg WB
# getarg cnc34
        cmpq WA,WB
        jb   cnc34
# ||sub|8,wa|8,wb||; no of chars to extract|18640
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|3,r_cim||; point to image|18641
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||jsr|6,sbstr|||; get title/subtitle|18642
# getarg sbstr
        call sbstr
# |cnc34|mov|7,xl|3,cnr_t||; point to storage location|18646
cnc34:
# getarg cnr_t
# getarg XL
        movq cnr_t,XL
# ||mov|9,(xl)|7,xr||; store title/subtitle|18647
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||beq|7,xl|20,=r_stl|6,cnc09|; return if stitl|18648
# getarg XL
# getarg W0
# getarg cnc09
        movq l_0726,W0
        cmpq XL,W0
        je   cnc09
# ||bnz|3,precl|6,cnc09||; return if extended listing|18649
# getarg precl
# getarg cnc09
        xor  W0,W0
        cmpq precl,W0
        jnz  cnc09
# ||bze|3,prich|6,cnc09||; return if regular printer|18650
# getarg prich
# getarg cnc09
        xor  W0,W0
        cmpq prich,W0
        jz   cnc09
# ||mov|7,xl|13,sclen(xr)||; get length of title|18651
# getarg sclen(,XR,8)
# getarg XL
        movq sclen(,XR,8),XL
# ||mov|8,wa|7,xl||; copy it|18652
# getarg XL
# getarg WA
        movq XL,WA
# ||bze|7,xl|6,cnc35||; jump if null|18653
# getarg XL
# getarg cnc35
        or   XL,XL
        jz   cnc35
# ||add|7,xl|18,=num10||; increment|18654
# getarg W0
# getarg XL
        movq l_0058,W0
        addq W0,XL
# ||bhi|7,xl|3,prlen|6,cnc09|; use default lstp0 val if too long|18655
# getarg XL
# getarg prlen
# getarg cnc09
        cmpq XL,prlen
        ja   cnc09
# ||add|8,wa|18,=num04||; point just past title|18656
# getarg W0
# getarg WA
        .data
l_0729: .long num04
        .text
        movq l_0729,W0
        addq W0,WA
# |cnc35|mov|3,lstpo|8,wa||; store offset|18660
cnc35:
# getarg WA
# getarg lstpo
        movq WA,lstpo
# ||brn|6,cnc09|||; return|18661
# getarg cnc09
        jmp  cnc09
# |cnc36|jsr|6,systt|||; toggle switch|18667
cnc36:
# getarg systt
        call systt
# ||brn|6,cnc08|||; merge|18668
# getarg cnc08
        jmp  cnc08
# |cnc37|jsr|6,scane|||; scan integer after -case|18675
cnc37:
# getarg scane
        call scane
# ||zer|8,wc|||; get 0 in case none there|18676
# getarg WC
        xor  WC,WC
# ||beq|7,xl|18,=t_smc|6,cnc38|; skip if no integer|18677
# getarg XL
# getarg W0
# getarg cnc38
        movq l_0697,W0
        cmpq XL,W0
        je   cnc38
# ||mov|11,-(xs)|7,xr||; stack it|18678
# getarg XR
        push XR
# ||jsr|6,gtsmi|||; check integer|18679
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_220
# ||ppm|6,cnc06|||; fail if not integer|18680
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0730
        jmp  cnc06
l_0730:
# ||ppm|6,cnc06|||; fail if negative or too large|18681
# getarg cnc06
# getarg cnc06
        decq rcode
        jns  l_0731
        jmp  cnc06
l_0731:
call_220:
# |cnc38|mov|3,kvcas|8,wc||; store new case value|18682
cnc38:
# getarg WC
# getarg kvcas
        movq WC,kvcas
# ||brn|6,cnc09|||; merge|18683
# getarg cnc09
        jmp  cnc09
# |cnc41|mnz|3,scncc|||; set flag for scane|18706
cnc41:
# getarg scncc
        mov  XS,scncc
# ||jsr|6,scane|||; scan quoted file name|18707
# getarg scane
        call scane
# ||zer|3,scncc|||; clear scane flag|18708
# getarg scncc
        mov  $0,W0
        mov  W0,scncc
# ||bne|7,xl|18,=t_con|6,cnc06|; if not constant|18709
# getarg XL
# getarg W0
# getarg cnc06
        movq l_0692,W0
        cmpq XL,W0
        jne  cnc06
# ||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18710
# getarg (XR)
# getarg W0
# getarg cnc06
        movq l_0094,W0
        cmpq (XR),W0
        jne  cnc06
# ||mov|3,r_ifn|7,xr||; save file name|18711
# getarg XR
# getarg r_ifn
        movq XR,r_ifn
# ||mov|7,xl|3,r_inc||; examine include file name table|18712
# getarg r_inc
# getarg XL
        movq r_inc,XL
# ||zer|8,wb|||; lookup by value|18713
# getarg WB
        xor  WB,WB
# ||jsr|6,tfind|||; do lookup|18714
# getarg tfind
        call tfind
        decq rcode
        js   call_221
# ||ppm||||; never fails|18715
# getarg 
        decq rcode
        jns  l_0732
        movq $299,rcode
        jmp  err_
l_0732:
call_221:
# ||beq|7,xr|21,=inton|6,cnc09|; ignore if already in table|18716
# getarg XR
# getarg W0
# getarg cnc09
        movq l_0063,W0
        cmpq XR,W0
        je   cnc09
# ||mnz|8,wb|||; set for trim|18717
# getarg WB
        mov  XS,WB
# ||mov|7,xr|3,r_ifn||; file name|18718
# getarg r_ifn
# getarg XR
        movq r_ifn,XR
# ||jsr|6,trimr|||; remove trailing blanks|18719
# getarg trimr
        call trimr
# ||mov|7,xl|3,r_inc||; include file name table|18720
# getarg r_inc
# getarg XL
        movq r_inc,XL
# ||mnz|8,wb|||; lookup by name this time|18721
# getarg WB
        mov  XS,WB
# ||jsr|6,tfind|||; do lookup|18722
# getarg tfind
        call tfind
        decq rcode
        js   call_222
# ||ppm||||; never fails|18723
# getarg 
        decq rcode
        jns  l_0733
        movq $299,rcode
        jmp  err_
l_0733:
call_222:
# ||mov|13,teval(xl)|21,=inton||; make table value integer 1|18724
# getarg W0
# getarg teval(,XL,8)
        movq l_0063,W0
        movq W0,teval(,XL,8)
# ||icv|3,cnind|||; increase nesting level|18725
# getarg cnind
        incq cnind
# ||mov|8,wa|3,cnind||; load new nest level|18726
# getarg cnind
# getarg WA
        movq cnind,WA
# ||bgt|8,wa|18,=ccinm|6,cnc42|; fail if excessive nesting|18727
# getarg WA
# getarg W0
# getarg cnc42
        movq l_0061,W0
        cmpq WA,W0
        ja   cnc42
# ||mov|7,xl|3,r_ifa||; array of nested file names|18732
# getarg r_ifa
# getarg XL
        movq r_ifa,XL
# ||add|8,wa|18,=vcvlb||; compute offset in words|18733
# getarg W0
# getarg WA
        movq l_0088,W0
        addq W0,WA
# ||wtb|8,wa|||; convert to bytes|18734
# getarg WA
        sal  WA,3
# ||add|7,xl|8,wa||; point to element|18735
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|9,(xl)|3,r_sfc||; record current file name|18736
# getarg r_sfc
# getarg W0
# getarg (XL)
        movq r_sfc,W0
        movq W0,(XL)
# ||mov|7,xl|8,wa||; preserve nesting byte offset|18737
# getarg WA
# getarg XL
        movq WA,XL
# ||mti|3,rdnln|||; fetch source line number as integer|18738
# getarg rdnln
        mov  rdnln,IA
# ||jsr|6,icbld|||; convert to icblk|18739
# getarg icbld
        call icbld
# ||add|7,xl|3,r_ifl||; entry in nested line number array|18740
# getarg r_ifl
# getarg XL
        addq r_ifl,XL
# ||mov|9,(xl)|7,xr||; record in array|18741
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||mov|8,wa|3,cswin||; max read length|18746
# getarg cswin
# getarg WA
        movq cswin,WA
# ||mov|7,xl|3,r_ifn||; include file name|18747
# getarg r_ifn
# getarg XL
        movq r_ifn,XL
# ||jsr|6,alocs|||; get buffer for complete file name|18748
# getarg alocs
        call alocs
# ||jsr|6,sysif|||; open include file|18749
# getarg sysif
        call sysif
        decq rcode
        js   call_223
# ||ppm|6,cnc43|||; could not open|18750
# getarg cnc43
# getarg cnc43
        decq rcode
        jns  l_0734
        jmp  cnc43
l_0734:
call_223:
# ||zer|8,wb|||; do not trim trailing blanks|18755
# getarg WB
        xor  WB,WB
# ||jsr|6,trimr|||; adjust scblk for actual length|18756
# getarg trimr
        call trimr
# ||mov|3,r_sfc|7,xr||; save ptr to file name|18757
# getarg XR
# getarg r_sfc
        movq XR,r_sfc
# ||mti|3,cmpsn|||; current statement as integer|18758
# getarg cmpsn
        mov  cmpsn,IA
# ||jsr|6,icbld|||; build icblk for stmt number|18759
# getarg icbld
        call icbld
# ||mov|7,xl|3,r_sfn||; file name table|18760
# getarg r_sfn
# getarg XL
        movq r_sfn,XL
# ||mnz|8,wb|||; lookup statement number by name|18761
# getarg WB
        mov  XS,WB
# ||jsr|6,tfind|||; allocate new teblk|18762
# getarg tfind
        call tfind
        decq rcode
        js   call_224
# ||ppm||||; always possible to allocate block|18763
# getarg 
        decq rcode
        jns  l_0735
        movq $299,rcode
        jmp  err_
l_0735:
call_224:
# ||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|18764
# getarg r_sfc
# getarg W0
# getarg teval(,XL,8)
        movq r_sfc,W0
        movq W0,teval(,XL,8)
# ||zer|3,rdnln|||; restart line counter for new file|18768
# getarg rdnln
        mov  $0,W0
        mov  W0,rdnln
# ||beq|3,stage|18,=stgic|6,cnc09|; if initial compile|18769
# getarg stage
# getarg W0
# getarg cnc09
        movq l_0053,W0
        cmpq stage,W0
        je   cnc09
# ||bne|3,cnind|18,=num01|6,cnc09|; if not first execute-time nesting|18770
# getarg cnind
# getarg W0
# getarg cnc09
        movq l_0060,W0
        cmpq cnind,W0
        jne  cnc09
# ||mov|3,r_ici|3,r_cim||; remember code argument string|18774
# getarg r_cim
# getarg W0
# getarg r_ici
        movq r_cim,W0
        movq W0,r_ici
# ||mov|3,cnspt|3,scnpt||; save position in string|18775
# getarg scnpt
# getarg W0
# getarg cnspt
        movq scnpt,W0
        movq W0,cnspt
# ||mov|3,cnsil|3,scnil||; and length of string|18776
# getarg scnil
# getarg W0
# getarg cnsil
        movq scnil,W0
        movq W0,cnsil
# ||brn|6,cnc09|||; all done, merge|18777
# getarg cnc09
        jmp  cnc09
# |cnc42|erb|1,284|26,excessively nested include files|||18781
cnc42:
        movq $284,rcode
        jmp  err_
# |cnc43|mov|3,dnamp|7,xr||; release allocated scblk|18785
cnc43:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||erb|1,285|26,include file cannot be opened|||18786
        movq $285,rcode
        jmp  err_
# |cnc44|jsr|6,scane|||; scan integer after -line|18793
cnc44:
# getarg scane
        call scane
# ||bne|7,xl|18,=t_con|6,cnc06|; jump if no line number|18794
# getarg XL
# getarg W0
# getarg cnc06
        movq l_0692,W0
        cmpq XL,W0
        jne  cnc06
# ||bne|9,(xr)|22,=b_icl|6,cnc06|; jump if not integer|18795
# getarg (XR)
# getarg W0
# getarg cnc06
        movq l_0087,W0
        cmpq (XR),W0
        jne  cnc06
# ||ldi|13,icval(xr)|||; fetch integer line number|18796
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||ile|6,cnc06|||; error if negative or zero|18797
# getarg cnc06
        mov  IA,W0
        or   W0,W0
        jle  cnc06
# ||beq|3,stage|18,=stgic|6,cnc45|; skip if initial compile|18798
# getarg stage
# getarg W0
# getarg cnc45
        movq l_0053,W0
        cmpq stage,W0
        je   cnc45
# ||mfi|3,cmpln|||; set directly for other compiles|18799
# getarg cmpln
        mov  IA,cmpln
# ||brn|6,cnc46|||; no need to set rdnln|18800
# getarg cnc46
        jmp  cnc46
# |cnc45|sbi|4,intv1|||; adjust number by one|18801
cnc45:
# getarg intv1
        sub  intv1,IA
        xor  W0,W0
        seto reg_fl
# ||mfi|3,rdnln|||; save line number|18802
# getarg rdnln
        mov  IA,rdnln
# |cnc46|mnz|3,scncc|||; set flag for scane|18804
cnc46:
# getarg scncc
        mov  XS,scncc
# ||jsr|6,scane|||; scan quoted file name|18805
# getarg scane
        call scane
# ||zer|3,scncc|||; clear scane flag|18806
# getarg scncc
        mov  $0,W0
        mov  W0,scncc
# ||beq|7,xl|18,=t_smc|6,cnc47|; done if no file name|18807
# getarg XL
# getarg W0
# getarg cnc47
        movq l_0697,W0
        cmpq XL,W0
        je   cnc47
# ||bne|7,xl|18,=t_con|6,cnc06|; error if not constant|18808
# getarg XL
# getarg W0
# getarg cnc06
        movq l_0692,W0
        cmpq XL,W0
        jne  cnc06
# ||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18809
# getarg (XR)
# getarg W0
# getarg cnc06
        movq l_0094,W0
        cmpq (XR),W0
        jne  cnc06
# ||jsr|6,newfn|||; record new file name|18810
# getarg newfn
        call newfn
# ||brn|6,cnc09|||; merge|18811
# getarg cnc09
        jmp  cnc09
# |cnc47|dcv|3,scnpt|||; set to rescan the terminator|18815
cnc47:
# getarg scnpt
        decq scnpt
# ||brn|6,cnc09|||; merge|18816
# getarg cnc09
        jmp  cnc09
# ||enp||||; end procedure cncrd|18821
# ||ejc|||||18822
# |dffnc|prc|25,e|1,0||; entry point|18904
dffnc:
# getarg 0
# ||bne|9,(xl)|22,=b_efc|6,dffn1|; skip if new function not external|18907
# getarg (XL)
# getarg W0
# getarg dffn1
        movq l_0443,W0
        cmpq (XL),W0
        jne  dffn1
# ||icv|13,efuse(xl)|||; else increment its use count|18908
# getarg efuse(,XL,8)
        incq efuse(,XL,8)
# |dffn1|mov|8,wa|7,xr||; save vrblk pointer|18912
dffn1:
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xr|13,vrfnc(xr)||; load old function pointer|18913
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_efc|6,dffn2|; jump if old function not external|18914
# getarg (XR)
# getarg W0
# getarg dffn2
        movq l_0443,W0
        cmpq (XR),W0
        jne  dffn2
# ||mov|8,wb|13,efuse(xr)||; else get use count|18915
# getarg efuse(,XR,8)
# getarg WB
        movq efuse(,XR,8),WB
# ||dcv|8,wb|||; decrement|18916
# getarg WB
        decq WB
# ||mov|13,efuse(xr)|8,wb||; store decremented value|18917
# getarg WB
# getarg efuse(,XR,8)
        movq WB,efuse(,XR,8)
# ||bnz|8,wb|6,dffn2||; jump if use count still non-zero|18918
# getarg WB
# getarg WB
# getarg dffn2
        or   WB,WB
        jnz  dffn2
# ||jsr|6,sysul|||; else call system unload function|18919
# getarg sysul
        call sysul
# |dffn2|mov|7,xr|8,wa||; restore vrblk pointer|18923
dffn2:
# getarg WA
# getarg XR
        movq WA,XR
# ||mov|8,wa|7,xl||; copy function block ptr|18925
# getarg XL
# getarg WA
        movq XL,WA
# ||blt|7,xr|20,=r_yyy|6,dffn3|; skip checks if opsyn op definition|18926
# getarg XR
# getarg W0
# getarg dffn3
        movq l_0039,W0
        cmpq XR,W0
        jb   dffn3
# ||bnz|13,vrlen(xr)|6,dffn3||; jump if not system variable|18927
# getarg vrlen(,XR,8)
# getarg dffn3
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  dffn3
# ||mov|7,xl|13,vrsvp(xr)||; point to svblk|18931
# getarg vrsvp(,XR,8)
# getarg XL
        movq vrsvp(,XR,8),XL
# ||mov|8,wb|13,svbit(xl)||; load bit indicators|18932
# getarg svbit(,XL,8)
# getarg WB
        movq svbit(,XL,8),WB
# ||anb|8,wb|4,btfnc||; is it a system function|18933
# getarg WB
# getarg btfnc
        and  WB,btfnc
# ||zrb|8,wb|6,dffn3||; redef ok if not|18934
# getarg WB
# getarg WB
# getarg dffn3
        or   WB,WB
        jz   dffn3
# ||erb|1,248|26,attempted redefinition of system function|||18935
        movq $248,rcode
        jmp  err_
# |dffn3|mov|13,vrfnc(xr)|8,wa||; store new function pointer|18939
dffn3:
# getarg WA
# getarg vrfnc(,XR,8)
        movq WA,vrfnc(,XR,8)
# ||mov|7,xl|8,wa||; restore function block pointer|18940
# getarg WA
# getarg XL
        movq WA,XL
# ||exi||||; return to dffnc caller|18941
# getarg 
        ret
# ||enp||||; end procedure dffnc|18942
# ||ejc|||||18943
# |dtach|prc|25,e|1,0||; entry point|18957
dtach:
# getarg 0
# ||mov|3,dtcnb|7,xl||; store name base (gbcol not called)|18958
# getarg XL
# getarg dtcnb
        movq XL,dtcnb
# ||add|7,xl|8,wa||; point to name location|18959
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|3,dtcnm|7,xl||; store it|18960
# getarg XL
# getarg dtcnm
        movq XL,dtcnm
# |dtch1|mov|7,xr|7,xl||; copy name pointer|18964
dtch1:
# getarg XL
# getarg XR
        movq XL,XR
# |dtch2|mov|7,xl|9,(xl)||; point to next value|18968
dtch2:
# getarg (XL)
# getarg XL
        movq (XL),XL
# ||bne|9,(xl)|22,=b_trt|6,dtch6|; jump at chain end|18969
# getarg (XL)
# getarg W0
# getarg dtch6
        movq l_0154,W0
        cmpq (XL),W0
        jne  dtch6
# ||mov|8,wa|13,trtyp(xl)||; get trap block type|18970
# getarg trtyp(,XL,8)
# getarg WA
        movq trtyp(,XL,8),WA
# ||beq|8,wa|18,=trtin|6,dtch3|; jump if input|18971
# getarg WA
# getarg W0
# getarg dtch3
        movq l_0066,W0
        cmpq WA,W0
        je   dtch3
# ||beq|8,wa|18,=trtou|6,dtch3|; jump if output|18972
# getarg WA
# getarg W0
# getarg dtch3
        movq l_0068,W0
        cmpq WA,W0
        je   dtch3
# ||add|7,xl|19,*trnxt||; point to next link|18973
# getarg W0
# getarg XL
        .data
l_0736: .long 8*trnxt
        .text
        movq l_0736,W0
        addq W0,XL
# ||brn|6,dtch1|||; loop|18974
# getarg dtch1
        jmp  dtch1
# |dtch3|mov|9,(xr)|13,trval(xl)||; delete trblk|18978
dtch3:
# getarg trval(,XL,8)
# getarg W0
# getarg (XR)
        movq trval(,XL,8),W0
        movq W0,(XR)
# ||mov|8,wa|7,xl||; dump xl ...|18979
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|8,wb|7,xr||; ... and xr|18980
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xl|13,trtrf(xl)||; point to trtrf trap block|18981
# getarg trtrf(,XL,8)
# getarg XL
        movq trtrf(,XL,8),XL
# ||bze|7,xl|6,dtch5||; jump if no iochn|18982
# getarg XL
# getarg dtch5
        or   XL,XL
        jz   dtch5
# ||bne|9,(xl)|22,=b_trt|6,dtch5|; jump if input, output, terminal|18983
# getarg (XL)
# getarg W0
# getarg dtch5
        movq l_0154,W0
        cmpq (XL),W0
        jne  dtch5
# |dtch4|mov|7,xr|7,xl||; remember link ptr|18987
dtch4:
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|13,trtrf(xl)||; point to next link|18988
# getarg trtrf(,XL,8)
# getarg XL
        movq trtrf(,XL,8),XL
# ||bze|7,xl|6,dtch5||; jump if end of chain|18989
# getarg XL
# getarg dtch5
        or   XL,XL
        jz   dtch5
# ||mov|8,wc|13,ionmb(xl)||; get name base|18990
# getarg ionmb(,XL,8)
# getarg WC
        movq ionmb(,XL,8),WC
# ||add|8,wc|13,ionmo(xl)||; add offset|18991
# getarg ionmo(,XL,8)
# getarg WC
        addq ionmo(,XL,8),WC
# ||bne|8,wc|3,dtcnm|6,dtch4|; loop if no match|18992
# getarg WC
# getarg dtcnm
# getarg dtch4
        cmpq WC,dtcnm
        jne  dtch4
# ||mov|13,trtrf(xr)|13,trtrf(xl)||; remove name from chain|18993
# getarg trtrf(,XL,8)
# getarg W0
# getarg trtrf(,XR,8)
        movq trtrf(,XL,8),W0
        movq W0,trtrf(,XR,8)
# ||ejc|||||18994
# |dtch5|mov|7,xl|8,wa||; recover xl ...|19000
dtch5:
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|7,xr|8,wb||; ... and xr|19001
# getarg WB
# getarg XR
        movq WB,XR
# ||add|7,xl|19,*trval||; point to value field|19002
# getarg W0
# getarg XL
        movq l_0032,W0
        addq W0,XL
# ||brn|6,dtch2|||; continue|19003
# getarg dtch2
        jmp  dtch2
# |dtch6|mov|7,xr|3,dtcnb||; possible vrblk ptr|19007
dtch6:
# getarg dtcnb
# getarg XR
        movq dtcnb,XR
# ||jsr|6,setvr|||; reset vrblk if necessary|19008
# getarg setvr
        call setvr
# ||exi||||; return|19009
# getarg 
        ret
# ||enp||||; end procedure dtach|19010
# ||ejc|||||19011
# |dtype|prc|25,e|1,0||; entry point|19019
dtype:
# getarg 0
# ||beq|9,(xr)|22,=b_pdt|6,dtyp1|; jump if prog.defined|19020
# getarg (XR)
# getarg W0
# getarg dtyp1
        movq l_0139,W0
        cmpq (XR),W0
        je   dtyp1
# ||mov|7,xr|9,(xr)||; load type word|19021
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||lei|7,xr|||; get entry point id (block code)|19022
        dec  XR
        mov  (XR),%al
        movzbq %al,XR
# ||wtb|7,xr|||; convert to byte offset|19023
# getarg XR
        sal  XR,3
# ||mov|7,xr|14,scnmt(xr)||; load table entry|19024
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||exi||||; exit to dtype caller|19025
# getarg 
        ret
# |dtyp1|mov|7,xr|13,pddfp(xr)||; point to dfblk|19029
dtyp1:
# getarg pddfp(,XR,8)
# getarg XR
        movq pddfp(,XR,8),XR
# ||mov|7,xr|13,dfnam(xr)||; get datatype name from dfblk|19030
# getarg dfnam(,XR,8)
# getarg XR
        movq dfnam(,XR,8),XR
# ||exi||||; return to dtype caller|19031
# getarg 
        ret
# ||enp||||; end procedure dtype|19032
# ||ejc|||||19033
# |dumpr|prc|25,e|1,0||; entry point|19054
dumpr:
# getarg 0
# ||bze|7,xr|6,dmp28||; skip dump if argument is zero|19055
# getarg XR
# getarg dmp28
        or   XR,XR
        jz   dmp28
# ||bgt|7,xr|18,=num03|6,dmp29|; jump if core dump required|19056
# getarg XR
# getarg W0
# getarg dmp29
        movq l_0350,W0
        cmpq XR,W0
        ja   dmp29
# ||zer|7,xl|||; clear xl|19057
# getarg XL
        xor  XL,XL
# ||zer|8,wb|||; zero move offset|19058
# getarg WB
        xor  WB,WB
# ||mov|3,dmarg|7,xr||; save dump argument|19059
# getarg XR
# getarg dmarg
        movq XR,dmarg
# ||zer|3,dnams|||; collect sediment too|19061
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# ||jsr|6,gbcol|||; collect garbage|19063
# getarg gbcol
        call gbcol
# ||jsr|6,prtpg|||; eject printer|19064
# getarg prtpg
        call prtpg
# ||mov|7,xr|21,=dmhdv||; point to heading for variables|19065
# getarg W0
# getarg XR
        .data
l_0737: .long dmhdv
        .text
        movq l_0737,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|19066
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; terminate print line|19067
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; and print a blank line|19068
# getarg prtnl
        call prtnl
# ||zer|3,dmvch|||; set null chain to start|19081
# getarg dmvch
        mov  $0,W0
        mov  W0,dmvch
# ||mov|8,wa|3,hshtb||; point to hash table|19082
# getarg hshtb
# getarg WA
        movq hshtb,WA
# |dmp00|mov|7,xr|8,wa||; copy hash bucket pointer|19086
dmp00:
# getarg WA
# getarg XR
        movq WA,XR
# ||ica|8,wa|||; bump pointer|19087
# getarg WA
        addq $8,WA
# ||sub|7,xr|19,*vrnxt||; set offset to merge|19088
# getarg W0
# getarg XR
        movq l_0034,W0
        subq W0,XR
# |dmp01|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|19092
dmp01:
# getarg vrnxt(,XR,8)
# getarg XR
        movq vrnxt(,XR,8),XR
# ||bze|7,xr|6,dmp09||; jump if end of this hash chain|19093
# getarg XR
# getarg dmp09
        or   XR,XR
        jz   dmp09
# ||mov|7,xl|7,xr||; else copy vrblk pointer|19094
# getarg XR
# getarg XL
        movq XR,XL
# ||ejc|||||19095
# |dmp02|mov|7,xl|13,vrval(xl)||; load value|19101
dmp02:
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||beq|3,dmarg|18,=num03|6,dmp2a|; skip null value check if dump(3)|19102
# getarg dmarg
# getarg W0
# getarg dmp2a
        movq l_0350,W0
        cmpq dmarg,W0
        je   dmp2a
# ||beq|7,xl|21,=nulls|6,dmp01|; loop for next vrblk if null value|19103
# getarg XL
# getarg W0
# getarg dmp01
        movq l_0054,W0
        cmpq XL,W0
        je   dmp01
# |dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|; loop back if value is trapped|19104
dmp2a:
# getarg (XL)
# getarg W0
# getarg dmp02
        movq l_0154,W0
        cmpq (XL),W0
        je   dmp02
# ||mov|8,wc|7,xr||; save vrblk pointer|19108
# getarg XR
# getarg WC
        movq XR,WC
# ||add|7,xr|19,*vrsof||; adjust ptr to be like scblk ptr|19109
# getarg W0
# getarg XR
        .data
l_0738: .long 8*vrsof
        .text
        movq l_0738,W0
        addq W0,XR
# ||bnz|13,sclen(xr)|6,dmp03||; jump if non-system variable|19110
# getarg sclen(,XR,8)
# getarg dmp03
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jnz  dmp03
# ||mov|7,xr|13,vrsvo(xr)||; else load ptr to name in svblk|19111
# getarg vrsvo(,XR,8)
# getarg XR
        movq vrsvo(,XR,8),XR
# |dmp03|mov|8,wb|7,xr||; save pointer to chars|19115
dmp03:
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|3,dmpsv|8,wa||; save hash bucket pointer|19116
# getarg WA
# getarg dmpsv
        movq WA,dmpsv
# ||mov|8,wa|20,=dmvch||; point to chain head|19117
# getarg W0
# getarg WA
        .data
l_0739: .long dmvch
        .text
        movq l_0739,W0
        movq W0,WA
# |dmp04|mov|3,dmpch|8,wa||; save chain pointer|19121
dmp04:
# getarg WA
# getarg dmpch
        movq WA,dmpch
# ||mov|7,xl|8,wa||; copy it|19122
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|7,xr|9,(xl)||; load pointer to next entry|19123
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||bze|7,xr|6,dmp08||; jump if end of chain to insert|19124
# getarg XR
# getarg dmp08
        or   XR,XR
        jz   dmp08
# ||add|7,xr|19,*vrsof||; else get name ptr for chained vrblk|19125
# getarg W0
# getarg XR
        movq l_0738,W0
        addq W0,XR
# ||bnz|13,sclen(xr)|6,dmp05||; jump if not system variable|19126
# getarg sclen(,XR,8)
# getarg dmp05
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jnz  dmp05
# ||mov|7,xr|13,vrsvo(xr)||; else point to name in svblk|19127
# getarg vrsvo(,XR,8)
# getarg XR
        movq vrsvo(,XR,8),XR
# |dmp05|mov|7,xl|8,wb||; point to entering vrblk string|19137
dmp05:
# getarg WB
# getarg XL
        movq WB,XL
# ||mov|8,wa|13,sclen(xl)||; load its length|19138
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||plc|7,xl|||; point to chars of entering string|19139
# getarg XL
        add  $cfp_f,XL
# ||bhi|8,wa|13,sclen(xr)|6,dmp06|; jump if entering length high|19162
# getarg WA
# getarg sclen(,XR,8)
# getarg dmp06
        cmpq WA,sclen(,XR,8)
        ja   dmp06
# ||plc|7,xr|||; else point to chars of old string|19163
# getarg XR
        add  $cfp_f,XR
# ||cmc|6,dmp08|6,dmp07||; compare, insert if new is llt old|19164
# getarg dmp08
# getarg dmp07
        repe cmpsb
        xor  W0,W0
        mov  W0,XL
        mov  XL,XR
        ja   dmp07
        jb   dmp08
# ||brn|6,dmp08|||; or if leq (we had shorter length)|19165
# getarg dmp08
        jmp  dmp08
# |dmp06|mov|8,wa|13,sclen(xr)||; load shorter length|19169
dmp06:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||plc|7,xr|||; point to chars of old string|19170
# getarg XR
        add  $cfp_f,XR
# ||cmc|6,dmp08|6,dmp07||; compare, insert if new one low|19171
# getarg dmp08
# getarg dmp07
        repe cmpsb
        xor  W0,W0
        mov  W0,XL
        mov  XL,XR
        ja   dmp07
        jb   dmp08
# ||ejc|||||19172
# |dmp07|mov|7,xl|3,dmpch||; copy chain pointer|19178
dmp07:
# getarg dmpch
# getarg XL
        movq dmpch,XL
# ||mov|8,wa|9,(xl)||; move to next entry on chain|19180
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||brn|6,dmp04|||; loop back|19181
# getarg dmp04
        jmp  dmp04
# |dmp08|mov|7,xl|3,dmpch||; copy chain pointer|19185
dmp08:
# getarg dmpch
# getarg XL
        movq dmpch,XL
# ||mov|8,wa|3,dmpsv||; restore hash bucket pointer|19186
# getarg dmpsv
# getarg WA
        movq dmpsv,WA
# ||mov|7,xr|8,wc||; restore vrblk pointer|19187
# getarg WC
# getarg XR
        movq WC,XR
# ||mov|13,vrget(xr)|9,(xl)||; link vrblk to rest of chain|19188
# getarg (XL)
# getarg W0
# getarg vrget(,XR,8)
        movq (XL),W0
        movq W0,vrget(,XR,8)
# ||mov|9,(xl)|7,xr||; link vrblk into current chain loc|19189
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||brn|6,dmp01|||; loop back for next vrblk|19190
# getarg dmp01
        jmp  dmp01
# |dmp09|bne|8,wa|3,hshte|6,dmp00|; loop back if more buckets to go|19194
dmp09:
# getarg WA
# getarg hshte
# getarg dmp00
        cmpq WA,hshte
        jne  dmp00
# |dmp10|mov|7,xr|3,dmvch||; load pointer to next entry on chain|19198
dmp10:
# getarg dmvch
# getarg XR
        movq dmvch,XR
# ||bze|7,xr|6,dmp11||; jump if end of chain|19199
# getarg XR
# getarg dmp11
        or   XR,XR
        jz   dmp11
# ||mov|3,dmvch|9,(xr)||; else update chain ptr to next entry|19200
# getarg (XR)
# getarg W0
# getarg dmvch
        movq (XR),W0
        movq W0,dmvch
# ||jsr|6,setvr|||; restore vrget field|19201
# getarg setvr
        call setvr
# ||mov|7,xl|7,xr||; copy vrblk pointer (name base)|19202
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; set offset for vrblk name|19203
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||jsr|6,prtnv|||; print name = value|19204
# getarg prtnv
        call prtnv
# ||brn|6,dmp10|||; loop back till all printed|19205
# getarg dmp10
        jmp  dmp10
# |dmp11|jsr|6,prtnl|||; print blank line|19209
dmp11:
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; and another|19210
# getarg prtnl
        call prtnl
# ||mov|7,xr|21,=dmhdk||; point to keyword heading|19211
# getarg W0
# getarg XR
        .data
l_0740: .long dmhdk
        .text
        movq l_0740,W0
        movq W0,XR
# ||jsr|6,prtst|||; print heading|19212
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; end line|19213
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; print one blank line|19214
# getarg prtnl
        call prtnl
# ||mov|7,xl|21,=vdmkw||; point to list of keyword svblk ptrs|19215
# getarg W0
# getarg XL
        .data
l_0741: .long vdmkw
        .text
        movq l_0741,W0
        movq W0,XL
# ||ejc|||||19216
# |dmp12|mov|7,xr|10,(xl)+||; load next svblk ptr from table|19222
dmp12:
# getarg XR
        lodsq
        movq W0,XR
# ||bze|7,xr|6,dmp13||; jump if end of list|19223
# getarg XR
# getarg dmp13
        or   XR,XR
        jz   dmp13
# ||beq|7,xr|18,=num01|6,dmp12|; &compare ignored if not implemented|19225
# getarg XR
# getarg W0
# getarg dmp12
        movq l_0060,W0
        cmpq XR,W0
        je   dmp12
# ||mov|8,wa|18,=ch_am||; load ampersand|19227
# getarg W0
# getarg WA
        .data
l_0742: .long ch_am
        .text
        movq l_0742,W0
        movq W0,WA
# ||jsr|6,prtch|||; print ampersand|19228
# getarg prtch
        call prtch
# ||jsr|6,prtst|||; print keyword name|19229
# getarg prtst
        call prtst
# ||mov|8,wa|13,svlen(xr)||; load name length from svblk|19230
# getarg svlen(,XR,8)
# getarg WA
        movq svlen(,XR,8),WA
# ||ctb|8,wa|2,svchs||; get length of name|19231
# getarg WA
        add  ($cfp_b-1)+$cfp_b*svchs,WA
        and  WA,-$8
# ||add|7,xr|8,wa||; point to svknm field|19232
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|3,dmpkn|9,(xr)||; store in dummy kvblk|19233
# getarg (XR)
# getarg W0
# getarg dmpkn
        movq (XR),W0
        movq W0,dmpkn
# ||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|19234
# getarg W0
# getarg XR
        .data
l_0743: .long tmbeb
        .text
        movq l_0743,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|19235
# getarg prtst
        call prtst
# ||mov|3,dmpsv|7,xl||; save table pointer|19236
# getarg XL
# getarg dmpsv
        movq XL,dmpsv
# ||mov|7,xl|20,=dmpkb||; point to dummy kvblk|19237
# getarg W0
# getarg XL
        .data
l_0744: .long dmpkb
        .text
        movq l_0744,W0
        movq W0,XL
# ||mov|9,(xl)|22,=b_kvt||; build type word|19238
# getarg W0
# getarg (XL)
        .data
l_0745: .long b_kvt
        .text
        movq l_0745,W0
        movq W0,(XL)
# ||mov|13,kvvar(xl)|21,=trbkv||; build ptr to dummy trace block|19239
# getarg W0
# getarg kvvar(,XL,8)
        movq l_0587,W0
        movq W0,kvvar(,XL,8)
# ||mov|8,wa|19,*kvvar||; set zero offset|19240
# getarg W0
# getarg WA
        .data
l_0746: .long 8*kvvar
        .text
        movq l_0746,W0
        movq W0,WA
# ||jsr|6,acess|||; get keyword value|19241
# getarg acess
        call acess
        decq rcode
        js   call_225
# ||ppm||||; failure is impossible|19242
# getarg 
        decq rcode
        jns  l_0747
        movq $299,rcode
        jmp  err_
l_0747:
call_225:
# ||jsr|6,prtvl|||; print keyword value|19243
# getarg prtvl
        call prtvl
# ||jsr|6,prtnl|||; terminate print line|19244
# getarg prtnl
        call prtnl
# ||mov|7,xl|3,dmpsv||; restore table pointer|19245
# getarg dmpsv
# getarg XL
        movq dmpsv,XL
# ||brn|6,dmp12|||; loop back till all printed|19246
# getarg dmp12
        jmp  dmp12
# |dmp13|beq|3,dmarg|18,=num01|6,dmp27|; exit if partial dump complete|19250
dmp13:
# getarg dmarg
# getarg W0
# getarg dmp27
        movq l_0060,W0
        cmpq dmarg,W0
        je   dmp27
# ||mov|7,xr|3,dnamb||; else point to first dynamic block|19251
# getarg dnamb
# getarg XR
        movq dnamb,XR
# |dmp14|beq|7,xr|3,dnamp|6,dmp27|; jump if end of used region|19255
dmp14:
# getarg XR
# getarg dnamp
# getarg dmp27
        cmpq XR,dnamp
        je   dmp27
# ||mov|8,wa|9,(xr)||; else load first word of block|19256
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_vct|6,dmp16|; jump if vector|19257
# getarg WA
# getarg W0
# getarg dmp16
        movq l_0085,W0
        cmpq WA,W0
        je   dmp16
# ||beq|8,wa|22,=b_art|6,dmp17|; jump if array|19258
# getarg WA
# getarg W0
# getarg dmp17
        movq l_0247,W0
        cmpq WA,W0
        je   dmp17
# ||beq|8,wa|22,=b_pdt|6,dmp18|; jump if program defined|19259
# getarg WA
# getarg W0
# getarg dmp18
        movq l_0139,W0
        cmpq WA,W0
        je   dmp18
# ||beq|8,wa|22,=b_tbt|6,dmp19|; jump if table|19260
# getarg WA
# getarg W0
# getarg dmp19
        movq l_0086,W0
        cmpq WA,W0
        je   dmp19
# |dmp15|jsr|6,blkln|||; get length of block|19268
dmp15:
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; point past this block|19269
# getarg WA
# getarg XR
        addq WA,XR
# ||brn|6,dmp14|||; loop back for next block|19270
# getarg dmp14
        jmp  dmp14
# ||ejc|||||19271
# |dmp16|mov|8,wb|19,*vcvls||; set offset to first value|19277
dmp16:
# getarg W0
# getarg WB
        .data
l_0748: .long 8*vcvls
        .text
        movq l_0748,W0
        movq W0,WB
# ||brn|6,dmp19|||; jump to merge|19278
# getarg dmp19
        jmp  dmp19
# |dmp17|mov|8,wb|13,arofs(xr)||; set offset to arpro field|19282
dmp17:
# getarg arofs(,XR,8)
# getarg WB
        movq arofs(,XR,8),WB
# ||ica|8,wb|||; bump to get offset to values|19283
# getarg WB
        addq $8,WB
# ||brn|6,dmp19|||; jump to merge|19284
# getarg dmp19
        jmp  dmp19
# |dmp18|mov|8,wb|19,*pdfld||; point to values, merge|19288
dmp18:
# getarg W0
# getarg WB
        movq l_0019,W0
        movq W0,WB
# |dmp19|bze|13,idval(xr)|6,dmp15||; ignore block if zero id value|19292
dmp19:
# getarg idval(,XR,8)
# getarg dmp15
        xor  W0,W0
        cmpq idval(,XR,8),W0
        jz   dmp15
# ||jsr|6,blkln|||; else get block length|19293
# getarg blkln
        call blkln
# ||mov|7,xl|7,xr||; copy block pointer|19294
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|3,dmpsv|8,wa||; save length|19295
# getarg WA
# getarg dmpsv
        movq WA,dmpsv
# ||mov|8,wa|8,wb||; copy offset to first value|19296
# getarg WB
# getarg WA
        movq WB,WA
# ||jsr|6,prtnl|||; print blank line|19297
# getarg prtnl
        call prtnl
# ||mov|3,dmpsa|8,wa||; preserve offset|19298
# getarg WA
# getarg dmpsa
        movq WA,dmpsa
# ||jsr|6,prtvl|||; print block value (for title)|19299
# getarg prtvl
        call prtvl
# ||mov|8,wa|3,dmpsa||; recover offset|19300
# getarg dmpsa
# getarg WA
        movq dmpsa,WA
# ||jsr|6,prtnl|||; end print line|19301
# getarg prtnl
        call prtnl
# ||beq|9,(xr)|22,=b_tbt|6,dmp22|; jump if table|19302
# getarg (XR)
# getarg W0
# getarg dmp22
        movq l_0086,W0
        cmpq (XR),W0
        je   dmp22
# ||dca|8,wa|||; point before first word|19303
# getarg WA
        subq $8,WA
# |dmp20|mov|7,xr|7,xl||; copy block pointer|19307
dmp20:
# getarg XL
# getarg XR
        movq XL,XR
# ||ica|8,wa|||; bump offset|19308
# getarg WA
        addq $8,WA
# ||add|7,xr|8,wa||; point to next value|19309
# getarg WA
# getarg XR
        addq WA,XR
# ||beq|8,wa|3,dmpsv|6,dmp14|; exit if end (xr past block)|19310
# getarg WA
# getarg dmpsv
# getarg dmp14
        cmpq WA,dmpsv
        je   dmp14
# ||sub|7,xr|19,*vrval||; subtract offset to merge into loop|19311
# getarg W0
# getarg XR
        movq l_0121,W0
        subq W0,XR
# |dmp21|mov|7,xr|13,vrval(xr)||; load next value|19315
dmp21:
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||beq|3,dmarg|18,=num03|6,dmp2b|; skip null value check if dump(3)|19316
# getarg dmarg
# getarg W0
# getarg dmp2b
        movq l_0350,W0
        cmpq dmarg,W0
        je   dmp2b
# ||beq|7,xr|21,=nulls|6,dmp20|; loop back if null value|19317
# getarg XR
# getarg W0
# getarg dmp20
        movq l_0054,W0
        cmpq XR,W0
        je   dmp20
# |dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|; loop back if trapped|19318
dmp2b:
# getarg (XR)
# getarg W0
# getarg dmp21
        movq l_0154,W0
        cmpq (XR),W0
        je   dmp21
# ||jsr|6,prtnv|||; else print name = value|19319
# getarg prtnv
        call prtnv
# ||brn|6,dmp20|||; loop back for next field|19320
# getarg dmp20
        jmp  dmp20
# ||ejc|||||19321
# |dmp22|mov|8,wc|19,*tbbuk||; set offset to first bucket|19327
dmp22:
# getarg W0
# getarg WC
        movq l_0632,W0
        movq W0,WC
# ||mov|8,wa|19,*teval||; set name offset for all teblks|19328
# getarg W0
# getarg WA
        .data
l_0749: .long 8*teval
        .text
        movq l_0749,W0
        movq W0,WA
# |dmp23|mov|11,-(xs)|7,xl||; save tbblk pointer|19332
dmp23:
# getarg XL
        push XL
# ||add|7,xl|8,wc||; point to next bucket header|19333
# getarg WC
# getarg XL
        addq WC,XL
# ||ica|8,wc|||; bump bucket offset|19334
# getarg WC
        addq $8,WC
# ||sub|7,xl|19,*tenxt||; subtract offset to merge into loop|19335
# getarg W0
# getarg XL
        movq l_0633,W0
        subq W0,XL
# |dmp24|mov|7,xl|13,tenxt(xl)||; point to next teblk|19339
dmp24:
# getarg tenxt(,XL,8)
# getarg XL
        movq tenxt(,XL,8),XL
# ||beq|7,xl|9,(xs)|6,dmp26|; jump if end of chain|19340
# getarg XL
# getarg (XT)
# getarg dmp26
        cmpq XL,(XT)
        je   dmp26
# ||mov|7,xr|7,xl||; else copy teblk pointer|19341
# getarg XL
# getarg XR
        movq XL,XR
# |dmp25|mov|7,xr|13,teval(xr)||; load next value|19345
dmp25:
# getarg teval(,XR,8)
# getarg XR
        movq teval(,XR,8),XR
# ||beq|7,xr|21,=nulls|6,dmp24|; ignore if null value|19346
# getarg XR
# getarg W0
# getarg dmp24
        movq l_0054,W0
        cmpq XR,W0
        je   dmp24
# ||beq|9,(xr)|22,=b_trt|6,dmp25|; loop back if trapped|19347
# getarg (XR)
# getarg W0
# getarg dmp25
        movq l_0154,W0
        cmpq (XR),W0
        je   dmp25
# ||mov|3,dmpsv|8,wc||; else save offset pointer|19348
# getarg WC
# getarg dmpsv
        movq WC,dmpsv
# ||jsr|6,prtnv|||; print name = value|19349
# getarg prtnv
        call prtnv
# ||mov|8,wc|3,dmpsv||; reload offset|19350
# getarg dmpsv
# getarg WC
        movq dmpsv,WC
# ||brn|6,dmp24|||; loop back for next teblk|19351
# getarg dmp24
        jmp  dmp24
# |dmp26|mov|7,xl|10,(xs)+||; restore tbblk pointer|19355
dmp26:
# getarg XL
        pop  XL
# ||bne|8,wc|13,tblen(xl)|6,dmp23|; loop back if more buckets to go|19356
# getarg WC
# getarg tblen(,XL,8)
# getarg dmp23
        cmpq WC,tblen(,XL,8)
        jne  dmp23
# ||mov|7,xr|7,xl||; else copy table pointer|19357
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xr|8,wc||; point to following block|19358
# getarg WC
# getarg XR
        addq WC,XR
# ||brn|6,dmp14|||; loop back to process next block|19359
# getarg dmp14
        jmp  dmp14
# |dmp27|jsr|6,prtpg|||; eject printer|19363
dmp27:
# getarg prtpg
        call prtpg
# |dmp28|exi||||; return to dump caller|19367
dmp28:
# getarg 
        ret
# |dmp29|jsr|6,sysdm|||; call it|19371
dmp29:
# getarg sysdm
        call sysdm
# ||brn|6,dmp28|||; return|19372
# getarg dmp28
        jmp  dmp28
# ||enp||||; end procedure dumpr|19408
# ||ejc|||||19409
# |ermsg|prc|25,e|1,0||; entry point|19417
ermsg:
# getarg 0
# ||mov|8,wa|3,kvert||; load error code|19418
# getarg kvert
# getarg WA
        movq kvert,WA
# ||mov|7,xr|21,=ermms||; point to error message /error/|19419
# getarg W0
# getarg XR
        .data
l_0750: .long ermms
        .text
        movq l_0750,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|19420
# getarg prtst
        call prtst
# ||jsr|6,ertex|||; get error message text|19421
# getarg ertex
        call ertex
# ||add|8,wa|18,=thsnd||; bump error code for print|19422
# getarg W0
# getarg WA
        .data
l_0751: .long thsnd
        .text
        movq l_0751,W0
        addq W0,WA
# ||mti|8,wa|||; fail code in int acc|19423
# getarg WA
        mov  WA,IA
# ||mov|8,wb|3,profs||; save current buffer position|19424
# getarg profs
# getarg WB
        movq profs,WB
# ||jsr|6,prtin|||; print code (now have error1xxx)|19425
# getarg prtin
        call prtin
# ||mov|7,xl|3,prbuf||; point to print buffer|19426
# getarg prbuf
# getarg XL
        movq prbuf,XL
# ||psc|7,xl|8,wb||; point to the 1|19427
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|8,wa|18,=ch_bl||; load a blank|19428
# getarg W0
# getarg WA
        movq l_0572,W0
        movq W0,WA
# ||sch|8,wa|9,(xl)||; store blank over 1 (error xxx)|19429
# getarg WA
        movb
# ||csc|7,xl|||; complete store characters|19430
# ||zer|7,xl|||; clear garbage pointer in xl|19431
# getarg XL
        xor  XL,XL
# ||mov|8,wa|7,xr||; keep error text|19432
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xr|21,=ermns||; point to / -- /|19433
# getarg W0
# getarg XR
        .data
l_0752: .long ermns
        .text
        movq l_0752,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|19434
# getarg prtst
        call prtst
# ||mov|7,xr|8,wa||; get error text again|19435
# getarg WA
# getarg XR
        movq WA,XR
# ||jsr|6,prtst|||; print error message text|19436
# getarg prtst
        call prtst
# ||jsr|6,prtis|||; print line|19437
# getarg prtis
        call prtis
# ||jsr|6,prtis|||; print blank line|19438
# getarg prtis
        call prtis
# ||exi||||; return to ermsg caller|19439
# getarg 
        ret
# ||enp||||; end procedure ermsg|19440
# ||ejc|||||19441
# |ertex|prc|25,e|1,0||; entry point|19451
ertex:
# getarg 0
# ||mov|3,ertwa|8,wa||; save wa|19452
# getarg WA
# getarg ertwa
        movq WA,ertwa
# ||mov|3,ertwb|8,wb||; save wb|19453
# getarg WB
# getarg ertwb
        movq WB,ertwb
# ||jsr|6,sysem|||; get failure message text|19454
# getarg sysem
        call sysem
# ||mov|7,xl|7,xr||; copy pointer to it|19455
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|13,sclen(xr)||; get length of string|19456
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||bze|8,wa|6,ert02||; jump if null|19457
# getarg WA
# getarg ert02
        or   WA,WA
        jz   ert02
# ||zer|8,wb|||; offset of zero|19458
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; copy into dynamic store|19459
# getarg sbstr
        call sbstr
# ||mov|3,r_etx|7,xr||; store for relocation|19460
# getarg XR
# getarg r_etx
        movq XR,r_etx
# |ert01|mov|8,wb|3,ertwb||; restore wb|19464
ert01:
# getarg ertwb
# getarg WB
        movq ertwb,WB
# ||mov|8,wa|3,ertwa||; restore wa|19465
# getarg ertwa
# getarg WA
        movq ertwa,WA
# ||exi||||; return to caller|19466
# getarg 
        ret
# |ert02|mov|7,xr|3,r_etx||; get errtext|19470
ert02:
# getarg r_etx
# getarg XR
        movq r_etx,XR
# ||brn|6,ert01|||; return|19471
# getarg ert01
        jmp  ert01
# ||enp|||||19472
# ||ejc|||||19473
# |evali|prc|25,r|1,4||; entry point (recursive)|19495
evali:
# getarg 4
# ||jsr|6,evalp|||; evaluate expression|19496
# getarg evalp
        call evalp
        decq rcode
        js   call_226
# ||ppm|6,evli1|||; jump on failure|19497
# getarg evli1
# getarg evli1
        decq rcode
        jns  l_0753
        jmp  evli1
l_0753:
call_226:
# ||mov|11,-(xs)|7,xl||; stack result for gtsmi|19498
# getarg XL
        push XL
# ||mov|7,xl|13,pthen(xr)||; load successor pointer|19499
# getarg pthen(,XR,8)
# getarg XL
        movq pthen(,XR,8),XL
# ||mov|3,evlio|7,xr||; save original node pointer|19500
# getarg XR
# getarg evlio
        movq XR,evlio
# ||mov|3,evlif|8,wc||; zero if simple argument|19501
# getarg WC
# getarg evlif
        movq WC,evlif
# ||jsr|6,gtsmi|||; convert arg to small integer|19502
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_227
# ||ppm|6,evli2|||; jump if not integer|19503
# getarg evli2
# getarg evli2
        decq rcode
        jns  l_0754
        jmp  evli2
l_0754:
# ||ppm|6,evli3|||; jump if out of range|19504
# getarg evli3
# getarg evli3
        decq rcode
        jns  l_0755
        jmp  evli3
l_0755:
call_227:
# ||mov|3,evliv|7,xr||; store result in special dummy node|19505
# getarg XR
# getarg evliv
        movq XR,evliv
# ||mov|7,xr|20,=evlin||; point to dummy node with result|19506
# getarg W0
# getarg XR
        .data
l_0756: .long evlin
        .text
        movq l_0756,W0
        movq W0,XR
# ||mov|9,(xr)|22,=p_len||; dummy pattern block pcode|19507
# getarg W0
# getarg (XR)
        movq l_0392,W0
        movq W0,(XR)
# ||mov|13,pthen(xr)|7,xl||; store successor pointer|19508
# getarg XL
# getarg pthen(,XR,8)
        movq XL,pthen(,XR,8)
# ||exi|1,4|||; take successful exit|19509
# getarg 4
        movq $4,rcode
        ret
# |evli1|exi|1,3|||; take failure return|19513
evli1:
# getarg 3
        movq $3,rcode
        ret
# |evli2|exi|1,1|||; take non-integer error exit|19517
evli2:
# getarg 1
        movq $1,rcode
        ret
# |evli3|exi|1,2|||; take out-of-range error exit|19521
evli3:
# getarg 2
        movq $2,rcode
        ret
# ||enp||||; end procedure evali|19522
# ||ejc|||||19523
# |evalp|prc|25,r|1,1||; entry point (recursive)|19554
evalp:
# getarg 1
# ||mov|7,xl|13,parm1(xr)||; load expression pointer|19555
# getarg parm1(,XR,8)
# getarg XL
        movq parm1(,XR,8),XL
# ||beq|9,(xl)|22,=b_exl|6,evlp1|; jump if exblk case|19556
# getarg (XL)
# getarg W0
# getarg evlp1
        .data
l_0757: .long b_exl
        .text
        movq l_0757,W0
        cmpq (XL),W0
        je   evlp1
# ||mov|7,xl|13,sevar(xl)||; load vrblk pointer|19563
# getarg sevar(,XL,8)
# getarg XL
        movq sevar(,XL,8),XL
# ||mov|7,xl|13,vrval(xl)||; load value of vrblk|19564
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||mov|8,wa|9,(xl)||; load first word of value|19565
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||bhi|8,wa|22,=b_t__|6,evlp3|; jump if not seblk, trblk or exblk|19566
# getarg WA
# getarg W0
# getarg evlp3
        .data
l_0758: .long b_t__
        .text
        movq l_0758,W0
        cmpq WA,W0
        ja   evlp3
# |evlp1|chk||||; check for stack space|19570
evlp1:
        chk_
        or   W0,W0
        jne  sec06
# ||mov|11,-(xs)|7,xr||; stack node pointer|19571
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wb||; stack cursor|19572
# getarg WB
        push WB
# ||mov|11,-(xs)|3,r_pms||; stack subject string pointer|19573
# getarg r_pms
        push r_pms
# ||mov|11,-(xs)|3,pmssl||; stack subject string length|19574
# getarg pmssl
        push pmssl
# ||mov|11,-(xs)|3,pmdfl||; stack dot flag|19575
# getarg pmdfl
        push pmdfl
# ||mov|11,-(xs)|3,pmhbs||; stack history stack base pointer|19576
# getarg pmhbs
        push pmhbs
# ||mov|7,xr|13,parm1(xr)||; load expression pointer|19577
# getarg parm1(,XR,8)
# getarg XR
        movq parm1(,XR,8),XR
# ||ejc|||||19578
# |evlp2|zer|8,wb|||; set flag for by value|19584
evlp2:
# getarg WB
        xor  WB,WB
# ||jsr|6,evalx|||; evaluate expression|19585
# getarg evalx
        call evalx
        decq rcode
        js   call_228
# ||ppm|6,evlp4|||; jump on failure|19586
# getarg evlp4
# getarg evlp4
        decq rcode
        jns  l_0759
        jmp  evlp4
l_0759:
call_228:
# ||mov|8,wa|9,(xr)||; else load first word of value|19587
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||blo|8,wa|22,=b_e__|6,evlp2|; loop back to reevaluate expression|19588
# getarg WA
# getarg W0
# getarg evlp2
        .data
l_0760: .long b_e__
        .text
        movq l_0760,W0
        cmpq WA,W0
        jb   evlp2
# ||mov|7,xl|7,xr||; copy result pointer|19592
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19593
# getarg pmhbs
        pop  pmhbs
# ||mov|3,pmdfl|10,(xs)+||; restore dot flag|19594
# getarg pmdfl
        pop  pmdfl
# ||mov|3,pmssl|10,(xs)+||; restore subject string length|19595
# getarg pmssl
        pop  pmssl
# ||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19596
# getarg r_pms
        pop  r_pms
# ||mov|8,wb|10,(xs)+||; restore cursor|19597
# getarg WB
        pop  WB
# ||mov|7,xr|10,(xs)+||; restore node pointer|19598
# getarg XR
        pop  XR
# ||mov|8,wc|7,xr||; non-zero for simple vrblk|19599
# getarg XR
# getarg WC
        movq XR,WC
# ||exi||||; return to evalp caller|19600
# getarg 
        movq $0,rcode
        ret
# |evlp3|zer|8,wc|||; simple vrblk, no side effects|19604
evlp3:
# getarg WC
        xor  WC,WC
# ||exi||||; return to evalp caller|19605
# getarg 
        movq $0,rcode
        ret
# |evlp4|mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19609
evlp4:
# getarg pmhbs
        pop  pmhbs
# ||mov|3,pmdfl|10,(xs)+||; restore dot flag|19610
# getarg pmdfl
        pop  pmdfl
# ||mov|3,pmssl|10,(xs)+||; restore subject string length|19611
# getarg pmssl
        pop  pmssl
# ||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19612
# getarg r_pms
        pop  r_pms
# ||add|7,xs|19,*num02||; remove node ptr, cursor|19613
# getarg W0
# getarg XT
        movq l_0135,W0
        addq W0,XT
# ||exi|1,1|||; take failure exit|19614
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure evalp|19615
# ||ejc|||||19616
# |evals|prc|25,r|1,3||; entry point (recursive)|19638
evals:
# getarg 3
# ||jsr|6,evalp|||; evaluate expression|19639
# getarg evalp
        call evalp
        decq rcode
        js   call_229
# ||ppm|6,evls1|||; jump if evaluation fails|19640
# getarg evls1
# getarg evls1
        decq rcode
        jns  l_0761
        jmp  evls1
l_0761:
call_229:
# ||mov|11,-(xs)|13,pthen(xr)||; save successor pointer|19641
# getarg pthen(,XR,8)
        push pthen(,XR,8)
# ||mov|11,-(xs)|8,wb||; save cursor|19642
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xl||; stack result ptr for patst|19643
# getarg XL
        push XL
# ||zer|8,wb|||; dummy pcode for one char string|19644
# getarg WB
        xor  WB,WB
# ||zer|8,wc|||; dummy pcode for expression arg|19645
# getarg WC
        xor  WC,WC
# ||mov|7,xl|22,=p_brk||; appropriate pcode for our use|19646
# getarg W0
# getarg XL
        movq l_0257,W0
        movq W0,XL
# ||jsr|6,patst|||; call routine to build node|19647
# getarg patst
        call patst
        decq rcode
        js   call_230
# ||ppm|6,evls2|||; jump if not string|19648
# getarg evls2
# getarg evls2
        decq rcode
        jns  l_0762
        jmp  evls2
l_0762:
call_230:
# ||mov|8,wb|10,(xs)+||; restore cursor|19649
# getarg WB
        pop  WB
# ||mov|13,pthen(xr)|10,(xs)+||; store successor pointer|19650
# getarg pthen(,XR,8)
        pop  pthen(,XR,8)
# ||exi|1,3|||; take success return|19651
# getarg 3
        movq $3,rcode
        ret
# |evls1|exi|1,2|||; take failure return|19655
evls1:
# getarg 2
        movq $2,rcode
        ret
# |evls2|add|7,xs|19,*num02||; pop successor and cursor|19659
evls2:
# getarg W0
# getarg XT
        movq l_0135,W0
        addq W0,XT
# ||exi|1,1|||; take non-string error exit|19660
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure evals|19661
# ||ejc|||||19662
# |evalx|prc|25,r|1,1||; entry point, recursive|19678
evalx:
# getarg 1
# ||beq|9,(xr)|22,=b_exl|6,evlx2|; jump if exblk case|19679
# getarg (XR)
# getarg W0
# getarg evlx2
        movq l_0757,W0
        cmpq (XR),W0
        je   evlx2
# ||mov|7,xl|13,sevar(xr)||; load vrblk pointer (name base)|19683
# getarg sevar(,XR,8)
# getarg XL
        movq sevar(,XR,8),XL
# ||mov|8,wa|19,*vrval||; set name offset|19684
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||bnz|8,wb|6,evlx1||; jump if called by name|19685
# getarg WB
# getarg WB
# getarg evlx1
        or   WB,WB
        jnz  evlx1
# ||jsr|6,acess|||; call routine to access value|19686
# getarg acess
        call acess
        decq rcode
        js   call_231
# ||ppm|6,evlx9|||; jump if failure on access|19687
# getarg evlx9
# getarg evlx9
        decq rcode
        jns  l_0763
        jmp  evlx9
l_0763:
call_231:
# |evlx1|exi||||; return to evalx caller|19691
evlx1:
# getarg 
        movq $0,rcode
        ret
# ||ejc|||||19692
# |evlx2|scp|8,wc|||; get code pointer|19711
evlx2:
# getarg WC
        scp_ WC
# ||mov|8,wa|3,r_cod||; load code block pointer|19712
# getarg r_cod
# getarg WA
        movq r_cod,WA
# ||sub|8,wc|8,wa||; get code pointer as offset|19713
# getarg WA
# getarg WC
        subq WA,WC
# ||mov|11,-(xs)|8,wa||; stack old code block pointer|19714
# getarg WA
        push WA
# ||mov|11,-(xs)|8,wc||; stack relative code offset|19715
# getarg WC
        push WC
# ||mov|11,-(xs)|3,flptr||; stack old failure pointer|19716
# getarg flptr
        push flptr
# ||mov|11,-(xs)|8,wb||; stack name/value indicator|19717
# getarg WB
        push WB
# ||mov|11,-(xs)|19,*exflc||; stack new fail offset|19718
# getarg W0
        movq l_0018,W0
        push W0
# ||mov|3,gtcef|3,flptr||; keep in case of error|19719
# getarg flptr
# getarg W0
# getarg gtcef
        movq flptr,W0
        movq W0,gtcef
# ||mov|3,r_gtc|3,r_cod||; keep code block pointer similarly|19720
# getarg r_cod
# getarg W0
# getarg r_gtc
        movq r_cod,W0
        movq W0,r_gtc
# ||mov|3,flptr|7,xs||; set new failure pointer|19721
# getarg XT
# getarg flptr
        movq XT,flptr
# ||mov|3,r_cod|7,xr||; set new code block pointer|19722
# getarg XR
# getarg r_cod
        movq XR,r_cod
# ||mov|13,exstm(xr)|3,kvstn||; remember stmnt number|19723
# getarg kvstn
# getarg W0
# getarg exstm(,XR,8)
        movq kvstn,W0
        movq W0,exstm(,XR,8)
# ||add|7,xr|19,*excod||; point to first code word|19724
# getarg W0
# getarg XR
        .data
l_0764: .long 8*excod
        .text
        movq l_0764,W0
        addq W0,XR
# ||lcp|7,xr|||; set code pointer|19725
# getarg XR
        lcp_ XR
# ||bne|3,stage|18,=stgxt|6,evlx0|; jump if not execution time|19726
# getarg stage
# getarg W0
# getarg evlx0
        movq l_0075,W0
        cmpq stage,W0
        jne  evlx0
# ||mov|3,stage|18,=stgee||; evaluating expression|19727
# getarg W0
# getarg stage
        .data
l_0765: .long stgee
        .text
        movq l_0765,W0
        movq W0,stage
# |evlx0|zer|7,xl|||; clear garbage xl|19731
evlx0:
# getarg XL
        xor  XL,XL
# ||lcw|7,xr|||; load first code word|19732
# getarg XR
        lcw_ XR
# ||bri|9,(xr)|||; execute it|19733
# getarg (XR)
        jmp  *(XR)
# ||ejc|||||19734
# |evlx3|mov|7,xr|10,(xs)+||; load value|19740
evlx3:
# getarg XR
        pop  XR
# ||bze|13,num01(xs)|6,evlx5||; jump if called by value|19741
# getarg num01(,XT,8)
# getarg evlx5
        xor  W0,W0
        cmpq num01(,XT,8),W0
        jz   evlx5
# ||erb|1,249|26,expression evaluated by name returned value|||19742
        movq $249,rcode
        jmp  err_
# |evlx4|mov|8,wa|10,(xs)+||; load name offset|19746
evlx4:
# getarg WA
        pop  WA
# ||mov|7,xl|10,(xs)+||; load name base|19747
# getarg XL
        pop  XL
# ||bnz|13,num01(xs)|6,evlx5||; jump if called by name|19748
# getarg num01(,XT,8)
# getarg evlx5
        xor  W0,W0
        cmpq num01(,XT,8),W0
        jnz  evlx5
# ||jsr|6,acess|||; else access value first|19749
# getarg acess
        call acess
        decq rcode
        js   call_232
# ||ppm|6,evlx6|||; jump if failure during access|19750
# getarg evlx6
# getarg evlx6
        decq rcode
        jns  l_0766
        jmp  evlx6
l_0766:
call_232:
# |evlx5|zer|8,wb|||; note successful|19754
evlx5:
# getarg WB
        xor  WB,WB
# ||brn|6,evlx7|||; merge|19755
# getarg evlx7
        jmp  evlx7
# |evlx6|mnz|8,wb|||; note unsuccessful|19759
evlx6:
# getarg WB
        mov  XS,WB
# |evlx7|bne|3,stage|18,=stgee|6,evlx8|; skip if was not previously xt|19763
evlx7:
# getarg stage
# getarg W0
# getarg evlx8
        movq l_0765,W0
        cmpq stage,W0
        jne  evlx8
# ||mov|3,stage|18,=stgxt||; execute time|19764
# getarg W0
# getarg stage
        movq l_0075,W0
        movq W0,stage
# |evlx8|add|7,xs|19,*num02||; pop name/value indicator, *exfal|19768
evlx8:
# getarg W0
# getarg XT
        movq l_0135,W0
        addq W0,XT
# ||mov|3,flptr|10,(xs)+||; restore old failure pointer|19769
# getarg flptr
        pop  flptr
# ||mov|8,wc|10,(xs)+||; load code offset|19770
# getarg WC
        pop  WC
# ||add|8,wc|9,(xs)||; make code pointer absolute|19771
# getarg (XT)
# getarg WC
        addq (XT),WC
# ||mov|3,r_cod|10,(xs)+||; restore old code block pointer|19772
# getarg r_cod
        pop  r_cod
# ||lcp|8,wc|||; restore old code pointer|19773
# getarg WC
        lcp_ WC
# ||bze|8,wb|6,evlx1||; jump for successful return|19774
# getarg WB
# getarg evlx1
        or   WB,WB
        jz   evlx1
# |evlx9|exi|1,1|||; take failure exit|19778
evlx9:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end of procedure evalx|19779
# ||ejc|||||19780
# |exbld|prc|25,e|1,0||; entry point|19793
exbld:
# getarg 0
# ||mov|8,wa|7,xl||; copy offset to start of code|19794
# getarg XL
# getarg WA
        movq XL,WA
# ||sub|8,wa|19,*excod||; calc reduction in offset in exblk|19795
# getarg W0
# getarg WA
        movq l_0764,W0
        subq W0,WA
# ||mov|11,-(xs)|8,wa||; stack for later|19796
# getarg WA
        push WA
# ||mov|8,wa|3,cwcof||; load final offset|19797
# getarg cwcof
# getarg WA
        movq cwcof,WA
# ||sub|8,wa|7,xl||; compute length of code|19798
# getarg XL
# getarg WA
        subq XL,WA
# ||add|8,wa|19,*exsi_||; add space for standard fields|19799
# getarg W0
# getarg WA
        .data
l_0767: .long 8*exsi_
        .text
        movq l_0767,W0
        addq W0,WA
# ||jsr|6,alloc|||; allocate space for exblk|19800
# getarg alloc
        call alloc
# ||mov|11,-(xs)|7,xr||; save pointer to exblk|19801
# getarg XR
        push XR
# ||mov|13,extyp(xr)|22,=b_exl||; store type word|19802
# getarg W0
# getarg extyp(,XR,8)
        movq l_0757,W0
        movq W0,extyp(,XR,8)
# ||zer|13,exstm(xr)|||; zeroise stmnt number field|19803
# getarg exstm(,XR,8)
        mov  $0,W0
        mov  W0,exstm(,XR,8)
# ||mov|13,exsln(xr)|3,cmpln||; set line number field|19805
# getarg cmpln
# getarg W0
# getarg exsln(,XR,8)
        movq cmpln,W0
        movq W0,exsln(,XR,8)
# ||mov|13,exlen(xr)|8,wa||; store length|19807
# getarg WA
# getarg exlen(,XR,8)
        movq WA,exlen(,XR,8)
# ||mov|13,exflc(xr)|21,=ofex_||; store failure word|19808
# getarg W0
# getarg exflc(,XR,8)
        .data
l_0768: .long ofex_
        .text
        movq l_0768,W0
        movq W0,exflc(,XR,8)
# ||add|7,xr|19,*exsi_||; set xr for mvw|19809
# getarg W0
# getarg XR
        movq l_0767,W0
        addq W0,XR
# ||mov|3,cwcof|7,xl||; reset offset to start of code|19810
# getarg XL
# getarg cwcof
        movq XL,cwcof
# ||add|7,xl|3,r_ccb||; point to start of code|19811
# getarg r_ccb
# getarg XL
        addq r_ccb,XL
# ||sub|8,wa|19,*exsi_||; length of code to move|19812
# getarg W0
# getarg WA
        movq l_0767,W0
        subq W0,WA
# ||mov|11,-(xs)|8,wa||; stack length of code|19813
# getarg WA
        push WA
# ||mvw||||; move code to exblk|19814
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0769:
        or   WA,WA
        jz   l_0770
        movsq
        decq WA
        jmp  l_0769
l_0770:
        cld
# ||mov|8,wa|10,(xs)+||; get length of code|19815
# getarg WA
        pop  WA
# ||btw|8,wa|||; convert byte count to word count|19816
# getarg WA
        shr  WA,3
# ||lct|8,wa|8,wa||; prepare counter for loop|19817
# ||mov|7,xl|9,(xs)||; copy exblk ptr, dont unstack|19818
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|7,xl|19,*excod||; point to code itself|19819
# getarg W0
# getarg XL
        movq l_0764,W0
        addq W0,XL
# ||mov|8,wb|13,num01(xs)||; get reduction in offset|19820
# getarg num01(,XT,8)
# getarg WB
        movq num01(,XT,8),WB
# |exbl1|mov|7,xr|10,(xl)+||; get next code word|19827
exbl1:
# getarg XR
        lodsq
        movq W0,XR
# ||beq|7,xr|21,=osla_|6,exbl3|; jump if selection found|19828
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0662,W0
        cmpq XR,W0
        je   exbl3
# ||beq|7,xr|21,=onta_|6,exbl3|; jump if negation found|19829
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0673,W0
        cmpq XR,W0
        je   exbl3
# ||bct|8,wa|6,exbl1||; loop to end of code|19830
# getarg WA
# getarg exbl1
        decq WA
        jnz  exbl1
# |exbl2|mov|7,xr|10,(xs)+||; pop exblk ptr into xr|19834
exbl2:
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; pop reduction constant|19835
# getarg XL
        pop  XL
# ||exi||||; return to caller|19836
# getarg 
        ret
# ||ejc|||||19837
# |exbl3|sub|10,(xl)+|8,wb||; adjust offset|19846
exbl3:
# getarg WB
# getarg (XL)
        subq WB,(XL)
        add  $8,XL
# ||bct|8,wa|6,exbl4||; decrement count|19847
# getarg WA
# getarg exbl4
        decq WA
        jnz  exbl4
# |exbl4|bct|8,wa|6,exbl5||; decrement count|19849
exbl4:
# getarg WA
# getarg exbl5
        decq WA
        jnz  exbl5
# |exbl5|mov|7,xr|10,(xl)+||; get next code word|19853
exbl5:
# getarg XR
        lodsq
        movq W0,XR
# ||beq|7,xr|21,=osla_|6,exbl3|; jump if offset found|19854
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0662,W0
        cmpq XR,W0
        je   exbl3
# ||beq|7,xr|21,=oslb_|6,exbl3|; jump if offset found|19855
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0663,W0
        cmpq XR,W0
        je   exbl3
# ||beq|7,xr|21,=oslc_|6,exbl3|; jump if offset found|19856
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0664,W0
        cmpq XR,W0
        je   exbl3
# ||beq|7,xr|21,=onta_|6,exbl3|; jump if offset found|19857
# getarg XR
# getarg W0
# getarg exbl3
        movq l_0673,W0
        cmpq XR,W0
        je   exbl3
# ||bct|8,wa|6,exbl5||; loop|19858
# getarg WA
# getarg exbl5
        decq WA
        jnz  exbl5
# ||brn|6,exbl2|||; merge to return|19859
# getarg exbl2
        jmp  exbl2
# ||enp||||; end procedure exbld|19860
# ||ejc|||||19861
# ||ejc|||||19914
# |expan|prc|25,e|1,0||; entry point|19920
expan:
# getarg 0
# ||zer|11,-(xs)|||; set top of stack indicator|19921
        push $0
# ||zer|8,wa|||; set initial state to zero|19922
# getarg WA
        xor  WA,WA
# ||zer|8,wc|||; zero counter value|19923
# getarg WC
        xor  WC,WC
# |exp01|jsr|6,scane|||; scan next element|19927
exp01:
# getarg scane
        call scane
# ||add|7,xl|8,wa||; add state to syntax code|19928
# getarg WA
# getarg XL
        addq WA,XL
# ||bsw|7,xl|2,t_nes||; switch on element type/state|19929
# getarg XL
        jmp  *l_0771(,XL,8)
        .data
l_0771:
# ||iff|2,t_uo0|6,exp27||; unop, s=0|19966
# getarg exp27
        .long exp27
# ||iff|2,t_uo1|6,exp27||; unop, s=1|19966
# getarg exp27
        .long exp27
# ||iff|2,t_uo2|6,exp04||; unop, s=2|19966
# getarg exp04
        .long exp04
# ||iff|2,t_lp0|6,exp06||; left paren, s=0|19966
# getarg exp06
        .long exp06
# ||iff|2,t_lp1|6,exp06||; left paren, s=1|19966
# getarg exp06
        .long exp06
# ||iff|2,t_lp2|6,exp04||; left paren, s=2|19966
# getarg exp04
        .long exp04
# ||iff|2,t_lb0|6,exp08||; left brkt, s=0|19966
# getarg exp08
        .long exp08
# ||iff|2,t_lb1|6,exp08||; left brkt, s=1|19966
# getarg exp08
        .long exp08
# ||iff|2,t_lb2|6,exp09||; left brkt, s=2|19966
# getarg exp09
        .long exp09
# ||iff|2,t_cm0|6,exp02||; comma, s=0|19966
# getarg exp02
        .long exp02
# ||iff|2,t_cm1|6,exp05||; comma, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_cm2|6,exp11||; comma, s=2|19966
# getarg exp11
        .long exp11
# ||iff|2,t_fn0|6,exp10||; function, s=0|19966
# getarg exp10
        .long exp10
# ||iff|2,t_fn1|6,exp10||; function, s=1|19966
# getarg exp10
        .long exp10
# ||iff|2,t_fn2|6,exp04||; function, s=2|19966
# getarg exp04
        .long exp04
# ||iff|2,t_va0|6,exp03||; variable, s=0|19966
# getarg exp03
        .long exp03
# ||iff|2,t_va1|6,exp03||; variable, state one|19966
# getarg exp03
        .long exp03
# ||iff|2,t_va2|6,exp04||; variable, s=2|19966
# getarg exp04
        .long exp04
# ||iff|2,t_co0|6,exp03||; constant, s=0|19966
# getarg exp03
        .long exp03
# ||iff|2,t_co1|6,exp03||; constant, s=1|19966
# getarg exp03
        .long exp03
# ||iff|2,t_co2|6,exp04||; constant, s=2|19966
# getarg exp04
        .long exp04
# ||iff|2,t_bo0|6,exp05||; binop, s=0|19966
# getarg exp05
        .long exp05
# ||iff|2,t_bo1|6,exp05||; binop, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_bo2|6,exp26||; binop, s=2|19966
# getarg exp26
        .long exp26
# ||iff|2,t_rp0|6,exp02||; right paren, s=0|19966
# getarg exp02
        .long exp02
# ||iff|2,t_rp1|6,exp05||; right paren, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_rp2|6,exp12||; right paren, s=2|19966
# getarg exp12
        .long exp12
# ||iff|2,t_rb0|6,exp02||; right brkt, s=0|19966
# getarg exp02
        .long exp02
# ||iff|2,t_rb1|6,exp05||; right brkt, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_rb2|6,exp18||; right brkt, s=2|19966
# getarg exp18
        .long exp18
# ||iff|2,t_cl0|6,exp02||; colon, s=0|19966
# getarg exp02
        .long exp02
# ||iff|2,t_cl1|6,exp05||; colon, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_cl2|6,exp19||; colon, s=2|19966
# getarg exp19
        .long exp19
# ||iff|2,t_sm0|6,exp02||; semicolon, s=0|19966
# getarg exp02
        .long exp02
# ||iff|2,t_sm1|6,exp05||; semicolon, s=1|19966
# getarg exp05
        .long exp05
# ||iff|2,t_sm2|6,exp19||; semicolon, s=2|19966
# getarg exp19
        .long exp19
# ||esw||||; end switch on element type/state|19966
        .text
# ||ejc|||||19967
# |exp02|mnz|3,scnrs|||; set to rescan element|19976
exp02:
# getarg scnrs
        mov  XS,scnrs
# ||mov|7,xr|21,=nulls||; point to null, merge|19977
# getarg W0
# getarg XR
        movq l_0054,W0
        movq W0,XR
# |exp03|mov|11,-(xs)|7,xr||; stack pointer to operand|19983
exp03:
# getarg XR
        push XR
# ||mov|8,wa|18,=num02||; set state 2|19984
# getarg W0
# getarg WA
        movq l_0130,W0
        movq W0,WA
# ||brn|6,exp01|||; jump for next element|19985
# getarg exp01
        jmp  exp01
# |exp04|mnz|3,scnrs|||; set to rescan element|19992
exp04:
# getarg scnrs
        mov  XS,scnrs
# ||mov|7,xr|21,=opdvc||; point to concat operator dv|19993
# getarg W0
# getarg XR
        .data
l_0772: .long opdvc
        .text
        movq l_0772,W0
        movq W0,XR
# ||bze|8,wb|6,exp4a||; ok if at top level|19994
# getarg WB
# getarg exp4a
        or   WB,WB
        jz   exp4a
# ||mov|7,xr|21,=opdvp||; else point to unmistakable concat.|19995
# getarg W0
# getarg XR
        .data
l_0773: .long opdvp
        .text
        movq l_0773,W0
        movq W0,XR
# |exp4a|bnz|3,scnbl|6,exp26||; merge bop if blanks, else error|19999
exp4a:
# getarg scnbl
# getarg exp26
        xor  W0,W0
        cmpq scnbl,W0
        jnz  exp26
# ||erb|1,220|26,syntax error: missing operator|||20001
        movq $220,rcode
        jmp  err_
# |exp05|erb|1,221|26,syntax error: missing operand|||20009
exp05:
        movq $221,rcode
        jmp  err_
# |exp06|mov|7,xl|18,=num04||; set new level indicator|20013
exp06:
# getarg W0
# getarg XL
        movq l_0729,W0
        movq W0,XL
# ||zer|7,xr|||; set zero value for cmopn|20014
# getarg XR
        xor  XR,XR
# ||ejc|||||20015
# |exp07|mov|11,-(xs)|7,xr||; stack cmopn value|20021
exp07:
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wc||; stack old counter|20022
# getarg WC
        push WC
# ||mov|11,-(xs)|8,wb||; stack old level indicator|20023
# getarg WB
        push WB
# ||chk||||; check for stack overflow|20024
        chk_
        or   W0,W0
        jne  sec06
# ||zer|8,wa|||; set new state to zero|20025
# getarg WA
        xor  WA,WA
# ||mov|8,wb|7,xl||; set new level indicator|20026
# getarg XL
# getarg WB
        movq XL,WB
# ||mov|8,wc|18,=num01||; initialize new counter|20027
# getarg W0
# getarg WC
        movq l_0060,W0
        movq W0,WC
# ||brn|6,exp01|||; jump to scan next element|20028
# getarg exp01
        jmp  exp01
# |exp08|erb|1,222|26,syntax error: invalid use of left bracket|||20034
exp08:
        movq $222,rcode
        jmp  err_
# |exp09|mov|7,xr|10,(xs)+||; load array ptr for cmopn|20040
exp09:
# getarg XR
        pop  XR
# ||mov|7,xl|18,=num03||; set new level indicator|20041
# getarg W0
# getarg XL
        movq l_0350,W0
        movq W0,XL
# ||brn|6,exp07|||; jump to stack old and start new|20042
# getarg exp07
        jmp  exp07
# |exp10|mov|7,xl|18,=num05||; set new lev indic (xr=vrblk=cmopn)|20048
exp10:
# getarg W0
# getarg XL
        movq l_0072,W0
        movq W0,XL
# ||brn|6,exp07|||; jump to stack old and start new|20049
# getarg exp07
        jmp  exp07
# |exp11|icv|8,wc|||; increment counter|20055
exp11:
# getarg WC
        incq WC
# ||jsr|6,expdm|||; dump operators at this level|20056
# getarg expdm
        call expdm
# ||zer|11,-(xs)|||; set new level for parameter|20057
        push $0
# ||zer|8,wa|||; set new state|20058
# getarg WA
        xor  WA,WA
# ||bgt|8,wb|18,=num02|6,exp01|; loop back unless outer level|20059
# getarg WB
# getarg W0
# getarg exp01
        movq l_0130,W0
        cmpq WB,W0
        ja   exp01
# ||erb|1,223|26,syntax error: invalid use of comma|||20060
        movq $223,rcode
        jmp  err_
# ||ejc|||||20061
# |exp12|beq|8,wb|18,=num01|6,exp20|; end of normal goto|20070
exp12:
# getarg WB
# getarg W0
# getarg exp20
        movq l_0060,W0
        cmpq WB,W0
        je   exp20
# ||beq|8,wb|18,=num05|6,exp13|; end of function arguments|20071
# getarg WB
# getarg W0
# getarg exp13
        movq l_0072,W0
        cmpq WB,W0
        je   exp13
# ||beq|8,wb|18,=num04|6,exp14|; end of grouping / selection|20072
# getarg WB
# getarg W0
# getarg exp14
        movq l_0729,W0
        cmpq WB,W0
        je   exp14
# ||erb|1,224|26,syntax error: unbalanced right parenthesis|||20073
        movq $224,rcode
        jmp  err_
# |exp13|mov|7,xl|18,=c_fnc||; set cmtyp value for function|20077
exp13:
# getarg W0
# getarg XL
        movq l_0671,W0
        movq W0,XL
# ||brn|6,exp15|||; jump to build cmblk|20078
# getarg exp15
        jmp  exp15
# |exp14|beq|8,wc|18,=num01|6,exp17|; jump if end of grouping|20082
exp14:
# getarg WC
# getarg W0
# getarg exp17
        movq l_0060,W0
        cmpq WC,W0
        je   exp17
# ||mov|7,xl|18,=c_sel||; else set cmtyp for selection|20083
# getarg W0
# getarg XL
        .data
l_0774: .long c_sel
        .text
        movq l_0774,W0
        movq W0,XL
# |exp15|jsr|6,expdm|||; dump operators at this level|20088
exp15:
# getarg expdm
        call expdm
# ||mov|8,wa|8,wc||; copy count|20089
# getarg WC
# getarg WA
        movq WC,WA
# ||add|8,wa|18,=cmvls||; add for standard fields at start|20090
# getarg W0
# getarg WA
        movq l_0649,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|20091
# getarg WA
        sal  WA,3
# ||jsr|6,alloc|||; allocate space for cmblk|20092
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_cmt||; store type code for cmblk|20093
# getarg W0
# getarg (XR)
        movq l_0640,W0
        movq W0,(XR)
# ||mov|13,cmtyp(xr)|7,xl||; store cmblk node type indicator|20094
# getarg XL
# getarg cmtyp(,XR,8)
        movq XL,cmtyp(,XR,8)
# ||mov|13,cmlen(xr)|8,wa||; store length|20095
# getarg WA
# getarg cmlen(,XR,8)
        movq WA,cmlen(,XR,8)
# ||add|7,xr|8,wa||; point past end of block|20096
# getarg WA
# getarg XR
        addq WA,XR
# ||lct|8,wc|8,wc||; set loop counter|20097
# |exp16|mov|11,-(xr)|10,(xs)+||; move one operand ptr from stack|20101
exp16:
# getarg (XR)
        sub  $8,XR
        pop  (XR)
# ||mov|8,wb|10,(xs)+||; pop to old level indicator|20102
# getarg WB
        pop  WB
# ||bct|8,wc|6,exp16||; loop till all moved|20103
# getarg WC
# getarg exp16
        decq WC
        jnz  exp16
# ||ejc|||||20104
# ||sub|7,xr|19,*cmvls||; point back to start of block|20110
# getarg W0
# getarg XR
        movq l_0658,W0
        subq W0,XR
# ||mov|8,wc|10,(xs)+||; restore old counter|20111
# getarg WC
        pop  WC
# ||mov|13,cmopn(xr)|9,(xs)||; store operand ptr in cmblk|20112
# getarg (XT)
# getarg W0
# getarg cmopn(,XR,8)
        movq (XT),W0
        movq W0,cmopn(,XR,8)
# ||mov|9,(xs)|7,xr||; stack cmblk pointer|20113
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|8,wa|18,=num02||; set new state|20114
# getarg W0
# getarg WA
        movq l_0130,W0
        movq W0,WA
# ||brn|6,exp01|||; back for next element|20115
# getarg exp01
        jmp  exp01
# |exp17|jsr|6,expdm|||; dump operators at this level|20119
exp17:
# getarg expdm
        call expdm
# ||mov|7,xr|10,(xs)+||; restore xr|20120
# getarg XR
        pop  XR
# ||mov|8,wb|10,(xs)+||; restore outer level|20121
# getarg WB
        pop  WB
# ||mov|8,wc|10,(xs)+||; restore outer count|20122
# getarg WC
        pop  WC
# ||mov|9,(xs)|7,xr||; store opnd over unused cmopn val|20123
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||mov|8,wa|18,=num02||; set new state|20124
# getarg W0
# getarg WA
        movq l_0130,W0
        movq W0,WA
# ||brn|6,exp01|||; back for next ele8ent|20125
# getarg exp01
        jmp  exp01
# |exp18|mov|7,xl|18,=c_arr||; set cmtyp for array reference|20132
exp18:
# getarg W0
# getarg XL
        .data
l_0775: .long c_arr
        .text
        movq l_0775,W0
        movq W0,XL
# ||beq|8,wb|18,=num03|6,exp15|; jump to build cmblk if end arrayref|20133
# getarg WB
# getarg W0
# getarg exp15
        movq l_0350,W0
        cmpq WB,W0
        je   exp15
# ||beq|8,wb|18,=num02|6,exp20|; jump if end of direct goto|20134
# getarg WB
# getarg W0
# getarg exp20
        movq l_0130,W0
        cmpq WB,W0
        je   exp20
# ||erb|1,225|26,syntax error: unbalanced right bracket|||20135
        movq $225,rcode
        jmp  err_
# ||ejc|||||20136
# |exp19|mnz|3,scnrs|||; rescan terminator|20144
exp19:
# getarg scnrs
        mov  XS,scnrs
# ||mov|7,xl|8,wb||; copy level indicator|20145
# getarg WB
# getarg XL
        movq WB,XL
# ||bsw|7,xl|1,6||; switch on level indicator|20146
# getarg XL
        jmp  *l_0776(,XL,8)
        .data
l_0776:
# ||iff|1,0|6,exp20||; normal outer level|20153
# getarg exp20
        .long exp20
# ||iff|1,1|6,exp22||; fail if normal goto|20153
# getarg exp22
        .long exp22
# ||iff|1,2|6,exp23||; fail if direct goto|20153
# getarg exp23
        .long exp23
# ||iff|1,3|6,exp24||; fail array brackets|20153
# getarg exp24
        .long exp24
# ||iff|1,4|6,exp21||; fail if in grouping|20153
# getarg exp21
        .long exp21
# ||iff|1,5|6,exp21||; fail function args|20153
# getarg exp21
        .long exp21
# ||esw||||; end switch on level|20153
        .text
# |exp20|jsr|6,expdm|||; dump remaining operators|20157
exp20:
# getarg expdm
        call expdm
# ||mov|7,xr|10,(xs)+||; load tree pointer|20158
# getarg XR
        pop  XR
# ||ica|7,xs|||; pop off bottom of stack marker|20159
# getarg XT
        addq $8,XT
# ||exi||||; return to expan caller|20160
# getarg 
        ret
# |exp21|erb|1,226|26,syntax error: missing right paren|||20164
exp21:
        movq $226,rcode
        jmp  err_
# |exp22|erb|1,227|26,syntax error: right paren missing from goto|||20168
exp22:
        movq $227,rcode
        jmp  err_
# |exp23|erb|1,228|26,syntax error: right bracket missing from goto|||20172
exp23:
        movq $228,rcode
        jmp  err_
# |exp24|erb|1,229|26,syntax error: missing right array bracket|||20176
exp24:
        movq $229,rcode
        jmp  err_
# ||ejc|||||20177
# |exp25|mov|3,expsv|7,xr||;|20183
exp25:
# getarg XR
# getarg expsv
        movq XR,expsv
# ||jsr|6,expop|||; pop one operator|20184
# getarg expop
        call expop
# ||mov|7,xr|3,expsv||; restore op dv pointer and merge|20185
# getarg expsv
# getarg XR
        movq expsv,XR
# |exp26|mov|7,xl|13,num01(xs)||; load operator dvptr from stack|20193
exp26:
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||ble|7,xl|18,=num05|6,exp27|; jump if bottom of stack level|20194
# getarg XL
# getarg W0
# getarg exp27
        movq l_0072,W0
        cmpq XL,W0
        jbe  exp27
# ||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|; else pop if new prec is lo|20195
# getarg dvlpr(,XL,8)
# getarg dvrpr(,XR,8)
# getarg W0
# getarg exp25
        movq dvlpr(,XL,8),W0
        cmpq dvrpr(,XR,8),W0
        jb   exp25
# |exp27|mov|11,-(xs)|7,xr||; stack operator dvptr on stack|20204
exp27:
# getarg XR
        push XR
# ||chk||||; check for stack overflow|20205
        chk_
        or   W0,W0
        jne  sec06
# ||mov|8,wa|18,=num01||; set new state|20206
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# ||bne|7,xr|21,=opdvs|6,exp01|; back for next element unless =|20207
# getarg XR
# getarg W0
# getarg exp01
        .data
l_0777: .long opdvs
        .text
        movq l_0777,W0
        cmpq XR,W0
        jne  exp01
# ||zer|8,wa|||; set state zero|20214
# getarg WA
        xor  WA,WA
# ||brn|6,exp01|||; jump for next element|20215
# getarg exp01
        jmp  exp01
# ||enp||||; end procedure expan|20216
# ||ejc|||||20217
# |expap|prc|25,e|1,1||; entry point|20236
expap:
# getarg 1
# ||mov|11,-(xs)|7,xl||; save xl|20237
# getarg XL
        push XL
# ||bne|9,(xr)|22,=b_cmt|6,expp2|; no match if not complex|20238
# getarg (XR)
# getarg W0
# getarg expp2
        movq l_0640,W0
        cmpq (XR),W0
        jne  expp2
# ||mov|8,wa|13,cmtyp(xr)||; else load type code|20239
# getarg cmtyp(,XR,8)
# getarg WA
        movq cmtyp(,XR,8),WA
# ||beq|8,wa|18,=c_cnc|6,expp1|; concatenation is a match|20240
# getarg WA
# getarg W0
# getarg expp1
        .data
l_0778: .long c_cnc
        .text
        movq l_0778,W0
        cmpq WA,W0
        je   expp1
# ||beq|8,wa|18,=c_pmt|6,expp1|; binary question mark is a match|20241
# getarg WA
# getarg W0
# getarg expp1
        movq l_0705,W0
        cmpq WA,W0
        je   expp1
# ||bne|8,wa|18,=c_alt|6,expp2|; else not match unless alternation|20242
# getarg WA
# getarg W0
# getarg expp2
        .data
l_0779: .long c_alt
        .text
        movq l_0779,W0
        cmpq WA,W0
        jne  expp2
# ||mov|7,xl|13,cmlop(xr)||; load left operand pointer|20246
# getarg cmlop(,XR,8)
# getarg XL
        movq cmlop(,XR,8),XL
# ||bne|9,(xl)|22,=b_cmt|6,expp2|; not match if left opnd not complex|20247
# getarg (XL)
# getarg W0
# getarg expp2
        movq l_0640,W0
        cmpq (XL),W0
        jne  expp2
# ||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|; not match if left op not conc|20248
# getarg cmtyp(,XL,8)
# getarg W0
# getarg expp2
        movq l_0778,W0
        cmpq cmtyp(,XL,8),W0
        jne  expp2
# ||mov|13,cmlop(xr)|13,cmrop(xl)||; xr points to (b / c)|20249
# getarg cmrop(,XL,8)
# getarg W0
# getarg cmlop(,XR,8)
        movq cmrop(,XL,8),W0
        movq W0,cmlop(,XR,8)
# ||mov|13,cmrop(xl)|7,xr||; set xl opnds to a, (b / c)|20250
# getarg XR
# getarg cmrop(,XL,8)
        movq XR,cmrop(,XL,8)
# ||mov|7,xr|7,xl||; point to this altered node|20251
# getarg XL
# getarg XR
        movq XL,XR
# |expp1|mov|7,xl|10,(xs)+||; restore entry xl|20255
expp1:
# getarg XL
        pop  XL
# ||exi||||; give pattern match return|20256
# getarg 
        movq $0,rcode
        ret
# |expp2|mov|7,xl|10,(xs)+||; restore entry xl|20260
expp2:
# getarg XL
        pop  XL
# ||exi|1,1|||; give non-match return|20261
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure expap|20262
# ||ejc|||||20263
# |expdm|prc|25,n|1,0||; entry point|20275
expdm:
# getarg 0
        pop  prc_+8*3
# ||mov|3,r_exs|7,xl||; save xl value|20276
# getarg XL
# getarg r_exs
        movq XL,r_exs
# |exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|; jump if stack bottom (saved level|20280
exdm1:
# getarg num01(,XT,8)
# getarg W0
# getarg exdm2
        movq l_0072,W0
        cmpq num01(,XT,8),W0
        jbe  exdm2
# ||jsr|6,expop|||; else pop one operator|20281
# getarg expop
        call expop
# ||brn|6,exdm1|||; and loop back|20282
# getarg exdm1
        jmp  exdm1
# |exdm2|mov|7,xl|3,r_exs||; restore xl|20286
exdm2:
# getarg r_exs
# getarg XL
        movq r_exs,XL
# ||zer|3,r_exs|||; release save location|20287
# getarg r_exs
        mov  $0,W0
        mov  W0,r_exs
# ||exi||||; return to expdm caller|20288
# getarg 
        movq $0,rcode
        mov  prc_+8*3,W0
        jmp  *W0
# ||enp||||; end procedure expdm|20289
# ||ejc|||||20290
# |expop|prc|25,n|1,0||; entry point|20305
expop:
# getarg 0
        pop  prc_+8*4
# ||mov|7,xr|13,num01(xs)||; load operator dv pointer|20306
# getarg num01(,XT,8)
# getarg XR
        movq num01(,XT,8),XR
# ||beq|13,dvlpr(xr)|18,=lluno|6,expo2|; jump if unary|20307
# getarg dvlpr(,XR,8)
# getarg W0
# getarg expo2
        .data
l_0780: .long lluno
        .text
        movq l_0780,W0
        cmpq dvlpr(,XR,8),W0
        je   expo2
# ||mov|8,wa|19,*cmbs_||; set size of binary operator cmblk|20311
# getarg W0
# getarg WA
        .data
l_0781: .long 8*cmbs_
        .text
        movq l_0781,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for cmblk|20312
# getarg alloc
        call alloc
# ||mov|13,cmrop(xr)|10,(xs)+||; pop and store right operand ptr|20313
# getarg cmrop(,XR,8)
        pop  cmrop(,XR,8)
# ||mov|7,xl|10,(xs)+||; pop and load operator dv ptr|20314
# getarg XL
        pop  XL
# ||mov|13,cmlop(xr)|9,(xs)||; store left operand pointer|20315
# getarg (XT)
# getarg W0
# getarg cmlop(,XR,8)
        movq (XT),W0
        movq W0,cmlop(,XR,8)
# |expo1|mov|9,(xr)|22,=b_cmt||; store type code for cmblk|20319
expo1:
# getarg W0
# getarg (XR)
        movq l_0640,W0
        movq W0,(XR)
# ||mov|13,cmtyp(xr)|13,dvtyp(xl)||; store cmblk node type code|20320
# getarg dvtyp(,XL,8)
# getarg W0
# getarg cmtyp(,XR,8)
        movq dvtyp(,XL,8),W0
        movq W0,cmtyp(,XR,8)
# ||mov|13,cmopn(xr)|7,xl||; store dvptr (=ptr to dac o_xxx)|20321
# getarg XL
# getarg cmopn(,XR,8)
        movq XL,cmopn(,XR,8)
# ||mov|13,cmlen(xr)|8,wa||; store cmblk length|20322
# getarg WA
# getarg cmlen(,XR,8)
        movq WA,cmlen(,XR,8)
# ||mov|9,(xs)|7,xr||; store resulting node ptr on stack|20323
# getarg XR
# getarg (XT)
        movq XR,(XT)
# ||exi||||; return to expop caller|20324
# getarg 
        movq $0,rcode
        mov  prc_+8*4,W0
        jmp  *W0
# |expo2|mov|8,wa|19,*cmus_||; set size of unary operator cmblk|20328
expo2:
# getarg W0
# getarg WA
        .data
l_0782: .long 8*cmus_
        .text
        movq l_0782,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for cmblk|20329
# getarg alloc
        call alloc
# ||mov|13,cmrop(xr)|10,(xs)+||; pop and store operand pointer|20330
# getarg cmrop(,XR,8)
        pop  cmrop(,XR,8)
# ||mov|7,xl|9,(xs)||; load operator dv pointer|20331
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||brn|6,expo1|||; merge back to exit|20332
# getarg expo1
        jmp  expo1
# ||enp||||; end procedure expop|20333
# ||ejc|||||20334
# |filnm|prc|25,e|1,0||; entry point|20359
filnm:
# getarg 0
# ||mov|11,-(xs)|8,wb||; preserve wb|20360
# getarg WB
        push WB
# ||bze|8,wc|6,filn3||; return nulls if stno is zero|20361
# getarg WC
# getarg filn3
        or   WC,WC
        jz   filn3
# ||mov|7,xl|3,r_sfn||; file name table|20362
# getarg r_sfn
# getarg XL
        movq r_sfn,XL
# ||bze|7,xl|6,filn3||; if no table|20363
# getarg XL
# getarg filn3
        or   XL,XL
        jz   filn3
# ||mov|8,wb|13,tbbuk(xl)||; get bucket entry|20364
# getarg tbbuk(,XL,8)
# getarg WB
        movq tbbuk(,XL,8),WB
# ||beq|8,wb|3,r_sfn|6,filn3|; jump if no teblks on chain|20365
# getarg WB
# getarg r_sfn
# getarg filn3
        cmpq WB,r_sfn
        je   filn3
# ||mov|11,-(xs)|7,xr||; preserve xr|20366
# getarg XR
        push XR
# ||mov|7,xr|8,wb||; previous block pointer|20367
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|11,-(xs)|8,wc||; preserve stmt number|20368
# getarg WC
        push WC
# |filn1|mov|7,xl|7,xr||; next element to examine|20372
filn1:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,tesub(xl)||; load subscript value (an icblk)|20373
# getarg tesub(,XL,8)
# getarg XR
        movq tesub(,XL,8),XR
# ||ldi|13,icval(xr)|||; load the statement number|20374
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||mfi|8,wc|||; convert to address constant|20375
# getarg WC
        mov  IA,WC
# ||blt|9,(xs)|8,wc|6,filn2|; compare arg with teblk stmt number|20376
# getarg (XT)
# getarg WC
# getarg filn2
        cmpq (XT),WC
        jb   filn2
# ||mov|8,wb|7,xl||; save previous entry pointer|20380
# getarg XL
# getarg WB
        movq XL,WB
# ||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|20381
# getarg tenxt(,XL,8)
# getarg XR
        movq tenxt(,XL,8),XR
# ||bne|7,xr|3,r_sfn|6,filn1|; jump if there is one|20382
# getarg XR
# getarg r_sfn
# getarg filn1
        cmpq XR,r_sfn
        jne  filn1
# |filn2|mov|7,xl|8,wb||; previous teblk|20386
filn2:
# getarg WB
# getarg XL
        movq WB,XL
# ||mov|7,xl|13,teval(xl)||; get ptr to file name scblk|20387
# getarg teval(,XL,8)
# getarg XL
        movq teval(,XL,8),XL
# ||mov|8,wc|10,(xs)+||; restore stmt number|20388
# getarg WC
        pop  WC
# ||mov|7,xr|10,(xs)+||; restore xr|20389
# getarg XR
        pop  XR
# ||mov|8,wb|10,(xs)+||; restore wb|20390
# getarg WB
        pop  WB
# ||exi|||||20391
# getarg 
        ret
# |filn3|mov|8,wb|10,(xs)+||; restore wb|20395
filn3:
# getarg WB
        pop  WB
# ||mov|7,xl|21,=nulls||; return null string|20396
# getarg W0
# getarg XL
        movq l_0054,W0
        movq W0,XL
# ||exi|||||20397
# getarg 
        ret
# ||enp|||||20398
# ||ejc|||||20399
# |flstg|prc|25,e|1,0||; entry point|20416
flstg:
# getarg 0
# ||bze|3,kvcas|6,fst99||; skip if &case is 0|20417
# getarg kvcas
# getarg fst99
        xor  W0,W0
        cmpq kvcas,W0
        jz   fst99
# ||mov|11,-(xs)|7,xl||; save xl across call|20418
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; save original scblk ptr|20419
# getarg XR
        push XR
# ||jsr|6,alocs|||; allocate new string block|20420
# getarg alocs
        call alocs
# ||mov|7,xl|9,(xs)||; point to original scblk|20421
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|11,-(xs)|7,xr||; save pointer to new scblk|20422
# getarg XR
        push XR
# ||plc|7,xl|||; point to original chars|20423
# getarg XL
        add  $cfp_f,XL
# ||psc|7,xr|||; point to new chars|20424
# getarg XR
        add  $cfp_f,XR
# ||zer|11,-(xs)|||; init did fold flag|20425
        push $0
# ||lct|8,wc|8,wc||; load loop counter|20426
# |fst01|lch|8,wa|10,(xl)+||; load character|20427
fst01:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||blt|8,wa|18,=ch_ua|6,fst02|; skip if less than uc a|20428
# getarg WA
# getarg W0
# getarg fst02
        .data
l_0783: .long ch_ua
        .text
        movq l_0783,W0
        cmpq WA,W0
        jb   fst02
# ||bgt|8,wa|18,=ch_uz|6,fst02|; skip if greater than uc z|20429
# getarg WA
# getarg W0
# getarg fst02
        .data
l_0784: .long ch_uz
        .text
        movq l_0784,W0
        cmpq WA,W0
        ja   fst02
# ||flc|8,wa|||; fold character to lower case|20430
# getarg WA
        cmpb
        jb   l_0785
        cmpb
        ja   l_0785
        add  $32
l_0785:
# ||mnz|9,(xs)|||; set did fold character flag|20431
# getarg (XT)
        mov  XS,(XT)
# |fst02|sch|8,wa|10,(xr)+||; store (possibly folded) character|20432
fst02:
# getarg WA
        movb al
        stosb
# ||bct|8,wc|6,fst01||; loop thru entire string|20433
# getarg WC
# getarg fst01
        decq WC
        jnz  fst01
# ||csc|7,xr|||; complete store characters|20434
# ||mov|7,xr|10,(xs)+||; see if any change|20435
# getarg XR
        pop  XR
# ||bnz|7,xr|6,fst10||; skip if folding done (no change)|20436
# getarg XR
# getarg XR
# getarg fst10
        or   XR,XR
        jnz  fst10
# ||mov|3,dnamp|10,(xs)+||; do not need new scblk|20437
# getarg dnamp
        pop  dnamp
# ||mov|7,xr|10,(xs)+||; return original scblk|20438
# getarg XR
        pop  XR
# ||brn|6,fst20|||; merge below|20439
# getarg fst20
        jmp  fst20
# |fst10|mov|7,xr|10,(xs)+||; return new scblk|20440
fst10:
# getarg XR
        pop  XR
# ||ica|7,xs|||; throw away original scblk pointer|20441
# getarg XT
        addq $8,XT
# |fst20|mov|8,wa|13,sclen(xr)||; reload string length|20442
fst20:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||mov|7,xl|10,(xs)+||; restore xl|20443
# getarg XL
        pop  XL
# |fst99|exi||||; return|20444
fst99:
# getarg 
        ret
# ||enp|||||20445
# ||ejc|||||20446
# ||ejc|||||20501
# ||ejc|||||20555
# ||ejc|||||20599
# ||ejc|||||20637
# |gbcol|prc|25,e|1,0||; entry point|20641
gbcol:
# getarg 0
# ||bnz|3,dmvch|6,gbc14||; fail if in mid-dump|20643
# getarg dmvch
# getarg gbc14
        xor  W0,W0
        cmpq dmvch,W0
        jnz  gbc14
# ||mnz|3,gbcfl|||; note gbcol entered|20644
# getarg gbcfl
        mov  XS,gbcfl
# ||mov|3,gbsva|8,wa||; save entry wa|20645
# getarg WA
# getarg gbsva
        movq WA,gbsva
# ||mov|3,gbsvb|8,wb||; save entry wb|20646
# getarg WB
# getarg gbsvb
        movq WB,gbsvb
# ||mov|3,gbsvc|8,wc||; save entry wc|20647
# getarg WC
# getarg gbsvc
        movq WC,gbsvc
# ||mov|11,-(xs)|7,xl||; save entry xl|20648
# getarg XL
        push XL
# ||scp|8,wa|||; get code pointer value|20649
# getarg WA
        scp_ WA
# ||sub|8,wa|3,r_cod||; make relative|20650
# getarg r_cod
# getarg WA
        subq r_cod,WA
# ||lcp|8,wa|||; and restore|20651
# getarg WA
        lcp_ WA
# ||bze|8,wb|6,gbc0a||; check there is no move offset|20653
# getarg WB
# getarg gbc0a
        or   WB,WB
        jz   gbc0a
# ||zer|3,dnams|||; collect sediment if must move it|20654
# getarg dnams
        mov  $0,W0
        mov  W0,dnams
# |gbc0a|mov|8,wa|3,dnamb||; start of dynamic area|20655
gbc0a:
# getarg dnamb
# getarg WA
        movq dnamb,WA
# ||add|8,wa|3,dnams||; size of sediment|20656
# getarg dnams
# getarg WA
        addq dnams,WA
# ||mov|3,gbcsd|8,wa||; first location past sediment|20657
# getarg WA
# getarg gbcsd
        movq WA,gbcsd
# ||mnz|7,xr|||; non-zero flags start of collection|20670
# getarg XR
        mov  XS,XR
# ||mov|8,wa|3,dnamb||; start of dynamic area|20671
# getarg dnamb
# getarg WA
        movq dnamb,WA
# ||mov|8,wb|3,dnamp||; next available location|20672
# getarg dnamp
# getarg WB
        movq dnamp,WB
# ||mov|8,wc|3,dname||; last available location + 1|20673
# getarg dname
# getarg WC
        movq dname,WC
# ||jsr|6,sysgc|||; inform of collection|20674
# getarg sysgc
        call sysgc
# ||mov|7,xr|7,xs||; point to stack front|20679
# getarg XT
# getarg XR
        movq XT,XR
# ||mov|7,xl|3,stbas||; point past end of stack|20680
# getarg stbas
# getarg XL
        movq stbas,XL
# ||bge|7,xl|7,xr|6,gbc00|; ok if d-stack|20681
# getarg XL
# getarg XR
# getarg gbc00
        cmpq XL,XR
        jae  gbc00
# ||mov|7,xr|7,xl||; reverse if ...|20682
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|7,xs||; ... u-stack|20683
# getarg XT
# getarg XL
        movq XT,XL
# |gbc00|jsr|6,gbcpf|||; process pointers on stack|20687
gbc00:
# getarg gbcpf
        call gbcpf
# ||mov|7,xr|20,=r_aaa||; point to start of relocatable locs|20691
# getarg W0
# getarg XR
        .data
l_0786: .long r_aaa
        .text
        movq l_0786,W0
        movq W0,XR
# ||mov|7,xl|20,=r_yyy||; point past end of relocatable locs|20692
# getarg W0
# getarg XL
        movq l_0039,W0
        movq W0,XL
# ||jsr|6,gbcpf|||; process work fields|20693
# getarg gbcpf
        call gbcpf
# ||mov|8,wa|3,hshtb||; point to first hash slot pointer|20697
# getarg hshtb
# getarg WA
        movq hshtb,WA
# |gbc01|mov|7,xl|8,wa||; point to next slot|20701
gbc01:
# getarg WA
# getarg XL
        movq WA,XL
# ||ica|8,wa|||; bump bucket pointer|20702
# getarg WA
        addq $8,WA
# ||mov|3,gbcnm|8,wa||; save bucket pointer|20703
# getarg WA
# getarg gbcnm
        movq WA,gbcnm
# ||ejc|||||20704
# |gbc02|mov|7,xr|9,(xl)||; load ptr to next vrblk|20710
gbc02:
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||bze|7,xr|6,gbc03||; jump if end of chain|20711
# getarg XR
# getarg gbc03
        or   XR,XR
        jz   gbc03
# ||mov|7,xl|7,xr||; else copy vrblk pointer|20712
# getarg XR
# getarg XL
        movq XR,XL
# ||add|7,xr|19,*vrval||; point to first reloc fld|20713
# getarg W0
# getarg XR
        movq l_0121,W0
        addq W0,XR
# ||add|7,xl|19,*vrnxt||; point past last (and to link ptr)|20714
# getarg W0
# getarg XL
        movq l_0034,W0
        addq W0,XL
# ||jsr|6,gbcpf|||; process reloc fields in vrblk|20715
# getarg gbcpf
        call gbcpf
# ||brn|6,gbc02|||; loop back for next block|20716
# getarg gbc02
        jmp  gbc02
# |gbc03|mov|8,wa|3,gbcnm||; restore bucket pointer|20720
gbc03:
# getarg gbcnm
# getarg WA
        movq gbcnm,WA
# ||bne|8,wa|3,hshte|6,gbc01|; loop back if more buckets to go|20721
# getarg WA
# getarg hshte
# getarg gbc01
        cmpq WA,hshte
        jne  gbc01
# ||ejc|||||20722
# ||mov|7,xr|3,dnamb||; point to first block|20751
# getarg dnamb
# getarg XR
        movq dnamb,XR
# ||zer|8,wb|||; accumulate size of dead blocks|20752
# getarg WB
        xor  WB,WB
# |gbc04|beq|7,xr|3,gbcsd|6,gbc4c|; jump if end of sediment|20753
gbc04:
# getarg XR
# getarg gbcsd
# getarg gbc4c
        cmpq XR,gbcsd
        je   gbc4c
# ||mov|8,wa|9,(xr)||; else get first word|20754
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||bod|8,wa|6,gbc4b||; jump if entry pointer (unused)|20756
# getarg WA
# getarg gbc4b
        test
        jne  gbc4b
# ||dcv|8,wa|||; restore entry pointer|20757
# getarg WA
        decq WA
# ||mov|9,(xr)|8,wa||; restore first word|20763
# getarg WA
# getarg (XR)
        movq WA,(XR)
# ||jsr|6,blkln|||; get length of this block|20764
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; bump actual pointer|20765
# getarg WA
# getarg XR
        addq WA,XR
# ||brn|6,gbc04|||; continue scan through sediment|20766
# getarg gbc04
        jmp  gbc04
# |gbc4b|jsr|6,blkln|||; get length of this block|20770
gbc4b:
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; bump actual pointer|20771
# getarg WA
# getarg XR
        addq WA,XR
# ||add|8,wb|8,wa||; count size of unused blocks|20772
# getarg WA
# getarg WB
        addq WA,WB
# ||brn|6,gbc04|||; continue scan through sediment|20773
# getarg gbc04
        jmp  gbc04
# |gbc4c|mov|3,gbcsf|8,wb||; size of sediment free space|20784
gbc4c:
# getarg WB
# getarg gbcsf
        movq WB,gbcsf
# ||mov|8,wc|7,xr||; set as first eventual location|20788
# getarg XR
# getarg WC
        movq XR,WC
# ||add|8,wc|3,gbsvb||; add offset for eventual move up|20789
# getarg gbsvb
# getarg WC
        addq gbsvb,WC
# ||zer|3,gbcnm|||; clear initial forward pointer|20790
# getarg gbcnm
        mov  $0,W0
        mov  W0,gbcnm
# ||mov|3,gbclm|20,=gbcnm||; initialize ptr to last move block|20791
# getarg W0
# getarg gbclm
        .data
l_0787: .long gbcnm
        .text
        movq l_0787,W0
        movq W0,gbclm
# ||mov|3,gbcns|7,xr||; initialize first address|20792
# getarg XR
# getarg gbcns
        movq XR,gbcns
# |gbc05|beq|7,xr|3,dnamp|6,gbc07|; jump if end of used region|20796
gbc05:
# getarg XR
# getarg dnamp
# getarg gbc07
        cmpq XR,dnamp
        je   gbc07
# ||mov|8,wa|9,(xr)||; else get first word|20797
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||bod|8,wa|6,gbc07||; jump if entry pointer (unused)|20799
# getarg WA
# getarg gbc07
        test
        jne  gbc07
# |gbc06|mov|7,xl|8,wa||; copy pointer|20807
gbc06:
# getarg WA
# getarg XL
        movq WA,XL
# ||mov|8,wa|9,(xl)||; load forward pointer|20808
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||mov|9,(xl)|8,wc||; relocate reference|20809
# getarg WC
# getarg (XL)
        movq WC,(XL)
# ||bev|8,wa|6,gbc06||; loop back if not end of chain|20811
# getarg WA
# getarg gbc06
        test
        je   gbc06
# ||ejc|||||20816
# ||mov|9,(xr)|8,wa||; restore first word|20822
# getarg WA
# getarg (XR)
        movq WA,(XR)
# ||jsr|6,blkln|||; get length of this block|20823
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; bump actual pointer|20824
# getarg WA
# getarg XR
        addq WA,XR
# ||add|8,wc|8,wa||; bump eventual pointer|20825
# getarg WA
# getarg WC
        addq WA,WC
# ||brn|6,gbc05|||; loop back for next block|20826
# getarg gbc05
        jmp  gbc05
# |gbc07|mov|8,wa|7,xr||; copy pointer past last block|20830
gbc07:
# getarg XR
# getarg WA
        movq XR,WA
# ||mov|7,xl|3,gbclm||; point to previous move block|20831
# getarg gbclm
# getarg XL
        movq gbclm,XL
# ||sub|8,wa|13,num01(xl)||; subtract starting address|20832
# getarg num01(,XL,8)
# getarg WA
        subq num01(,XL,8),WA
# ||mov|13,num01(xl)|8,wa||; store length of block to be moved|20833
# getarg WA
# getarg num01(,XL,8)
        movq WA,num01(,XL,8)
# |gbc08|beq|7,xr|3,dnamp|6,gbc10|; jump if end of used region|20837
gbc08:
# getarg XR
# getarg dnamp
# getarg gbc10
        cmpq XR,dnamp
        je   gbc10
# ||mov|8,wa|9,(xr)||; else load first word of next block|20838
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||bev|8,wa|6,gbc09||; jump if in use|20840
# getarg WA
# getarg gbc09
        test
        je   gbc09
# ||jsr|6,blkln|||; else get length of next block|20845
# getarg blkln
        call blkln
# ||add|7,xr|8,wa||; push pointer|20846
# getarg WA
# getarg XR
        addq WA,XR
# ||brn|6,gbc08|||; and loop back|20847
# getarg gbc08
        jmp  gbc08
# |gbc09|sub|7,xr|19,*num02||; point 2 words behind for move block|20852
gbc09:
# getarg W0
# getarg XR
        movq l_0135,W0
        subq W0,XR
# ||mov|7,xl|3,gbclm||; point to previous move block|20853
# getarg gbclm
# getarg XL
        movq gbclm,XL
# ||mov|9,(xl)|7,xr||; set forward ptr in previous block|20854
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||zer|9,(xr)|||; zero forward ptr of new block|20855
# getarg (XR)
        mov  $0,W0
        mov  W0,(XR)
# ||mov|3,gbclm|7,xr||; remember address of this block|20856
# getarg XR
# getarg gbclm
        movq XR,gbclm
# ||mov|7,xl|7,xr||; copy ptr to move block|20857
# getarg XR
# getarg XL
        movq XR,XL
# ||add|7,xr|19,*num02||; point back to block in use|20858
# getarg W0
# getarg XR
        movq l_0135,W0
        addq W0,XR
# ||mov|13,num01(xl)|7,xr||; store starting address|20859
# getarg XR
# getarg num01(,XL,8)
        movq XR,num01(,XL,8)
# ||brn|6,gbc06|||; jump to process block in use|20860
# getarg gbc06
        jmp  gbc06
# ||ejc|||||20861
# |gbc10|mov|7,xr|3,gbcsd||; point to storage above sediment|20871
gbc10:
# getarg gbcsd
# getarg XR
        movq gbcsd,XR
# ||add|7,xr|3,gbcns||; bump past unmoved blocks at start|20875
# getarg gbcns
# getarg XR
        addq gbcns,XR
# |gbc11|mov|7,xl|3,gbcnm||; point to next move block|20879
gbc11:
# getarg gbcnm
# getarg XL
        movq gbcnm,XL
# ||bze|7,xl|6,gbc12||; jump if end of chain|20880
# getarg XL
# getarg gbc12
        or   XL,XL
        jz   gbc12
# ||mov|3,gbcnm|10,(xl)+||; move pointer down chain|20881
# getarg gbcnm
        lodsq
        movq W0,gbcnm
# ||mov|8,wa|10,(xl)+||; get length to move|20882
# getarg WA
        lodsq
        movq W0,WA
# ||mvw||||; perform move|20883
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0788:
        or   WA,WA
        jz   l_0789
        movsq
        decq WA
        jmp  l_0788
l_0789:
        cld
# ||brn|6,gbc11|||; loop back|20884
# getarg gbc11
        jmp  gbc11
# |gbc12|mov|3,dnamp|7,xr||; set next available loc ptr|20888
gbc12:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||mov|8,wb|3,gbsvb||; reload move offset|20889
# getarg gbsvb
# getarg WB
        movq gbsvb,WB
# ||bze|8,wb|6,gbc13||; jump if no move required|20890
# getarg WB
# getarg gbc13
        or   WB,WB
        jz   gbc13
# ||mov|7,xl|7,xr||; else copy old top of core|20891
# getarg XR
# getarg XL
        movq XR,XL
# ||add|7,xr|8,wb||; point to new top of core|20892
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|3,dnamp|7,xr||; save new top of core pointer|20893
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||mov|8,wa|7,xl||; copy old top|20894
# getarg XL
# getarg WA
        movq XL,WA
# ||sub|8,wa|3,dnamb||; minus old bottom = length|20895
# getarg dnamb
# getarg WA
        subq dnamb,WA
# ||add|3,dnamb|8,wb||; bump bottom to get new value|20896
# getarg WB
# getarg dnamb
        addq WB,dnamb
# ||mwb||||; perform move (backwards)|20897
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0790:
        or   WA,WA
        jz   l_0791
        movsq
        decq WA
        jmp  l_0790
l_0791:
        cld
# |gbc13|zer|7,xr|||; clear garbage value in xr|20901
gbc13:
# getarg XR
        xor  XR,XR
# ||mov|3,gbcfl|7,xr||; note exit from gbcol|20902
# getarg XR
# getarg gbcfl
        movq XR,gbcfl
# ||mov|8,wa|3,dnamb||; start of dynamic area|20904
# getarg dnamb
# getarg WA
        movq dnamb,WA
# ||mov|8,wb|3,dnamp||; next available location|20905
# getarg dnamp
# getarg WB
        movq dnamp,WB
# ||mov|8,wc|3,dname||; last available location + 1|20906
# getarg dname
# getarg WC
        movq dname,WC
# ||jsr|6,sysgc|||; inform sysgc of completion|20907
# getarg sysgc
        call sysgc
# ||sti|3,gbcia|||; save ia|20915
# getarg gbcia
        mov  IA,gbcia
# ||zer|7,xr|||; presume no sediment will remain|20916
# getarg XR
        xor  XR,XR
# ||mov|8,wb|3,gbcsf||; free space in sediment|20917
# getarg gbcsf
# getarg WB
        movq gbcsf,WB
# ||btw|8,wb|||; convert bytes to words|20918
# getarg WB
        shr  WB,3
# ||mti|8,wb|||; put sediment free store in ia|20919
# getarg WB
        mov  WB,IA
# ||mli|3,gbsed|||; multiply by sediment factor|20920
# getarg gbsed
        imul gbsed,IA
        seto reg_fl
# ||iov|6,gb13a|||; jump if overflowed|20921
# getarg gb13a
        iov_ gb13a
# ||mov|8,wb|3,dnamp||; end of dynamic area in use|20922
# getarg dnamp
# getarg WB
        movq dnamp,WB
# ||sub|8,wb|3,dnamb||; minus start is sediment remaining|20923
# getarg dnamb
# getarg WB
        subq dnamb,WB
# ||btw|8,wb|||; convert to words|20924
# getarg WB
        shr  WB,3
# ||mov|3,gbcsf|8,wb||; store it|20925
# getarg WB
# getarg gbcsf
        movq WB,gbcsf
# ||sbi|3,gbcsf|||; subtract from scaled up free store|20926
# getarg gbcsf
        sub  gbcsf,IA
        xor  W0,W0
        seto reg_fl
# ||igt|6,gb13a|||; jump if large free store in sedimnt|20927
# getarg gb13a
        mov  IA,W0
        or   W0,W0
        jg   gb13a
# ||mov|7,xr|3,dnamp||; below threshold, return sediment|20928
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||sub|7,xr|3,dnamb||; for use by caller|20929
# getarg dnamb
# getarg XR
        subq dnamb,XR
# |gb13a|ldi|3,gbcia|||; restore ia|20930
gb13a:
# getarg gbcia
        mov  gbcia,IA
# ||mov|8,wa|3,gbsva||; restore wa|20932
# getarg gbsva
# getarg WA
        movq gbsva,WA
# ||mov|8,wb|3,gbsvb||; restore wb|20933
# getarg gbsvb
# getarg WB
        movq gbsvb,WB
# ||scp|8,wc|||; get code pointer|20934
# getarg WC
        scp_ WC
# ||add|8,wc|3,r_cod||; make absolute again|20935
# getarg r_cod
# getarg WC
        addq r_cod,WC
# ||lcp|8,wc|||; and replace absolute value|20936
# getarg WC
        lcp_ WC
# ||mov|8,wc|3,gbsvc||; restore wc|20937
# getarg gbsvc
# getarg WC
        movq gbsvc,WC
# ||mov|7,xl|10,(xs)+||; restore entry xl|20938
# getarg XL
        pop  XL
# ||icv|3,gbcnt|||; increment count of collections|20939
# getarg gbcnt
        incq gbcnt
# ||exi||||; exit to gbcol caller|20940
# getarg 
        ret
# |gbc14|icv|3,errft|||; fatal error|20944
gbc14:
# getarg errft
        incq errft
# ||erb|1,250|26,insufficient memory to complete dump|||20945
        movq $250,rcode
        jmp  err_
# ||enp||||; end procedure gbcol|20946
# ||ejc|||||20947
# |gbcpf|prc|25,e|1,0||; entry point|20962
gbcpf:
# getarg 0
# ||zer|11,-(xs)|||; set zero to mark bottom of stack|20963
        push $0
# ||mov|11,-(xs)|7,xl||; save end pointer|20964
# getarg XL
        push XL
# |gpf01|mov|7,xl|9,(xr)||; load field contents|20974
gpf01:
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||mov|8,wc|7,xr||; save field pointer|20975
# getarg XR
# getarg WC
        movq XR,WC
# ||blt|7,xl|3,dnamb|6,gpf2a|; jump if not ptr into dynamic area|20979
# getarg XL
# getarg dnamb
# getarg gpf2a
        cmpq XL,dnamb
        jb   gpf2a
# ||bge|7,xl|3,dnamp|6,gpf2a|; jump if not ptr into dynamic area|20980
# getarg XL
# getarg dnamp
# getarg gpf2a
        cmpq XL,dnamp
        jae  gpf2a
# ||mov|8,wa|9,(xl)||; load ptr to chain (or entry ptr)|20985
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||blt|7,xl|3,gbcsd|6,gpf1a|; do not chain if within sediment|20987
# getarg XL
# getarg gbcsd
# getarg gpf1a
        cmpq XL,gbcsd
        jb   gpf1a
# ||mov|9,(xl)|7,xr||; set this field as new head of chain|20989
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||mov|9,(xr)|8,wa||; set forward pointer|20990
# getarg WA
# getarg (XR)
        movq WA,(XR)
# |gpf1a|bod|8,wa|6,gpf03||; jump if not already processed|20995
gpf1a:
# getarg WA
# getarg gpf03
        test
        jne  gpf03
# |gpf02|mov|7,xr|8,wc||; restore field pointer|21003
gpf02:
# getarg WC
# getarg XR
        movq WC,XR
# |gpf2a|ica|7,xr|||; bump to next field|21007
gpf2a:
# getarg XR
        addq $8,XR
# ||bne|7,xr|9,(xs)|6,gpf01|; loop back if more to go|21008
# getarg XR
# getarg (XT)
# getarg gpf01
        cmpq XR,(XT)
        jne  gpf01
# ||ejc|||||21009
# ||mov|7,xl|10,(xs)+||; restore pointer past end|21015
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; restore block pointer|21016
# getarg XR
        pop  XR
# ||bnz|7,xr|6,gpf2a||; continue loop unless outer levl|21017
# getarg XR
# getarg XR
# getarg gpf2a
        or   XR,XR
        jnz  gpf2a
# ||exi||||; return to caller if outer level|21018
# getarg 
        ret
# |gpf03|bge|7,xl|3,gbcsd|6,gpf3a|; if not within sediment|21031
gpf03:
# getarg XL
# getarg gbcsd
# getarg gpf3a
        cmpq XL,gbcsd
        jae  gpf3a
# ||icv|9,(xl)|||; mark by making entry point even|21033
# getarg (XL)
        incq (XL)
# |gpf3a|mov|7,xr|7,xl||; copy block pointer|21037
gpf3a:
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|8,wa||; copy first word of block|21041
# getarg WA
# getarg XL
        movq WA,XL
# ||lei|7,xl|||; load entry point id (bl_xx)|21042
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||bsw|7,xl|2,bl___||; switch on block type|21047
# getarg XL
        jmp  *l_0792(,XL,8)
        .data
l_0792:
# ||iff|2,bl_ar|6,gpf06||; arblk|21085
# getarg gpf06
        .long gpf06
# ||iff|2,bl_cd|6,gpf19||; cdblk|21085
# getarg gpf19
        .long gpf19
# ||iff|2,bl_ex|6,gpf17||; exblk|21085
# getarg gpf17
        .long gpf17
# ||iff|2,bl_ic|6,gpf02||; icblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_nm|6,gpf10||; nmblk|21085
# getarg gpf10
        .long gpf10
# ||iff|2,bl_p0|6,gpf10||; p0blk|21085
# getarg gpf10
        .long gpf10
# ||iff|2,bl_p1|6,gpf12||; p1blk|21085
# getarg gpf12
        .long gpf12
# ||iff|2,bl_p2|6,gpf12||; p2blk|21085
# getarg gpf12
        .long gpf12
# ||iff|2,bl_rc|6,gpf02||; rcblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_sc|6,gpf02||; scblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_se|6,gpf02||; seblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_tb|6,gpf08||; tbblk|21085
# getarg gpf08
        .long gpf08
# ||iff|2,bl_vc|6,gpf08||; vcblk|21085
# getarg gpf08
        .long gpf08
# ||iff|2,bl_xn|6,gpf02||; xnblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_xr|6,gpf09||; xrblk|21085
# getarg gpf09
        .long gpf09
# ||iff|2,bl_bc|6,gpf02||; bcblk - dummy to fill out iffs|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_pd|6,gpf13||; pdblk|21085
# getarg gpf13
        .long gpf13
# ||iff|2,bl_tr|6,gpf16||; trblk|21085
# getarg gpf16
        .long gpf16
# ||iff|2,bl_bf|6,gpf02||; bfblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_cc|6,gpf07||; ccblk|21085
# getarg gpf07
        .long gpf07
# ||iff|2,bl_cm|6,gpf04||; cmblk|21085
# getarg gpf04
        .long gpf04
# ||iff|2,bl_ct|6,gpf02||; ctblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_df|6,gpf02||; dfblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_ef|6,gpf02||; efblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_ev|6,gpf10||; evblk|21085
# getarg gpf10
        .long gpf10
# ||iff|2,bl_ff|6,gpf11||; ffblk|21085
# getarg gpf11
        .long gpf11
# ||iff|2,bl_kv|6,gpf02||; kvblk|21085
# getarg gpf02
        .long gpf02
# ||iff|2,bl_pf|6,gpf14||; pfblk|21085
# getarg gpf14
        .long gpf14
# ||iff|2,bl_te|6,gpf15||; teblk|21085
# getarg gpf15
        .long gpf15
# ||esw||||; end of jump table|21085
        .text
# ||ejc|||||21086
# |gpf04|mov|8,wa|13,cmlen(xr)||; load length|21092
gpf04:
# getarg cmlen(,XR,8)
# getarg WA
        movq cmlen(,XR,8),WA
# ||mov|8,wb|19,*cmtyp||; set offset|21093
# getarg W0
# getarg WB
        .data
l_0793: .long 8*cmtyp
        .text
        movq l_0793,W0
        movq W0,WB
# |gpf05|add|8,wa|7,xr||; point past last reloc field|21102
gpf05:
# getarg XR
# getarg WA
        addq XR,WA
# ||add|7,xr|8,wb||; point to first reloc field|21103
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|11,-(xs)|8,wc||; stack old field pointer|21104
# getarg WC
        push WC
# ||mov|11,-(xs)|8,wa||; stack new limit pointer|21105
# getarg WA
        push WA
# ||chk||||; check for stack overflow|21106
        chk_
        or   W0,W0
        jne  sec06
# ||brn|6,gpf01|||; if ok, back to process|21107
# getarg gpf01
        jmp  gpf01
# |gpf06|mov|8,wa|13,arlen(xr)||; load length|21111
gpf06:
# getarg arlen(,XR,8)
# getarg WA
        movq arlen(,XR,8),WA
# ||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)|21112
# getarg arofs(,XR,8)
# getarg WB
        movq arofs(,XR,8),WB
# ||brn|6,gpf05|||; all set|21113
# getarg gpf05
        jmp  gpf05
# |gpf07|mov|8,wa|13,ccuse(xr)||; set length in use|21117
gpf07:
# getarg ccuse(,XR,8)
# getarg WA
        movq ccuse(,XR,8),WA
# ||mov|8,wb|19,*ccuse||; 1st word (make sure at least one)|21118
# getarg W0
# getarg WB
        movq l_0682,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21119
# getarg gpf05
        jmp  gpf05
# ||ejc|||||21120
# |gpf19|mov|8,wa|13,cdlen(xr)||; load length|21127
gpf19:
# getarg cdlen(,XR,8)
# getarg WA
        movq cdlen(,XR,8),WA
# ||mov|8,wb|19,*cdfal||; set offset|21128
# getarg W0
# getarg WB
        movq l_0011,W0
        movq W0,WB
# ||brn|6,gpf05|||; jump back|21129
# getarg gpf05
        jmp  gpf05
# |gpf08|mov|8,wa|13,offs2(xr)||; load length|21136
gpf08:
# getarg offs2(,XR,8)
# getarg WA
        movq offs2(,XR,8),WA
# ||mov|8,wb|19,*offs3||; set offset|21137
# getarg W0
# getarg WB
        movq l_0016,W0
        movq W0,WB
# ||brn|6,gpf05|||; jump back|21138
# getarg gpf05
        jmp  gpf05
# |gpf09|mov|8,wa|13,xrlen(xr)||; load length|21142
gpf09:
# getarg xrlen(,XR,8)
# getarg WA
        movq xrlen(,XR,8),WA
# ||mov|8,wb|19,*xrptr||; set offset|21143
# getarg W0
# getarg WB
        movq l_0033,W0
        movq W0,WB
# ||brn|6,gpf05|||; jump back|21144
# getarg gpf05
        jmp  gpf05
# |gpf10|mov|8,wa|19,*offs2||; point past second field|21148
gpf10:
# getarg W0
# getarg WA
        movq l_0023,W0
        movq W0,WA
# ||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)|21149
# getarg W0
# getarg WB
        movq l_0024,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21150
# getarg gpf05
        jmp  gpf05
# |gpf11|mov|8,wa|19,*ffofs||; set length|21154
gpf11:
# getarg W0
# getarg WA
        movq l_0021,W0
        movq W0,WA
# ||mov|8,wb|19,*ffnxt||; set offset|21155
# getarg W0
# getarg WB
        .data
l_0794: .long 8*ffnxt
        .text
        movq l_0794,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21156
# getarg gpf05
        jmp  gpf05
# |gpf12|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)|21160
gpf12:
# getarg W0
# getarg WA
        movq l_0025,W0
        movq W0,WA
# ||mov|8,wb|19,*pthen||; set offset|21161
# getarg W0
# getarg WB
        movq l_0026,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21162
# getarg gpf05
        jmp  gpf05
# ||ejc|||||21163
# |gpf13|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk|21169
gpf13:
# getarg pddfp(,XR,8)
# getarg XL
        movq pddfp(,XR,8),XL
# ||mov|8,wa|13,dfpdl(xl)||; get pdblk length|21170
# getarg dfpdl(,XL,8)
# getarg WA
        movq dfpdl(,XL,8),WA
# ||mov|8,wb|19,*pdfld||; set offset|21171
# getarg W0
# getarg WB
        movq l_0019,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21172
# getarg gpf05
        jmp  gpf05
# |gpf14|mov|8,wa|19,*pfarg||; length past last reloc|21176
gpf14:
# getarg W0
# getarg WA
        movq l_0156,W0
        movq W0,WA
# ||mov|8,wb|19,*pfcod||; offset to first reloc|21177
# getarg W0
# getarg WB
        movq l_0028,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21178
# getarg gpf05
        jmp  gpf05
# |gpf15|mov|8,wa|19,*tesi_||; set length|21182
gpf15:
# getarg W0
# getarg WA
        movq l_0029,W0
        movq W0,WA
# ||mov|8,wb|19,*tesub||; and offset|21183
# getarg W0
# getarg WB
        movq l_0030,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21184
# getarg gpf05
        jmp  gpf05
# |gpf16|mov|8,wa|19,*trsi_||; set length|21188
gpf16:
# getarg W0
# getarg WA
        movq l_0031,W0
        movq W0,WA
# ||mov|8,wb|19,*trval||; and offset|21189
# getarg W0
# getarg WB
        movq l_0032,W0
        movq W0,WB
# ||brn|6,gpf05|||; all set|21190
# getarg gpf05
        jmp  gpf05
# |gpf17|mov|8,wa|13,exlen(xr)||; load length|21194
gpf17:
# getarg exlen(,XR,8)
# getarg WA
        movq exlen(,XR,8),WA
# ||mov|8,wb|19,*exflc||; set offset|21195
# getarg W0
# getarg WB
        movq l_0018,W0
        movq W0,WB
# ||brn|6,gpf05|||; jump back|21196
# getarg gpf05
        jmp  gpf05
# ||enp||||; end procedure gbcpf|21206
# ||ejc|||||21207
# |gtarr|prc|25,e|1,2||; entry point|21223
gtarr:
# getarg 2
# ||mov|3,gtawa|8,wa||; save wa indicator|21224
# getarg WA
# getarg gtawa
        movq WA,gtawa
# ||mov|8,wa|9,(xr)||; load type word|21225
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_art|6,gtar8|; exit if already an array|21226
# getarg WA
# getarg W0
# getarg gtar8
        movq l_0247,W0
        cmpq WA,W0
        je   gtar8
# ||beq|8,wa|22,=b_vct|6,gtar8|; exit if already an array|21227
# getarg WA
# getarg W0
# getarg gtar8
        movq l_0085,W0
        cmpq WA,W0
        je   gtar8
# ||bne|8,wa|22,=b_tbt|6,gta9a|; else fail if not a table (sgd02)|21228
# getarg WA
# getarg W0
# getarg gta9a
        movq l_0086,W0
        cmpq WA,W0
        jne  gta9a
# ||mov|11,-(xs)|7,xr||; replace tbblk pointer on stack|21232
# getarg XR
        push XR
# ||zer|7,xr|||; signal first pass|21233
# getarg XR
        xor  XR,XR
# ||zer|8,wb|||; zero non-null element count|21234
# getarg WB
        xor  WB,WB
# |gtar1|mov|7,xl|9,(xs)||; point to table|21244
gtar1:
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|7,xl|13,tblen(xl)||; point past last bucket|21245
# getarg tblen(,XL,8)
# getarg XL
        addq tblen(,XL,8),XL
# ||sub|7,xl|19,*tbbuk||; set first bucket offset|21246
# getarg W0
# getarg XL
        movq l_0632,W0
        subq W0,XL
# ||mov|8,wa|7,xl||; copy adjusted pointer|21247
# getarg XL
# getarg WA
        movq XL,WA
# |gtar2|mov|7,xl|8,wa||; copy bucket pointer|21253
gtar2:
# getarg WA
# getarg XL
        movq WA,XL
# ||dca|8,wa|||; decrement bucket pointer|21254
# getarg WA
        subq $8,WA
# |gtar3|mov|7,xl|13,tenxt(xl)||; point to next teblk|21258
gtar3:
# getarg tenxt(,XL,8)
# getarg XL
        movq tenxt(,XL,8),XL
# ||beq|7,xl|9,(xs)|6,gtar6|; jump if chain end (tbblk ptr)|21259
# getarg XL
# getarg (XT)
# getarg gtar6
        cmpq XL,(XT)
        je   gtar6
# ||mov|3,cnvtp|7,xl||; else save teblk pointer|21260
# getarg XL
# getarg cnvtp
        movq XL,cnvtp
# |gtar4|mov|7,xl|13,teval(xl)||; load value|21264
gtar4:
# getarg teval(,XL,8)
# getarg XL
        movq teval(,XL,8),XL
# ||beq|9,(xl)|22,=b_trt|6,gtar4|; loop till value found|21265
# getarg (XL)
# getarg W0
# getarg gtar4
        movq l_0154,W0
        cmpq (XL),W0
        je   gtar4
# ||mov|8,wc|7,xl||; copy value|21266
# getarg XL
# getarg WC
        movq XL,WC
# ||mov|7,xl|3,cnvtp||; restore teblk pointer|21267
# getarg cnvtp
# getarg XL
        movq cnvtp,XL
# ||ejc|||||21268
# ||beq|8,wc|21,=nulls|6,gtar3|; loop back to ignore null value|21274
# getarg WC
# getarg W0
# getarg gtar3
        movq l_0054,W0
        cmpq WC,W0
        je   gtar3
# ||bnz|7,xr|6,gtar5||; jump if second pass|21275
# getarg XR
# getarg XR
# getarg gtar5
        or   XR,XR
        jnz  gtar5
# ||icv|8,wb|||; for the first pass, bump count|21276
# getarg WB
        incq WB
# ||brn|6,gtar3|||; and loop back for next teblk|21277
# getarg gtar3
        jmp  gtar3
# |gtar5|bze|3,gtawa|6,gta5a||; jump if address wanted|21281
gtar5:
# getarg gtawa
# getarg gta5a
        xor  W0,W0
        cmpq gtawa,W0
        jz   gta5a
# ||mov|10,(xr)+|13,tesub(xl)||; store subscript name|21282
# getarg tesub(,XL,8)
        movq tesub(,XL,8),W0
        stosq
# ||mov|10,(xr)+|8,wc||; store value in arblk|21283
# getarg WC
        movq WC,W0
        stosq
# ||brn|6,gtar3|||; loop back for next teblk|21284
# getarg gtar3
        jmp  gtar3
# |gta5a|mov|10,(xr)+|7,xl||; store teblk address in name|21289
gta5a:
# getarg XL
        movq XL,W0
        stosq
# ||mov|10,(xr)+|7,xl||; and value slots|21290
# getarg XL
        movq XL,W0
        stosq
# ||brn|6,gtar3|||; loop back for next teblk|21291
# getarg gtar3
        jmp  gtar3
# |gtar6|bne|8,wa|9,(xs)|6,gtar2|; loop back if more buckets to go|21295
gtar6:
# getarg WA
# getarg (XT)
# getarg gtar2
        cmpq WA,(XT)
        jne  gtar2
# ||bnz|7,xr|6,gtar7||; else jump if second pass|21296
# getarg XR
# getarg XR
# getarg gtar7
        or   XR,XR
        jnz  gtar7
# ||bze|8,wb|6,gtar9||; fail if no non-null elements|21300
# getarg WB
# getarg gtar9
        or   WB,WB
        jz   gtar9
# ||mov|8,wa|8,wb||; else copy count|21301
# getarg WB
# getarg WA
        movq WB,WA
# ||add|8,wa|8,wb||; double (two words/element)|21302
# getarg WB
# getarg WA
        addq WB,WA
# ||add|8,wa|18,=arvl2||; add space for standard fields|21303
# getarg W0
# getarg WA
        .data
l_0795: .long arvl2
        .text
        movq l_0795,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|21304
# getarg WA
        sal  WA,3
# ||bgt|8,wa|3,mxlen|6,gta9b|; error if too long for array|21305
# getarg WA
# getarg mxlen
# getarg gta9b
        cmpq WA,mxlen
        ja   gta9b
# ||jsr|6,alloc|||; else allocate space for arblk|21306
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_art||; store type word|21307
# getarg W0
# getarg (XR)
        movq l_0247,W0
        movq W0,(XR)
# ||zer|13,idval(xr)|||; zero id for the moment|21308
# getarg idval(,XR,8)
        mov  $0,W0
        mov  W0,idval(,XR,8)
# ||mov|13,arlen(xr)|8,wa||; store length|21309
# getarg WA
# getarg arlen(,XR,8)
        movq WA,arlen(,XR,8)
# ||mov|13,arndm(xr)|18,=num02||; set dimensions = 2|21310
# getarg W0
# getarg arndm(,XR,8)
        movq l_0130,W0
        movq W0,arndm(,XR,8)
# ||ldi|4,intv1|||; get integer one|21311
# getarg intv1
        mov  intv1,IA
# ||sti|13,arlbd(xr)|||; store as lbd 1|21312
# getarg arlbd(,XR,8)
        mov  IA,arlbd(,XR,8)
# ||sti|13,arlb2(xr)|||; store as lbd 2|21313
# getarg arlb2(,XR,8)
        mov  IA,arlb2(,XR,8)
# ||ldi|4,intv2|||; load integer two|21314
# getarg intv2
        mov  intv2,IA
# ||sti|13,ardm2(xr)|||; store as dim 2|21315
# getarg ardm2(,XR,8)
        mov  IA,ardm2(,XR,8)
# ||mti|8,wb|||; get element count as integer|21316
# getarg WB
        mov  WB,IA
# ||sti|13,ardim(xr)|||; store as dim 1|21317
# getarg ardim(,XR,8)
        mov  IA,ardim(,XR,8)
# ||zer|13,arpr2(xr)|||; zero prototype field for now|21318
# getarg arpr2(,XR,8)
        mov  $0,W0
        mov  W0,arpr2(,XR,8)
# ||mov|13,arofs(xr)|19,*arpr2||; set offset field (signal pass 2)|21319
# getarg W0
# getarg arofs(,XR,8)
        .data
l_0796: .long 8*arpr2
        .text
        movq l_0796,W0
        movq W0,arofs(,XR,8)
# ||mov|8,wb|7,xr||; save arblk pointer|21320
# getarg XR
# getarg WB
        movq XR,WB
# ||add|7,xr|19,*arvl2||; point to first element location|21321
# getarg W0
# getarg XR
        movq l_0284,W0
        addq W0,XR
# ||brn|6,gtar1|||; jump back to fill in elements|21322
# getarg gtar1
        jmp  gtar1
# ||ejc|||||21323
# |gtar7|mov|7,xr|8,wb||; restore arblk pointer|21329
gtar7:
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|9,(xs)|8,wb||; store as result|21330
# getarg WB
# getarg (XT)
        movq WB,(XT)
# ||ldi|13,ardim(xr)|||; get number of elements (nn)|21336
# getarg ardim(,XR,8)
        mov  ardim(,XR,8),IA
# ||mli|4,intvh|||; multiply by 100|21337
# getarg intvh
        imul intvh,IA
        seto reg_fl
# ||adi|4,intv2|||; add 2 (nn02)|21338
# getarg intv2
        add  intv2,IA
        seto reg_fl
# ||jsr|6,icbld|||; build integer|21339
# getarg icbld
        call icbld
# ||mov|11,-(xs)|7,xr||; store ptr for gtstg|21340
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert to string|21341
# getarg gtstg
        call gtstg
        decq rcode
        js   call_233
# ||ppm||||; convert fail is impossible|21342
# getarg 
        decq rcode
        jns  l_0797
        movq $299,rcode
        jmp  err_
l_0797:
call_233:
# ||mov|7,xl|7,xr||; copy string pointer|21343
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|10,(xs)+||; reload arblk pointer|21344
# getarg XR
        pop  XR
# ||mov|13,arpr2(xr)|7,xl||; store prototype ptr (nn02)|21345
# getarg XL
# getarg arpr2(,XR,8)
        movq XL,arpr2(,XR,8)
# ||sub|8,wa|18,=num02||; adjust length to point to zero|21346
# getarg W0
# getarg WA
        movq l_0130,W0
        subq W0,WA
# ||psc|7,xl|8,wa||; point to zero|21347
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|8,wb|18,=ch_cm||; load a comma|21348
# getarg W0
# getarg WB
        movq l_0159,W0
        movq W0,WB
# ||sch|8,wb|9,(xl)||; store a comma over the zero|21349
# getarg WB
        movb
# ||csc|7,xl|||; complete store characters|21350
# |gtar8|exi||||; return to caller|21354
gtar8:
# getarg 
        movq $0,rcode
        ret
# |gtar9|mov|7,xr|10,(xs)+||; restore stack for conv err (sgd02)|21358
gtar9:
# getarg XR
        pop  XR
# ||exi|1,1|||; return|21359
# getarg 1
        movq $1,rcode
        ret
# |gta9a|exi|1,2|||; return|21363
gta9a:
# getarg 2
        movq $2,rcode
        ret
# |gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||21367
gta9b:
        movq $260,rcode
        jmp  err_
# ||enp||||; procedure gtarr|21368
# ||ejc|||||21369
# |gtcod|prc|25,e|1,1||; entry point|21383
gtcod:
# getarg 1
# ||beq|9,(xr)|22,=b_cds|6,gtcd1|; jump if already code|21384
# getarg (XR)
# getarg W0
# getarg gtcd1
        movq l_0112,W0
        cmpq (XR),W0
        je   gtcd1
# ||beq|9,(xr)|22,=b_cdc|6,gtcd1|; jump if already code|21385
# getarg (XR)
# getarg W0
# getarg gtcd1
        movq l_0012,W0
        cmpq (XR),W0
        je   gtcd1
# ||mov|11,-(xs)|7,xr||; stack argument for gtstg|21389
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert argument to string|21390
# getarg gtstg
        call gtstg
        decq rcode
        js   call_234
# ||ppm|6,gtcd2|||; jump if non-convertible|21391
# getarg gtcd2
# getarg gtcd2
        decq rcode
        jns  l_0798
        jmp  gtcd2
l_0798:
call_234:
# ||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21392
# getarg flptr
# getarg W0
# getarg gtcef
        movq flptr,W0
        movq W0,gtcef
# ||mov|3,r_gtc|3,r_cod||; also save code ptr|21393
# getarg r_cod
# getarg W0
# getarg r_gtc
        movq r_cod,W0
        movq W0,r_gtc
# ||mov|3,r_cim|7,xr||; else set image pointer|21394
# getarg XR
# getarg r_cim
        movq XR,r_cim
# ||mov|3,scnil|8,wa||; set image length|21395
# getarg WA
# getarg scnil
        movq WA,scnil
# ||zer|3,scnpt|||; set scan pointer|21396
# getarg scnpt
        mov  $0,W0
        mov  W0,scnpt
# ||mov|3,stage|18,=stgxc||; set stage for execute compile|21397
# getarg W0
# getarg stage
        .data
l_0799: .long stgxc
        .text
        movq l_0799,W0
        movq W0,stage
# ||mov|3,lstsn|3,cmpsn||; in case listr called|21398
# getarg cmpsn
# getarg W0
# getarg lstsn
        movq cmpsn,W0
        movq W0,lstsn
# ||icv|3,cmpln|||; bump line number|21400
# getarg cmpln
        incq cmpln
# ||jsr|6,cmpil|||; compile string|21402
# getarg cmpil
        call cmpil
# ||mov|3,stage|18,=stgxt||; reset stage for execute time|21403
# getarg W0
# getarg stage
        movq l_0075,W0
        movq W0,stage
# ||zer|3,r_cim|||; clear image|21404
# getarg r_cim
        mov  $0,W0
        mov  W0,r_cim
# |gtcd1|exi||||; give normal gtcod return|21408
gtcd1:
# getarg 
        movq $0,rcode
        ret
# |gtcd2|exi|1,1|||; give error return|21412
gtcd2:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure gtcod|21413
# ||ejc|||||21414
# |gtexp|prc|25,e|1,1||; entry point|21431
gtexp:
# getarg 1
# ||blo|9,(xr)|22,=b_e__|6,gtex1|; jump if already an expression|21432
# getarg (XR)
# getarg W0
# getarg gtex1
        movq l_0760,W0
        cmpq (XR),W0
        jb   gtex1
# ||mov|11,-(xs)|7,xr||; store argument for gtstg|21433
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert argument to string|21434
# getarg gtstg
        call gtstg
        decq rcode
        js   call_235
# ||ppm|6,gtex2|||; jump if unconvertible|21435
# getarg gtex2
# getarg gtex2
        decq rcode
        jns  l_0800
        jmp  gtex2
l_0800:
call_235:
# ||mov|7,xl|7,xr||; copy input string pointer|21443
# getarg XR
# getarg XL
        movq XR,XL
# ||plc|7,xl|8,wa||; point one past the string end|21444
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||lch|7,xl|11,-(xl)||; fetch the last character|21445
# getarg XL
        decq XL
        xor  W0,W0
        movb (XL),%al
        mov  W0,XL
# ||beq|7,xl|18,=ch_cl|6,gtex2|; error if it is a semicolon|21446
# getarg XL
# getarg W0
# getarg gtex2
        movq l_0162,W0
        cmpq XL,W0
        je   gtex2
# ||beq|7,xl|18,=ch_sm|6,gtex2|; or if it is a colon|21447
# getarg XL
# getarg W0
# getarg gtex2
        movq l_0687,W0
        cmpq XL,W0
        je   gtex2
# ||mov|3,r_cim|7,xr||; set input image pointer|21451
# getarg XR
# getarg r_cim
        movq XR,r_cim
# ||zer|3,scnpt|||; set scan pointer|21452
# getarg scnpt
        mov  $0,W0
        mov  W0,scnpt
# ||mov|3,scnil|8,wa||; set input image length|21453
# getarg WA
# getarg scnil
        movq WA,scnil
# ||mov|11,-(xs)|8,wb||; save value/name flag|21455
# getarg WB
        push WB
# ||zer|8,wb|||; set code for normal scan|21457
# getarg WB
        xor  WB,WB
# ||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21458
# getarg flptr
# getarg W0
# getarg gtcef
        movq flptr,W0
        movq W0,gtcef
# ||mov|3,r_gtc|3,r_cod||; also save code ptr|21459
# getarg r_cod
# getarg W0
# getarg r_gtc
        movq r_cod,W0
        movq W0,r_gtc
# ||mov|3,stage|18,=stgev||; adjust stage for compile|21460
# getarg W0
# getarg stage
        .data
l_0801: .long stgev
        .text
        movq l_0801,W0
        movq W0,stage
# ||mov|3,scntp|18,=t_uok||; indicate unary operator acceptable|21461
# getarg W0
# getarg scntp
        .data
l_0802: .long t_uok
        .text
        movq l_0802,W0
        movq W0,scntp
# ||jsr|6,expan|||; build tree for expression|21462
# getarg expan
        call expan
# ||zer|3,scnrs|||; reset rescan flag|21463
# getarg scnrs
        mov  $0,W0
        mov  W0,scnrs
# ||mov|8,wa|10,(xs)+||; restore value/name flag|21465
# getarg WA
        pop  WA
# ||bne|3,scnpt|3,scnil|6,gtex2|; error if not end of image|21467
# getarg scnil
# getarg scnpt
# getarg W0
# getarg gtex2
        movq scnil,W0
        cmpq scnpt,W0
        jne  gtex2
# ||zer|8,wb|||; set ok value for cdgex call|21468
# getarg WB
        xor  WB,WB
# ||mov|7,xl|7,xr||; copy tree pointer|21469
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,cdgex|||; build expression block|21470
# getarg cdgex
        call cdgex
# ||zer|3,r_cim|||; clear pointer|21471
# getarg r_cim
        mov  $0,W0
        mov  W0,r_cim
# ||mov|3,stage|18,=stgxt||; restore stage for execute time|21472
# getarg W0
# getarg stage
        movq l_0075,W0
        movq W0,stage
# |gtex1|exi||||; return to gtexp caller|21476
gtex1:
# getarg 
        movq $0,rcode
        ret
# |gtex2|exi|1,1|||; take error exit|21480
gtex2:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure gtexp|21481
# ||ejc|||||21482
# |gtint|prc|25,e|1,1||; entry point|21497
gtint:
# getarg 1
# ||beq|9,(xr)|22,=b_icl|6,gtin2|; jump if already an integer|21498
# getarg (XR)
# getarg W0
# getarg gtin2
        movq l_0087,W0
        cmpq (XR),W0
        je   gtin2
# ||mov|3,gtina|8,wa||; else save wa|21499
# getarg WA
# getarg gtina
        movq WA,gtina
# ||mov|3,gtinb|8,wb||; save wb|21500
# getarg WB
# getarg gtinb
        movq WB,gtinb
# ||jsr|6,gtnum|||; convert to numeric|21501
# getarg gtnum
        call gtnum
        decq rcode
        js   call_236
# ||ppm|6,gtin3|||; jump if unconvertible|21502
# getarg gtin3
# getarg gtin3
        decq rcode
        jns  l_0803
        jmp  gtin3
l_0803:
call_236:
# ||beq|8,wa|22,=b_icl|6,gtin1|; jump if integer|21505
# getarg WA
# getarg W0
# getarg gtin1
        movq l_0087,W0
        cmpq WA,W0
        je   gtin1
# ||ldr|13,rcval(xr)|||; load real value|21509
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||rti|6,gtin3|||; convert to integer (err if ovflow)|21510
# getarg gtin3
        rti_
        jc   gtin3
# ||jsr|6,icbld|||; if ok build icblk|21511
# getarg icbld
        call icbld
# |gtin1|mov|8,wa|3,gtina||; restore wa|21516
gtin1:
# getarg gtina
# getarg WA
        movq gtina,WA
# ||mov|8,wb|3,gtinb||; restore wb|21517
# getarg gtinb
# getarg WB
        movq gtinb,WB
# |gtin2|exi||||; return to gtint caller|21521
gtin2:
# getarg 
        movq $0,rcode
        ret
# |gtin3|exi|1,1|||; take convert error exit|21525
gtin3:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure gtint|21526
# ||ejc|||||21527
# |gtnum|prc|25,e|1,1||; entry point|21542
gtnum:
# getarg 1
# ||mov|8,wa|9,(xr)||; load first word of block|21543
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_icl|6,gtn34|; jump if integer (no conversion)|21544
# getarg WA
# getarg W0
# getarg gtn34
        movq l_0087,W0
        cmpq WA,W0
        je   gtn34
# ||beq|8,wa|22,=b_rcl|6,gtn34|; jump if real (no conversion)|21547
# getarg WA
# getarg W0
# getarg gtn34
        movq l_0101,W0
        cmpq WA,W0
        je   gtn34
# ||mov|11,-(xs)|7,xr||; stack argument in case convert err|21553
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xr||; stack argument for gtstg|21554
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert argument to string|21556
# getarg gtstg
        call gtstg
        decq rcode
        js   call_237
# ||ppm|6,gtn36|||; jump if unconvertible|21560
# getarg gtn36
# getarg gtn36
        decq rcode
        jns  l_0804
        jmp  gtn36
l_0804:
call_237:
# ||ldi|4,intv0|||; initialize integer result to zero|21564
# getarg intv0
        mov  intv0,IA
# ||bze|8,wa|6,gtn32||; jump to exit with zero if null|21565
# getarg WA
# getarg gtn32
        or   WA,WA
        jz   gtn32
# ||lct|8,wa|8,wa||; set bct counter for following loops|21566
# ||zer|3,gtnnf|||; tentatively indicate result +|21567
# getarg gtnnf
        mov  $0,W0
        mov  W0,gtnnf
# ||sti|3,gtnex|||; initialise exponent to zero|21570
# getarg gtnex
        mov  IA,gtnex
# ||zer|3,gtnsc|||; zero scale in case real|21571
# getarg gtnsc
        mov  $0,W0
        mov  W0,gtnsc
# ||zer|3,gtndf|||; reset flag for dec point found|21572
# getarg gtndf
        mov  $0,W0
        mov  W0,gtndf
# ||zer|3,gtnrd|||; reset flag for digits found|21573
# getarg gtnrd
        mov  $0,W0
        mov  W0,gtnrd
# ||ldr|4,reav0|||; zero real accum in case real|21574
        movq l_0109,W0
        call ldr_
# ||plc|7,xr|||; point to argument characters|21576
# getarg XR
        add  $cfp_f,XR
# |gtn01|lch|8,wb|10,(xr)+||; load first character|21580
gtn01:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||blt|8,wb|18,=ch_d0|6,gtn02|; jump if not digit|21581
# getarg WB
# getarg W0
# getarg gtn02
        movq l_0719,W0
        cmpq WB,W0
        jb   gtn02
# ||ble|8,wb|18,=ch_d9|6,gtn06|; jump if first char is a digit|21582
# getarg WB
# getarg W0
# getarg gtn06
        movq l_0720,W0
        cmpq WB,W0
        jbe  gtn06
# ||ejc|||||21583
# |gtn02|bne|8,wb|18,=ch_bl|6,gtn03|; jump if non-blank|21589
gtn02:
# getarg WB
# getarg W0
# getarg gtn03
        movq l_0572,W0
        cmpq WB,W0
        jne  gtn03
# |gtna2|bct|8,wa|6,gtn01||; else decr count and loop back|21590
gtna2:
# getarg WA
# getarg gtn01
        decq WA
        jnz  gtn01
# ||brn|6,gtn07|||; jump to return zero if all blanks|21591
# getarg gtn07
        jmp  gtn07
# |gtn03|beq|8,wb|18,=ch_pl|6,gtn04|; jump if plus sign|21595
gtn03:
# getarg WB
# getarg W0
# getarg gtn04
        .data
l_0805: .long ch_pl
        .text
        movq l_0805,W0
        cmpq WB,W0
        je   gtn04
# ||beq|8,wb|18,=ch_ht|6,gtna2|; horizontal tab equiv to blank|21597
# getarg WB
# getarg W0
# getarg gtna2
        movq l_0693,W0
        cmpq WB,W0
        je   gtna2
# ||bne|8,wb|18,=ch_mn|6,gtn12|; jump if not minus (may be real)|21605
# getarg WB
# getarg W0
# getarg gtn12
        movq l_0689,W0
        cmpq WB,W0
        jne  gtn12
# ||mnz|3,gtnnf|||; if minus sign, set negative flag|21607
# getarg gtnnf
        mov  XS,gtnnf
# |gtn04|bct|8,wa|6,gtn05||; jump if chars left|21611
gtn04:
# getarg WA
# getarg gtn05
        decq WA
        jnz  gtn05
# ||brn|6,gtn36|||; else error|21612
# getarg gtn36
        jmp  gtn36
# |gtn05|lch|8,wb|10,(xr)+||; load next character|21616
gtn05:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||blt|8,wb|18,=ch_d0|6,gtn08|; jump if not a digit|21617
# getarg WB
# getarg W0
# getarg gtn08
        movq l_0719,W0
        cmpq WB,W0
        jb   gtn08
# ||bgt|8,wb|18,=ch_d9|6,gtn08|; jump if not a digit|21618
# getarg WB
# getarg W0
# getarg gtn08
        movq l_0720,W0
        cmpq WB,W0
        ja   gtn08
# |gtn06|sti|3,gtnsi|||; save current value|21622
gtn06:
# getarg gtnsi
        mov  IA,gtnsi
# ||cvm|6,gtn35|||; current*10-(new dig) jump if ovflow|21626
# getarg gtn35
        mov  IA,W0
        imul W0,10
        jo   gtn35
        sub  $ch_d0,WB
        sub  WB,W0
        mov  W0,IA
        jo   gtn35
# ||mnz|3,gtnrd|||; set digit read flag|21627
# getarg gtnrd
        mov  XS,gtnrd
# ||bct|8,wa|6,gtn05||; else loop back if more chars|21629
# getarg WA
# getarg gtn05
        decq WA
        jnz  gtn05
# |gtn07|bnz|3,gtnnf|6,gtn32||; jump if negative (all set)|21633
gtn07:
# getarg gtnnf
# getarg gtn32
        xor  W0,W0
        cmpq gtnnf,W0
        jnz  gtn32
# ||ngi||||; else negate|21634
        neg  IA
        seto reg_fl
# ||ino|6,gtn32|||; jump if no overflow|21635
# getarg gtn32
        ino_ gtn32
# ||brn|6,gtn36|||; else signal error|21636
# getarg gtn36
        jmp  gtn36
# ||ejc|||||21637
# |gtn08|beq|8,wb|18,=ch_bl|6,gtna9|; jump if a blank|21644
gtn08:
# getarg WB
# getarg W0
# getarg gtna9
        movq l_0572,W0
        cmpq WB,W0
        je   gtna9
# ||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21646
# getarg WB
# getarg W0
# getarg gtna9
        movq l_0693,W0
        cmpq WB,W0
        je   gtna9
# ||itr||||; else convert integer to real|21654
        call itr_
# ||ngr||||; negate to get positive value|21655
        call ngr_
# ||brn|6,gtn12|||; jump to try for real|21656
# getarg gtn12
        jmp  gtn12
# |gtn09|lch|8,wb|10,(xr)+||; get next char|21661
gtn09:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21663
# getarg WB
# getarg W0
# getarg gtna9
        movq l_0693,W0
        cmpq WB,W0
        je   gtna9
# ||bne|8,wb|18,=ch_bl|6,gtn36|; error if non-blank|21668
# getarg WB
# getarg W0
# getarg gtn36
        movq l_0572,W0
        cmpq WB,W0
        jne  gtn36
# |gtna9|bct|8,wa|6,gtn09||; loop back if more chars to check|21669
gtna9:
# getarg WA
# getarg gtn09
        decq WA
        jnz  gtn09
# ||brn|6,gtn07|||; return integer if all blanks|21670
# getarg gtn07
        jmp  gtn07
# |gtn10|lch|8,wb|10,(xr)+||; load next character|21676
gtn10:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||blt|8,wb|18,=ch_d0|6,gtn12|; jump if non-numeric|21677
# getarg WB
# getarg W0
# getarg gtn12
        movq l_0719,W0
        cmpq WB,W0
        jb   gtn12
# ||bgt|8,wb|18,=ch_d9|6,gtn12|; jump if non-numeric|21678
# getarg WB
# getarg W0
# getarg gtn12
        movq l_0720,W0
        cmpq WB,W0
        ja   gtn12
# |gtn11|sub|8,wb|18,=ch_d0||; convert digit to number|21682
gtn11:
# getarg W0
# getarg WB
        movq l_0719,W0
        subq W0,WB
# ||mlr|4,reavt|||; multiply real by 10.0|21683
        movq l_0044,W0
        call mlr_
# ||rov|6,gtn36|||; convert error if overflow|21684
# getarg gtn36
        rov_ gtn36
# ||str|3,gtnsr|||; save result|21685
        .data
l_0806: .long
        .text
        movq l_0806,W0
        call str_
# ||mti|8,wb|||; get new digit as integer|21686
# getarg WB
        mov  WB,IA
# ||itr||||; convert new digit to real|21687
        call itr_
# ||adr|3,gtnsr|||; add to get new total|21688
        movq l_0806,W0
        call adr_
# ||add|3,gtnsc|3,gtndf||; increment scale if after dec point|21689
# getarg gtndf
# getarg W0
# getarg gtnsc
        movq gtndf,W0
        addq W0,gtnsc
# ||mnz|3,gtnrd|||; set digit found flag|21690
# getarg gtnrd
        mov  XS,gtnrd
# ||bct|8,wa|6,gtn10||; loop back if more chars|21691
# getarg WA
# getarg gtn10
        decq WA
        jnz  gtn10
# ||brn|6,gtn22|||; else jump to scale|21692
# getarg gtn22
        jmp  gtn22
# ||ejc|||||21693
# |gtn12|bne|8,wb|18,=ch_dt|6,gtn13|; jump if not dec point|21699
gtn12:
# getarg WB
# getarg W0
# getarg gtn13
        .data
l_0807: .long ch_dt
        .text
        movq l_0807,W0
        cmpq WB,W0
        jne  gtn13
# ||bnz|3,gtndf|6,gtn36||; if dec point, error if one already|21700
# getarg gtndf
# getarg gtn36
        xor  W0,W0
        cmpq gtndf,W0
        jnz  gtn36
# ||mov|3,gtndf|18,=num01||; else set flag for dec point|21701
# getarg W0
# getarg gtndf
        movq l_0060,W0
        movq W0,gtndf
# ||bct|8,wa|6,gtn10||; loop back if more chars|21702
# getarg WA
# getarg gtn10
        decq WA
        jnz  gtn10
# ||brn|6,gtn22|||; else jump to scale|21703
# getarg gtn22
        jmp  gtn22
# |gtn13|beq|8,wb|18,=ch_le|6,gtn15|; jump if e for exponent|21707
gtn13:
# getarg WB
# getarg W0
# getarg gtn15
        .data
l_0808: .long ch_le
        .text
        movq l_0808,W0
        cmpq WB,W0
        je   gtn15
# ||beq|8,wb|18,=ch_ld|6,gtn15|; jump if d for exponent|21708
# getarg WB
# getarg W0
# getarg gtn15
        .data
l_0809: .long ch_ld
        .text
        movq l_0809,W0
        cmpq WB,W0
        je   gtn15
# ||beq|8,wb|18,=ch_ue|6,gtn15|; jump if e for exponent|21710
# getarg WB
# getarg W0
# getarg gtn15
        .data
l_0810: .long ch_ue
        .text
        movq l_0810,W0
        cmpq WB,W0
        je   gtn15
# ||beq|8,wb|18,=ch_ud|6,gtn15|; jump if d for exponent|21711
# getarg WB
# getarg W0
# getarg gtn15
        .data
l_0811: .long ch_ud
        .text
        movq l_0811,W0
        cmpq WB,W0
        je   gtn15
# |gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|; jump if blank|21716
gtn14:
# getarg WB
# getarg W0
# getarg gtnb4
        movq l_0572,W0
        cmpq WB,W0
        je   gtnb4
# ||beq|8,wb|18,=ch_ht|6,gtnb4|; jump if horizontal tab|21718
# getarg WB
# getarg W0
# getarg gtnb4
        movq l_0693,W0
        cmpq WB,W0
        je   gtnb4
# ||brn|6,gtn36|||; error if non-blank|21723
# getarg gtn36
        jmp  gtn36
# |gtnb4|lch|8,wb|10,(xr)+||; get next character|21725
gtnb4:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||bct|8,wa|6,gtn14||; loop back to check if more|21726
# getarg WA
# getarg gtn14
        decq WA
        jnz  gtn14
# ||brn|6,gtn22|||; else jump to scale|21727
# getarg gtn22
        jmp  gtn22
# |gtn15|zer|3,gtnes|||; set exponent sign positive|21731
gtn15:
# getarg gtnes
        mov  $0,W0
        mov  W0,gtnes
# ||ldi|4,intv0|||; initialize exponent to zero|21732
# getarg intv0
        mov  intv0,IA
# ||mnz|3,gtndf|||; reset no dec point indication|21733
# getarg gtndf
        mov  XS,gtndf
# ||bct|8,wa|6,gtn16||; jump skipping past e or d|21734
# getarg WA
# getarg gtn16
        decq WA
        jnz  gtn16
# ||brn|6,gtn36|||; error if null exponent|21735
# getarg gtn36
        jmp  gtn36
# |gtn16|lch|8,wb|10,(xr)+||; load first exponent character|21739
gtn16:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||beq|8,wb|18,=ch_pl|6,gtn17|; jump if plus sign|21740
# getarg WB
# getarg W0
# getarg gtn17
        movq l_0805,W0
        cmpq WB,W0
        je   gtn17
# ||bne|8,wb|18,=ch_mn|6,gtn19|; else jump if not minus sign|21741
# getarg WB
# getarg W0
# getarg gtn19
        movq l_0689,W0
        cmpq WB,W0
        jne  gtn19
# ||mnz|3,gtnes|||; set sign negative if minus sign|21742
# getarg gtnes
        mov  XS,gtnes
# |gtn17|bct|8,wa|6,gtn18||; jump if chars left|21746
gtn17:
# getarg WA
# getarg gtn18
        decq WA
        jnz  gtn18
# ||brn|6,gtn36|||; else error|21747
# getarg gtn36
        jmp  gtn36
# |gtn18|lch|8,wb|10,(xr)+||; load next character|21751
gtn18:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||ejc|||||21752
# |gtn19|blt|8,wb|18,=ch_d0|6,gtn20|; jump if not digit|21758
gtn19:
# getarg WB
# getarg W0
# getarg gtn20
        movq l_0719,W0
        cmpq WB,W0
        jb   gtn20
# ||bgt|8,wb|18,=ch_d9|6,gtn20|; jump if not digit|21759
# getarg WB
# getarg W0
# getarg gtn20
        movq l_0720,W0
        cmpq WB,W0
        ja   gtn20
# ||cvm|6,gtn36|||; else current*10, subtract new digit|21760
# getarg gtn36
        mov  IA,W0
        imul W0,10
        jo   gtn36
        sub  $ch_d0,WB
        sub  WB,W0
        mov  W0,IA
        jo   gtn36
# ||bct|8,wa|6,gtn18||; loop back if more chars|21761
# getarg WA
# getarg gtn18
        decq WA
        jnz  gtn18
# ||brn|6,gtn21|||; jump if exponent field is exhausted|21762
# getarg gtn21
        jmp  gtn21
# |gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|; jump if blank|21766
gtn20:
# getarg WB
# getarg W0
# getarg gtnc0
        movq l_0572,W0
        cmpq WB,W0
        je   gtnc0
# ||beq|8,wb|18,=ch_ht|6,gtnc0|; jump if horizontal tab|21768
# getarg WB
# getarg W0
# getarg gtnc0
        movq l_0693,W0
        cmpq WB,W0
        je   gtnc0
# ||brn|6,gtn36|||; error if non-blank|21773
# getarg gtn36
        jmp  gtn36
# |gtnc0|lch|8,wb|10,(xr)+||; get next character|21775
gtnc0:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||bct|8,wa|6,gtn20||; loop back till all blanks scanned|21776
# getarg WA
# getarg gtn20
        decq WA
        jnz  gtn20
# |gtn21|sti|3,gtnex|||; save collected exponent|21780
gtn21:
# getarg gtnex
        mov  IA,gtnex
# ||bnz|3,gtnes|6,gtn22||; jump if it was negative|21781
# getarg gtnes
# getarg gtn22
        xor  W0,W0
        cmpq gtnes,W0
        jnz  gtn22
# ||ngi||||; else complement|21782
        neg  IA
        seto reg_fl
# ||iov|6,gtn36|||; error if overflow|21783
# getarg gtn36
        iov_ gtn36
# ||sti|3,gtnex|||; and store positive exponent|21784
# getarg gtnex
        mov  IA,gtnex
# |gtn22|bze|3,gtnrd|6,gtn36||; error if not digits collected|21788
gtn22:
# getarg gtnrd
# getarg gtn36
        xor  W0,W0
        cmpq gtnrd,W0
        jz   gtn36
# ||bze|3,gtndf|6,gtn36||; error if no exponent or dec point|21789
# getarg gtndf
# getarg gtn36
        xor  W0,W0
        cmpq gtndf,W0
        jz   gtn36
# ||mti|3,gtnsc|||; else load scale as integer|21790
# getarg gtnsc
        mov  gtnsc,IA
# ||sbi|3,gtnex|||; subtract exponent|21791
# getarg gtnex
        sub  gtnex,IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,gtn36|||; error if overflow|21792
# getarg gtn36
        iov_ gtn36
# ||ilt|6,gtn26|||; jump if we must scale up|21793
# getarg gtn26
        mov  IA,W0
        or   W0,W0
        jl   gtn26
# ||mfi|8,wa|6,gtn36||; load scale factor, err if ovflow|21797
# getarg gtn36
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   gtn36
        mov  IA,WA
# |gtn23|ble|8,wa|18,=num10|6,gtn24|; jump if 10 or less to go|21801
gtn23:
# getarg WA
# getarg W0
# getarg gtn24
        movq l_0058,W0
        cmpq WA,W0
        jbe  gtn24
# ||dvr|4,reatt|||; else divide by 10**10|21802
        .data
l_0812: .long
        .text
        movq l_0812,W0
        call dvr_
# ||sub|8,wa|18,=num10||; decrement scale|21803
# getarg W0
# getarg WA
        movq l_0058,W0
        subq W0,WA
# ||brn|6,gtn23|||; and loop back|21804
# getarg gtn23
        jmp  gtn23
# ||ejc|||||21805
# |gtn24|bze|8,wa|6,gtn30||; jump if scaled|21811
gtn24:
# getarg WA
# getarg gtn30
        or   WA,WA
        jz   gtn30
# ||lct|8,wb|18,=cfp_r||; else get indexing factor|21812
# getarg WB
# getarg W0
        .data
l_0813: .long cfp_r
        .text
        movq l_0813,W0
        mov  WB,W0
# ||mov|7,xr|21,=reav1||; point to powers of ten table|21813
# getarg W0
# getarg XR
        .data
l_0814: .long reav1
        .text
        movq l_0814,W0
        movq W0,XR
# ||wtb|8,wa|||; convert remaining scale to byte ofs|21814
# getarg WA
        sal  WA,3
# |gtn25|add|7,xr|8,wa||; bump pointer|21818
gtn25:
# getarg WA
# getarg XR
        addq WA,XR
# ||bct|8,wb|6,gtn25||; once for each value word|21819
# getarg WB
# getarg gtn25
        decq WB
        jnz  gtn25
# ||dvr|9,(xr)|||; scale down as required|21820
        .data
l_0815: .long
        .text
        movq l_0815,W0
        call dvr_
# ||brn|6,gtn30|||; and jump|21821
# getarg gtn30
        jmp  gtn30
# |gtn26|ngi||||; get absolute value of exponent|21825
gtn26:
        neg  IA
        seto reg_fl
# ||iov|6,gtn36|||; error if overflow|21826
# getarg gtn36
        iov_ gtn36
# ||mfi|8,wa|6,gtn36||; acquire scale, error if ovflow|21827
# getarg gtn36
# getarg WA
        mov  IA,W0
        or   W0,W0
        js   gtn36
        mov  IA,WA
# |gtn27|ble|8,wa|18,=num10|6,gtn28|; jump if 10 or less to go|21831
gtn27:
# getarg WA
# getarg W0
# getarg gtn28
        movq l_0058,W0
        cmpq WA,W0
        jbe  gtn28
# ||mlr|4,reatt|||; else multiply by 10**10|21832
        movq l_0812,W0
        call mlr_
# ||rov|6,gtn36|||; error if overflow|21833
# getarg gtn36
        rov_ gtn36
# ||sub|8,wa|18,=num10||; else decrement scale|21834
# getarg W0
# getarg WA
        movq l_0058,W0
        subq W0,WA
# ||brn|6,gtn27|||; and loop back|21835
# getarg gtn27
        jmp  gtn27
# |gtn28|bze|8,wa|6,gtn30||; jump if scaled|21839
gtn28:
# getarg WA
# getarg gtn30
        or   WA,WA
        jz   gtn30
# ||lct|8,wb|18,=cfp_r||; else get indexing factor|21840
# getarg WB
# getarg W0
        movq l_0813,W0
        mov  WB,W0
# ||mov|7,xr|21,=reav1||; point to powers of ten table|21841
# getarg W0
# getarg XR
        movq l_0814,W0
        movq W0,XR
# ||wtb|8,wa|||; convert remaining scale to byte ofs|21842
# getarg WA
        sal  WA,3
# |gtn29|add|7,xr|8,wa||; bump pointer|21846
gtn29:
# getarg WA
# getarg XR
        addq WA,XR
# ||bct|8,wb|6,gtn29||; once for each word in value|21847
# getarg WB
# getarg gtn29
        decq WB
        jnz  gtn29
# ||mlr|9,(xr)|||; scale up|21848
        movq l_0815,W0
        call mlr_
# ||rov|6,gtn36|||; error if overflow|21849
# getarg gtn36
        rov_ gtn36
# ||ejc|||||21850
# |gtn30|bze|3,gtnnf|6,gtn31||; jump if positive|21856
gtn30:
# getarg gtnnf
# getarg gtn31
        xor  W0,W0
        cmpq gtnnf,W0
        jz   gtn31
# ||ngr||||; else negate|21857
        call ngr_
# |gtn31|jsr|6,rcbld|||; build real block|21861
gtn31:
# getarg rcbld
        call rcbld
# ||brn|6,gtn33|||; merge to exit|21862
# getarg gtn33
        jmp  gtn33
# |gtn32|jsr|6,icbld|||; build icblk|21867
gtn32:
# getarg icbld
        call icbld
# |gtn33|mov|8,wa|9,(xr)||; load first word of result block|21871
gtn33:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||ica|7,xs|||; pop argument off stack|21872
# getarg XT
        addq $8,XT
# |gtn34|exi||||; return to gtnum caller|21876
gtn34:
# getarg 
        movq $0,rcode
        ret
# |gtn35|lch|8,wb|11,-(xr)||; reload current character|21883
gtn35:
# getarg WB
        decq XR
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
# ||lch|8,wb|10,(xr)+||; bump character pointer|21884
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||ldi|3,gtnsi|||; reload integer so far|21885
# getarg gtnsi
        mov  gtnsi,IA
# ||itr||||; convert to real|21886
        call itr_
# ||ngr||||; make value positive|21887
        call ngr_
# ||brn|6,gtn11|||; merge with real circuit|21888
# getarg gtn11
        jmp  gtn11
# |gtn36|mov|7,xr|10,(xs)+||; reload original argument|21893
gtn36:
# getarg XR
        pop  XR
# ||exi|1,1|||; take convert-error exit|21894
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure gtnum|21895
# ||ejc|||||21896
# |gtnvr|prc|25,e|1,1||; entry point|21910
gtnvr:
# getarg 1
# ||bne|9,(xr)|22,=b_nml|6,gnv02|; jump if not name|21912
# getarg (XR)
# getarg W0
# getarg gnv02
        movq l_0126,W0
        cmpq (XR),W0
        jne  gnv02
# ||mov|7,xr|13,nmbas(xr)||; else load name base if name|21913
# getarg nmbas(,XR,8)
# getarg XR
        movq nmbas(,XR,8),XR
# ||blo|7,xr|3,state|6,gnv07|; skip if vrblk (in static region)|21914
# getarg XR
# getarg state
# getarg gnv07
        cmpq XR,state
        jb   gnv07
# |gnv01|exi|1,1|||; take convert-error exit|21918
gnv01:
# getarg 1
        movq $1,rcode
        ret
# |gnv02|mov|3,gnvsa|8,wa||; save wa|21922
gnv02:
# getarg WA
# getarg gnvsa
        movq WA,gnvsa
# ||mov|3,gnvsb|8,wb||; save wb|21923
# getarg WB
# getarg gnvsb
        movq WB,gnvsb
# ||mov|11,-(xs)|7,xr||; stack argument for gtstg|21924
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert argument to string|21925
# getarg gtstg
        call gtstg
        decq rcode
        js   call_238
# ||ppm|6,gnv01|||; jump if conversion error|21926
# getarg gnv01
# getarg gnv01
        decq rcode
        jns  l_0816
        jmp  gnv01
l_0816:
call_238:
# ||bze|8,wa|6,gnv01||; null string is an error|21927
# getarg WA
# getarg gnv01
        or   WA,WA
        jz   gnv01
# ||jsr|6,flstg|||; fold upper case to lower case|21929
# getarg flstg
        call flstg
# ||mov|11,-(xs)|7,xl||; save xl|21931
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; stack string ptr for later|21932
# getarg XR
        push XR
# ||mov|8,wb|7,xr||; copy string pointer|21933
# getarg XR
# getarg WB
        movq XR,WB
# ||add|8,wb|19,*schar||; point to characters of string|21934
# getarg W0
# getarg WB
        .data
l_0817: .long 8*schar
        .text
        movq l_0817,W0
        addq W0,WB
# ||mov|3,gnvst|8,wb||; save pointer to characters|21935
# getarg WB
# getarg gnvst
        movq WB,gnvst
# ||mov|8,wb|8,wa||; copy length|21936
# getarg WA
# getarg WB
        movq WA,WB
# ||ctw|8,wb|1,0||; get number of words in name|21937
# getarg WB
        add  ($8-1)+$cfp_c*0,WB
        shr  WB,log_cfp_c
# ||mov|3,gnvnw|8,wb||; save for later|21938
# getarg WB
# getarg gnvnw
        movq WB,gnvnw
# ||jsr|6,hashs|||; compute hash index for string|21939
# getarg hashs
        call hashs
# ||rmi|3,hshnb|||; compute hash offset by taking mod|21940
# getarg hshnb
        mov  hshnb,W0
        call rmi__
# ||mfi|8,wc|||; get as offset|21941
# getarg WC
        mov  IA,WC
# ||wtb|8,wc|||; convert offset to bytes|21942
# getarg WC
        sal  WC,3
# ||add|8,wc|3,hshtb||; point to proper hash chain|21943
# getarg hshtb
# getarg WC
        addq hshtb,WC
# ||sub|8,wc|19,*vrnxt||; subtract offset to merge into loop|21944
# getarg W0
# getarg WC
        movq l_0034,W0
        subq W0,WC
# ||ejc|||||21945
# |gnv03|mov|7,xl|8,wc||; copy hash chain pointer|21951
gnv03:
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|7,xl|13,vrnxt(xl)||; point to next vrblk on chain|21952
# getarg vrnxt(,XL,8)
# getarg XL
        movq vrnxt(,XL,8),XL
# ||bze|7,xl|6,gnv08||; jump if end of chain|21953
# getarg XL
# getarg gnv08
        or   XL,XL
        jz   gnv08
# ||mov|8,wc|7,xl||; save pointer to this vrblk|21954
# getarg XL
# getarg WC
        movq XL,WC
# ||bnz|13,vrlen(xl)|6,gnv04||; jump if not system variable|21955
# getarg vrlen(,XL,8)
# getarg gnv04
        xor  W0,W0
        cmpq vrlen(,XL,8),W0
        jnz  gnv04
# ||mov|7,xl|13,vrsvp(xl)||; else point to svblk|21956
# getarg vrsvp(,XL,8)
# getarg XL
        movq vrsvp(,XL,8),XL
# ||sub|7,xl|19,*vrsof||; adjust offset for merge|21957
# getarg W0
# getarg XL
        movq l_0738,W0
        subq W0,XL
# |gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|; back for next vrblk if lengths ne|21961
gnv04:
# getarg WA
# getarg vrlen(,XL,8)
# getarg gnv03
        cmpq WA,vrlen(,XL,8)
        jne  gnv03
# ||add|7,xl|19,*vrchs||; else point to chars of chain entry|21962
# getarg W0
# getarg XL
        .data
l_0818: .long 8*vrchs
        .text
        movq l_0818,W0
        addq W0,XL
# ||lct|8,wb|3,gnvnw||; get word counter to control loop|21963
# getarg WB
# getarg gnvnw
        mov  WB,gnvnw
# ||mov|7,xr|3,gnvst||; point to chars of new name|21964
# getarg gnvst
# getarg XR
        movq gnvst,XR
# |gnv05|cne|9,(xr)|9,(xl)|6,gnv03|; jump if no match for next vrblk|21968
gnv05:
# getarg (XL)
# getarg (XR)
# getarg W0
# getarg gnv03
        movq (XL),W0
        cmpb (XR),W0
        jnz  gnv03
# ||ica|7,xr|||; bump new name pointer|21969
# getarg XR
        addq $8,XR
# ||ica|7,xl|||; bump vrblk in chain name pointer|21970
# getarg XL
        addq $8,XL
# ||bct|8,wb|6,gnv05||; else loop till all compared|21971
# getarg WB
# getarg gnv05
        decq WB
        jnz  gnv05
# ||mov|7,xr|8,wc||; we have found a match, get vrblk|21972
# getarg WC
# getarg XR
        movq WC,XR
# |gnv06|mov|8,wa|3,gnvsa||; restore wa|21976
gnv06:
# getarg gnvsa
# getarg WA
        movq gnvsa,WA
# ||mov|8,wb|3,gnvsb||; restore wb|21977
# getarg gnvsb
# getarg WB
        movq gnvsb,WB
# ||ica|7,xs|||; pop string pointer|21978
# getarg XT
        addq $8,XT
# ||mov|7,xl|10,(xs)+||; restore xl|21979
# getarg XL
        pop  XL
# |gnv07|exi||||; return to gtnvr caller|21983
gnv07:
# getarg 
        movq $0,rcode
        ret
# |gnv08|zer|7,xr|||; clear garbage xr pointer|21987
gnv08:
# getarg XR
        xor  XR,XR
# ||mov|3,gnvhe|8,wc||; save ptr to end of hash chain|21988
# getarg WC
# getarg gnvhe
        movq WC,gnvhe
# ||bgt|8,wa|18,=num09|6,gnv14|; cannot be system var if length gt 9|21989
# getarg WA
# getarg W0
# getarg gnv14
        .data
l_0819: .long num09
        .text
        movq l_0819,W0
        cmpq WA,W0
        ja   gnv14
# ||mov|7,xl|8,wa||; else copy length|21990
# getarg WA
# getarg XL
        movq WA,XL
# ||wtb|7,xl|||; convert to byte offset|21991
# getarg XL
        sal  XL,3
# ||mov|7,xl|14,vsrch(xl)||; point to first svblk of this length|21992
# getarg (XL)
# getarg XL
        movq (XL),XL
# ||ejc|||||21993
# |gnv09|mov|3,gnvsp|7,xl||; save table pointer|21999
gnv09:
# getarg XL
# getarg gnvsp
        movq XL,gnvsp
# ||mov|8,wc|10,(xl)+||; load svbit bit string|22000
# getarg WC
        lodsq
        movq W0,WC
# ||mov|8,wb|10,(xl)+||; load length from table entry|22001
# getarg WB
        lodsq
        movq W0,WB
# ||bne|8,wa|8,wb|6,gnv14|; jump if end of right length entries|22002
# getarg WA
# getarg WB
# getarg gnv14
        cmpq WA,WB
        jne  gnv14
# ||lct|8,wb|3,gnvnw||; get word counter to control loop|22003
# getarg WB
# getarg gnvnw
        mov  WB,gnvnw
# ||mov|7,xr|3,gnvst||; point to chars of new name|22004
# getarg gnvst
# getarg XR
        movq gnvst,XR
# |gnv10|cne|9,(xr)|9,(xl)|6,gnv11|; jump if name mismatch|22008
gnv10:
# getarg (XL)
# getarg (XR)
# getarg W0
# getarg gnv11
        movq (XL),W0
        cmpb (XR),W0
        jnz  gnv11
# ||ica|7,xr|||; else bump new name pointer|22009
# getarg XR
        addq $8,XR
# ||ica|7,xl|||; bump svblk pointer|22010
# getarg XL
        addq $8,XL
# ||bct|8,wb|6,gnv10||; else loop until all checked|22011
# getarg WB
# getarg gnv10
        decq WB
        jnz  gnv10
# ||zer|8,wc|||; set vrlen value zero|22015
# getarg WC
        xor  WC,WC
# ||mov|8,wa|19,*vrsi_||; set standard size|22016
# getarg W0
# getarg WA
        movq l_0037,W0
        movq W0,WA
# ||brn|6,gnv15|||; jump to build vrblk|22017
# getarg gnv15
        jmp  gnv15
# |gnv11|ica|7,xl|||; bump past word of chars|22021
gnv11:
# getarg XL
        addq $8,XL
# ||bct|8,wb|6,gnv11||; loop back if more to go|22022
# getarg WB
# getarg gnv11
        decq WB
        jnz  gnv11
# ||rsh|8,wc|2,svnbt||; remove uninteresting bits|22023
# getarg svnbt
# getarg WC
        shl  svnbt,WC
# |gnv12|mov|8,wb|4,bits1||; load bit to test|22027
gnv12:
# getarg bits1
# getarg WB
        movq bits1,WB
# ||anb|8,wb|8,wc||; test for word present|22028
# getarg WB
# getarg WC
        and  WB,WC
# ||zrb|8,wb|6,gnv13||; jump if not present|22029
# getarg WB
# getarg WB
# getarg gnv13
        or   WB,WB
        jz   gnv13
# ||ica|7,xl|||; else bump table pointer|22030
# getarg XL
        addq $8,XL
# |gnv13|rsh|8,wc|1,1||; remove bit already processed|22034
gnv13:
# getarg 1
# getarg WC
        shl  1,WC
# ||nzb|8,wc|6,gnv12||; loop back if more bits to test|22035
# getarg WC
# getarg WC
# getarg gnv12
        or   WC,WC
        jnz  gnv12
# ||brn|6,gnv09|||; else loop back for next svblk|22036
# getarg gnv09
        jmp  gnv09
# |gnv14|mov|8,wc|8,wa||; copy vrlen value|22040
gnv14:
# getarg WA
# getarg WC
        movq WA,WC
# ||mov|8,wa|18,=vrchs||; load standard size -chars|22041
# getarg W0
# getarg WA
        .data
l_0820: .long vrchs
        .text
        movq l_0820,W0
        movq W0,WA
# ||add|8,wa|3,gnvnw||; adjust for chars of name|22042
# getarg gnvnw
# getarg WA
        addq gnvnw,WA
# ||wtb|8,wa|||; convert length to bytes|22043
# getarg WA
        sal  WA,3
# ||ejc|||||22044
# |gnv15|jsr|6,alost|||; allocate space for vrblk (static)|22050
gnv15:
# getarg alost
        call alost
# ||mov|8,wb|7,xr||; save vrblk pointer|22051
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xl|21,=stnvr||; point to model variable block|22052
# getarg W0
# getarg XL
        .data
l_0821: .long stnvr
        .text
        movq l_0821,W0
        movq W0,XL
# ||mov|8,wa|19,*vrlen||; set length of standard fields|22053
# getarg W0
# getarg WA
        movq l_0035,W0
        movq W0,WA
# ||mvw||||; set initial fields of new block|22054
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0822:
        or   WA,WA
        jz   l_0823
        movsq
        decq WA
        jmp  l_0822
l_0823:
        cld
# ||mov|7,xl|3,gnvhe||; load pointer to end of hash chain|22055
# getarg gnvhe
# getarg XL
        movq gnvhe,XL
# ||mov|13,vrnxt(xl)|8,wb||; add new block to end of chain|22056
# getarg WB
# getarg vrnxt(,XL,8)
        movq WB,vrnxt(,XL,8)
# ||mov|10,(xr)+|8,wc||; set vrlen field, bump ptr|22057
# getarg WC
        movq WC,W0
        stosq
# ||mov|8,wa|3,gnvnw||; get length in words|22058
# getarg gnvnw
# getarg WA
        movq gnvnw,WA
# ||wtb|8,wa|||; convert to length in bytes|22059
# getarg WA
        sal  WA,3
# ||bze|8,wc|6,gnv16||; jump if system variable|22060
# getarg WC
# getarg gnv16
        or   WC,WC
        jz   gnv16
# ||mov|7,xl|9,(xs)||; point back to string name|22064
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|7,xl|19,*schar||; point to chars of name|22065
# getarg W0
# getarg XL
        movq l_0817,W0
        addq W0,XL
# ||mvw||||; move characters into place|22066
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0824:
        or   WA,WA
        jz   l_0825
        movsq
        decq WA
        jmp  l_0824
l_0825:
        cld
# ||mov|7,xr|8,wb||; restore vrblk pointer|22067
# getarg WB
# getarg XR
        movq WB,XR
# ||brn|6,gnv06|||; jump back to exit|22068
# getarg gnv06
        jmp  gnv06
# |gnv16|mov|7,xl|3,gnvsp||; load pointer to svblk|22073
gnv16:
# getarg gnvsp
# getarg XL
        movq gnvsp,XL
# ||mov|9,(xr)|7,xl||; set svblk ptr in vrblk|22074
# getarg XL
# getarg (XR)
        movq XL,(XR)
# ||mov|7,xr|8,wb||; restore vrblk pointer|22075
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|8,wb|13,svbit(xl)||; load bit indicators|22076
# getarg svbit(,XL,8)
# getarg WB
        movq svbit(,XL,8),WB
# ||add|7,xl|19,*svchs||; point to characters of name|22077
# getarg W0
# getarg XL
        .data
l_0826: .long 8*svchs
        .text
        movq l_0826,W0
        addq W0,XL
# ||add|7,xl|8,wa||; point past characters|22078
# getarg WA
# getarg XL
        addq WA,XL
# ||mov|8,wc|4,btknm||; load test bit|22082
# getarg btknm
# getarg WC
        movq btknm,WC
# ||anb|8,wc|8,wb||; and to test|22083
# getarg WC
# getarg WB
        and  WC,WB
# ||zrb|8,wc|6,gnv17||; jump if no keyword number|22084
# getarg WC
# getarg WC
# getarg gnv17
        or   WC,WC
        jz   gnv17
# ||ica|7,xl|||; else bump pointer|22085
# getarg XL
        addq $8,XL
# ||ejc|||||22086
# |gnv17|mov|8,wc|4,btfnc||; get test bit|22092
gnv17:
# getarg btfnc
# getarg WC
        movq btfnc,WC
# ||anb|8,wc|8,wb||; and to test|22093
# getarg WC
# getarg WB
        and  WC,WB
# ||zrb|8,wc|6,gnv18||; skip if no system function|22094
# getarg WC
# getarg WC
# getarg gnv18
        or   WC,WC
        jz   gnv18
# ||mov|13,vrfnc(xr)|7,xl||; else point vrfnc to svfnc field|22095
# getarg XL
# getarg vrfnc(,XR,8)
        movq XL,vrfnc(,XR,8)
# ||add|7,xl|19,*num02||; and bump past svfnc, svnar fields|22096
# getarg W0
# getarg XL
        movq l_0135,W0
        addq W0,XL
# |gnv18|mov|8,wc|4,btlbl||; get test bit|22100
gnv18:
# getarg btlbl
# getarg WC
        movq btlbl,WC
# ||anb|8,wc|8,wb||; and to test|22101
# getarg WC
# getarg WB
        and  WC,WB
# ||zrb|8,wc|6,gnv19||; jump if bit is off (no system labl)|22102
# getarg WC
# getarg WC
# getarg gnv19
        or   WC,WC
        jz   gnv19
# ||mov|13,vrlbl(xr)|7,xl||; else point vrlbl to svlbl field|22103
# getarg XL
# getarg vrlbl(,XR,8)
        movq XL,vrlbl(,XR,8)
# ||ica|7,xl|||; bump past svlbl field|22104
# getarg XL
        addq $8,XL
# |gnv19|mov|8,wc|4,btval||; load test bit|22108
gnv19:
# getarg btval
# getarg WC
        movq btval,WC
# ||anb|8,wc|8,wb||; and to test|22109
# getarg WC
# getarg WB
        and  WC,WB
# ||zrb|8,wc|6,gnv06||; all done if no value|22110
# getarg WC
# getarg WC
# getarg gnv06
        or   WC,WC
        jz   gnv06
# ||mov|13,vrval(xr)|9,(xl)||; else set initial value|22111
# getarg (XL)
# getarg W0
# getarg vrval(,XR,8)
        movq (XL),W0
        movq W0,vrval(,XR,8)
# ||mov|13,vrsto(xr)|22,=b_vre||; set error store access|22112
# getarg W0
# getarg vrsto(,XR,8)
        movq l_0269,W0
        movq W0,vrsto(,XR,8)
# ||brn|6,gnv06|||; merge back to exit to caller|22113
# getarg gnv06
        jmp  gnv06
# ||enp||||; end procedure gtnvr|22114
# ||ejc|||||22115
# |gtpat|prc|25,e|1,1||; entry point|22130
gtpat:
# getarg 1
# ||bhi|9,(xr)|22,=p_aaa|6,gtpt5|; jump if pattern already|22132
# getarg (XR)
# getarg W0
# getarg gtpt5
        movq l_0180,W0
        cmpq (XR),W0
        ja   gtpt5
# ||mov|3,gtpsb|8,wb||; save wb|22136
# getarg WB
# getarg gtpsb
        movq WB,gtpsb
# ||mov|11,-(xs)|7,xr||; stack argument for gtstg|22137
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert argument to string|22138
# getarg gtstg
        call gtstg
        decq rcode
        js   call_239
# ||ppm|6,gtpt2|||; jump if impossible|22139
# getarg gtpt2
# getarg gtpt2
        decq rcode
        jns  l_0827
        jmp  gtpt2
l_0827:
call_239:
# ||bnz|8,wa|6,gtpt1||; jump if non-null|22143
# getarg WA
# getarg WA
# getarg gtpt1
        or   WA,WA
        jnz  gtpt1
# ||mov|7,xr|21,=ndnth||; point to nothen node|22147
# getarg W0
# getarg XR
        movq l_0320,W0
        movq W0,XR
# ||brn|6,gtpt4|||; jump to exit|22148
# getarg gtpt4
        jmp  gtpt4
# ||ejc|||||22149
# |gtpt1|mov|8,wb|22,=p_str||; load pcode for multi-char string|22155
gtpt1:
# getarg W0
# getarg WB
        .data
l_0828: .long p_str
        .text
        movq l_0828,W0
        movq W0,WB
# ||bne|8,wa|18,=num01|6,gtpt3|; jump if multi-char string|22156
# getarg WA
# getarg W0
# getarg gtpt3
        movq l_0060,W0
        cmpq WA,W0
        jne  gtpt3
# ||plc|7,xr|||; point to character|22160
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wa|9,(xr)||; load character|22161
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
# ||mov|7,xr|8,wa||; set as parm1|22162
# getarg WA
# getarg XR
        movq WA,XR
# ||mov|8,wb|22,=p_ans||; point to pcode for 1-char any|22163
# getarg W0
# getarg WB
        movq l_0227,W0
        movq W0,WB
# ||brn|6,gtpt3|||; jump to build node|22164
# getarg gtpt3
        jmp  gtpt3
# |gtpt2|mov|8,wb|22,=p_exa||; set pcode for expression in case|22168
gtpt2:
# getarg W0
# getarg WB
        .data
l_0829: .long p_exa
        .text
        movq l_0829,W0
        movq W0,WB
# ||blo|9,(xr)|22,=b_e__|6,gtpt3|; jump to build node if expression|22169
# getarg (XR)
# getarg W0
# getarg gtpt3
        movq l_0760,W0
        cmpq (XR),W0
        jb   gtpt3
# ||exi|1,1|||; take convert error exit|22173
# getarg 1
        movq $1,rcode
        ret
# |gtpt3|jsr|6,pbild|||; call routine to build pattern node|22177
gtpt3:
# getarg pbild
        call pbild
# |gtpt4|mov|8,wb|3,gtpsb||; restore wb|22181
gtpt4:
# getarg gtpsb
# getarg WB
        movq gtpsb,WB
# |gtpt5|exi||||; return to gtpat caller|22185
gtpt5:
# getarg 
        movq $0,rcode
        ret
# ||enp||||; end procedure gtpat|22186
# ||ejc|||||22189
# |gtrea|prc|25,e|1,1||; entry point|22203
gtrea:
# getarg 1
# ||mov|8,wa|9,(xr)||; get first word of block|22204
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real|22205
# getarg WA
# getarg W0
# getarg gtre2
        movq l_0101,W0
        cmpq WA,W0
        je   gtre2
# ||jsr|6,gtnum|||; else convert argument to numeric|22206
# getarg gtnum
        call gtnum
        decq rcode
        js   call_240
# ||ppm|6,gtre3|||; jump if unconvertible|22207
# getarg gtre3
# getarg gtre3
        decq rcode
        jns  l_0830
        jmp  gtre3
l_0830:
call_240:
# ||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real was returned|22208
# getarg WA
# getarg W0
# getarg gtre2
        movq l_0101,W0
        cmpq WA,W0
        je   gtre2
# |gtre1|ldi|13,icval(xr)|||; load integer|22212
gtre1:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||itr||||; convert to real|22213
        call itr_
# ||jsr|6,rcbld|||; build rcblk|22214
# getarg rcbld
        call rcbld
# |gtre2|exi||||; return to gtrea caller|22218
gtre2:
# getarg 
        movq $0,rcode
        ret
# |gtre3|exi|1,1|||; take convert error exit|22222
gtre3:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure gtrea|22223
# ||ejc|||||22225
# |gtsmi|prc|25,n|1,2||; entry point|22245
gtsmi:
# getarg 2
        pop  prc_+8*5
# ||mov|7,xr|10,(xs)+||; load argument|22246
# getarg XR
        pop  XR
# ||beq|9,(xr)|22,=b_icl|6,gtsm1|; skip if already an integer|22247
# getarg (XR)
# getarg W0
# getarg gtsm1
        movq l_0087,W0
        cmpq (XR),W0
        je   gtsm1
# ||jsr|6,gtint|||; convert argument to integer|22251
# getarg gtint
        call gtint
        decq rcode
        js   call_241
# ||ppm|6,gtsm2|||; jump if convert is impossible|22252
# getarg gtsm2
# getarg gtsm2
        decq rcode
        jns  l_0831
        jmp  gtsm2
l_0831:
call_241:
# |gtsm1|ldi|13,icval(xr)|||; load integer value|22256
gtsm1:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||mfi|8,wc|6,gtsm3||; move as one word, jump if ovflow|22257
# getarg gtsm3
# getarg WC
        mov  IA,W0
        or   W0,W0
        js   gtsm3
        mov  IA,WC
# ||bgt|8,wc|3,mxlen|6,gtsm3|; or if too large|22258
# getarg WC
# getarg mxlen
# getarg gtsm3
        cmpq WC,mxlen
        ja   gtsm3
# ||mov|7,xr|8,wc||; copy result to xr|22259
# getarg WC
# getarg XR
        movq WC,XR
# ||exi||||; return to gtsmi caller|22260
# getarg 
        movq $0,rcode
        mov  prc_+8*5,W0
        jmp  *W0
# |gtsm2|exi|1,1|||; take non-integer error exit|22264
gtsm2:
# getarg 1
        movq $1,rcode
        mov  prc_+8*5,W0
        jmp  *W0
# |gtsm3|exi|1,2|||; take out-of-range error exit|22268
gtsm3:
# getarg 2
        movq $2,rcode
        mov  prc_+8*5,W0
        jmp  *W0
# ||enp||||; end procedure gtsmi|22269
# ||ejc|||||22270
# |gtstg|prc|25,n|1,1||; entry point|22336
gtstg:
# getarg 1
        pop  prc_+8*6
# ||mov|7,xr|10,(xs)+||; load argument, pop stack|22337
# getarg XR
        pop  XR
# ||beq|9,(xr)|22,=b_scl|6,gts30|; jump if already a string|22338
# getarg (XR)
# getarg W0
# getarg gts30
        movq l_0094,W0
        cmpq (XR),W0
        je   gts30
# |gts01|mov|11,-(xs)|7,xr||; restack argument in case error|22342
gts01:
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xl||; save xl|22343
# getarg XL
        push XL
# ||mov|3,gtsvb|8,wb||; save wb|22344
# getarg WB
# getarg gtsvb
        movq WB,gtsvb
# ||mov|3,gtsvc|8,wc||; save wc|22345
# getarg WC
# getarg gtsvc
        movq WC,gtsvc
# ||mov|8,wa|9,(xr)||; load first word of block|22346
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||beq|8,wa|22,=b_icl|6,gts05|; jump to convert integer|22347
# getarg WA
# getarg W0
# getarg gts05
        movq l_0087,W0
        cmpq WA,W0
        je   gts05
# ||beq|8,wa|22,=b_rcl|6,gts10|; jump to convert real|22350
# getarg WA
# getarg W0
# getarg gts10
        movq l_0101,W0
        cmpq WA,W0
        je   gts10
# ||beq|8,wa|22,=b_nml|6,gts03|; jump to convert name|22352
# getarg WA
# getarg W0
# getarg gts03
        movq l_0126,W0
        cmpq WA,W0
        je   gts03
# |gts02|mov|7,xl|10,(xs)+||; restore xl|22360
gts02:
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; reload input argument|22361
# getarg XR
        pop  XR
# ||exi|1,1|||; take convert error exit|22362
# getarg 1
        movq $1,rcode
        mov  prc_+8*6,W0
        jmp  *W0
# ||ejc|||||22363
# |gts03|mov|7,xl|13,nmbas(xr)||; load name base|22369
gts03:
# getarg nmbas(,XR,8)
# getarg XL
        movq nmbas(,XR,8),XL
# ||bhi|7,xl|3,state|6,gts02|; error if not natural var (static)|22370
# getarg XL
# getarg state
# getarg gts02
        cmpq XL,state
        ja   gts02
# ||add|7,xl|19,*vrsof||; else point to possible string name|22371
# getarg W0
# getarg XL
        movq l_0738,W0
        addq W0,XL
# ||mov|8,wa|13,sclen(xl)||; load length|22372
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||bnz|8,wa|6,gts04||; jump if not system variable|22373
# getarg WA
# getarg WA
# getarg gts04
        or   WA,WA
        jnz  gts04
# ||mov|7,xl|13,vrsvo(xl)||; else point to svblk|22374
# getarg vrsvo(,XL,8)
# getarg XL
        movq vrsvo(,XL,8),XL
# ||mov|8,wa|13,svlen(xl)||; and load name length|22375
# getarg svlen(,XL,8)
# getarg WA
        movq svlen(,XL,8),WA
# |gts04|zer|8,wb|||; set offset to zero|22379
gts04:
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; use sbstr to copy string|22380
# getarg sbstr
        call sbstr
# ||brn|6,gts29|||; jump to exit|22381
# getarg gts29
        jmp  gts29
# |gts05|ldi|13,icval(xr)|||; load integer value|22385
gts05:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||mov|3,gtssf|18,=num01||; set sign flag negative|22393
# getarg W0
# getarg gtssf
        movq l_0060,W0
        movq W0,gtssf
# ||ilt|6,gts06|||; skip if integer is negative|22394
# getarg gts06
        mov  IA,W0
        or   W0,W0
        jl   gts06
# ||ngi||||; else negate integer|22395
        neg  IA
        seto reg_fl
# ||zer|3,gtssf|||; and reset negative flag|22396
# getarg gtssf
        mov  $0,W0
        mov  W0,gtssf
# ||ejc|||||22397
# |gts06|mov|7,xr|3,gtswk||; point to result work area|22404
gts06:
# getarg gtswk
# getarg XR
        movq gtswk,XR
# ||mov|8,wb|18,=nstmx||; initialize counter to max length|22405
# getarg W0
# getarg WB
        movq l_0049,W0
        movq W0,WB
# ||psc|7,xr|8,wb||; prepare to store (right-left)|22406
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# |gts07|cvd||||; convert one digit into wa|22410
gts07:
        cvd_
# ||sch|8,wa|11,-(xr)||; store in work area|22411
# getarg WA
        dec  XR
        movzbq
# ||dcv|8,wb|||; decrement counter|22412
# getarg WB
        decq WB
# ||ine|6,gts07|||; loop if more digits to go|22413
# getarg gts07
        mov  IA,W0
        or   W0,W0
        jne  gts07
# ||csc|7,xr|||; complete store characters|22414
# |gts08|mov|8,wa|18,=nstmx||; get max number of characters|22420
gts08:
# getarg W0
# getarg WA
        movq l_0049,W0
        movq W0,WA
# ||sub|8,wa|8,wb||; compute length of result|22421
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|8,wa||; remember length for move later on|22422
# getarg WA
# getarg XL
        movq WA,XL
# ||add|8,wa|3,gtssf||; add one for negative sign if needed|22423
# getarg gtssf
# getarg WA
        addq gtssf,WA
# ||jsr|6,alocs|||; allocate string for result|22424
# getarg alocs
        call alocs
# ||mov|8,wc|7,xr||; save result pointer for the moment|22425
# getarg XR
# getarg WC
        movq XR,WC
# ||psc|7,xr|||; point to chars of result block|22426
# getarg XR
        add  $cfp_f,XR
# ||bze|3,gtssf|6,gts09||; skip if positive|22427
# getarg gtssf
# getarg gts09
        xor  W0,W0
        cmpq gtssf,W0
        jz   gts09
# ||mov|8,wa|18,=ch_mn||; else load negative sign|22428
# getarg W0
# getarg WA
        movq l_0689,W0
        movq W0,WA
# ||sch|8,wa|10,(xr)+||; and store it|22429
# getarg WA
        movb al
        stosb
# ||csc|7,xr|||; complete store characters|22430
# |gts09|mov|8,wa|7,xl||; recall length to move|22434
gts09:
# getarg XL
# getarg WA
        movq XL,WA
# ||mov|7,xl|3,gtswk||; point to result work area|22435
# getarg gtswk
# getarg XL
        movq gtswk,XL
# ||plc|7,xl|8,wb||; point to first result character|22436
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mvc||||; move chars to result string|22437
        rep
        movsb
# ||mov|7,xr|8,wc||; restore result pointer|22438
# getarg WC
# getarg XR
        movq WC,XR
# ||brn|6,gts29|||; jump to exit|22441
# getarg gts29
        jmp  gts29
# ||ejc|||||22442
# |gts10|ldr|13,rcval(xr)|||; load real|22448
gts10:
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||zer|3,gtssf|||; reset negative flag|22460
# getarg gtssf
        mov  $0,W0
        mov  W0,gtssf
# ||req|6,gts31|||; skip if zero|22461
# getarg gts31
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        je   gts31
# ||rge|6,gts11|||; jump if real is positive|22462
# getarg gts11
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jge  gts11
# ||mov|3,gtssf|18,=num01||; else set negative flag|22463
# getarg W0
# getarg gtssf
        movq l_0060,W0
        movq W0,gtssf
# ||ngr||||; and get absolute value of real|22464
        call ngr_
# |gts11|ldi|4,intv0|||; initialize exponent to zero|22468
gts11:
# getarg intv0
        mov  intv0,IA
# |gts12|str|3,gtsrs|||; save real value|22472
gts12:
        .data
l_0833: .long
        .text
        movq l_0833,W0
        call str_
# ||sbr|4,reap1|||; subtract 0.1 to compare|22473
        .data
l_0834: .long
        .text
        movq l_0834,W0
        call sbr_
# ||rge|6,gts13|||; jump if scale up not required|22474
# getarg gts13
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jge  gts13
# ||ldr|3,gtsrs|||; else reload value|22475
        movq l_0833,W0
        call ldr_
# ||mlr|4,reatt|||; multiply by 10**10|22476
        movq l_0812,W0
        call mlr_
# ||sbi|4,intvt|||; decrement exponent by 10|22477
# getarg intvt
        sub  intvt,IA
        xor  W0,W0
        seto reg_fl
# ||brn|6,gts12|||; loop back to test again|22478
# getarg gts12
        jmp  gts12
# |gts13|ldr|3,gtsrs|||; reload value|22482
gts13:
        movq l_0833,W0
        call ldr_
# ||sbr|4,reav1|||; subtract 1.0|22483
        movq l_0043,W0
        call sbr_
# ||rlt|6,gts17|||; jump if no scale down required|22484
# getarg gts17
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   gts17
# ||ldr|3,gtsrs|||; else reload value|22485
        movq l_0833,W0
        call ldr_
# |gts14|sbr|4,reatt|||; subtract 10**10 to compare|22489
gts14:
        movq l_0812,W0
        call sbr_
# ||rlt|6,gts15|||; jump if large step not required|22490
# getarg gts15
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   gts15
# ||ldr|3,gtsrs|||; else restore value|22491
        movq l_0833,W0
        call ldr_
# ||dvr|4,reatt|||; divide by 10**10|22492
        movq l_0812,W0
        call dvr_
# ||str|3,gtsrs|||; store new value|22493
        movq l_0833,W0
        call str_
# ||adi|4,intvt|||; increment exponent by 10|22494
# getarg intvt
        add  intvt,IA
        seto reg_fl
# ||brn|6,gts14|||; loop back|22495
# getarg gts14
        jmp  gts14
# ||ejc|||||22496
# |gts15|mov|7,xr|21,=reav1||; point to powers of ten table|22503
gts15:
# getarg W0
# getarg XR
        movq l_0814,W0
        movq W0,XR
# |gts16|ldr|3,gtsrs|||; reload value|22507
gts16:
        movq l_0833,W0
        call ldr_
# ||adi|4,intv1|||; increment exponent|22508
# getarg intv1
        add  intv1,IA
        seto reg_fl
# ||add|7,xr|19,*cfp_r||; point to next entry in table|22509
# getarg W0
# getarg XR
        .data
l_0835: .long 8*cfp_r
        .text
        movq l_0835,W0
        addq W0,XR
# ||sbr|9,(xr)|||; subtract it to compare|22510
        movq l_0815,W0
        call sbr_
# ||rge|6,gts16|||; loop till we find a larger entry|22511
# getarg gts16
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jge  gts16
# ||ldr|3,gtsrs|||; then reload the value|22512
        movq l_0833,W0
        call ldr_
# ||dvr|9,(xr)|||; and complete scaling|22513
        movq l_0815,W0
        call dvr_
# ||str|3,gtsrs|||; store value|22514
        movq l_0833,W0
        call str_
# |gts17|ldr|3,gtsrs|||; get value again|22518
gts17:
        movq l_0833,W0
        call ldr_
# ||adr|3,gtsrn|||; add rounding factor|22519
        movq l_0047,W0
        call adr_
# ||str|3,gtsrs|||; store result|22520
        movq l_0833,W0
        call str_
# ||sbr|4,reav1|||; subtract 1.0 to compare|22525
        movq l_0043,W0
        call sbr_
# ||rlt|6,gts18|||; skip if ok|22526
# getarg gts18
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jl   gts18
# ||adi|4,intv1|||; else increment exponent|22527
# getarg intv1
        add  intv1,IA
        seto reg_fl
# ||ldr|3,gtsrs|||; reload value|22528
        movq l_0833,W0
        call ldr_
# ||dvr|4,reavt|||; divide by 10.0 to rescale|22529
        movq l_0044,W0
        call dvr_
# ||brn|6,gts19|||; jump to merge|22530
# getarg gts19
        jmp  gts19
# |gts18|ldr|3,gtsrs|||; reload rounded value|22534
gts18:
        movq l_0833,W0
        call ldr_
# ||ejc|||||22535
# |gts19|mov|7,xl|18,=cfp_s||; set num dec digits = cfp_s|22559
gts19:
# getarg W0
# getarg XL
        movq l_0042,W0
        movq W0,XL
# ||mov|3,gtses|18,=ch_mn||; set exponent sign negative|22560
# getarg W0
# getarg gtses
        movq l_0689,W0
        movq W0,gtses
# ||ilt|6,gts21|||; all set if exponent is negative|22561
# getarg gts21
        mov  IA,W0
        or   W0,W0
        jl   gts21
# ||mfi|8,wa|||; else fetch exponent|22562
# getarg WA
        mov  IA,WA
# ||ble|8,wa|18,=cfp_s|6,gts20|; skip if we can use special format|22563
# getarg WA
# getarg W0
# getarg gts20
        movq l_0042,W0
        cmpq WA,W0
        jbe  gts20
# ||mti|8,wa|||; else restore exponent|22564
# getarg WA
        mov  WA,IA
# ||ngi||||; set negative for cvd|22565
        neg  IA
        seto reg_fl
# ||mov|3,gtses|18,=ch_pl||; set plus sign for exponent sign|22566
# getarg W0
# getarg gtses
        movq l_0805,W0
        movq W0,gtses
# ||brn|6,gts21|||; jump to generate exponent|22567
# getarg gts21
        jmp  gts21
# |gts20|sub|7,xl|8,wa||; compute digits after decimal point|22571
gts20:
# getarg WA
# getarg XL
        subq WA,XL
# ||ldi|4,intv0|||; reset exponent to zero|22572
# getarg intv0
        mov  intv0,IA
# ||ejc|||||22573
# |gts21|mov|7,xr|3,gtswk||; point to work area|22584
gts21:
# getarg gtswk
# getarg XR
        movq gtswk,XR
# ||mov|8,wb|18,=nstmx||; set character ctr to max length|22585
# getarg W0
# getarg WB
        movq l_0049,W0
        movq W0,WB
# ||psc|7,xr|8,wb||; prepare to store (right to left)|22586
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# ||ieq|6,gts23|||; skip exponent if it is zero|22587
# getarg gts23
        mov  IA,W0
        or   W0,W0
        je   gts23
# |gts22|cvd||||; convert a digit into wa|22591
gts22:
        cvd_
# ||sch|8,wa|11,-(xr)||; store in work area|22592
# getarg WA
        dec  XR
        movzbq
# ||dcv|8,wb|||; decrement counter|22593
# getarg WB
        decq WB
# ||ine|6,gts22|||; loop back if more digits to go|22594
# getarg gts22
        mov  IA,W0
        or   W0,W0
        jne  gts22
# ||mov|8,wa|3,gtses||; load exponent sign|22598
# getarg gtses
# getarg WA
        movq gtses,WA
# ||sch|8,wa|11,-(xr)||; store in work area|22599
# getarg WA
        dec  XR
        movzbq
# ||mov|8,wa|18,=ch_le||; get character letter e|22600
# getarg W0
# getarg WA
        movq l_0808,W0
        movq W0,WA
# ||sch|8,wa|11,-(xr)||; store in work area|22601
# getarg WA
        dec  XR
        movzbq
# ||sub|8,wb|18,=num02||; decrement counter for sign and e|22602
# getarg W0
# getarg WB
        movq l_0130,W0
        subq W0,WB
# |gts23|mlr|3,gtssc|||; convert real to integer (10**cfp_s)|22606
gts23:
        movq l_0045,W0
        call mlr_
# ||rti||||; get integer (overflow impossible)|22607
        rti_
# ||ngi||||; negate as required by cvd|22608
        neg  IA
        seto reg_fl
# |gts24|bze|7,xl|6,gts27||; jump if no digits left to do|22612
gts24:
# getarg XL
# getarg gts27
        or   XL,XL
        jz   gts27
# ||cvd||||; else convert one digit|22613
        cvd_
# ||bne|8,wa|18,=ch_d0|6,gts26|; jump if not a zero|22614
# getarg WA
# getarg W0
# getarg gts26
        movq l_0719,W0
        cmpq WA,W0
        jne  gts26
# ||dcv|7,xl|||; decrement counter|22615
# getarg XL
        decq XL
# ||brn|6,gts24|||; loop back for next digit|22616
# getarg gts24
        jmp  gts24
# ||ejc|||||22617
# |gts25|cvd||||; convert a digit into wa|22623
gts25:
        cvd_
# |gts26|sch|8,wa|11,-(xr)||; store digit|22627
gts26:
# getarg WA
        dec  XR
        movzbq
# ||dcv|8,wb|||; decrement counter|22628
# getarg WB
        decq WB
# ||dcv|7,xl|||; decrement counter|22629
# getarg XL
        decq XL
# ||bnz|7,xl|6,gts25||; loop back if more to go|22630
# getarg XL
# getarg XL
# getarg gts25
        or   XL,XL
        jnz  gts25
# |gts27|mov|8,wa|18,=ch_dt||; load decimal point|22634
gts27:
# getarg W0
# getarg WA
        movq l_0807,W0
        movq W0,WA
# ||sch|8,wa|11,-(xr)||; store in work area|22635
# getarg WA
        dec  XR
        movzbq
# ||dcv|8,wb|||; decrement counter|22636
# getarg WB
        decq WB
# |gts28|cvd||||; convert a digit into wa|22640
gts28:
        cvd_
# ||sch|8,wa|11,-(xr)||; store in work area|22641
# getarg WA
        dec  XR
        movzbq
# ||dcv|8,wb|||; decrement counter|22642
# getarg WB
        decq WB
# ||ine|6,gts28|||; loop back if more to go|22643
# getarg gts28
        mov  IA,W0
        or   W0,W0
        jne  gts28
# ||csc|7,xr|||; complete store characters|22644
# ||brn|6,gts08|||; else jump back to exit|22645
# getarg gts08
        jmp  gts08
# |gts29|mov|7,xl|10,(xs)+||; restore xl|22651
gts29:
# getarg XL
        pop  XL
# ||ica|7,xs|||; pop argument|22652
# getarg XT
        addq $8,XT
# ||mov|8,wb|3,gtsvb||; restore wb|22653
# getarg gtsvb
# getarg WB
        movq gtsvb,WB
# ||mov|8,wc|3,gtsvc||; restore wc|22654
# getarg gtsvc
# getarg WC
        movq gtsvc,WC
# |gts30|mov|8,wa|13,sclen(xr)||; load string length|22658
gts30:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||exi||||; return to caller|22659
# getarg 
        movq $0,rcode
        mov  prc_+8*6,W0
        jmp  *W0
# |gts31|mov|7,xl|21,=scre0||; point to string|22665
gts31:
# getarg W0
# getarg XL
        .data
l_0836: .long scre0
        .text
        movq l_0836,W0
        movq W0,XL
# ||mov|8,wa|18,=num02||; 2 chars|22666
# getarg W0
# getarg WA
        movq l_0130,W0
        movq W0,WA
# ||zer|8,wb|||; zero offset|22667
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; copy string|22668
# getarg sbstr
        call sbstr
# ||brn|6,gts29|||; return|22669
# getarg gts29
        jmp  gts29
# ||enp||||; end procedure gtstg|22696
# ||ejc|||||22697
# |gtvar|prc|25,e|1,1||; entry point|22712
gtvar:
# getarg 1
# ||bne|9,(xr)|22,=b_nml|6,gtvr2|; jump if not a name|22713
# getarg (XR)
# getarg W0
# getarg gtvr2
        movq l_0126,W0
        cmpq (XR),W0
        jne  gtvr2
# ||mov|8,wa|13,nmofs(xr)||; else load name offset|22714
# getarg nmofs(,XR,8)
# getarg WA
        movq nmofs(,XR,8),WA
# ||mov|7,xl|13,nmbas(xr)||; load name base|22715
# getarg nmbas(,XR,8)
# getarg XL
        movq nmbas(,XR,8),XL
# ||beq|9,(xl)|22,=b_evt|6,gtvr1|; error if expression variable|22716
# getarg (XL)
# getarg W0
# getarg gtvr1
        movq l_0118,W0
        cmpq (XL),W0
        je   gtvr1
# ||bne|9,(xl)|22,=b_kvt|6,gtvr3|; all ok if not keyword variable|22717
# getarg (XL)
# getarg W0
# getarg gtvr3
        movq l_0745,W0
        cmpq (XL),W0
        jne  gtvr3
# |gtvr1|exi|1,1|||; take convert error exit|22721
gtvr1:
# getarg 1
        movq $1,rcode
        ret
# |gtvr2|mov|3,gtvrc|8,wc||; save wc|22725
gtvr2:
# getarg WC
# getarg gtvrc
        movq WC,gtvrc
# ||jsr|6,gtnvr|||; locate vrblk if possible|22726
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_242
# ||ppm|6,gtvr1|||; jump if convert error|22727
# getarg gtvr1
# getarg gtvr1
        decq rcode
        jns  l_0837
        jmp  gtvr1
l_0837:
call_242:
# ||mov|7,xl|7,xr||; else copy vrblk name base|22728
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*vrval||; and set offset|22729
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||mov|8,wc|3,gtvrc||; restore wc|22730
# getarg gtvrc
# getarg WC
        movq gtvrc,WC
# |gtvr3|bhi|7,xl|3,state|6,gtvr4|; all ok if not natural variable|22734
gtvr3:
# getarg XL
# getarg state
# getarg gtvr4
        cmpq XL,state
        ja   gtvr4
# ||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|; error if protected variable|22735
# getarg vrsto(,XL,8)
# getarg W0
# getarg gtvr1
        movq l_0269,W0
        cmpq vrsto(,XL,8),W0
        je   gtvr1
# |gtvr4|exi||||; return to caller|22739
gtvr4:
# getarg 
        movq $0,rcode
        ret
# ||enp||||; end procedure gtvar|22740
# ||ejc|||||22741
# ||ejc|||||22742
# |hashs|prc|25,e|1,0||; entry point|22778
hashs:
# getarg 0
# ||mov|8,wc|18,=e_hnw||; get number of words to use|22780
# getarg W0
# getarg WC
        .data
l_0838: .long e_hnw
        .text
        movq l_0838,W0
        movq W0,WC
# ||bze|8,wc|6,hshsa||; branch if one character per word|22781
# getarg WC
# getarg hshsa
        or   WC,WC
        jz   hshsa
# ||mov|8,wc|13,sclen(xr)||; load string length in characters|22782
# getarg sclen(,XR,8)
# getarg WC
        movq sclen(,XR,8),WC
# ||mov|8,wb|8,wc||; initialize with length|22783
# getarg WC
# getarg WB
        movq WC,WB
# ||bze|8,wc|6,hshs3||; jump if null string|22784
# getarg WC
# getarg hshs3
        or   WC,WC
        jz   hshs3
# ||zgb|8,wb|||; correct byte ordering if necessary|22785
        nop
# ||ctw|8,wc|1,0||; get number of words of chars|22786
# getarg WC
        add  ($8-1)+$cfp_c*0,WC
        shr  WC,log_cfp_c
# ||add|7,xr|19,*schar||; point to characters of string|22787
# getarg W0
# getarg XR
        movq l_0817,W0
        addq W0,XR
# ||blo|8,wc|18,=e_hnw|6,hshs1|; use whole string if short|22788
# getarg WC
# getarg W0
# getarg hshs1
        movq l_0838,W0
        cmpq WC,W0
        jb   hshs1
# ||mov|8,wc|18,=e_hnw||; else set to involve first e_hnw wds|22789
# getarg W0
# getarg WC
        movq l_0838,W0
        movq W0,WC
# |hshs1|lct|8,wc|8,wc||; set counter to control loop|22793
hshs1:
# |hshs2|xob|8,wb|10,(xr)+||; exclusive or next word of chars|22797
hshs2:
# getarg WB
# getarg (XR)
        xor  WB,(XR)
        add  $8,XR
# ||bct|8,wc|6,hshs2||; loop till all processed|22798
# getarg WC
# getarg hshs2
        decq WC
        jnz  hshs2
# |hshs3|zgb|8,wb|||; zeroise undefined bits|22802
hshs3:
        nop
# ||anb|8,wb|4,bitsm||; ensure in range 0 to cfp_m|22803
# getarg WB
# getarg bitsm
        and  WB,bitsm
# ||mti|8,wb|||; move result as integer|22804
# getarg WB
        mov  WB,IA
# ||zer|7,xr|||; clear garbage value in xr|22805
# getarg XR
        xor  XR,XR
# ||exi||||; return to hashs caller|22806
# getarg 
        ret
# |hshsa|mov|8,wc|13,sclen(xr)||; load string length in characters|22810
hshsa:
# getarg sclen(,XR,8)
# getarg WC
        movq sclen(,XR,8),WC
# ||mov|8,wb|8,wc||; initialize with length|22811
# getarg WC
# getarg WB
        movq WC,WB
# ||bze|8,wc|6,hshs3||; jump if null string|22812
# getarg WC
# getarg hshs3
        or   WC,WC
        jz   hshs3
# ||zgb|8,wb|||; correct byte ordering if necessary|22813
        nop
# ||ctw|8,wc|1,0||; get number of words of chars|22814
# getarg WC
        add  ($8-1)+$cfp_c*0,WC
        shr  WC,log_cfp_c
# ||plc|7,xr|||;|22815
# getarg XR
        add  $cfp_f,XR
# ||mov|11,-(xs)|7,xl||; save xl|22816
# getarg XL
        push XL
# ||mov|7,xl|8,wc||; load length for branch|22817
# getarg WC
# getarg XL
        movq WC,XL
# ||bge|7,xl|18,=num25|6,hsh24|; use first characters if longer|22818
# getarg XL
# getarg W0
# getarg hsh24
        .data
l_0839: .long num25
        .text
        movq l_0839,W0
        cmpq XL,W0
        jae  hsh24
# ||bsw|7,xl|1,25||; merge to compute hash|22819
# getarg XL
        jmp  *l_0840(,XL,8)
        .data
l_0840:
# ||iff|1,0|6,hsh00||;|22845
# getarg hsh00
        .long hsh00
# ||iff|1,1|6,hsh01||;|22845
# getarg hsh01
        .long hsh01
# ||iff|1,2|6,hsh02||;|22845
# getarg hsh02
        .long hsh02
# ||iff|1,3|6,hsh03||;|22845
# getarg hsh03
        .long hsh03
# ||iff|1,4|6,hsh04||;|22845
# getarg hsh04
        .long hsh04
# ||iff|1,5|6,hsh05||;|22845
# getarg hsh05
        .long hsh05
# ||iff|1,6|6,hsh06||;|22845
# getarg hsh06
        .long hsh06
# ||iff|1,7|6,hsh07||;|22845
# getarg hsh07
        .long hsh07
# ||iff|1,8|6,hsh08||;|22845
# getarg hsh08
        .long hsh08
# ||iff|1,9|6,hsh09||;|22845
# getarg hsh09
        .long hsh09
# ||iff|1,10|6,hsh10||;|22845
# getarg hsh10
        .long hsh10
# ||iff|1,11|6,hsh11||;|22845
# getarg hsh11
        .long hsh11
# ||iff|1,12|6,hsh12||;|22845
# getarg hsh12
        .long hsh12
# ||iff|1,13|6,hsh13||;|22845
# getarg hsh13
        .long hsh13
# ||iff|1,14|6,hsh14||;|22845
# getarg hsh14
        .long hsh14
# ||iff|1,15|6,hsh15||;|22845
# getarg hsh15
        .long hsh15
# ||iff|1,16|6,hsh16||;|22845
# getarg hsh16
        .long hsh16
# ||iff|1,17|6,hsh17||;|22845
# getarg hsh17
        .long hsh17
# ||iff|1,18|6,hsh18||;|22845
# getarg hsh18
        .long hsh18
# ||iff|1,19|6,hsh19||;|22845
# getarg hsh19
        .long hsh19
# ||iff|1,20|6,hsh20||;|22845
# getarg hsh20
        .long hsh20
# ||iff|1,21|6,hsh21||;|22845
# getarg hsh21
        .long hsh21
# ||iff|1,22|6,hsh22||;|22845
# getarg hsh22
        .long hsh22
# ||iff|1,23|6,hsh23||;|22845
# getarg hsh23
        .long hsh23
# ||iff|1,24|6,hsh24||;|22845
# getarg hsh24
        .long hsh24
# ||esw|||||22845
        .text
# |hsh24|lch|8,wc|10,(xr)+||; load next character|22846
hsh24:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22847
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22848
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh23|lch|8,wc|10,(xr)+||; load next character|22849
hsh23:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22850
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22851
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh22|lch|8,wc|10,(xr)+||; load next character|22852
hsh22:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22853
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22854
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh21|lch|8,wc|10,(xr)+||; load next character|22855
hsh21:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22856
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh20|lch|8,wc|10,(xr)+||; load next character|22857
hsh20:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22858
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22859
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh19|lch|8,wc|10,(xr)+||; load next character|22860
hsh19:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22861
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22862
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh18|lch|8,wc|10,(xr)+||; load next character|22863
hsh18:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22864
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22865
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh17|lch|8,wc|10,(xr)+||; load next character|22866
hsh17:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22867
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh16|lch|8,wc|10,(xr)+||; load next character|22868
hsh16:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22869
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22870
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh15|lch|8,wc|10,(xr)+||; load next character|22871
hsh15:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22872
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22873
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh14|lch|8,wc|10,(xr)+||; load next character|22874
hsh14:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22875
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22876
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh13|lch|8,wc|10,(xr)+||; load next character|22877
hsh13:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22878
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh12|lch|8,wc|10,(xr)+||; load next character|22879
hsh12:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22880
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22881
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh11|lch|8,wc|10,(xr)+||; load next character|22882
hsh11:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22883
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22884
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh10|lch|8,wc|10,(xr)+||; load next character|22885
hsh10:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22886
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22887
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh09|lch|8,wc|10,(xr)+||; load next character|22888
hsh09:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22889
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh08|lch|8,wc|10,(xr)+||; load next character|22890
hsh08:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22891
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22892
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh07|lch|8,wc|10,(xr)+||; load next character|22893
hsh07:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22894
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22895
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh06|lch|8,wc|10,(xr)+||; load next character|22896
hsh06:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22897
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22898
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh05|lch|8,wc|10,(xr)+||; load next character|22899
hsh05:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22900
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh04|lch|8,wc|10,(xr)+||; load next character|22901
hsh04:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,24||; shift for hash|22902
# getarg 24
# getarg WC
        shl  24,WC
# ||xob|8,wb|8,wc||; hash character|22903
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh03|lch|8,wc|10,(xr)+||; load next character|22904
hsh03:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,16||; shift for hash|22905
# getarg 16
# getarg WC
        shl  16,WC
# ||xob|8,wb|8,wc||; hash character|22906
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh02|lch|8,wc|10,(xr)+||; load next character|22907
hsh02:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||lsh|8,wc|1,8||; shift for hash|22908
# getarg 8
# getarg WC
        shl  8,WC
# ||xob|8,wb|8,wc||; hash character|22909
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh01|lch|8,wc|10,(xr)+||; load next character|22910
hsh01:
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
        incq XR
# ||xob|8,wb|8,wc||; hash character|22911
# getarg WB
# getarg WC
        xor  WB,WC
# |hsh00|mov|7,xl|10,(xs)+||; restore xl|22912
hsh00:
# getarg XL
        pop  XL
# ||brn|6,hshs3|||; merge to complete hash|22913
# getarg hshs3
        jmp  hshs3
# ||enp||||; end procedure hashs|22914
# |icbld|prc|25,e|1,0||; entry point|22923
icbld:
# getarg 0
# ||mfi|7,xr|6,icbl1||; copy small integers|22925
# getarg icbl1
# getarg XR
        mov  IA,W0
        or   W0,W0
        js   icbl1
        mov  IA,XR
# ||ble|7,xr|18,=num02|6,icbl3|; jump if 0,1 or 2|22926
# getarg XR
# getarg W0
# getarg icbl3
        movq l_0130,W0
        cmpq XR,W0
        jbe  icbl3
# |icbl1|mov|7,xr|3,dnamp||; load pointer to next available loc|22930
icbl1:
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||add|7,xr|19,*icsi_||; point past new icblk|22931
# getarg W0
# getarg XR
        movq l_0628,W0
        addq W0,XR
# ||blo|7,xr|3,dname|6,icbl2|; jump if there is room|22932
# getarg XR
# getarg dname
# getarg icbl2
        cmpq XR,dname
        jb   icbl2
# ||mov|8,wa|19,*icsi_||; else load length of icblk|22933
# getarg W0
# getarg WA
        movq l_0628,W0
        movq W0,WA
# ||jsr|6,alloc|||; use standard allocator to get block|22934
# getarg alloc
        call alloc
# ||add|7,xr|8,wa||; point past block to merge|22935
# getarg WA
# getarg XR
        addq WA,XR
# |icbl2|mov|3,dnamp|7,xr||; set new pointer|22939
icbl2:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||sub|7,xr|19,*icsi_||; point back to start of block|22940
# getarg W0
# getarg XR
        movq l_0628,W0
        subq W0,XR
# ||mov|9,(xr)|22,=b_icl||; store type word|22941
# getarg W0
# getarg (XR)
        movq l_0087,W0
        movq W0,(XR)
# ||sti|13,icval(xr)|||; store integer value in icblk|22942
# getarg icval(,XR,8)
        mov  IA,icval(,XR,8)
# ||exi||||; return to icbld caller|22943
# getarg 
        ret
# |icbl3|wtb|7,xr|||; convert integer to offset|22947
icbl3:
# getarg XR
        sal  XR,3
# ||mov|7,xr|14,intab(xr)||; point to pre-built icblk|22948
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||exi||||; return|22949
# getarg 
        ret
# ||enp||||; end procedure icbld|22950
# ||ejc|||||22951
# |ident|prc|25,e|1,1||; entry point|22965
ident:
# getarg 1
# ||beq|7,xr|7,xl|6,iden7|; jump if same pointer (ident)|22966
# getarg XR
# getarg XL
# getarg iden7
        cmpq XR,XL
        je   iden7
# ||mov|8,wc|9,(xr)||; else load arg 1 type word|22967
# getarg (XR)
# getarg WC
        movq (XR),WC
# ||bne|8,wc|9,(xl)|6,iden1|; differ if arg 2 type word differ|22969
# getarg WC
# getarg (XL)
# getarg iden1
        cmpq WC,(XL)
        jne  iden1
# ||beq|8,wc|22,=b_scl|6,iden2|; jump if strings|22973
# getarg WC
# getarg W0
# getarg iden2
        movq l_0094,W0
        cmpq WC,W0
        je   iden2
# ||beq|8,wc|22,=b_icl|6,iden4|; jump if integers|22974
# getarg WC
# getarg W0
# getarg iden4
        movq l_0087,W0
        cmpq WC,W0
        je   iden4
# ||beq|8,wc|22,=b_rcl|6,iden5|; jump if reals|22977
# getarg WC
# getarg W0
# getarg iden5
        movq l_0101,W0
        cmpq WC,W0
        je   iden5
# ||beq|8,wc|22,=b_nml|6,iden6|; jump if names|22979
# getarg WC
# getarg W0
# getarg iden6
        movq l_0126,W0
        cmpq WC,W0
        je   iden6
# |iden1|exi||||; take differ exit|23022
iden1:
# getarg 
        movq $0,rcode
        ret
# |iden2|mov|8,wc|13,sclen(xr)||; load arg 1 length|23026
iden2:
# getarg sclen(,XR,8)
# getarg WC
        movq sclen(,XR,8),WC
# ||bne|8,wc|13,sclen(xl)|6,iden1|; differ if lengths differ|23027
# getarg WC
# getarg sclen(,XL,8)
# getarg iden1
        cmpq WC,sclen(,XL,8)
        jne  iden1
# |idn2a|add|7,xr|19,*schar||; point to chars of arg 1|23031
idn2a:
# getarg W0
# getarg XR
        movq l_0817,W0
        addq W0,XR
# ||add|7,xl|19,*schar||; point to chars of arg 2|23032
# getarg W0
# getarg XL
        movq l_0817,W0
        addq W0,XL
# ||ctw|8,wc|1,0||; get number of words in strings|23033
# getarg WC
        add  ($8-1)+$cfp_c*0,WC
        shr  WC,log_cfp_c
# ||lct|8,wc|8,wc||; set loop counter|23034
# |iden3|cne|9,(xr)|9,(xl)|6,iden8|; differ if chars do not match|23039
iden3:
# getarg (XL)
# getarg (XR)
# getarg W0
# getarg iden8
        movq (XL),W0
        cmpb (XR),W0
        jnz  iden8
# ||ica|7,xr|||; else bump arg one pointer|23040
# getarg XR
        addq $8,XR
# ||ica|7,xl|||; bump arg two pointer|23041
# getarg XL
        addq $8,XL
# ||bct|8,wc|6,iden3||; loop back till all checked|23042
# getarg WC
# getarg iden3
        decq WC
        jnz  iden3
# ||ejc|||||23043
# ||zer|7,xl|||; clear garbage value in xl|23049
# getarg XL
        xor  XL,XL
# ||zer|7,xr|||; clear garbage value in xr|23050
# getarg XR
        xor  XR,XR
# ||exi|1,1|||; take ident exit|23051
# getarg 1
        movq $1,rcode
        ret
# |iden4|ldi|13,icval(xr)|||; load arg 1|23055
iden4:
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||sbi|13,icval(xl)|||; subtract arg 2 to compare|23056
# getarg icval(,XL,8)
        sub  icval(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,iden1|||; differ if overflow|23057
# getarg iden1
        iov_ iden1
# ||ine|6,iden1|||; differ if result is not zero|23058
# getarg iden1
        mov  IA,W0
        or   W0,W0
        jne  iden1
# ||exi|1,1|||; take ident exit|23059
# getarg 1
        movq $1,rcode
        ret
# |iden5|ldr|13,rcval(xr)|||; load arg 1|23065
iden5:
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call ldr_
# ||sbr|13,rcval(xl)|||; subtract arg 2 to compare|23066
        mov  XL,W0
        add  8*rcval,W0
        movq l_0080,W0
        call sbr_
# ||rov|6,iden1|||; differ if overflow|23067
# getarg iden1
        rov_ iden1
# ||rne|6,iden1|||; differ if result is not zero|23068
# getarg iden1
        call cpr_
        mov  (reg_fl),%al
        or   %al,%al
        jne  iden1
# ||exi|1,1|||; take ident exit|23069
# getarg 1
        movq $1,rcode
        ret
# |iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|; differ if different offset|23074
iden6:
# getarg nmofs(,XL,8)
# getarg nmofs(,XR,8)
# getarg W0
# getarg iden1
        movq nmofs(,XL,8),W0
        cmpq nmofs(,XR,8),W0
        jne  iden1
# ||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|; differ if different base|23075
# getarg nmbas(,XL,8)
# getarg nmbas(,XR,8)
# getarg W0
# getarg iden1
        movq nmbas(,XL,8),W0
        cmpq nmbas(,XR,8),W0
        jne  iden1
# |iden7|exi|1,1|||; take ident exit|23079
iden7:
# getarg 1
        movq $1,rcode
        ret
# |iden8|zer|7,xr|||; clear garbage ptr in xr|23083
iden8:
# getarg XR
        xor  XR,XR
# ||zer|7,xl|||; clear garbage ptr in xl|23084
# getarg XL
        xor  XL,XL
# ||exi||||; return to caller (differ)|23085
# getarg 
        movq $0,rcode
        ret
# ||enp||||; end procedure ident|23086
# ||ejc|||||23087
# |inout|prc|25,e|1,0||; entry point|23102
inout:
# getarg 0
# ||mov|11,-(xs)|8,wb||; stack trblk type|23103
# getarg WB
        push WB
# ||mov|8,wa|13,sclen(xl)||; get name length|23104
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||zer|8,wb|||; point to start of name|23105
# getarg WB
        xor  WB,WB
# ||jsr|6,sbstr|||; build a proper scblk|23106
# getarg sbstr
        call sbstr
# ||jsr|6,gtnvr|||; build vrblk|23107
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_243
# ||ppm||||; no error return|23108
# getarg 
        decq rcode
        jns  l_0841
        movq $299,rcode
        jmp  err_
l_0841:
call_243:
# ||mov|8,wc|7,xr||; save vrblk pointer|23109
# getarg XR
# getarg WC
        movq XR,WC
# ||mov|8,wb|10,(xs)+||; get trter field|23110
# getarg WB
        pop  WB
# ||zer|7,xl|||; zero trfpt|23111
# getarg XL
        xor  XL,XL
# ||jsr|6,trbld|||; build trblk|23112
# getarg trbld
        call trbld
# ||mov|7,xl|8,wc||; recall vrblk pointer|23113
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|13,trter(xr)|13,vrsvp(xl)||; store svblk pointer|23114
# getarg vrsvp(,XL,8)
# getarg W0
# getarg trter(,XR,8)
        movq vrsvp(,XL,8),W0
        movq W0,trter(,XR,8)
# ||mov|13,vrval(xl)|7,xr||; store trblk ptr in vrblk|23115
# getarg XR
# getarg vrval(,XL,8)
        movq XR,vrval(,XL,8)
# ||mov|13,vrget(xl)|22,=b_vra||; set trapped access|23116
# getarg W0
# getarg vrget(,XL,8)
        movq l_0653,W0
        movq W0,vrget(,XL,8)
# ||mov|13,vrsto(xl)|22,=b_vrv||; set trapped store|23117
# getarg W0
# getarg vrsto(,XL,8)
        .data
l_0842: .long b_vrv
        .text
        movq l_0842,W0
        movq W0,vrsto(,XL,8)
# ||exi||||; return to caller|23118
# getarg 
        ret
# ||enp||||; end procedure inout|23119
# ||ejc|||||23120
# |insta|prc|25,e|1,0||; entry point|23299
insta:
# getarg 0
# ||mov|8,wc|3,prlen||; no. of chars in print bfr|23304
# getarg prlen
# getarg WC
        movq prlen,WC
# ||mov|3,prbuf|7,xr||; print bfr is put at static start|23305
# getarg XR
# getarg prbuf
        movq XR,prbuf
# ||mov|10,(xr)+|22,=b_scl||; store string type code|23306
# getarg W0
        movq l_0094,W0
        movq W0,W0
        stosq
# ||mov|10,(xr)+|8,wc||; and string length|23307
# getarg WC
        movq WC,W0
        stosq
# ||ctw|8,wc|1,0||; get number of words in buffer|23308
# getarg WC
        add  ($8-1)+$cfp_c*0,WC
        shr  WC,log_cfp_c
# ||mov|3,prlnw|8,wc||; store for buffer clear|23309
# getarg WC
# getarg prlnw
        movq WC,prlnw
# ||lct|8,wc|8,wc||; words to clear|23310
# |inst1|mov|10,(xr)+|4,nullw||; store blank|23314
inst1:
# getarg nullw
        movq nullw,W0
        stosq
# ||bct|8,wc|6,inst1||; loop|23315
# getarg WC
# getarg inst1
        decq WC
        jnz  inst1
# ||mov|8,wa|18,=nstmx||; get max num chars in output number|23319
# getarg W0
# getarg WA
        movq l_0049,W0
        movq W0,WA
# ||ctb|8,wa|2,scsi_||; no of bytes needed|23320
# getarg WA
        add  ($cfp_b-1)+$cfp_b*scsi_,WA
        and  WA,-$8
# ||mov|3,gtswk|7,xr||; store bfr adrs|23321
# getarg XR
# getarg gtswk
        movq XR,gtswk
# ||add|7,xr|8,wa||; bump for work bfr|23322
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|3,kvalp|7,xr||; save alphabet pointer|23326
# getarg XR
# getarg kvalp
        movq XR,kvalp
# ||mov|9,(xr)|22,=b_scl||; string blk type|23327
# getarg W0
# getarg (XR)
        movq l_0094,W0
        movq W0,(XR)
# ||mov|8,wc|18,=cfp_a||; no of chars in alphabet|23328
# getarg W0
# getarg WC
        movq l_0048,W0
        movq W0,WC
# ||mov|13,sclen(xr)|8,wc||; store as string length|23329
# getarg WC
# getarg sclen(,XR,8)
        movq WC,sclen(,XR,8)
# ||mov|8,wb|8,wc||; copy char count|23330
# getarg WC
# getarg WB
        movq WC,WB
# ||ctb|8,wb|2,scsi_||; no. of bytes needed|23331
# getarg WB
        add  ($cfp_b-1)+$cfp_b*scsi_,WB
        and  WB,-$8
# ||add|8,wb|7,xr||; current end address for static|23332
# getarg XR
# getarg WB
        addq XR,WB
# ||mov|8,wa|8,wb||; save adrs past alphabet string|23333
# getarg WB
# getarg WA
        movq WB,WA
# ||lct|8,wc|8,wc||; loop counter|23334
# ||psc|7,xr|||; point to chars of string|23335
# getarg XR
        add  $cfp_f,XR
# ||zer|8,wb|||; set initial character value|23336
# getarg WB
        xor  WB,WB
# |inst2|sch|8,wb|10,(xr)+||; store next code|23340
inst2:
# getarg WB
        movb al
        stosb
# ||icv|8,wb|||; bump code value|23341
# getarg WB
        incq WB
# ||bct|8,wc|6,inst2||; loop till all stored|23342
# getarg WC
# getarg inst2
        decq WC
        jnz  inst2
# ||csc|7,xr|||; complete store characters|23343
# ||mov|7,xr|8,wa||; return current static ptr|23344
# getarg WA
# getarg XR
        movq WA,XR
# ||exi||||; return to caller|23345
# getarg 
        ret
# ||enp||||; end procedure insta|23346
# ||ejc|||||23347
# |iofcb|prc|25,n|1,3||; entry point|23365
iofcb:
# getarg 3
        pop  prc_+8*7
# ||jsr|6,gtstg|||; get arg as string|23367
# getarg gtstg
        call gtstg
        decq rcode
        js   call_244
# ||ppm|6,iofc2|||; fail|23368
# getarg iofc2
# getarg iofc2
        decq rcode
        jns  l_0843
        jmp  iofc2
l_0843:
call_244:
# ||mov|7,xl|7,xr||; copy string ptr|23369
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,gtnvr|||; get as natural variable|23370
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_245
# ||ppm|6,iofc3|||; fail if null|23371
# getarg iofc3
# getarg iofc3
        decq rcode
        jns  l_0844
        jmp  iofc3
l_0844:
call_245:
# ||mov|8,wb|7,xl||; copy string pointer again|23372
# getarg XL
# getarg WB
        movq XL,WB
# ||mov|7,xl|7,xr||; copy vrblk ptr for return|23373
# getarg XR
# getarg XL
        movq XR,XL
# ||zer|8,wa|||; in case no trblk found|23374
# getarg WA
        xor  WA,WA
# |iofc1|mov|7,xr|13,vrval(xr)||; get possible trblk ptr|23378
iofc1:
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||bne|9,(xr)|22,=b_trt|6,iofc4|; fail if end of chain|23379
# getarg (XR)
# getarg W0
# getarg iofc4
        movq l_0154,W0
        cmpq (XR),W0
        jne  iofc4
# ||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|; loop if not file arg trblk|23380
# getarg trtyp(,XR,8)
# getarg W0
# getarg iofc1
        movq l_0333,W0
        cmpq trtyp(,XR,8),W0
        jne  iofc1
# ||mov|8,wa|13,trfpt(xr)||; get fcblk ptr|23381
# getarg trfpt(,XR,8)
# getarg WA
        movq trfpt(,XR,8),WA
# ||mov|7,xr|8,wb||; copy arg|23382
# getarg WB
# getarg XR
        movq WB,XR
# ||exi||||; return|23383
# getarg 
        movq $0,rcode
        mov  prc_+8*7,W0
        jmp  *W0
# |iofc2|exi|1,1|||; fail|23387
iofc2:
# getarg 1
        movq $1,rcode
        mov  prc_+8*7,W0
        jmp  *W0
# |iofc3|exi|1,2|||; null arg return|23391
iofc3:
# getarg 2
        movq $2,rcode
        mov  prc_+8*7,W0
        jmp  *W0
# |iofc4|exi|1,3|||; file not found return|23395
iofc4:
# getarg 3
        movq $3,rcode
        mov  prc_+8*7,W0
        jmp  *W0
# ||enp||||; end procedure iofcb|23396
# ||ejc|||||23397
# |ioppf|prc|25,n|1,0||; entry point|23410
ioppf:
# getarg 0
        pop  prc_+8*8
# ||zer|8,wb|||; to count fields extracted|23411
# getarg WB
        xor  WB,WB
# |iopp1|mov|7,xl|18,=iodel||; get delimiter|23415
iopp1:
# getarg W0
# getarg XL
        .data
l_0845: .long iodel
        .text
        movq l_0845,W0
        movq W0,XL
# ||mov|8,wc|7,xl||; copy it|23416
# getarg XL
# getarg WC
        movq XL,WC
# ||zer|8,wa|||; retain leading blanks in filearg2|23417
# getarg WA
        xor  WA,WA
# ||jsr|6,xscan|||; get next field|23418
# getarg xscan
        call xscan
# ||mov|11,-(xs)|7,xr||; stack it|23419
# getarg XR
        push XR
# ||icv|8,wb|||; increment count|23420
# getarg WB
        incq WB
# ||bnz|8,wa|6,iopp1||; loop|23421
# getarg WA
# getarg WA
# getarg iopp1
        or   WA,WA
        jnz  iopp1
# ||mov|8,wc|8,wb||; count of fields|23422
# getarg WB
# getarg WC
        movq WB,WC
# ||mov|8,wb|3,ioptt||; i/o marker|23423
# getarg ioptt
# getarg WB
        movq ioptt,WB
# ||mov|8,wa|3,r_iof||; fcblk ptr or 0|23424
# getarg r_iof
# getarg WA
        movq r_iof,WA
# ||mov|7,xr|3,r_io2||; file arg2 ptr|23425
# getarg r_io2
# getarg XR
        movq r_io2,XR
# ||mov|7,xl|3,r_io1||; filearg1|23426
# getarg r_io1
# getarg XL
        movq r_io1,XL
# ||exi||||; return|23427
# getarg 
        movq $0,rcode
        mov  prc_+8*8,W0
        jmp  *W0
# ||enp||||; end procedure ioppf|23428
# ||ejc|||||23429
# ||ejc|||||23485
# |ioput|prc|25,n|1,7||; entry point|23509
ioput:
# getarg 7
        pop  prc_+8*9
# ||zer|3,r_iot|||; in case no trtrf block used|23510
# getarg r_iot
        mov  $0,W0
        mov  W0,r_iot
# ||zer|3,r_iof|||; in case no fcblk alocated|23511
# getarg r_iof
        mov  $0,W0
        mov  W0,r_iof
# ||zer|3,r_iop|||; in case sysio fails|23512
# getarg r_iop
        mov  $0,W0
        mov  W0,r_iop
# ||mov|3,ioptt|8,wb||; store i/o trace type|23513
# getarg WB
# getarg ioptt
        movq WB,ioptt
# ||jsr|6,xscni|||; prepare to scan filearg2|23514
# getarg xscni
        call xscni
        decq rcode
        js   call_246
# ||ppm|6,iop13|||; fail|23515
# getarg iop13
# getarg iop13
        decq rcode
        jns  l_0846
        jmp  iop13
l_0846:
# ||ppm|6,iopa0|||; null file arg2|23516
# getarg iopa0
# getarg iopa0
        decq rcode
        jns  l_0847
        jmp  iopa0
l_0847:
call_246:
# |iopa0|mov|3,r_io2|7,xr||; keep file arg2|23518
iopa0:
# getarg XR
# getarg r_io2
        movq XR,r_io2
# ||mov|7,xl|8,wa||; copy length|23519
# getarg WA
# getarg XL
        movq WA,XL
# ||jsr|6,gtstg|||; convert filearg1 to string|23520
# getarg gtstg
        call gtstg
        decq rcode
        js   call_247
# ||ppm|6,iop14|||; fail|23521
# getarg iop14
# getarg iop14
        decq rcode
        jns  l_0848
        jmp  iop14
l_0848:
call_247:
# ||mov|3,r_io1|7,xr||; keep filearg1 ptr|23522
# getarg XR
# getarg r_io1
        movq XR,r_io1
# ||jsr|6,gtnvr|||; convert to natural variable|23523
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_248
# ||ppm|6,iop00|||; jump if null|23524
# getarg iop00
# getarg iop00
        decq rcode
        jns  l_0849
        jmp  iop00
l_0849:
call_248:
# ||brn|6,iop04|||; jump to process non-null args|23525
# getarg iop04
        jmp  iop04
# |iop00|bze|7,xl|6,iop01||; skip if both args null|23529
iop00:
# getarg XL
# getarg iop01
        or   XL,XL
        jz   iop01
# ||jsr|6,ioppf|||; process filearg2|23530
# getarg ioppf
        call ioppf
# ||jsr|6,sysfc|||; call for filearg2 check|23531
# getarg sysfc
        call sysfc
        decq rcode
        js   call_249
# ||ppm|6,iop16|||; fail|23532
# getarg iop16
# getarg iop16
        decq rcode
        jns  l_0850
        jmp  iop16
l_0850:
# ||ppm|6,iop26|||; fail|23533
# getarg iop26
# getarg iop26
        decq rcode
        jns  l_0851
        jmp  iop26
l_0851:
call_249:
# ||brn|6,iop11|||; complete file association|23534
# getarg iop11
        jmp  iop11
# ||ejc|||||23535
# |iop01|mov|8,wb|3,ioptt||; get trace type|23541
iop01:
# getarg ioptt
# getarg WB
        movq ioptt,WB
# ||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23542
# getarg r_iot
# getarg XR
        movq r_iot,XR
# ||jsr|6,trbld|||; build trblk|23543
# getarg trbld
        call trbld
# ||mov|8,wc|7,xr||; copy trblk pointer|23544
# getarg XR
# getarg WC
        movq XR,WC
# ||mov|7,xr|10,(xs)+||; get variable from stack|23545
# getarg XR
        pop  XR
# ||mov|11,-(xs)|8,wc||; make trblk collectable|23546
# getarg WC
        push WC
# ||jsr|6,gtvar|||; point to variable|23547
# getarg gtvar
        call gtvar
        decq rcode
        js   call_250
# ||ppm|6,iop15|||; fail|23548
# getarg iop15
# getarg iop15
        decq rcode
        jns  l_0852
        jmp  iop15
l_0852:
call_250:
# ||mov|8,wc|10,(xs)+||; recover trblk pointer|23549
# getarg WC
        pop  WC
# ||mov|3,r_ion|7,xl||; save name pointer|23550
# getarg XL
# getarg r_ion
        movq XL,r_ion
# ||mov|7,xr|7,xl||; copy name pointer|23551
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xr|8,wa||; point to variable|23552
# getarg WA
# getarg XR
        addq WA,XR
# ||sub|7,xr|19,*vrval||; subtract offset,merge into loop|23553
# getarg W0
# getarg XR
        movq l_0121,W0
        subq W0,XR
# |iop02|mov|7,xl|7,xr||; copy blk ptr|23557
iop02:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|13,vrval(xr)||; load ptr to next trblk|23558
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||bne|9,(xr)|22,=b_trt|6,iop03|; jump if not trapped|23559
# getarg (XR)
# getarg W0
# getarg iop03
        movq l_0154,W0
        cmpq (XR),W0
        jne  iop03
# ||bne|13,trtyp(xr)|3,ioptt|6,iop02|; loop if not same assocn|23560
# getarg ioptt
# getarg trtyp(,XR,8)
# getarg W0
# getarg iop02
        movq ioptt,W0
        cmpq trtyp(,XR,8),W0
        jne  iop02
# ||mov|7,xr|13,trnxt(xr)||; get value and delete old trblk|23561
# getarg trnxt(,XR,8)
# getarg XR
        movq trnxt(,XR,8),XR
# |iop03|mov|13,vrval(xl)|8,wc||; link to this trblk|23567
iop03:
# getarg WC
# getarg vrval(,XL,8)
        movq WC,vrval(,XL,8)
# ||mov|7,xl|8,wc||; copy pointer|23568
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|13,trnxt(xl)|7,xr||; store value in trblk|23569
# getarg XR
# getarg trnxt(,XL,8)
        movq XR,trnxt(,XL,8)
# ||mov|7,xr|3,r_ion||; restore possible vrblk pointer|23570
# getarg r_ion
# getarg XR
        movq r_ion,XR
# ||mov|8,wb|8,wa||; keep offset to name|23571
# getarg WA
# getarg WB
        movq WA,WB
# ||jsr|6,setvr|||; if vrblk, set vrget,vrsto|23572
# getarg setvr
        call setvr
# ||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23573
# getarg r_iot
# getarg XR
        movq r_iot,XR
# ||bnz|7,xr|6,iop19||; jump if trtrf block exists|23574
# getarg XR
# getarg XR
# getarg iop19
        or   XR,XR
        jnz  iop19
# ||exi||||; return to caller|23575
# getarg 
        movq $0,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop04|zer|8,wa|||; in case no fcblk found|23580
iop04:
# getarg WA
        xor  WA,WA
# ||ejc|||||23581
# |iop05|mov|8,wb|7,xr||; remember blk ptr|23587
iop05:
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|13,vrval(xr)||; chain along|23588
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||bne|9,(xr)|22,=b_trt|6,iop06|; jump if end of trblk chain|23589
# getarg (XR)
# getarg W0
# getarg iop06
        movq l_0154,W0
        cmpq (XR),W0
        jne  iop06
# ||bne|13,trtyp(xr)|18,=trtfc|6,iop05|; loop if more to go|23590
# getarg trtyp(,XR,8)
# getarg W0
# getarg iop05
        movq l_0333,W0
        cmpq trtyp(,XR,8),W0
        jne  iop05
# ||mov|3,r_iot|7,xr||; point to file arg1 trblk|23591
# getarg XR
# getarg r_iot
        movq XR,r_iot
# ||mov|8,wa|13,trfpt(xr)||; get fcblk ptr from trblk|23592
# getarg trfpt(,XR,8)
# getarg WA
        movq trfpt(,XR,8),WA
# |iop06|mov|3,r_iof|8,wa||; keep possible fcblk ptr|23598
iop06:
# getarg WA
# getarg r_iof
        movq WA,r_iof
# ||mov|3,r_iop|8,wb||; keep preceding blk ptr|23599
# getarg WB
# getarg r_iop
        movq WB,r_iop
# ||jsr|6,ioppf|||; process filearg2|23600
# getarg ioppf
        call ioppf
# ||jsr|6,sysfc|||; see if fcblk required|23601
# getarg sysfc
        call sysfc
        decq rcode
        js   call_251
# ||ppm|6,iop16|||; fail|23602
# getarg iop16
# getarg iop16
        decq rcode
        jns  l_0853
        jmp  iop16
l_0853:
# ||ppm|6,iop26|||; fail|23603
# getarg iop26
# getarg iop26
        decq rcode
        jns  l_0854
        jmp  iop26
l_0854:
call_251:
# ||bze|8,wa|6,iop12||; skip if no new fcblk wanted|23604
# getarg WA
# getarg iop12
        or   WA,WA
        jz   iop12
# ||blt|8,wc|18,=num02|6,iop6a|; jump if fcblk in dynamic|23605
# getarg WC
# getarg W0
# getarg iop6a
        movq l_0130,W0
        cmpq WC,W0
        jb   iop6a
# ||jsr|6,alost|||; get it in static|23606
# getarg alost
        call alost
# ||brn|6,iop6b|||; skip|23607
# getarg iop6b
        jmp  iop6b
# |iop6a|jsr|6,alloc|||; get space for fcblk|23611
iop6a:
# getarg alloc
        call alloc
# |iop6b|mov|7,xl|7,xr||; point to fcblk|23615
iop6b:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wb|8,wa||; copy its length|23616
# getarg WA
# getarg WB
        movq WA,WB
# ||btw|8,wb|||; get count as words (sgd apr80)|23617
# getarg WB
        shr  WB,3
# ||lct|8,wb|8,wb||; loop counter|23618
# |iop07|zer|10,(xr)+|||; clear a word|23622
iop07:
        mov  $0,W0
        stosq
# ||bct|8,wb|6,iop07||; loop|23623
# getarg WB
# getarg iop07
        decq WB
        jnz  iop07
# ||beq|8,wc|18,=num02|6,iop09|; skip if in static - dont set fields|23624
# getarg WC
# getarg W0
# getarg iop09
        movq l_0130,W0
        cmpq WC,W0
        je   iop09
# ||mov|9,(xl)|22,=b_xnt||; store xnblk code in case|23625
# getarg W0
# getarg (XL)
        .data
l_0855: .long b_xnt
        .text
        movq l_0855,W0
        movq W0,(XL)
# ||mov|13,num01(xl)|8,wa||; store length|23626
# getarg WA
# getarg num01(,XL,8)
        movq WA,num01(,XL,8)
# ||bnz|8,wc|6,iop09||; jump if xnblk wanted|23627
# getarg WC
# getarg WC
# getarg iop09
        or   WC,WC
        jnz  iop09
# ||mov|9,(xl)|22,=b_xrt||; xrblk code requested|23628
# getarg W0
# getarg (XL)
        .data
l_0856: .long b_xrt
        .text
        movq l_0856,W0
        movq W0,(XL)
# ||ejc|||||23630
# |iop09|mov|7,xr|3,r_iot||; get possible trblk ptr|23635
iop09:
# getarg r_iot
# getarg XR
        movq r_iot,XR
# ||mov|3,r_iof|7,xl||; store fcblk ptr|23636
# getarg XL
# getarg r_iof
        movq XL,r_iof
# ||bnz|7,xr|6,iop10||; jump if trblk already found|23637
# getarg XR
# getarg XR
# getarg iop10
        or   XR,XR
        jnz  iop10
# ||mov|8,wb|18,=trtfc||; trtyp for fcblk trap blk|23641
# getarg W0
# getarg WB
        movq l_0333,W0
        movq W0,WB
# ||jsr|6,trbld|||; make the block|23642
# getarg trbld
        call trbld
# ||mov|3,r_iot|7,xr||; copy trtrf ptr|23643
# getarg XR
# getarg r_iot
        movq XR,r_iot
# ||mov|7,xl|3,r_iop||; point to preceding blk|23644
# getarg r_iop
# getarg XL
        movq r_iop,XL
# ||mov|13,vrval(xr)|13,vrval(xl)||; copy value field to trblk|23645
# getarg vrval(,XL,8)
# getarg W0
# getarg vrval(,XR,8)
        movq vrval(,XL,8),W0
        movq W0,vrval(,XR,8)
# ||mov|13,vrval(xl)|7,xr||; link new trblk into chain|23646
# getarg XR
# getarg vrval(,XL,8)
        movq XR,vrval(,XL,8)
# ||mov|7,xr|7,xl||; point to predecessor blk|23647
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,setvr|||; set trace intercepts|23648
# getarg setvr
        call setvr
# ||mov|7,xr|13,vrval(xr)||; recover trblk ptr|23649
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||brn|6,iop1a|||; store fcblk ptr|23650
# getarg iop1a
        jmp  iop1a
# |iop10|zer|3,r_iop|||; do not release if sysio fails|23654
iop10:
# getarg r_iop
        mov  $0,W0
        mov  W0,r_iop
# |iop1a|mov|13,trfpt(xr)|3,r_iof||; store fcblk ptr|23658
iop1a:
# getarg r_iof
# getarg W0
# getarg trfpt(,XR,8)
        movq r_iof,W0
        movq W0,trfpt(,XR,8)
# |iop11|mov|8,wa|3,r_iof||; copy fcblk ptr or 0|23662
iop11:
# getarg r_iof
# getarg WA
        movq r_iof,WA
# ||mov|8,wb|3,ioptt||; get input/output flag|23663
# getarg ioptt
# getarg WB
        movq ioptt,WB
# ||mov|7,xr|3,r_io2||; get file arg2|23664
# getarg r_io2
# getarg XR
        movq r_io2,XR
# ||mov|7,xl|3,r_io1||; get file arg1|23665
# getarg r_io1
# getarg XL
        movq r_io1,XL
# ||jsr|6,sysio|||; associate to the file|23666
# getarg sysio
        call sysio
        decq rcode
        js   call_252
# ||ppm|6,iop17|||; fail|23667
# getarg iop17
# getarg iop17
        decq rcode
        jns  l_0857
        jmp  iop17
l_0857:
# ||ppm|6,iop18|||; fail|23668
# getarg iop18
# getarg iop18
        decq rcode
        jns  l_0858
        jmp  iop18
l_0858:
call_252:
# ||bnz|3,r_iot|6,iop01||; not std input if non-null trtrf blk|23669
# getarg r_iot
# getarg iop01
        xor  W0,W0
        cmpq r_iot,W0
        jnz  iop01
# ||bnz|3,ioptt|6,iop01||; jump if output|23670
# getarg ioptt
# getarg iop01
        xor  W0,W0
        cmpq ioptt,W0
        jnz  iop01
# ||bze|8,wc|6,iop01||; no change to standard read length|23671
# getarg WC
# getarg iop01
        or   WC,WC
        jz   iop01
# ||mov|3,cswin|8,wc||; store new read length for std file|23672
# getarg WC
# getarg cswin
        movq WC,cswin
# ||brn|6,iop01|||; merge to finish the task|23673
# getarg iop01
        jmp  iop01
# |iop12|bnz|7,xl|6,iop09||; jump if private fcblk|23677
iop12:
# getarg XL
# getarg XL
# getarg iop09
        or   XL,XL
        jnz  iop09
# ||brn|6,iop11|||; finish the association|23678
# getarg iop11
        jmp  iop11
# |iop13|exi|1,1|||; 3rd arg not a string|23682
iop13:
# getarg 1
        movq $1,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop14|exi|1,2|||; 2nd arg unsuitable|23683
iop14:
# getarg 2
        movq $2,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop15|ica|7,xs|||; discard trblk pointer|23684
iop15:
# getarg XT
        addq $8,XT
# ||exi|1,3|||; 1st arg unsuitable|23685
# getarg 3
        movq $3,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop16|exi|1,4|||; file spec wrong|23686
iop16:
# getarg 4
        movq $4,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop26|exi|1,7|||; fcblk in use|23687
iop26:
# getarg 7
        movq $7,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop17|mov|7,xr|3,r_iop||; is there a trblk to release|23691
iop17:
# getarg r_iop
# getarg XR
        movq r_iop,XR
# ||bze|7,xr|6,iopa7||; if not|23692
# getarg XR
# getarg iopa7
        or   XR,XR
        jz   iopa7
# ||mov|7,xl|13,vrval(xr)||; point to trblk|23693
# getarg vrval(,XR,8)
# getarg XL
        movq vrval(,XR,8),XL
# ||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23694
# getarg vrval(,XL,8)
# getarg W0
# getarg vrval(,XR,8)
        movq vrval(,XL,8),W0
        movq W0,vrval(,XR,8)
# ||jsr|6,setvr|||; adjust trace intercepts|23695
# getarg setvr
        call setvr
# |iopa7|exi|1,5|||; i/o file does not exist|23696
iopa7:
# getarg 5
        movq $5,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# |iop18|mov|7,xr|3,r_iop||; is there a trblk to release|23700
iop18:
# getarg r_iop
# getarg XR
        movq r_iop,XR
# ||bze|7,xr|6,iopa7||; if not|23701
# getarg XR
# getarg iopa7
        or   XR,XR
        jz   iopa7
# ||mov|7,xl|13,vrval(xr)||; point to trblk|23702
# getarg vrval(,XR,8)
# getarg XL
        movq vrval(,XR,8),XL
# ||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23703
# getarg vrval(,XL,8)
# getarg W0
# getarg vrval(,XR,8)
        movq vrval(,XL,8),W0
        movq W0,vrval(,XR,8)
# ||jsr|6,setvr|||; adjust trace intercepts|23704
# getarg setvr
        call setvr
# |iopa8|exi|1,6|||; i/o file cannot be read/written|23705
iopa8:
# getarg 6
        movq $6,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# ||ejc|||||23706
# |iop19|mov|8,wc|3,r_ion||; wc = name base, wb = name offset|23713
iop19:
# getarg r_ion
# getarg WC
        movq r_ion,WC
# |iop20|mov|7,xr|13,trtrf(xr)||; next link of chain|23717
iop20:
# getarg trtrf(,XR,8)
# getarg XR
        movq trtrf(,XR,8),XR
# ||bze|7,xr|6,iop21||; not found|23718
# getarg XR
# getarg iop21
        or   XR,XR
        jz   iop21
# ||bne|8,wc|13,ionmb(xr)|6,iop20|; no match|23719
# getarg WC
# getarg ionmb(,XR,8)
# getarg iop20
        cmpq WC,ionmb(,XR,8)
        jne  iop20
# ||beq|8,wb|13,ionmo(xr)|6,iop22|; exit if matched|23720
# getarg WB
# getarg ionmo(,XR,8)
# getarg iop22
        cmpq WB,ionmo(,XR,8)
        je   iop22
# ||brn|6,iop20|||; loop|23721
# getarg iop20
        jmp  iop20
# |iop21|mov|8,wa|19,*num05||; space needed|23725
iop21:
# getarg W0
# getarg WA
        movq l_0626,W0
        movq W0,WA
# ||jsr|6,alloc|||; get it|23726
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_xrt||; store xrblk code|23727
# getarg W0
# getarg (XR)
        movq l_0856,W0
        movq W0,(XR)
# ||mov|13,num01(xr)|8,wa||; store length|23728
# getarg WA
# getarg num01(,XR,8)
        movq WA,num01(,XR,8)
# ||mov|13,ionmb(xr)|8,wc||; store name base|23729
# getarg WC
# getarg ionmb(,XR,8)
        movq WC,ionmb(,XR,8)
# ||mov|13,ionmo(xr)|8,wb||; store name offset|23730
# getarg WB
# getarg ionmo(,XR,8)
        movq WB,ionmo(,XR,8)
# ||mov|7,xl|3,r_iot||; point to trtrf blk|23731
# getarg r_iot
# getarg XL
        movq r_iot,XL
# ||mov|8,wa|13,trtrf(xl)||; get ptr field contents|23732
# getarg trtrf(,XL,8)
# getarg WA
        movq trtrf(,XL,8),WA
# ||mov|13,trtrf(xl)|7,xr||; store ptr to new block|23733
# getarg XR
# getarg trtrf(,XL,8)
        movq XR,trtrf(,XL,8)
# ||mov|13,trtrf(xr)|8,wa||; complete the linking|23734
# getarg WA
# getarg trtrf(,XR,8)
        movq WA,trtrf(,XR,8)
# |iop22|bze|3,r_iof|6,iop25||; skip if no fcblk|23738
iop22:
# getarg r_iof
# getarg iop25
        xor  W0,W0
        cmpq r_iof,W0
        jz   iop25
# ||mov|7,xl|3,r_fcb||; ptr to head of existing chain|23739
# getarg r_fcb
# getarg XL
        movq r_fcb,XL
# |iop23|bze|7,xl|6,iop24||; not on if end of chain|23743
iop23:
# getarg XL
# getarg iop24
        or   XL,XL
        jz   iop24
# ||beq|13,num03(xl)|3,r_iof|6,iop25|; dont duplicate if find it|23744
# getarg r_iof
# getarg num03(,XL,8)
# getarg W0
# getarg iop25
        movq r_iof,W0
        cmpq num03(,XL,8),W0
        je   iop25
# ||mov|7,xl|13,num02(xl)||; get next link|23745
# getarg num02(,XL,8)
# getarg XL
        movq num02(,XL,8),XL
# ||brn|6,iop23|||; loop|23746
# getarg iop23
        jmp  iop23
# |iop24|mov|8,wa|19,*num04||; space needed|23750
iop24:
# getarg W0
# getarg WA
        movq l_0167,W0
        movq W0,WA
# ||jsr|6,alloc|||; get it|23751
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_xrt||; store block code|23752
# getarg W0
# getarg (XR)
        movq l_0856,W0
        movq W0,(XR)
# ||mov|13,num01(xr)|8,wa||; store length|23753
# getarg WA
# getarg num01(,XR,8)
        movq WA,num01(,XR,8)
# ||mov|13,num02(xr)|3,r_fcb||; store previous link in this node|23754
# getarg r_fcb
# getarg W0
# getarg num02(,XR,8)
        movq r_fcb,W0
        movq W0,num02(,XR,8)
# ||mov|13,num03(xr)|3,r_iof||; store fcblk ptr|23755
# getarg r_iof
# getarg W0
# getarg num03(,XR,8)
        movq r_iof,W0
        movq W0,num03(,XR,8)
# ||mov|3,r_fcb|7,xr||; insert node into fcblk chain|23756
# getarg XR
# getarg r_fcb
        movq XR,r_fcb
# |iop25|exi||||; return to caller|23760
iop25:
# getarg 
        movq $0,rcode
        mov  prc_+8*9,W0
        jmp  *W0
# ||enp||||; end procedure ioput|23761
# ||ejc|||||23762
# |ktrex|prc|25,r|1,0||; entry point (recursive)|23774
ktrex:
# getarg 0
# ||bze|7,xl|6,ktrx3||; immediate exit if keyword untraced|23775
# getarg XL
# getarg ktrx3
        or   XL,XL
        jz   ktrx3
# ||bze|3,kvtra|6,ktrx3||; immediate exit if trace = 0|23776
# getarg kvtra
# getarg ktrx3
        xor  W0,W0
        cmpq kvtra,W0
        jz   ktrx3
# ||dcv|3,kvtra|||; else decrement trace|23777
# getarg kvtra
        decq kvtra
# ||mov|11,-(xs)|7,xr||; save xr|23778
# getarg XR
        push XR
# ||mov|7,xr|7,xl||; copy trblk pointer|23779
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|13,trkvr(xr)||; load vrblk pointer (nmbas)|23780
# getarg trkvr(,XR,8)
# getarg XL
        movq trkvr(,XR,8),XL
# ||mov|8,wa|19,*vrval||; set name offset|23781
# getarg W0
# getarg WA
        movq l_0121,W0
        movq W0,WA
# ||bze|13,trfnc(xr)|6,ktrx1||; jump if print trace|23782
# getarg trfnc(,XR,8)
# getarg ktrx1
        xor  W0,W0
        cmpq trfnc(,XR,8),W0
        jz   ktrx1
# ||jsr|6,trxeq|||; else execute full trace|23783
# getarg trxeq
        call trxeq
# ||brn|6,ktrx2|||; and jump to exit|23784
# getarg ktrx2
        jmp  ktrx2
# |ktrx1|mov|11,-(xs)|7,xl||; stack vrblk ptr for kwnam|23788
ktrx1:
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wa||; stack offset for kwnam|23789
# getarg WA
        push WA
# ||jsr|6,prtsn|||; print statement number|23790
# getarg prtsn
        call prtsn
# ||mov|8,wa|18,=ch_am||; load ampersand|23791
# getarg W0
# getarg WA
        movq l_0742,W0
        movq W0,WA
# ||jsr|6,prtch|||; print ampersand|23792
# getarg prtch
        call prtch
# ||jsr|6,prtnm|||; print keyword name|23793
# getarg prtnm
        call prtnm
# ||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|23794
# getarg W0
# getarg XR
        movq l_0743,W0
        movq W0,XR
# ||jsr|6,prtst|||; print blank-equal-blank|23795
# getarg prtst
        call prtst
# ||jsr|6,kwnam|||; get keyword pseudo-variable name|23796
# getarg kwnam
        call kwnam
# ||mov|3,dnamp|7,xr||; reset ptr to delete kvblk|23797
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||jsr|6,acess|||; get keyword value|23798
# getarg acess
        call acess
        decq rcode
        js   call_253
# ||ppm||||; failure is impossible|23799
# getarg 
        decq rcode
        jns  l_0859
        movq $299,rcode
        jmp  err_
l_0859:
call_253:
# ||jsr|6,prtvl|||; print keyword value|23800
# getarg prtvl
        call prtvl
# ||jsr|6,prtnl|||; terminate print line|23801
# getarg prtnl
        call prtnl
# |ktrx2|mov|7,xr|10,(xs)+||; restore entry xr|23805
ktrx2:
# getarg XR
        pop  XR
# |ktrx3|exi||||; return to ktrex caller|23809
ktrx3:
# getarg 
        ret
# ||enp||||; end procedure ktrex|23810
# ||ejc|||||23811
# |kwnam|prc|25,n|1,0||; entry point|23822
kwnam:
# getarg 0
        pop  prc_+8*10
# ||ica|7,xs|||; ignore name offset|23823
# getarg XT
        addq $8,XT
# ||mov|7,xr|10,(xs)+||; load name base|23824
# getarg XR
        pop  XR
# ||bge|7,xr|3,state|6,kwnm1|; jump if not natural variable name|23825
# getarg XR
# getarg state
# getarg kwnm1
        cmpq XR,state
        jae  kwnm1
# ||bnz|13,vrlen(xr)|6,kwnm1||; error if not system variable|23826
# getarg vrlen(,XR,8)
# getarg kwnm1
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  kwnm1
# ||mov|7,xr|13,vrsvp(xr)||; else point to svblk|23827
# getarg vrsvp(,XR,8)
# getarg XR
        movq vrsvp(,XR,8),XR
# ||mov|8,wa|13,svbit(xr)||; load bit mask|23828
# getarg svbit(,XR,8)
# getarg WA
        movq svbit(,XR,8),WA
# ||anb|8,wa|4,btknm||; and with keyword bit|23829
# getarg WA
# getarg btknm
        and  WA,btknm
# ||zrb|8,wa|6,kwnm1||; error if no keyword association|23830
# getarg WA
# getarg WA
# getarg kwnm1
        or   WA,WA
        jz   kwnm1
# ||mov|8,wa|13,svlen(xr)||; else load name length in characters|23831
# getarg svlen(,XR,8)
# getarg WA
        movq svlen(,XR,8),WA
# ||ctb|8,wa|2,svchs||; compute offset to field we want|23832
# getarg WA
        add  ($cfp_b-1)+$cfp_b*svchs,WA
        and  WA,-$8
# ||add|7,xr|8,wa||; point to svknm field|23833
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|8,wb|9,(xr)||; load svknm value|23834
# getarg (XR)
# getarg WB
        movq (XR),WB
# ||mov|8,wa|19,*kvsi_||; set size of kvblk|23835
# getarg W0
# getarg WA
        .data
l_0860: .long 8*kvsi_
        .text
        movq l_0860,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate kvblk|23836
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_kvt||; store type word|23837
# getarg W0
# getarg (XR)
        movq l_0745,W0
        movq W0,(XR)
# ||mov|13,kvnum(xr)|8,wb||; store keyword number|23838
# getarg WB
# getarg kvnum(,XR,8)
        movq WB,kvnum(,XR,8)
# ||mov|13,kvvar(xr)|21,=trbkv||; set dummy trblk pointer|23839
# getarg W0
# getarg kvvar(,XR,8)
        movq l_0587,W0
        movq W0,kvvar(,XR,8)
# ||mov|7,xl|7,xr||; copy kvblk pointer|23840
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*kvvar||; set proper offset|23841
# getarg W0
# getarg WA
        movq l_0746,W0
        movq W0,WA
# ||exi||||; return to kvnam caller|23842
# getarg 
        movq $0,rcode
        mov  prc_+8*10,W0
        jmp  *W0
# |kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||23846
kwnm1:
        movq $251,rcode
        jmp  err_
# ||enp||||; end procedure kwnam|23847
# ||ejc|||||23848
# |lcomp|prc|25,n|1,5||; entry point|23865
lcomp:
# getarg 5
        pop  prc_+8*11
# ||jsr|6,gtstg|||; convert second arg to string|23867
# getarg gtstg
        call gtstg
        decq rcode
        js   call_254
# ||ppm|6,lcmp6|||; jump if second arg not string|23871
# getarg lcmp6
# getarg lcmp6
        decq rcode
        jns  l_0861
        jmp  lcmp6
l_0861:
call_254:
# ||mov|7,xl|7,xr||; else save pointer|23872
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wc|8,wa||; and length|23873
# getarg WA
# getarg WC
        movq WA,WC
# ||jsr|6,gtstg|||; convert first argument to string|23875
# getarg gtstg
        call gtstg
        decq rcode
        js   call_255
# ||ppm|6,lcmp5|||; jump if not string|23879
# getarg lcmp5
# getarg lcmp5
        decq rcode
        jns  l_0862
        jmp  lcmp5
l_0862:
call_255:
# ||mov|8,wb|8,wa||; save arg 1 length|23880
# getarg WA
# getarg WB
        movq WA,WB
# ||plc|7,xr|||; point to chars of arg 1|23881
# getarg XR
        add  $cfp_f,XR
# ||plc|7,xl|||; point to chars of arg 2|23882
# getarg XL
        add  $cfp_f,XL
# ||blo|8,wa|8,wc|6,lcmp1|; jump if arg 1 length is smaller|23894
# getarg WA
# getarg WC
# getarg lcmp1
        cmpq WA,WC
        jb   lcmp1
# ||mov|8,wa|8,wc||; else set arg 2 length as smaller|23895
# getarg WC
# getarg WA
        movq WC,WA
# |lcmp1|bze|8,wa|6,lcmp7||; if null string, compare lengths|23899
lcmp1:
# getarg WA
# getarg lcmp7
        or   WA,WA
        jz   lcmp7
# ||cmc|6,lcmp4|6,lcmp3||; compare strings, jump if unequal|23900
# getarg lcmp4
# getarg lcmp3
        repe cmpsb
        xor  W0,W0
        mov  W0,XL
        mov  XL,XR
        ja   lcmp3
        jb   lcmp4
# |lcmp7|bne|8,wb|8,wc|6,lcmp2|; if equal, jump if lengths unequal|23901
lcmp7:
# getarg WB
# getarg WC
# getarg lcmp2
        cmpq WB,WC
        jne  lcmp2
# ||exi|1,4|||; else identical strings, leq exit|23902
# getarg 4
        movq $4,rcode
        mov  prc_+8*11,W0
        jmp  *W0
# ||ejc|||||23903
# |lcmp2|bhi|8,wb|8,wc|6,lcmp4|; jump if arg 1 length gt arg 2 leng|23909
lcmp2:
# getarg WB
# getarg WC
# getarg lcmp4
        cmpq WB,WC
        ja   lcmp4
# |lcmp3|exi|1,3|||; take llt exit|23914
lcmp3:
# getarg 3
        movq $3,rcode
        mov  prc_+8*11,W0
        jmp  *W0
# |lcmp4|exi|1,5|||; take lgt exit|23918
lcmp4:
# getarg 5
        movq $5,rcode
        mov  prc_+8*11,W0
        jmp  *W0
# |lcmp5|exi|1,1|||; take bad first arg exit|23922
lcmp5:
# getarg 1
        movq $1,rcode
        mov  prc_+8*11,W0
        jmp  *W0
# |lcmp6|exi|1,2|||; take bad second arg error exit|23926
lcmp6:
# getarg 2
        movq $2,rcode
        mov  prc_+8*11,W0
        jmp  *W0
# ||enp||||; end procedure lcomp|23927
# ||ejc|||||23928
# |listr|prc|25,e|1,0||; entry point|23967
listr:
# getarg 0
# ||bnz|3,cnttl|6,list5||; jump if -title or -stitl|23968
# getarg cnttl
# getarg list5
        xor  W0,W0
        cmpq cnttl,W0
        jnz  list5
# ||bnz|3,lstpf|6,list4||; immediate exit if already listed|23969
# getarg lstpf
# getarg list4
        xor  W0,W0
        cmpq lstpf,W0
        jnz  list4
# ||bge|3,lstlc|3,lstnp|6,list6|; jump if no room|23970
# getarg lstnp
# getarg lstlc
# getarg W0
# getarg list6
        movq lstnp,W0
        cmpq lstlc,W0
        jae  list6
# |list0|mov|7,xr|3,r_cim||; load pointer to current image|23974
list0:
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||bze|7,xr|6,list4||; jump if no image to print|23975
# getarg XR
# getarg list4
        or   XR,XR
        jz   list4
# ||plc|7,xr|||; point to characters|23976
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wa|9,(xr)||; load first character|23977
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
# ||mov|7,xr|3,lstsn||; load statement number|23978
# getarg lstsn
# getarg XR
        movq lstsn,XR
# ||bze|7,xr|6,list2||; jump if no statement number|23979
# getarg XR
# getarg list2
        or   XR,XR
        jz   list2
# ||mti|7,xr|||; else get stmnt number as integer|23980
# getarg XR
        mov  XR,IA
# ||bne|3,stage|18,=stgic|6,list1|; skip if execute time|23981
# getarg stage
# getarg W0
# getarg list1
        movq l_0053,W0
        cmpq stage,W0
        jne  list1
# ||beq|8,wa|18,=ch_as|6,list2|; no stmnt number list if comment|23982
# getarg WA
# getarg W0
# getarg list2
        movq l_0688,W0
        cmpq WA,W0
        je   list2
# ||beq|8,wa|18,=ch_mn|6,list2|; no stmnt no. if control card|23983
# getarg WA
# getarg W0
# getarg list2
        movq l_0689,W0
        cmpq WA,W0
        je   list2
# |list1|jsr|6,prtin|||; else print statement number|23987
list1:
# getarg prtin
        call prtin
# ||zer|3,lstsn|||; and clear for next time in|23988
# getarg lstsn
        mov  $0,W0
        mov  W0,lstsn
# |list2|mov|7,xr|3,lstid||; include depth of image|23993
list2:
# getarg lstid
# getarg XR
        movq lstid,XR
# ||bze|7,xr|6,list8||; if not from an include file|23994
# getarg XR
# getarg list8
        or   XR,XR
        jz   list8
# ||mov|8,wa|18,=stnpd||; position for start of statement|23995
# getarg W0
# getarg WA
        .data
l_0863: .long stnpd
        .text
        movq l_0863,W0
        movq W0,WA
# ||sub|8,wa|18,=num03||; position to place include depth|23996
# getarg W0
# getarg WA
        movq l_0350,W0
        subq W0,WA
# ||mov|3,profs|8,wa||; set as starting position|23997
# getarg WA
# getarg profs
        movq WA,profs
# ||mti|7,xr|||; include depth as integer|23998
# getarg XR
        mov  XR,IA
# ||jsr|6,prtin|||; print include depth|23999
# getarg prtin
        call prtin
# ||ejc|||||24000
# |list8|mov|3,profs|18,=stnpd||; point past statement number|24006
list8:
# getarg W0
# getarg profs
        movq l_0863,W0
        movq W0,profs
# ||mov|7,xr|3,r_cim||; load pointer to current image|24016
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||jsr|6,prtst|||; print it|24017
# getarg prtst
        call prtst
# ||icv|3,lstlc|||; bump line counter|24018
# getarg lstlc
        incq lstlc
# ||bnz|3,erlst|6,list3||; jump if error copy to int.ch.|24019
# getarg erlst
# getarg list3
        xor  W0,W0
        cmpq erlst,W0
        jnz  list3
# ||jsr|6,prtnl|||; terminate line|24020
# getarg prtnl
        call prtnl
# ||bze|3,cswdb|6,list3||; jump if -single mode|24021
# getarg cswdb
# getarg list3
        xor  W0,W0
        cmpq cswdb,W0
        jz   list3
# ||jsr|6,prtnl|||; else add a blank line|24022
# getarg prtnl
        call prtnl
# ||icv|3,lstlc|||; and bump line counter|24023
# getarg lstlc
        incq lstlc
# |list3|mnz|3,lstpf|||; set flag for line printed|24027
list3:
# getarg lstpf
        mov  XS,lstpf
# |list4|exi||||; return to listr caller|24031
list4:
# getarg 
        ret
# |list5|zer|3,cnttl|||; clear flag|24035
list5:
# getarg cnttl
        mov  $0,W0
        mov  W0,cnttl
# |list6|jsr|6,prtps|||; eject|24039
list6:
# getarg prtps
        call prtps
# ||bze|3,prich|6,list7||; skip if listing to regular printer|24040
# getarg prich
# getarg list7
        xor  W0,W0
        cmpq prich,W0
        jz   list7
# ||beq|3,r_ttl|21,=nulls|6,list0|; terminal listing omits null title|24041
# getarg r_ttl
# getarg W0
# getarg list0
        movq l_0054,W0
        cmpq r_ttl,W0
        je   list0
# |list7|jsr|6,listt|||; list title|24045
list7:
# getarg listt
        call listt
# ||brn|6,list0|||; merge|24046
# getarg list0
        jmp  list0
# ||enp||||; end procedure listr|24047
# ||ejc|||||24048
# |listt|prc|25,e|1,0||; entry point|24057
listt:
# getarg 0
# ||mov|7,xr|3,r_ttl||; point to source listing title|24058
# getarg r_ttl
# getarg XR
        movq r_ttl,XR
# ||jsr|6,prtst|||; print title|24059
# getarg prtst
        call prtst
# ||mov|3,profs|3,lstpo||; set offset|24060
# getarg lstpo
# getarg W0
# getarg profs
        movq lstpo,W0
        movq W0,profs
# ||mov|7,xr|21,=lstms||; set page message|24061
# getarg W0
# getarg XR
        .data
l_0864: .long lstms
        .text
        movq l_0864,W0
        movq W0,XR
# ||jsr|6,prtst|||; print page message|24062
# getarg prtst
        call prtst
# ||icv|3,lstpg|||; bump page number|24063
# getarg lstpg
        incq lstpg
# ||mti|3,lstpg|||; load page number as integer|24064
# getarg lstpg
        mov  lstpg,IA
# ||jsr|6,prtin|||; print page number|24065
# getarg prtin
        call prtin
# ||jsr|6,prtnl|||; terminate title line|24066
# getarg prtnl
        call prtnl
# ||add|3,lstlc|18,=num02||; count title line and blank line|24067
# getarg W0
# getarg lstlc
        movq l_0130,W0
        addq W0,lstlc
# ||mov|7,xr|3,r_stl||; load pointer to sub-title|24071
# getarg r_stl
# getarg XR
        movq r_stl,XR
# ||bze|7,xr|6,lstt1||; jump if no sub-title|24072
# getarg XR
# getarg lstt1
        or   XR,XR
        jz   lstt1
# ||jsr|6,prtst|||; else print sub-title|24073
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; terminate line|24074
# getarg prtnl
        call prtnl
# ||icv|3,lstlc|||; bump line count|24075
# getarg lstlc
        incq lstlc
# |lstt1|jsr|6,prtnl|||; print a blank line|24079
lstt1:
# getarg prtnl
        call prtnl
# ||exi||||; return to caller|24080
# getarg 
        ret
# ||enp||||; end procedure listt|24081
# ||ejc|||||24082
# |newfn|prc|25,e|1,0||; entry point|24099
newfn:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save new name|24100
# getarg XR
        push XR
# ||mov|7,xl|3,r_sfc||; load previous name|24101
# getarg r_sfc
# getarg XL
        movq r_sfc,XL
# ||jsr|6,ident|||; check for equality|24102
# getarg ident
        call ident
        decq rcode
        js   call_256
# ||ppm|6,nwfn1|||; jump if identical|24103
# getarg nwfn1
# getarg nwfn1
        decq rcode
        jns  l_0865
        jmp  nwfn1
l_0865:
call_256:
# ||mov|7,xr|10,(xs)+||; different, restore name|24104
# getarg XR
        pop  XR
# ||mov|3,r_sfc|7,xr||; record current file name|24105
# getarg XR
# getarg r_sfc
        movq XR,r_sfc
# ||mov|8,wb|3,cmpsn||; get current statement|24106
# getarg cmpsn
# getarg WB
        movq cmpsn,WB
# ||mti|8,wb|||; convert to integer|24107
# getarg WB
        mov  WB,IA
# ||jsr|6,icbld|||; build icblk for stmt number|24108
# getarg icbld
        call icbld
# ||mov|7,xl|3,r_sfn||; file name table|24109
# getarg r_sfn
# getarg XL
        movq r_sfn,XL
# ||mnz|8,wb|||; lookup statement number by name|24110
# getarg WB
        mov  XS,WB
# ||jsr|6,tfind|||; allocate new teblk|24111
# getarg tfind
        call tfind
        decq rcode
        js   call_257
# ||ppm||||; always possible to allocate block|24112
# getarg 
        decq rcode
        jns  l_0866
        movq $299,rcode
        jmp  err_
l_0866:
call_257:
# ||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|24113
# getarg r_sfc
# getarg W0
# getarg teval(,XL,8)
        movq r_sfc,W0
        movq W0,teval(,XL,8)
# ||exi|||||24114
# getarg 
        ret
# |nwfn1|ica|7,xs|||; pop stack|24118
nwfn1:
# getarg XT
        addq $8,XT
# ||exi|||||24119
# getarg 
        ret
# ||ejc|||||24120
# |nexts|prc|25,e|1,0||; entry point|24152
nexts:
# getarg 0
# ||bze|3,cswls|6,nxts2||; jump if -nolist|24153
# getarg cswls
# getarg nxts2
        xor  W0,W0
        cmpq cswls,W0
        jz   nxts2
# ||mov|7,xr|3,r_cim||; point to image|24154
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||bze|7,xr|6,nxts2||; jump if no image|24155
# getarg XR
# getarg nxts2
        or   XR,XR
        jz   nxts2
# ||plc|7,xr|||; get char ptr|24156
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wa|9,(xr)||; get first char|24157
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
# ||bne|8,wa|18,=ch_mn|6,nxts1|; jump if not ctrl card|24158
# getarg WA
# getarg W0
# getarg nxts1
        movq l_0689,W0
        cmpq WA,W0
        jne  nxts1
# ||bze|3,cswpr|6,nxts2||; jump if -noprint|24159
# getarg cswpr
# getarg nxts2
        xor  W0,W0
        cmpq cswpr,W0
        jz   nxts2
# |nxts1|jsr|6,listr|||; list line|24163
nxts1:
# getarg listr
        call listr
# |nxts2|mov|7,xr|3,r_cni||; point to next image|24167
nxts2:
# getarg r_cni
# getarg XR
        movq r_cni,XR
# ||mov|3,r_cim|7,xr||; set as next image|24168
# getarg XR
# getarg r_cim
        movq XR,r_cim
# ||mov|3,rdcln|3,rdnln||; set as current line number|24169
# getarg rdnln
# getarg W0
# getarg rdcln
        movq rdnln,W0
        movq W0,rdcln
# ||mov|3,lstid|3,cnind||; set as current include depth|24171
# getarg cnind
# getarg W0
# getarg lstid
        movq cnind,W0
        movq W0,lstid
# ||zer|3,r_cni|||; clear next image pointer|24173
# getarg r_cni
        mov  $0,W0
        mov  W0,r_cni
# ||mov|8,wa|13,sclen(xr)||; get input image length|24174
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||mov|8,wb|3,cswin||; get max allowable length|24175
# getarg cswin
# getarg WB
        movq cswin,WB
# ||blo|8,wa|8,wb|6,nxts3|; skip if not too long|24176
# getarg WA
# getarg WB
# getarg nxts3
        cmpq WA,WB
        jb   nxts3
# ||mov|8,wa|8,wb||; else truncate|24177
# getarg WB
# getarg WA
        movq WB,WA
# |nxts3|mov|3,scnil|8,wa||; use as record length|24181
nxts3:
# getarg WA
# getarg scnil
        movq WA,scnil
# ||zer|3,scnse|||; reset scnse|24182
# getarg scnse
        mov  $0,W0
        mov  W0,scnse
# ||zer|3,lstpf|||; set line not listed yet|24183
# getarg lstpf
        mov  $0,W0
        mov  W0,lstpf
# ||exi||||; return to nexts caller|24184
# getarg 
        ret
# ||enp||||; end procedure nexts|24185
# ||ejc|||||24186
# |patin|prc|25,n|1,2||; entry point|24202
patin:
# getarg 2
        pop  prc_+8*12
# ||mov|7,xl|8,wa||; preserve expression arg pcode|24203
# getarg WA
# getarg XL
        movq WA,XL
# ||jsr|6,gtsmi|||; try to convert arg as small integer|24204
# getarg gtsmi
        call gtsmi
        decq rcode
        js   call_258
# ||ppm|6,ptin2|||; jump if not integer|24205
# getarg ptin2
# getarg ptin2
        decq rcode
        jns  l_0867
        jmp  ptin2
l_0867:
# ||ppm|6,ptin3|||; jump if out of range|24206
# getarg ptin3
# getarg ptin3
        decq rcode
        jns  l_0868
        jmp  ptin3
l_0868:
call_258:
# |ptin1|jsr|6,pbild|||; build pattern node|24210
ptin1:
# getarg pbild
        call pbild
# ||exi||||; return to caller|24211
# getarg 
        movq $0,rcode
        mov  prc_+8*12,W0
        jmp  *W0
# |ptin2|mov|8,wb|7,xl||; copy expr arg case pcode|24215
ptin2:
# getarg XL
# getarg WB
        movq XL,WB
# ||blo|9,(xr)|22,=b_e__|6,ptin1|; all ok if expression arg|24216
# getarg (XR)
# getarg W0
# getarg ptin1
        movq l_0760,W0
        cmpq (XR),W0
        jb   ptin1
# ||exi|1,1|||; else take error exit for wrong type|24217
# getarg 1
        movq $1,rcode
        mov  prc_+8*12,W0
        jmp  *W0
# |ptin3|exi|1,2|||; take out-of-range error exit|24221
ptin3:
# getarg 2
        movq $2,rcode
        mov  prc_+8*12,W0
        jmp  *W0
# ||enp||||; end procedure patin|24222
# ||ejc|||||24223
# |patst|prc|25,n|1,1||; entry point|24247
patst:
# getarg 1
        pop  prc_+8*13
# ||jsr|6,gtstg|||; convert argument as string|24248
# getarg gtstg
        call gtstg
        decq rcode
        js   call_259
# ||ppm|6,pats7|||; jump if not string|24249
# getarg pats7
# getarg pats7
        decq rcode
        jns  l_0869
        jmp  pats7
l_0869:
call_259:
# ||bze|8,wa|6,pats7||; jump if null string (catspaw)|24250
# getarg WA
# getarg pats7
        or   WA,WA
        jz   pats7
# ||bne|8,wa|18,=num01|6,pats2|; jump if not one char string|24251
# getarg WA
# getarg W0
# getarg pats2
        movq l_0060,W0
        cmpq WA,W0
        jne  pats2
# ||bze|8,wb|6,pats2||; treat as multi-char if evals call|24255
# getarg WB
# getarg pats2
        or   WB,WB
        jz   pats2
# ||plc|7,xr|||; point to character|24256
# getarg XR
        add  $cfp_f,XR
# ||lch|7,xr|9,(xr)||; load character|24257
# getarg XR
        xor  W0,W0
        movb (XR),%al
        mov  W0,XR
# |pats1|jsr|6,pbild|||; call routine to build node|24261
pats1:
# getarg pbild
        call pbild
# ||exi||||; return to patst caller|24262
# getarg 
        movq $0,rcode
        mov  prc_+8*13,W0
        jmp  *W0
# ||ejc|||||24263
# |pats2|mov|11,-(xs)|7,xl||; save multi-char pcode|24269
pats2:
# getarg XL
        push XL
# ||mov|8,wc|3,ctmsk||; load current mask bit|24270
# getarg ctmsk
# getarg WC
        movq ctmsk,WC
# ||beq|7,xr|3,r_cts|6,pats6|; jump if same as last string c3.738|24271
# getarg XR
# getarg r_cts
# getarg pats6
        cmpq XR,r_cts
        je   pats6
# ||mov|11,-(xs)|7,xr||; save string pointer|24272
# getarg XR
        push XR
# ||lsh|8,wc|1,1||; shift to next position|24273
# getarg 1
# getarg WC
        shl  1,WC
# ||nzb|8,wc|6,pats4||; skip if position left in this tbl|24274
# getarg WC
# getarg WC
# getarg pats4
        or   WC,WC
        jnz  pats4
# ||mov|8,wa|19,*ctsi_||; set size of ctblk|24278
# getarg W0
# getarg WA
        movq l_0627,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate ctblk|24279
# getarg alloc
        call alloc
# ||mov|3,r_ctp|7,xr||; store ptr to new ctblk|24280
# getarg XR
# getarg r_ctp
        movq XR,r_ctp
# ||mov|10,(xr)+|22,=b_ctt||; store type code, bump ptr|24281
# getarg W0
        .data
l_0870: .long b_ctt
        .text
        movq l_0870,W0
        movq W0,W0
        stosq
# ||lct|8,wb|18,=cfp_a||; set number of words to clear|24282
# getarg WB
# getarg W0
        movq l_0048,W0
        mov  WB,W0
# ||mov|8,wc|4,bits0||; load all zero bits|24283
# getarg bits0
# getarg WC
        movq bits0,WC
# |pats3|mov|10,(xr)+|8,wc||; move word of zero bits|24287
pats3:
# getarg WC
        movq WC,W0
        stosq
# ||bct|8,wb|6,pats3||; loop till all cleared|24288
# getarg WB
# getarg pats3
        decq WB
        jnz  pats3
# ||mov|8,wc|4,bits1||; set initial bit position|24289
# getarg bits1
# getarg WC
        movq bits1,WC
# |pats4|mov|3,ctmsk|8,wc||; save parm2 (new bit position)|24293
pats4:
# getarg WC
# getarg ctmsk
        movq WC,ctmsk
# ||mov|7,xl|10,(xs)+||; restore pointer to argument string|24294
# getarg XL
        pop  XL
# ||mov|3,r_cts|7,xl||; save for next time   c3.738|24295
# getarg XL
# getarg r_cts
        movq XL,r_cts
# ||mov|8,wb|13,sclen(xl)||; load string length|24296
# getarg sclen(,XL,8)
# getarg WB
        movq sclen(,XL,8),WB
# ||bze|8,wb|6,pats6||; jump if null string case|24297
# getarg WB
# getarg pats6
        or   WB,WB
        jz   pats6
# ||lct|8,wb|8,wb||; else set loop counter|24298
# ||plc|7,xl|||; point to characters in argument|24299
# getarg XL
        add  $cfp_f,XL
# ||ejc|||||24300
# |pats5|lch|8,wa|10,(xl)+||; load next character|24306
pats5:
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||wtb|8,wa|||; convert to byte offset|24307
# getarg WA
        sal  WA,3
# ||mov|7,xr|3,r_ctp||; point to ctblk|24308
# getarg r_ctp
# getarg XR
        movq r_ctp,XR
# ||add|7,xr|8,wa||; point to ctblk entry|24309
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|8,wa|8,wc||; copy bit mask|24310
# getarg WC
# getarg WA
        movq WC,WA
# ||orb|8,wa|13,ctchs(xr)||; or in bits already set|24311
# getarg WA
# getarg ctchs(,XR,8)
        or   WA,ctchs(,XR,8)
# ||mov|13,ctchs(xr)|8,wa||; store resulting bit string|24312
# getarg WA
# getarg ctchs(,XR,8)
        movq WA,ctchs(,XR,8)
# ||bct|8,wb|6,pats5||; loop till all bits set|24313
# getarg WB
# getarg pats5
        decq WB
        jnz  pats5
# |pats6|mov|7,xr|3,r_ctp||; load ctblk ptr as parm1 for pbild|24317
pats6:
# getarg r_ctp
# getarg XR
        movq r_ctp,XR
# ||zer|7,xl|||; clear garbage ptr in xl|24318
# getarg XL
        xor  XL,XL
# ||mov|8,wb|10,(xs)+||; load pcode for multi-char str case|24319
# getarg WB
        pop  WB
# ||brn|6,pats1|||; back to exit (wc=bitstring=parm2)|24320
# getarg pats1
        jmp  pats1
# |pats7|mov|8,wb|8,wc||; set pcode for expression argument|24327
pats7:
# getarg WC
# getarg WB
        movq WC,WB
# ||blo|9,(xr)|22,=b_e__|6,pats1|; jump to exit if expression arg|24328
# getarg (XR)
# getarg W0
# getarg pats1
        movq l_0760,W0
        cmpq (XR),W0
        jb   pats1
# ||exi|1,1|||; else take wrong type error exit|24329
# getarg 1
        movq $1,rcode
        mov  prc_+8*13,W0
        jmp  *W0
# ||enp||||; end procedure patst|24330
# ||ejc|||||24331
# |pbild|prc|25,e|1,0||; entry point|24342
pbild:
# getarg 0
# ||mov|11,-(xs)|7,xr||; stack possible parm1|24343
# getarg XR
        push XR
# ||mov|7,xr|8,wb||; copy pcode|24344
# getarg WB
# getarg XR
        movq WB,XR
# ||lei|7,xr|||; load entry point id (bl_px)|24345
        dec  XR
        mov  (XR),%al
        movzbq %al,XR
# ||beq|7,xr|18,=bl_p1|6,pbld1|; jump if one parameter|24346
# getarg XR
# getarg W0
# getarg pbld1
        .data
l_0871: .long bl_p1
        .text
        movq l_0871,W0
        cmpq XR,W0
        je   pbld1
# ||beq|7,xr|18,=bl_p0|6,pbld3|; jump if no parameters|24347
# getarg XR
# getarg W0
# getarg pbld3
        .data
l_0872: .long bl_p0
        .text
        movq l_0872,W0
        cmpq XR,W0
        je   pbld3
# ||mov|8,wa|19,*pcsi_||; set size of p2blk|24351
# getarg W0
# getarg WA
        .data
l_0873: .long 8*pcsi_
        .text
        movq l_0873,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate block|24352
# getarg alloc
        call alloc
# ||mov|13,parm2(xr)|8,wc||; store second parameter|24353
# getarg WC
# getarg parm2(,XR,8)
        movq WC,parm2(,XR,8)
# ||brn|6,pbld2|||; merge with one parm case|24354
# getarg pbld2
        jmp  pbld2
# |pbld1|mov|8,wa|19,*pbsi_||; set size of p1blk|24358
pbld1:
# getarg W0
# getarg WA
        .data
l_0874: .long 8*pbsi_
        .text
        movq l_0874,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate node|24359
# getarg alloc
        call alloc
# |pbld2|mov|13,parm1(xr)|9,(xs)||; store first parameter|24363
pbld2:
# getarg (XT)
# getarg W0
# getarg parm1(,XR,8)
        movq (XT),W0
        movq W0,parm1(,XR,8)
# ||brn|6,pbld4|||; merge with no parameter case|24364
# getarg pbld4
        jmp  pbld4
# |pbld3|mov|8,wa|19,*pasi_||; set size of p0blk|24368
pbld3:
# getarg W0
# getarg WA
        .data
l_0875: .long 8*pasi_
        .text
        movq l_0875,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate node|24369
# getarg alloc
        call alloc
# |pbld4|mov|9,(xr)|8,wb||; store pcode|24373
pbld4:
# getarg WB
# getarg (XR)
        movq WB,(XR)
# ||ica|7,xs|||; pop first parameter|24374
# getarg XT
        addq $8,XT
# ||mov|13,pthen(xr)|21,=ndnth||; set nothen successor pointer|24375
# getarg W0
# getarg pthen(,XR,8)
        movq l_0320,W0
        movq W0,pthen(,XR,8)
# ||exi||||; return to pbild caller|24376
# getarg 
        ret
# ||enp||||; end procedure pbild|24377
# ||ejc|||||24378
# |pconc|prc|25,e|1,0||; entry point|24413
pconc:
# getarg 0
# ||zer|11,-(xs)|||; make room for one entry at bottom|24414
        push $0
# ||mov|8,wc|7,xs||; store pointer to start of list|24415
# getarg XT
# getarg WC
        movq XT,WC
# ||mov|11,-(xs)|21,=ndnth||; stack nothen node as old node|24416
# getarg W0
        movq l_0320,W0
        push W0
# ||mov|11,-(xs)|7,xl||; store right arg as copy of nothen|24417
# getarg XL
        push XL
# ||mov|7,xt|7,xs||; initialize pointer to stack entries|24418
# getarg XT
# getarg XT
        movq XT,XT
# ||jsr|6,pcopy|||; copy first node of left arg|24419
# getarg pcopy
        call pcopy
# ||mov|13,num02(xt)|8,wa||; store as result under list|24420
# getarg WA
# getarg num02(,XT,8)
        movq WA,num02(,XT,8)
# ||ejc|||||24421
# |pcnc1|beq|7,xt|7,xs|6,pcnc2|; jump if all entries processed|24428
pcnc1:
# getarg XT
# getarg XT
# getarg pcnc2
        cmpq XT,XT
        je   pcnc2
# ||mov|7,xr|11,-(xt)||; else load next old address|24429
# getarg (XT)
# getarg XR
        sub  $8,XT
        movq (XT),XR
# ||mov|7,xr|13,pthen(xr)||; load pointer to successor|24430
# getarg pthen(,XR,8)
# getarg XR
        movq pthen(,XR,8),XR
# ||jsr|6,pcopy|||; copy successor node|24431
# getarg pcopy
        call pcopy
# ||mov|7,xr|11,-(xt)||; load pointer to new node (copy)|24432
# getarg (XT)
# getarg XR
        sub  $8,XT
        movq (XT),XR
# ||mov|13,pthen(xr)|8,wa||; store ptr to new successor|24433
# getarg WA
# getarg pthen(,XR,8)
        movq WA,pthen(,XR,8)
# ||bne|9,(xr)|22,=p_alt|6,pcnc1|; loop back if not|24438
# getarg (XR)
# getarg W0
# getarg pcnc1
        movq l_0083,W0
        cmpq (XR),W0
        jne  pcnc1
# ||mov|7,xr|13,parm1(xr)||; else load pointer to alternative|24439
# getarg parm1(,XR,8)
# getarg XR
        movq parm1(,XR,8),XR
# ||jsr|6,pcopy|||; copy it|24440
# getarg pcopy
        call pcopy
# ||mov|7,xr|9,(xt)||; restore ptr to new node|24441
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|13,parm1(xr)|8,wa||; store ptr to copied alternative|24442
# getarg WA
# getarg parm1(,XR,8)
        movq WA,parm1(,XR,8)
# ||brn|6,pcnc1|||; loop back for next entry|24443
# getarg pcnc1
        jmp  pcnc1
# |pcnc2|mov|7,xs|8,wc||; restore stack pointer|24447
pcnc2:
# getarg WC
# getarg XT
        movq WC,XT
# ||mov|7,xr|10,(xs)+||; load pointer to copy|24448
# getarg XR
        pop  XR
# ||exi||||; return to pconc caller|24449
# getarg 
        ret
# ||enp||||; end procedure pconc|24450
# ||ejc|||||24451
# |pcopy|prc|25,n|1,0||; entry point|24466
pcopy:
# getarg 0
        pop  prc_+8*14
# ||mov|8,wb|7,xt||; save xt|24467
# getarg XT
# getarg WB
        movq XT,WB
# ||mov|7,xt|8,wc||; point to start of list|24468
# getarg WC
# getarg XT
        movq WC,XT
# |pcop1|dca|7,xt|||; point to next entry on list|24472
pcop1:
# getarg XT
        subq $8,XT
# ||beq|7,xr|9,(xt)|6,pcop2|; jump if match|24473
# getarg XR
# getarg (XT)
# getarg pcop2
        cmpq XR,(XT)
        je   pcop2
# ||dca|7,xt|||; else skip over copied address|24474
# getarg XT
        subq $8,XT
# ||bne|7,xt|7,xs|6,pcop1|; loop back if more to test|24475
# getarg XT
# getarg XT
# getarg pcop1
        cmpq XT,XT
        jne  pcop1
# ||mov|8,wa|9,(xr)||; load first word of block|24479
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||jsr|6,blkln|||; get length of block|24480
# getarg blkln
        call blkln
# ||mov|7,xl|7,xr||; save pointer to old node|24481
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,alloc|||; allocate space for copy|24482
# getarg alloc
        call alloc
# ||mov|11,-(xs)|7,xl||; store old address on list|24483
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; store new address on list|24484
# getarg XR
        push XR
# ||chk||||; check for stack overflow|24485
        chk_
        or   W0,W0
        jne  sec06
# ||mvw||||; move words from old block to copy|24486
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0876:
        or   WA,WA
        jz   l_0877
        movsq
        decq WA
        jmp  l_0876
l_0877:
        cld
# ||mov|8,wa|9,(xs)||; load pointer to copy|24487
# getarg (XT)
# getarg WA
        movq (XT),WA
# ||brn|6,pcop3|||; jump to exit|24488
# getarg pcop3
        jmp  pcop3
# |pcop2|mov|8,wa|11,-(xt)||; load address of copy from list|24492
pcop2:
# getarg (XT)
# getarg WA
        sub  $8,XT
        movq (XT),WA
# |pcop3|mov|7,xt|8,wb||; restore xt|24496
pcop3:
# getarg WB
# getarg XT
        movq WB,XT
# ||exi||||; return to pcopy caller|24497
# getarg 
        movq $0,rcode
        mov  prc_+8*14,W0
        jmp  *W0
# ||enp||||; end procedure pcopy|24498
# ||ejc|||||24499
# |prflr|prc|25,e|1,0||;|24510
prflr:
# getarg 0
# ||bze|3,pfdmp|6,prfl4||; no printing if no profiling done|24511
# getarg pfdmp
# getarg prfl4
        xor  W0,W0
        cmpq pfdmp,W0
        jz   prfl4
# ||mov|11,-(xs)|7,xr||; preserve entry xr|24512
# getarg XR
        push XR
# ||mov|3,pfsvw|8,wb||; and also wb|24513
# getarg WB
# getarg pfsvw
        movq WB,pfsvw
# ||jsr|6,prtpg|||; eject|24514
# getarg prtpg
        call prtpg
# ||mov|7,xr|21,=pfms1||; load msg /program profile/|24515
# getarg W0
# getarg XR
        .data
l_0878: .long pfms1
        .text
        movq l_0878,W0
        movq W0,XR
# ||jsr|6,prtst|||; and print it|24516
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; followed by newline|24517
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; and another|24518
# getarg prtnl
        call prtnl
# ||mov|7,xr|21,=pfms2||; point to first hdr|24519
# getarg W0
# getarg XR
        .data
l_0879: .long pfms2
        .text
        movq l_0879,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|24520
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; new line|24521
# getarg prtnl
        call prtnl
# ||mov|7,xr|21,=pfms3||; second hdr|24522
# getarg W0
# getarg XR
        .data
l_0880: .long pfms3
        .text
        movq l_0880,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|24523
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; new line|24524
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; and another blank line|24525
# getarg prtnl
        call prtnl
# ||zer|8,wb|||; initial stmt count|24526
# getarg WB
        xor  WB,WB
# ||mov|7,xr|3,pftbl||; point to table origin|24527
# getarg pftbl
# getarg XR
        movq pftbl,XR
# ||add|7,xr|19,*xndta||; bias past xnblk header (sgd07)|24528
# getarg W0
# getarg XR
        .data
l_0881: .long 8*xndta
        .text
        movq l_0881,W0
        addq W0,XR
# |prfl1|icv|8,wb|||; bump stmt nr|24532
prfl1:
# getarg WB
        incq WB
# ||ldi|9,(xr)|||; load nr of executions|24533
# getarg (XR)
        mov  (XR),IA
# ||ieq|6,prfl3|||; no printing if zero|24534
# getarg prfl3
        mov  IA,W0
        or   W0,W0
        je   prfl3
# ||mov|3,profs|18,=pfpd1||; point where to print|24535
# getarg W0
# getarg profs
        .data
l_0882: .long pfpd1
        .text
        movq l_0882,W0
        movq W0,profs
# ||jsr|6,prtin|||; and print it|24536
# getarg prtin
        call prtin
# ||zer|3,profs|||; back to start of line|24537
# getarg profs
        mov  $0,W0
        mov  W0,profs
# ||mti|8,wb|||; load stmt nr|24538
# getarg WB
        mov  WB,IA
# ||jsr|6,prtin|||; print it there|24539
# getarg prtin
        call prtin
# ||mov|3,profs|18,=pfpd2||; and pad past count|24540
# getarg W0
# getarg profs
        .data
l_0883: .long pfpd2
        .text
        movq l_0883,W0
        movq W0,profs
# ||ldi|13,cfp_i(xr)|||; load total exec time|24541
# getarg cfp_i(,XR,8)
        mov  cfp_i(,XR,8),IA
# ||jsr|6,prtin|||; print that too|24542
# getarg prtin
        call prtin
# ||ldi|13,cfp_i(xr)|||; reload time|24543
# getarg cfp_i(,XR,8)
        mov  cfp_i(,XR,8),IA
# ||mli|4,intth|||; convert to microsec|24544
# getarg intth
        imul intth,IA
        seto reg_fl
# ||iov|6,prfl2|||; omit next bit if overflow|24545
# getarg prfl2
        iov_ prfl2
# ||dvi|9,(xr)|||; divide by executions|24546
# getarg (XR)
        mov  (XR),W0
        call dvi__
# ||mov|3,profs|18,=pfpd3||; pad last print|24547
# getarg W0
# getarg profs
        .data
l_0884: .long pfpd3
        .text
        movq l_0884,W0
        movq W0,profs
# ||jsr|6,prtin|||; and print mcsec/execn|24548
# getarg prtin
        call prtin
# |prfl2|jsr|6,prtnl|||; thats another line|24552
prfl2:
# getarg prtnl
        call prtnl
# |prfl3|add|7,xr|19,*pf_i2||; bump index ptr (sgd07)|24556
prfl3:
# getarg W0
# getarg XR
        .data
l_0885: .long 8*pf_i2
        .text
        movq l_0885,W0
        addq W0,XR
# ||blt|8,wb|3,pfnte|6,prfl1|; loop if more stmts|24557
# getarg WB
# getarg pfnte
# getarg prfl1
        cmpq WB,pfnte
        jb   prfl1
# ||mov|7,xr|10,(xs)+||; restore callers xr|24558
# getarg XR
        pop  XR
# ||mov|8,wb|3,pfsvw||; and wb too|24559
# getarg pfsvw
# getarg WB
        movq pfsvw,WB
# |prfl4|exi||||; return|24563
prfl4:
# getarg 
        ret
# ||enp||||; end of prflr|24564
# ||ejc|||||24565
# |prflu|prc|25,e|1,0||;|24574
prflu:
# getarg 0
# ||bnz|3,pffnc|6,pflu4||; skip if just entered function|24575
# getarg pffnc
# getarg pflu4
        xor  W0,W0
        cmpq pffnc,W0
        jnz  pflu4
# ||mov|11,-(xs)|7,xr||; preserve entry xr|24576
# getarg XR
        push XR
# ||mov|3,pfsvw|8,wa||; save wa (sgd07)|24577
# getarg WA
# getarg pfsvw
        movq WA,pfsvw
# ||bnz|3,pftbl|6,pflu2||; branch if table allocated|24578
# getarg pftbl
# getarg pflu2
        xor  W0,W0
        cmpq pftbl,W0
        jnz  pflu2
# ||sub|3,pfnte|18,=num01||; adjust for extra count (sgd07)|24588
# getarg W0
# getarg pfnte
        movq l_0060,W0
        subq W0,pfnte
# ||mti|4,pfi2a|||; convrt entry size to int|24589
# getarg pfi2a
        mov  pfi2a,IA
# ||sti|3,pfste|||; and store safely for later|24590
# getarg pfste
        mov  IA,pfste
# ||mti|3,pfnte|||; load table length as integer|24591
# getarg pfnte
        mov  pfnte,IA
# ||mli|3,pfste|||; multiply by entry size|24592
# getarg pfste
        imul pfste,IA
        seto reg_fl
# ||mfi|8,wa|||; get back address-style|24593
# getarg WA
        mov  IA,WA
# ||add|8,wa|18,=num02||; add on 2 word overhead|24594
# getarg W0
# getarg WA
        movq l_0130,W0
        addq W0,WA
# ||wtb|8,wa|||; convert the whole lot to bytes|24595
# getarg WA
        sal  WA,3
# ||jsr|6,alost|||; gimme the space|24596
# getarg alost
        call alost
# ||mov|3,pftbl|7,xr||; save block pointer|24597
# getarg XR
# getarg pftbl
        movq XR,pftbl
# ||mov|10,(xr)+|22,=b_xnt||; put block type and ...|24598
# getarg W0
        movq l_0855,W0
        movq W0,W0
        stosq
# ||mov|10,(xr)+|8,wa||; ... length into header|24599
# getarg WA
        movq WA,W0
        stosq
# ||mfi|8,wa|||; get back nr of wds in data area|24600
# getarg WA
        mov  IA,WA
# ||lct|8,wa|8,wa||; load the counter|24601
# |pflu1|zer|10,(xr)+|||; blank a word|24605
pflu1:
        mov  $0,W0
        stosq
# ||bct|8,wa|6,pflu1||; and alllllll the rest|24606
# getarg WA
# getarg pflu1
        decq WA
        jnz  pflu1
# |pflu2|mti|3,kvstn|||; load nr of stmt just ended|24610
pflu2:
# getarg kvstn
        mov  kvstn,IA
# ||sbi|4,intv1|||; make into index offset|24611
# getarg intv1
        sub  intv1,IA
        xor  W0,W0
        seto reg_fl
# ||mli|3,pfste|||; make offset of table entry|24612
# getarg pfste
        imul pfste,IA
        seto reg_fl
# ||mfi|8,wa|||; convert to address|24613
# getarg WA
        mov  IA,WA
# ||wtb|8,wa|||; get as baus|24614
# getarg WA
        sal  WA,3
# ||add|8,wa|19,*num02||; offset includes table header|24615
# getarg W0
# getarg WA
        movq l_0135,W0
        addq W0,WA
# ||mov|7,xr|3,pftbl||; get table start|24616
# getarg pftbl
# getarg XR
        movq pftbl,XR
# ||bge|8,wa|13,num01(xr)|6,pflu3|; if out of table, skip it|24617
# getarg WA
# getarg num01(,XR,8)
# getarg pflu3
        cmpq WA,num01(,XR,8)
        jae  pflu3
# ||add|7,xr|8,wa||; else point to entry|24618
# getarg WA
# getarg XR
        addq WA,XR
# ||ldi|9,(xr)|||; get nr of executions so far|24619
# getarg (XR)
        mov  (XR),IA
# ||adi|4,intv1|||; nudge up one|24620
# getarg intv1
        add  intv1,IA
        seto reg_fl
# ||sti|9,(xr)|||; and put back|24621
# getarg (XR)
        mov  IA,(XR)
# ||jsr|6,systm|||; get time now|24622
# getarg systm
        call systm
# ||sti|3,pfetm|||; stash ending time|24623
# getarg pfetm
        mov  IA,pfetm
# ||sbi|3,pfstm|||; subtract start time|24624
# getarg pfstm
        sub  pfstm,IA
        xor  W0,W0
        seto reg_fl
# ||adi|13,cfp_i(xr)|||; add cumulative time so far|24625
# getarg cfp_i(,XR,8)
        add  cfp_i(,XR,8),IA
        seto reg_fl
# ||sti|13,cfp_i(xr)|||; and put back new total|24626
# getarg cfp_i(,XR,8)
        mov  IA,cfp_i(,XR,8)
# ||ldi|3,pfetm|||; load end time of this stmt ...|24627
# getarg pfetm
        mov  pfetm,IA
# ||sti|3,pfstm|||; ... which is start time of next|24628
# getarg pfstm
        mov  IA,pfstm
# |pflu3|mov|7,xr|10,(xs)+||; restore callers xr|24632
pflu3:
# getarg XR
        pop  XR
# ||mov|8,wa|3,pfsvw||; restore saved reg|24633
# getarg pfsvw
# getarg WA
        movq pfsvw,WA
# ||exi||||; and return|24634
# getarg 
        ret
# |pflu4|zer|3,pffnc|||; reset the condition flag|24640
pflu4:
# getarg pffnc
        mov  $0,W0
        mov  W0,pffnc
# ||exi||||; and immediate return|24641
# getarg 
        ret
# ||enp||||; end of procedure prflu|24642
# ||ejc|||||24643
# |prpar|prc|25,e|1,0||; entry point|24656
prpar:
# getarg 0
# ||bnz|8,wc|6,prpa8||; jump to associate terminal|24657
# getarg WC
# getarg WC
# getarg prpa8
        or   WC,WC
        jnz  prpa8
# ||jsr|6,syspp|||; get print parameters|24658
# getarg syspp
        call syspp
# ||bnz|8,wb|6,prpa1||; jump if lines/page specified|24659
# getarg WB
# getarg WB
# getarg prpa1
        or   WB,WB
        jnz  prpa1
# ||mov|8,wb|3,mxint||; else use a large value|24660
# getarg mxint
# getarg WB
        movq mxint,WB
# ||rsh|8,wb|1,1||; but not too large|24661
# getarg 1
# getarg WB
        shl  1,WB
# |prpa1|mov|3,lstnp|8,wb||; store number of lines/page|24665
prpa1:
# getarg WB
# getarg lstnp
        movq WB,lstnp
# ||mov|3,lstlc|8,wb||; pretend page is full initially|24666
# getarg WB
# getarg lstlc
        movq WB,lstlc
# ||zer|3,lstpg|||; clear page number|24667
# getarg lstpg
        mov  $0,W0
        mov  W0,lstpg
# ||mov|8,wb|3,prlen||; get prior length if any|24668
# getarg prlen
# getarg WB
        movq prlen,WB
# ||bze|8,wb|6,prpa2||; skip if no length|24669
# getarg WB
# getarg prpa2
        or   WB,WB
        jz   prpa2
# ||bgt|8,wa|8,wb|6,prpa3|; skip storing if too big|24670
# getarg WA
# getarg WB
# getarg prpa3
        cmpq WA,WB
        ja   prpa3
# |prpa2|mov|3,prlen|8,wa||; store value|24674
prpa2:
# getarg WA
# getarg prlen
        movq WA,prlen
# |prpa3|mov|8,wb|4,bits3||; bit 3 mask|24678
prpa3:
# getarg bits3
# getarg WB
        movq bits3,WB
# ||anb|8,wb|8,wc||; get -nolist bit|24679
# getarg WB
# getarg WC
        and  WB,WC
# ||zrb|8,wb|6,prpa4||; skip if clear|24680
# getarg WB
# getarg WB
# getarg prpa4
        or   WB,WB
        jz   prpa4
# ||zer|3,cswls|||; set -nolist|24681
# getarg cswls
        mov  $0,W0
        mov  W0,cswls
# |prpa4|mov|8,wb|4,bits1||; bit 1 mask|24685
prpa4:
# getarg bits1
# getarg WB
        movq bits1,WB
# ||anb|8,wb|8,wc||; get bit|24686
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,erich|8,wb||; store int. chan. error flag|24687
# getarg WB
# getarg erich
        movq WB,erich
# ||mov|8,wb|4,bits2||; bit 2 mask|24688
# getarg bits2
# getarg WB
        movq bits2,WB
# ||anb|8,wb|8,wc||; get bit|24689
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,prich|8,wb||; flag for std printer on int. chan.|24690
# getarg WB
# getarg prich
        movq WB,prich
# ||mov|8,wb|4,bits4||; bit 4 mask|24691
# getarg bits4
# getarg WB
        movq bits4,WB
# ||anb|8,wb|8,wc||; get bit|24692
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,cpsts|8,wb||; flag for compile stats suppressn.|24693
# getarg WB
# getarg cpsts
        movq WB,cpsts
# ||mov|8,wb|4,bits5||; bit 5 mask|24694
# getarg bits5
# getarg WB
        movq bits5,WB
# ||anb|8,wb|8,wc||; get bit|24695
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,exsts|8,wb||; flag for exec stats suppression|24696
# getarg WB
# getarg exsts
        movq WB,exsts
# ||ejc|||||24697
# ||mov|8,wb|4,bits6||; bit 6 mask|24701
# getarg bits6
# getarg WB
        movq bits6,WB
# ||anb|8,wb|8,wc||; get bit|24702
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,precl|8,wb||; extended/compact listing flag|24703
# getarg WB
# getarg precl
        movq WB,precl
# ||sub|8,wa|18,=num08||; point 8 chars from line end|24704
# getarg W0
# getarg WA
        .data
l_0886: .long num08
        .text
        movq l_0886,W0
        subq W0,WA
# ||zrb|8,wb|6,prpa5||; jump if not extended|24705
# getarg WB
# getarg WB
# getarg prpa5
        or   WB,WB
        jz   prpa5
# ||mov|3,lstpo|8,wa||; store for listing page headings|24706
# getarg WA
# getarg lstpo
        movq WA,lstpo
# |prpa5|mov|8,wb|4,bits7||; bit 7 mask|24710
prpa5:
# getarg bits7
# getarg WB
        movq bits7,WB
# ||anb|8,wb|8,wc||; get bit 7|24711
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,cswex|8,wb||; set -noexecute if non-zero|24712
# getarg WB
# getarg cswex
        movq WB,cswex
# ||mov|8,wb|4,bit10||; bit 10 mask|24713
# getarg bit10
# getarg WB
        movq bit10,WB
# ||anb|8,wb|8,wc||; get bit 10|24714
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,headp|8,wb||; pretend printed to omit headers|24715
# getarg WB
# getarg headp
        movq WB,headp
# ||mov|8,wb|4,bits9||; bit 9 mask|24716
# getarg bits9
# getarg WB
        movq bits9,WB
# ||anb|8,wb|8,wc||; get bit 9|24717
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,prsto|8,wb||; keep it as std listing option|24718
# getarg WB
# getarg prsto
        movq WB,prsto
# ||mov|8,wb|8,wc||; copy flags|24720
# getarg WC
# getarg WB
        movq WC,WB
# ||rsh|8,wb|1,12||; right justify bit 13|24721
# getarg 12
# getarg WB
        shl  12,WB
# ||anb|8,wb|4,bits1||; get bit|24722
# getarg WB
# getarg bits1
        and  WB,bits1
# ||mov|3,kvcas|8,wb||; set -case|24723
# getarg WB
# getarg kvcas
        movq WB,kvcas
# ||mov|8,wb|4,bit12||; bit 12 mask|24725
# getarg bit12
# getarg WB
        movq bit12,WB
# ||anb|8,wb|8,wc||; get bit 12|24726
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,cswer|8,wb||; keep it as errors/noerrors option|24727
# getarg WB
# getarg cswer
        movq WB,cswer
# ||zrb|8,wb|6,prpa6||; skip if clear|24728
# getarg WB
# getarg WB
# getarg prpa6
        or   WB,WB
        jz   prpa6
# ||mov|8,wa|3,prlen||; get print buffer length|24729
# getarg prlen
# getarg WA
        movq prlen,WA
# ||sub|8,wa|18,=num08||; point 8 chars from line end|24730
# getarg W0
# getarg WA
        movq l_0886,W0
        subq W0,WA
# ||mov|3,lstpo|8,wa||; store page offset|24731
# getarg WA
# getarg lstpo
        movq WA,lstpo
# |prpa6|mov|8,wb|4,bit11||; bit 11 mask|24735
prpa6:
# getarg bit11
# getarg WB
        movq bit11,WB
# ||anb|8,wb|8,wc||; get bit 11|24736
# getarg WB
# getarg WC
        and  WB,WC
# ||mov|3,cswpr|8,wb||; set -print if non-zero|24737
# getarg WB
# getarg cswpr
        movq WB,cswpr
# ||anb|8,wc|4,bits8||; see if terminal to be activated|24741
# getarg WC
# getarg bits8
        and  WC,bits8
# ||bnz|8,wc|6,prpa8||; jump if terminal required|24742
# getarg WC
# getarg WC
# getarg prpa8
        or   WC,WC
        jnz  prpa8
# ||bze|3,initr|6,prpa9||; jump if no terminal to detach|24743
# getarg initr
# getarg prpa9
        xor  W0,W0
        cmpq initr,W0
        jz   prpa9
# ||mov|7,xl|21,=v_ter||; ptr to /terminal/|24744
# getarg W0
# getarg XL
        movq l_0590,W0
        movq W0,XL
# ||jsr|6,gtnvr|||; get vrblk pointer|24745
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_260
# ||ppm||||; cant fail|24746
# getarg 
        decq rcode
        jns  l_0887
        movq $299,rcode
        jmp  err_
l_0887:
call_260:
# ||mov|13,vrval(xr)|21,=nulls||; clear value of terminal|24747
# getarg W0
# getarg vrval(,XR,8)
        movq l_0054,W0
        movq W0,vrval(,XR,8)
# ||jsr|6,setvr|||; remove association|24748
# getarg setvr
        call setvr
# ||brn|6,prpa9|||; return|24749
# getarg prpa9
        jmp  prpa9
# |prpa8|mnz|3,initr|||; note terminal associated|24753
prpa8:
# getarg initr
        mov  XS,initr
# ||bze|3,dnamb|6,prpa9||; cant if memory not organised|24754
# getarg dnamb
# getarg prpa9
        xor  W0,W0
        cmpq dnamb,W0
        jz   prpa9
# ||mov|7,xl|21,=v_ter||; point to terminal string|24755
# getarg W0
# getarg XL
        movq l_0590,W0
        movq W0,XL
# ||mov|8,wb|18,=trtou||; output trace type|24756
# getarg W0
# getarg WB
        movq l_0068,W0
        movq W0,WB
# ||jsr|6,inout|||; attach output trblk to vrblk|24757
# getarg inout
        call inout
# ||mov|11,-(xs)|7,xr||; stack trblk ptr|24758
# getarg XR
        push XR
# ||mov|7,xl|21,=v_ter||; point to terminal string|24759
# getarg W0
# getarg XL
        movq l_0590,W0
        movq W0,XL
# ||mov|8,wb|18,=trtin||; input trace type|24760
# getarg W0
# getarg WB
        movq l_0066,W0
        movq W0,WB
# ||jsr|6,inout|||; attach input trace blk|24761
# getarg inout
        call inout
# ||mov|13,vrval(xr)|10,(xs)+||; add output trblk to chain|24762
# getarg vrval(,XR,8)
        pop  vrval(,XR,8)
# |prpa9|exi||||; return|24766
prpa9:
# getarg 
        ret
# ||enp||||; end procedure prpar|24767
# ||ejc|||||24768
# |prtch|prc|25,e|1,0||; entry point|24777
prtch:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save xr|24778
# getarg XR
        push XR
# ||bne|3,profs|3,prlen|6,prch1|; jump if room in buffer|24779
# getarg prlen
# getarg profs
# getarg W0
# getarg prch1
        movq prlen,W0
        cmpq profs,W0
        jne  prch1
# ||jsr|6,prtnl|||; else print this line|24780
# getarg prtnl
        call prtnl
# |prch1|mov|7,xr|3,prbuf||; point to print buffer|24784
prch1:
# getarg prbuf
# getarg XR
        movq prbuf,XR
# ||psc|7,xr|3,profs||; point to next character location|24785
# getarg XR
# getarg profs
        add  $cfp_f,XR
        add  profs,XR
# ||sch|8,wa|9,(xr)||; store new character|24786
# getarg WA
        movb
# ||csc|7,xr|||; complete store characters|24787
# ||icv|3,profs|||; bump pointer|24788
# getarg profs
        incq profs
# ||mov|7,xr|10,(xs)+||; restore entry xr|24789
# getarg XR
        pop  XR
# ||exi||||; return to prtch caller|24790
# getarg 
        ret
# ||enp||||; end procedure prtch|24791
# ||ejc|||||24792
# |prtic|prc|25,e|1,0||; entry point|24804
prtic:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save xr|24805
# getarg XR
        push XR
# ||mov|7,xr|3,prbuf||; point to buffer|24806
# getarg prbuf
# getarg XR
        movq prbuf,XR
# ||mov|8,wa|3,profs||; no of chars|24807
# getarg profs
# getarg WA
        movq profs,WA
# ||jsr|6,syspi|||; print|24808
# getarg syspi
        call syspi
        decq rcode
        js   call_261
# ||ppm|6,prtc2|||; fail return|24809
# getarg prtc2
# getarg prtc2
        decq rcode
        jns  l_0888
        jmp  prtc2
l_0888:
call_261:
# |prtc1|mov|7,xr|10,(xs)+||; restore xr|24813
prtc1:
# getarg XR
        pop  XR
# ||exi||||; return|24814
# getarg 
        ret
# |prtc2|zer|3,erich|||; prevent looping|24818
prtc2:
# getarg erich
        mov  $0,W0
        mov  W0,erich
# ||erb|1,252|26,error on printing to interactive channel|||24819
        movq $252,rcode
        jmp  err_
# ||brn|6,prtc1|||; return|24820
# getarg prtc1
        jmp  prtc1
# ||enp||||; procedure prtic|24821
# ||ejc|||||24822
# |prtis|prc|25,e|1,0||; entry point|24835
prtis:
# getarg 0
# ||bnz|3,prich|6,prts1||; jump if standard printer is int.ch.|24836
# getarg prich
# getarg prts1
        xor  W0,W0
        cmpq prich,W0
        jnz  prts1
# ||bze|3,erich|6,prts1||; skip if not doing int. error reps.|24837
# getarg erich
# getarg prts1
        xor  W0,W0
        cmpq erich,W0
        jz   prts1
# ||jsr|6,prtic|||; print to interactive channel|24838
# getarg prtic
        call prtic
# |prts1|jsr|6,prtnl|||; print to standard printer|24842
prts1:
# getarg prtnl
        call prtnl
# ||exi||||; return|24843
# getarg 
        ret
# ||enp||||; end procedure prtis|24844
# ||ejc|||||24845
# |prtin|prc|25,e|1,0||; entry point|24857
prtin:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save xr|24858
# getarg XR
        push XR
# ||jsr|6,icbld|||; build integer block|24859
# getarg icbld
        call icbld
# ||blo|7,xr|3,dnamb|6,prti1|; jump if icblk below dynamic|24860
# getarg XR
# getarg dnamb
# getarg prti1
        cmpq XR,dnamb
        jb   prti1
# ||bhi|7,xr|3,dnamp|6,prti1|; jump if above dynamic|24861
# getarg XR
# getarg dnamp
# getarg prti1
        cmpq XR,dnamp
        ja   prti1
# ||mov|3,dnamp|7,xr||; immediately delete it|24862
# getarg XR
# getarg dnamp
        movq XR,dnamp
# |prti1|mov|11,-(xs)|7,xr||; stack ptr for gtstg|24866
prti1:
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert to string|24867
# getarg gtstg
        call gtstg
        decq rcode
        js   call_262
# ||ppm||||; convert error is impossible|24868
# getarg 
        decq rcode
        jns  l_0889
        movq $299,rcode
        jmp  err_
l_0889:
call_262:
# ||mov|3,dnamp|7,xr||; reset pointer to delete scblk|24869
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||jsr|6,prtst|||; print integer string|24870
# getarg prtst
        call prtst
# ||mov|7,xr|10,(xs)+||; restore entry xr|24871
# getarg XR
        pop  XR
# ||exi||||; return to prtin caller|24872
# getarg 
        ret
# ||enp||||; end procedure prtin|24873
# ||ejc|||||24874
# |prtmi|prc|25,e|1,0||; entry point|24884
prtmi:
# getarg 0
# ||jsr|6,prtst|||; print string message|24885
# getarg prtst
        call prtst
# ||mov|3,profs|18,=prtmf||; set column offset|24886
# getarg W0
# getarg profs
        movq l_0579,W0
        movq W0,profs
# ||jsr|6,prtin|||; print integer|24887
# getarg prtin
        call prtin
# ||jsr|6,prtnl|||; print line|24888
# getarg prtnl
        call prtnl
# ||exi||||; return to prtmi caller|24889
# getarg 
        ret
# ||enp||||; end procedure prtmi|24890
# ||ejc|||||24891
# |prtmm|prc|25,e|1,0||;|24900
prtmm:
# getarg 0
# ||mov|8,wa|3,dnamp||; next available loc|24901
# getarg dnamp
# getarg WA
        movq dnamp,WA
# ||sub|8,wa|3,statb||; minus start|24902
# getarg statb
# getarg WA
        subq statb,WA
# ||mti|8,wa|||; convert to integer|24907
# getarg WA
        mov  WA,IA
# ||mov|7,xr|21,=encm1||; point to /memory used (words)/|24908
# getarg W0
# getarg XR
        .data
l_0890: .long encm1
        .text
        movq l_0890,W0
        movq W0,XR
# ||jsr|6,prtmi|||; print message|24909
# getarg prtmi
        call prtmi
# ||mov|8,wa|3,dname||; end of memory|24910
# getarg dname
# getarg WA
        movq dname,WA
# ||sub|8,wa|3,dnamp||; minus next available loc|24911
# getarg dnamp
# getarg WA
        subq dnamp,WA
# ||mti|8,wa|||; convert to integer|24916
# getarg WA
        mov  WA,IA
# ||mov|7,xr|21,=encm2||; point to /memory available (words)/|24917
# getarg W0
# getarg XR
        .data
l_0891: .long encm2
        .text
        movq l_0891,W0
        movq W0,XR
# ||jsr|6,prtmi|||; print line|24918
# getarg prtmi
        call prtmi
# ||exi||||; return to prtmm caller|24919
# getarg 
        ret
# ||enp||||; end of procedure prtmm|24920
# ||ejc|||||24921
# |prtmx|prc|25,e|1,0||; entry point|24928
prtmx:
# getarg 0
# ||jsr|6,prtst|||; print string message|24929
# getarg prtst
        call prtst
# ||mov|3,profs|18,=prtmf||; set column offset|24930
# getarg W0
# getarg profs
        movq l_0579,W0
        movq W0,profs
# ||jsr|6,prtin|||; print integer|24931
# getarg prtin
        call prtin
# ||jsr|6,prtis|||; print line|24932
# getarg prtis
        call prtis
# ||exi||||; return|24933
# getarg 
        ret
# ||enp||||; end procedure prtmx|24934
# ||ejc|||||24935
# |prtnl|prc|25,r|1,0||; entry point|24944
prtnl:
# getarg 0
# ||bnz|3,headp|6,prnl0||; were headers printed|24945
# getarg headp
# getarg prnl0
        xor  W0,W0
        cmpq headp,W0
        jnz  prnl0
# ||jsr|6,prtps|||; no - print them|24946
# getarg prtps
        call prtps
# |prnl0|mov|11,-(xs)|7,xr||; save entry xr|24950
prnl0:
# getarg XR
        push XR
# ||mov|3,prtsa|8,wa||; save wa|24951
# getarg WA
# getarg prtsa
        movq WA,prtsa
# ||mov|3,prtsb|8,wb||; save wb|24952
# getarg WB
# getarg prtsb
        movq WB,prtsb
# ||mov|7,xr|3,prbuf||; load pointer to buffer|24953
# getarg prbuf
# getarg XR
        movq prbuf,XR
# ||mov|8,wa|3,profs||; load number of chars in buffer|24954
# getarg profs
# getarg WA
        movq profs,WA
# ||jsr|6,syspr|||; call system print routine|24955
# getarg syspr
        call syspr
        decq rcode
        js   call_263
# ||ppm|6,prnl2|||; jump if failed|24956
# getarg prnl2
# getarg prnl2
        decq rcode
        jns  l_0892
        jmp  prnl2
l_0892:
call_263:
# ||lct|8,wa|3,prlnw||; load length of buffer in words|24957
# getarg WA
# getarg prlnw
        mov  WA,prlnw
# ||add|7,xr|19,*schar||; point to chars of buffer|24958
# getarg W0
# getarg XR
        movq l_0817,W0
        addq W0,XR
# ||mov|8,wb|4,nullw||; get word of blanks|24959
# getarg nullw
# getarg WB
        movq nullw,WB
# |prnl1|mov|10,(xr)+|8,wb||; store word of blanks, bump ptr|24963
prnl1:
# getarg WB
        movq WB,W0
        stosq
# ||bct|8,wa|6,prnl1||; loop till all blanked|24964
# getarg WA
# getarg prnl1
        decq WA
        jnz  prnl1
# ||mov|8,wb|3,prtsb||; restore wb|24968
# getarg prtsb
# getarg WB
        movq prtsb,WB
# ||mov|8,wa|3,prtsa||; restore wa|24969
# getarg prtsa
# getarg WA
        movq prtsa,WA
# ||mov|7,xr|10,(xs)+||; restore entry xr|24970
# getarg XR
        pop  XR
# ||zer|3,profs|||; reset print buffer pointer|24971
# getarg profs
        mov  $0,W0
        mov  W0,profs
# ||exi||||; return to prtnl caller|24972
# getarg 
        ret
# |prnl2|bnz|3,prtef|6,prnl3||; jump if not first time|24976
prnl2:
# getarg prtef
# getarg prnl3
        xor  W0,W0
        cmpq prtef,W0
        jnz  prnl3
# ||mnz|3,prtef|||; mark first occurrence|24977
# getarg prtef
        mov  XS,prtef
# ||erb|1,253|26,print limit exceeded on standard output channel|||24978
        movq $253,rcode
        jmp  err_
# |prnl3|mov|8,wb|18,=nini8||; ending code|24982
prnl3:
# getarg W0
# getarg WB
        .data
l_0893: .long nini8
        .text
        movq l_0893,W0
        movq W0,WB
# ||mov|8,wa|3,kvstn||; statement number|24983
# getarg kvstn
# getarg WA
        movq kvstn,WA
# ||mov|7,xl|3,r_fcb||; get fcblk chain head|24984
# getarg r_fcb
# getarg XL
        movq r_fcb,XL
# ||jsr|6,sysej|||; stop|24985
# getarg sysej
        call sysej
# ||enp||||; end procedure prtnl|24986
# ||ejc|||||24987
# |prtnm|prc|25,r|1,0||; entry point (recursive, see prtvl)|25000
prtnm:
# getarg 0
# ||mov|11,-(xs)|8,wa||; save wa (offset is collectable)|25001
# getarg WA
        push WA
# ||mov|11,-(xs)|7,xr||; save entry xr|25002
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xl||; save name base|25003
# getarg XL
        push XL
# ||bhi|7,xl|3,state|6,prn02|; jump if not natural variable|25004
# getarg XL
# getarg state
# getarg prn02
        cmpq XL,state
        ja   prn02
# ||mov|7,xr|7,xl||; point to vrblk|25009
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,prtvn|||; print name of variable|25010
# getarg prtvn
        call prtvn
# |prn01|mov|7,xl|10,(xs)+||; restore name base|25014
prn01:
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; restore entry value of xr|25015
# getarg XR
        pop  XR
# ||mov|8,wa|10,(xs)+||; restore wa|25016
# getarg WA
        pop  WA
# ||exi||||; return to prtnm caller|25017
# getarg 
        ret
# |prn02|mov|8,wb|8,wa||; copy name offset|25021
prn02:
# getarg WA
# getarg WB
        movq WA,WB
# ||bne|9,(xl)|22,=b_pdt|6,prn03|; jump if array or table|25022
# getarg (XL)
# getarg W0
# getarg prn03
        movq l_0139,W0
        cmpq (XL),W0
        jne  prn03
# ||mov|7,xr|13,pddfp(xl)||; load pointer to dfblk|25026
# getarg pddfp(,XL,8)
# getarg XR
        movq pddfp(,XL,8),XR
# ||add|7,xr|8,wa||; add name offset|25027
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|7,xr|13,pdfof(xr)||; load vrblk pointer for field|25028
# getarg pdfof(,XR,8)
# getarg XR
        movq pdfof(,XR,8),XR
# ||jsr|6,prtvn|||; print field name|25029
# getarg prtvn
        call prtvn
# ||mov|8,wa|18,=ch_pp||; load left paren|25030
# getarg W0
# getarg WA
        movq l_0158,W0
        movq W0,WA
# ||jsr|6,prtch|||; print character|25031
# getarg prtch
        call prtch
# ||ejc|||||25032
# |prn03|bne|9,(xl)|22,=b_tet|6,prn04|; jump if we got there (or not te)|25045
prn03:
# getarg (XL)
# getarg W0
# getarg prn04
        .data
l_0894: .long b_tet
        .text
        movq l_0894,W0
        cmpq (XL),W0
        jne  prn04
# ||mov|7,xl|13,tenxt(xl)||; else move out on chain|25046
# getarg tenxt(,XL,8)
# getarg XL
        movq tenxt(,XL,8),XL
# ||brn|6,prn03|||; and loop back|25047
# getarg prn03
        jmp  prn03
# |prn04|mov|7,xr|3,prnmv||; point to vrblk we found last time|25055
prn04:
# getarg prnmv
# getarg XR
        movq prnmv,XR
# ||mov|8,wa|3,hshtb||; point to hash table in case not|25056
# getarg hshtb
# getarg WA
        movq hshtb,WA
# ||brn|6,prn07|||; jump into search for special check|25057
# getarg prn07
        jmp  prn07
# |prn05|mov|7,xr|8,wa||; copy slot pointer|25061
prn05:
# getarg WA
# getarg XR
        movq WA,XR
# ||ica|8,wa|||; bump slot pointer|25062
# getarg WA
        addq $8,WA
# ||sub|7,xr|19,*vrnxt||; introduce standard vrblk offset|25063
# getarg W0
# getarg XR
        movq l_0034,W0
        subq W0,XR
# |prn06|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on hash chain|25067
prn06:
# getarg vrnxt(,XR,8)
# getarg XR
        movq vrnxt(,XR,8),XR
# |prn07|mov|8,wc|7,xr||; copy vrblk pointer|25071
prn07:
# getarg XR
# getarg WC
        movq XR,WC
# ||bze|8,wc|6,prn09||; jump if chain end (or prnmv zero)|25072
# getarg WC
# getarg prn09
        or   WC,WC
        jz   prn09
# ||ejc|||||25073
# |prn08|mov|7,xr|13,vrval(xr)||; load value|25079
prn08:
# getarg vrval(,XR,8)
# getarg XR
        movq vrval(,XR,8),XR
# ||beq|9,(xr)|22,=b_trt|6,prn08|; loop if that was a trblk|25080
# getarg (XR)
# getarg W0
# getarg prn08
        movq l_0154,W0
        cmpq (XR),W0
        je   prn08
# ||beq|7,xr|7,xl|6,prn10|; jump if this matches the name base|25084
# getarg XR
# getarg XL
# getarg prn10
        cmpq XR,XL
        je   prn10
# ||mov|7,xr|8,wc||; else point back to that vrblk|25085
# getarg WC
# getarg XR
        movq WC,XR
# ||brn|6,prn06|||; and loop back|25086
# getarg prn06
        jmp  prn06
# |prn09|blt|8,wa|3,hshte|6,prn05|; loop back if more to go|25090
prn09:
# getarg WA
# getarg hshte
# getarg prn05
        cmpq WA,hshte
        jb   prn05
# ||mov|7,xr|7,xl||; else not found, copy value pointer|25091
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,prtvl|||; print value|25092
# getarg prtvl
        call prtvl
# ||brn|6,prn11|||; and merge ahead|25093
# getarg prn11
        jmp  prn11
# |prn10|mov|7,xr|8,wc||; copy vrblk pointer|25097
prn10:
# getarg WC
# getarg XR
        movq WC,XR
# ||mov|3,prnmv|7,xr||; save for next time in|25098
# getarg XR
# getarg prnmv
        movq XR,prnmv
# ||jsr|6,prtvn|||; print variable name|25099
# getarg prtvn
        call prtvn
# |prn11|mov|8,wc|9,(xl)||; load first word of name base|25103
prn11:
# getarg (XL)
# getarg WC
        movq (XL),WC
# ||bne|8,wc|22,=b_pdt|6,prn13|; jump if not program defined|25104
# getarg WC
# getarg W0
# getarg prn13
        movq l_0139,W0
        cmpq WC,W0
        jne  prn13
# ||mov|8,wa|18,=ch_rp||; load right paren, merge|25108
# getarg W0
# getarg WA
        movq l_0160,W0
        movq W0,WA
# |prn12|jsr|6,prtch|||; print final character|25112
prn12:
# getarg prtch
        call prtch
# ||mov|8,wa|8,wb||; restore name offset|25113
# getarg WB
# getarg WA
        movq WB,WA
# ||brn|6,prn01|||; merge back to exit|25114
# getarg prn01
        jmp  prn01
# ||ejc|||||25115
# |prn13|mov|8,wa|18,=ch_bb||; load left bracket|25121
prn13:
# getarg W0
# getarg WA
        .data
l_0895: .long ch_bb
        .text
        movq l_0895,W0
        movq W0,WA
# ||jsr|6,prtch|||; and print it|25122
# getarg prtch
        call prtch
# ||mov|7,xl|9,(xs)||; restore block pointer|25123
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|8,wc|9,(xl)||; load type word again|25124
# getarg (XL)
# getarg WC
        movq (XL),WC
# ||bne|8,wc|22,=b_tet|6,prn15|; jump if not table|25125
# getarg WC
# getarg W0
# getarg prn15
        movq l_0894,W0
        cmpq WC,W0
        jne  prn15
# ||mov|7,xr|13,tesub(xl)||; load subscript value|25129
# getarg tesub(,XL,8)
# getarg XR
        movq tesub(,XL,8),XR
# ||mov|7,xl|8,wb||; save name offset|25130
# getarg WB
# getarg XL
        movq WB,XL
# ||jsr|6,prtvl|||; print subscript value|25131
# getarg prtvl
        call prtvl
# ||mov|8,wb|7,xl||; restore name offset|25132
# getarg XL
# getarg WB
        movq XL,WB
# |prn14|mov|8,wa|18,=ch_rb||; load right bracket|25136
prn14:
# getarg W0
# getarg WA
        .data
l_0896: .long ch_rb
        .text
        movq l_0896,W0
        movq W0,WA
# ||brn|6,prn12|||; merge back to print it|25137
# getarg prn12
        jmp  prn12
# |prn15|mov|8,wa|8,wb||; copy name offset|25141
prn15:
# getarg WB
# getarg WA
        movq WB,WA
# ||btw|8,wa|||; convert to words|25142
# getarg WA
        shr  WA,3
# ||beq|8,wc|22,=b_art|6,prn16|; jump if arblk|25143
# getarg WC
# getarg W0
# getarg prn16
        movq l_0247,W0
        cmpq WC,W0
        je   prn16
# ||sub|8,wa|18,=vcvlb||; adjust for standard fields|25147
# getarg W0
# getarg WA
        movq l_0088,W0
        subq W0,WA
# ||mti|8,wa|||; move to integer accum|25148
# getarg WA
        mov  WA,IA
# ||jsr|6,prtin|||; print linear subscript|25149
# getarg prtin
        call prtin
# ||brn|6,prn14|||; merge back for right bracket|25150
# getarg prn14
        jmp  prn14
# ||ejc|||||25151
# |prn16|mov|8,wc|13,arofs(xl)||; load length of bounds info|25160
prn16:
# getarg arofs(,XL,8)
# getarg WC
        movq arofs(,XL,8),WC
# ||ica|8,wc|||; adjust for arpro field|25161
# getarg WC
        addq $8,WC
# ||btw|8,wc|||; convert to words|25162
# getarg WC
        shr  WC,3
# ||sub|8,wa|8,wc||; get linear zero-origin subscript|25163
# getarg WC
# getarg WA
        subq WC,WA
# ||mti|8,wa|||; get integer value|25164
# getarg WA
        mov  WA,IA
# ||lct|8,wa|13,arndm(xl)||; set num of dimensions as loop count|25165
# getarg WA
# getarg arndm(,XL,8)
        mov  WA,arndm(,XL,8)
# ||add|7,xl|13,arofs(xl)||; point past bounds information|25166
# getarg arofs(,XL,8)
# getarg XL
        addq arofs(,XL,8),XL
# ||sub|7,xl|19,*arlbd||; set ok offset for proper ptr later|25167
# getarg W0
# getarg XL
        movq l_0248,W0
        subq W0,XL
# |prn17|sub|7,xl|19,*ardms||; point to next set of bounds|25171
prn17:
# getarg W0
# getarg XL
        movq l_0245,W0
        subq W0,XL
# ||sti|3,prnsi|||; save current offset|25172
# getarg prnsi
        mov  IA,prnsi
# ||rmi|13,ardim(xl)|||; get remainder on dividing by dimens|25173
# getarg ardim(,XL,8)
        mov  ardim(,XL,8),W0
        call rmi__
# ||mfi|11,-(xs)|||; store on stack (one word)|25174
        mov  IA,W0
        push W0
# ||ldi|3,prnsi|||; reload argument|25175
# getarg prnsi
        mov  prnsi,IA
# ||dvi|13,ardim(xl)|||; divide to get quotient|25176
# getarg ardim(,XL,8)
        mov  ardim(,XL,8),W0
        call dvi__
# ||bct|8,wa|6,prn17||; loop till all stacked|25177
# getarg WA
# getarg prn17
        decq WA
        jnz  prn17
# ||zer|7,xr|||; set offset to first set of bounds|25178
# getarg XR
        xor  XR,XR
# ||lct|8,wb|13,arndm(xl)||; load count of dims to control loop|25179
# getarg WB
# getarg arndm(,XL,8)
        mov  WB,arndm(,XL,8)
# ||brn|6,prn19|||; jump into print loop|25180
# getarg prn19
        jmp  prn19
# |prn18|mov|8,wa|18,=ch_cm||; load a comma|25185
prn18:
# getarg W0
# getarg WA
        movq l_0159,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|25186
# getarg prtch
        call prtch
# |prn19|mti|10,(xs)+|||; load subscript offset as integer|25190
prn19:
        pop  W0
        mov  W0,IA
# ||add|7,xl|7,xr||; point to current lbd|25191
# getarg XR
# getarg XL
        addq XR,XL
# ||adi|13,arlbd(xl)|||; add lbd to get signed subscript|25192
# getarg arlbd(,XL,8)
        add  arlbd(,XL,8),IA
        seto reg_fl
# ||sub|7,xl|7,xr||; point back to start of arblk|25193
# getarg XR
# getarg XL
        subq XR,XL
# ||jsr|6,prtin|||; print subscript|25194
# getarg prtin
        call prtin
# ||add|7,xr|19,*ardms||; bump offset to next bounds|25195
# getarg W0
# getarg XR
        movq l_0245,W0
        addq W0,XR
# ||bct|8,wb|6,prn18||; loop back till all printed|25196
# getarg WB
# getarg prn18
        decq WB
        jnz  prn18
# ||brn|6,prn14|||; merge back to print right bracket|25197
# getarg prn14
        jmp  prn14
# ||enp||||; end procedure prtnm|25198
# ||ejc|||||25199
# |prtnv|prc|25,e|1,0||; entry point|25215
prtnv:
# getarg 0
# ||jsr|6,prtnm|||; print argument name|25216
# getarg prtnm
        call prtnm
# ||mov|11,-(xs)|7,xr||; save entry xr|25217
# getarg XR
        push XR
# ||mov|11,-(xs)|8,wa||; save name offset (collectable)|25218
# getarg WA
        push WA
# ||mov|7,xr|21,=tmbeb||; point to blank equal blank|25219
# getarg W0
# getarg XR
        movq l_0743,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|25220
# getarg prtst
        call prtst
# ||mov|7,xr|7,xl||; copy name base|25221
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xr|8,wa||; point to value|25222
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|7,xr|9,(xr)||; load value pointer|25223
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||jsr|6,prtvl|||; print value|25224
# getarg prtvl
        call prtvl
# ||jsr|6,prtnl|||; terminate line|25225
# getarg prtnl
        call prtnl
# ||mov|8,wa|10,(xs)+||; restore name offset|25226
# getarg WA
        pop  WA
# ||mov|7,xr|10,(xs)+||; restore entry xr|25227
# getarg XR
        pop  XR
# ||exi||||; return to caller|25228
# getarg 
        ret
# ||enp||||; end procedure prtnv|25229
# ||ejc|||||25230
# |prtpg|prc|25,e|1,0||; entry point|25239
prtpg:
# getarg 0
# ||beq|3,stage|18,=stgxt|6,prp01|; jump if execution time|25240
# getarg stage
# getarg W0
# getarg prp01
        movq l_0075,W0
        cmpq stage,W0
        je   prp01
# ||bze|3,lstlc|6,prp06||; return if top of page already|25241
# getarg lstlc
# getarg prp06
        xor  W0,W0
        cmpq lstlc,W0
        jz   prp06
# ||zer|3,lstlc|||; clear line count|25242
# getarg lstlc
        mov  $0,W0
        mov  W0,lstlc
# |prp01|mov|11,-(xs)|7,xr||; preserve xr|25246
prp01:
# getarg XR
        push XR
# ||bnz|3,prstd|6,prp02||; eject if flag set|25247
# getarg prstd
# getarg prp02
        xor  W0,W0
        cmpq prstd,W0
        jnz  prp02
# ||bnz|3,prich|6,prp03||; jump if interactive listing channel|25248
# getarg prich
# getarg prp03
        xor  W0,W0
        cmpq prich,W0
        jnz  prp03
# ||bze|3,precl|6,prp03||; jump if compact listing|25249
# getarg precl
# getarg prp03
        xor  W0,W0
        cmpq precl,W0
        jz   prp03
# |prp02|jsr|6,sysep|||; eject|25253
prp02:
# getarg sysep
        call sysep
# ||brn|6,prp04|||; merge|25254
# getarg prp04
        jmp  prp04
# |prp03|mov|7,xr|3,headp||; remember headp|25260
prp03:
# getarg headp
# getarg XR
        movq headp,XR
# ||mnz|3,headp|||; set to avoid repeated prtpg calls|25261
# getarg headp
        mov  XS,headp
# ||jsr|6,prtnl|||; print blank line|25262
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; print blank line|25263
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; print blank line|25264
# getarg prtnl
        call prtnl
# ||mov|3,lstlc|18,=num03||; count blank lines|25265
# getarg W0
# getarg lstlc
        movq l_0350,W0
        movq W0,lstlc
# ||mov|3,headp|7,xr||; restore header flag|25266
# getarg XR
# getarg headp
        movq XR,headp
# ||ejc|||||25267
# |prp04|bnz|3,headp|6,prp05||; jump if header listed|25273
prp04:
# getarg headp
# getarg prp05
        xor  W0,W0
        cmpq headp,W0
        jnz  prp05
# ||mnz|3,headp|||; mark headers printed|25274
# getarg headp
        mov  XS,headp
# ||mov|11,-(xs)|7,xl||; keep xl|25275
# getarg XL
        push XL
# ||mov|7,xr|21,=headr||; point to listing header|25276
# getarg W0
# getarg XR
        .data
l_0897: .long headr
        .text
        movq l_0897,W0
        movq W0,XR
# ||jsr|6,prtst|||; place it|25277
# getarg prtst
        call prtst
# ||jsr|6,sysid|||; get system identification|25278
# getarg sysid
        call sysid
# ||jsr|6,prtst|||; append extra chars|25279
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; print it|25280
# getarg prtnl
        call prtnl
# ||mov|7,xr|7,xl||; extra header line|25281
# getarg XL
# getarg XR
        movq XL,XR
# ||jsr|6,prtst|||; place it|25282
# getarg prtst
        call prtst
# ||jsr|6,prtnl|||; print it|25283
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; print a blank|25284
# getarg prtnl
        call prtnl
# ||jsr|6,prtnl|||; and another|25285
# getarg prtnl
        call prtnl
# ||add|3,lstlc|18,=num04||; four header lines printed|25286
# getarg W0
# getarg lstlc
        movq l_0729,W0
        addq W0,lstlc
# ||mov|7,xl|10,(xs)+||; restore xl|25287
# getarg XL
        pop  XL
# |prp05|mov|7,xr|10,(xs)+||; restore xr|25291
prp05:
# getarg XR
        pop  XR
# |prp06|exi||||; return|25295
prp06:
# getarg 
        ret
# ||enp||||; end procedure prtpg|25296
# ||ejc|||||25297
# |prtps|prc|25,e|1,0||; entry point|25306
prtps:
# getarg 0
# ||mov|3,prstd|3,prsto||; copy option flag|25307
# getarg prsto
# getarg W0
# getarg prstd
        movq prsto,W0
        movq W0,prstd
# ||jsr|6,prtpg|||; print page|25308
# getarg prtpg
        call prtpg
# ||zer|3,prstd|||; clear flag|25309
# getarg prstd
        mov  $0,W0
        mov  W0,prstd
# ||exi||||; return|25310
# getarg 
        ret
# ||enp||||; end procedure prtps|25311
# ||ejc|||||25312
# |prtsn|prc|25,e|1,0||; entry point|25331
prtsn:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save entry xr|25332
# getarg XR
        push XR
# ||mov|3,prsna|8,wa||; save entry wa|25333
# getarg WA
# getarg prsna
        movq WA,prsna
# ||mov|7,xr|21,=tmasb||; point to asterisks|25334
# getarg W0
# getarg XR
        .data
l_0898: .long tmasb
        .text
        movq l_0898,W0
        movq W0,XR
# ||jsr|6,prtst|||; print asterisks|25335
# getarg prtst
        call prtst
# ||mov|3,profs|18,=num04||; point into middle of asterisks|25336
# getarg W0
# getarg profs
        movq l_0729,W0
        movq W0,profs
# ||mti|3,kvstn|||; load statement number as integer|25337
# getarg kvstn
        mov  kvstn,IA
# ||jsr|6,prtin|||; print integer statement number|25338
# getarg prtin
        call prtin
# ||mov|3,profs|18,=prsnf||; point past asterisks plus blank|25339
# getarg W0
# getarg profs
        .data
l_0899: .long prsnf
        .text
        movq l_0899,W0
        movq W0,profs
# ||mov|7,xr|3,kvfnc||; get fnclevel|25340
# getarg kvfnc
# getarg XR
        movq kvfnc,XR
# ||mov|8,wa|18,=ch_li||; set letter i|25341
# getarg W0
# getarg WA
        movq l_0713,W0
        movq W0,WA
# |prsn1|bze|7,xr|6,prsn2||; jump if all set|25345
prsn1:
# getarg XR
# getarg prsn2
        or   XR,XR
        jz   prsn2
# ||jsr|6,prtch|||; else print an i|25346
# getarg prtch
        call prtch
# ||dcv|7,xr|||; decrement counter|25347
# getarg XR
        decq XR
# ||brn|6,prsn1|||; loop back|25348
# getarg prsn1
        jmp  prsn1
# |prsn2|mov|8,wa|18,=ch_bl||; get blank|25352
prsn2:
# getarg W0
# getarg WA
        movq l_0572,W0
        movq W0,WA
# ||jsr|6,prtch|||; print blank|25353
# getarg prtch
        call prtch
# ||mov|8,wa|3,prsna||; restore entry wa|25354
# getarg prsna
# getarg WA
        movq prsna,WA
# ||mov|7,xr|10,(xs)+||; restore entry xr|25355
# getarg XR
        pop  XR
# ||exi||||; return to prtsn caller|25356
# getarg 
        ret
# ||enp||||; end procedure prtsn|25357
# ||ejc|||||25358
# |prtst|prc|25,r|1,0||; entry point|25373
prtst:
# getarg 0
# ||bnz|3,headp|6,prst0||; were headers printed|25374
# getarg headp
# getarg prst0
        xor  W0,W0
        cmpq headp,W0
        jnz  prst0
# ||jsr|6,prtps|||; no - print them|25375
# getarg prtps
        call prtps
# |prst0|mov|3,prsva|8,wa||; save wa|25379
prst0:
# getarg WA
# getarg prsva
        movq WA,prsva
# ||mov|3,prsvb|8,wb||; save wb|25380
# getarg WB
# getarg prsvb
        movq WB,prsvb
# ||zer|8,wb|||; set chars printed count to zero|25381
# getarg WB
        xor  WB,WB
# |prst1|mov|8,wa|13,sclen(xr)||; load string length|25385
prst1:
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||sub|8,wa|8,wb||; subtract count of chars already out|25386
# getarg WB
# getarg WA
        subq WB,WA
# ||bze|8,wa|6,prst4||; jump to exit if none left|25387
# getarg WA
# getarg prst4
        or   WA,WA
        jz   prst4
# ||mov|11,-(xs)|7,xl||; else stack entry xl|25388
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; save argument|25389
# getarg XR
        push XR
# ||mov|7,xl|7,xr||; copy for eventual move|25390
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|3,prlen||; load print buffer length|25391
# getarg prlen
# getarg XR
        movq prlen,XR
# ||sub|7,xr|3,profs||; get chars left in print buffer|25392
# getarg profs
# getarg XR
        subq profs,XR
# ||bnz|7,xr|6,prst2||; skip if room left on this line|25393
# getarg XR
# getarg XR
# getarg prst2
        or   XR,XR
        jnz  prst2
# ||jsr|6,prtnl|||; else print this line|25394
# getarg prtnl
        call prtnl
# ||mov|7,xr|3,prlen||; and set full width available|25395
# getarg prlen
# getarg XR
        movq prlen,XR
# ||ejc|||||25396
# |prst2|blo|8,wa|7,xr|6,prst3|; jump if room for rest of string|25402
prst2:
# getarg WA
# getarg XR
# getarg prst3
        cmpq WA,XR
        jb   prst3
# ||mov|8,wa|7,xr||; else set to fill line|25403
# getarg XR
# getarg WA
        movq XR,WA
# |prst3|mov|7,xr|3,prbuf||; point to print buffer|25407
prst3:
# getarg prbuf
# getarg XR
        movq prbuf,XR
# ||plc|7,xl|8,wb||; point to location in string|25408
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||psc|7,xr|3,profs||; point to location in buffer|25409
# getarg XR
# getarg profs
        add  $cfp_f,XR
        add  profs,XR
# ||add|8,wb|8,wa||; bump string chars count|25410
# getarg WA
# getarg WB
        addq WA,WB
# ||add|3,profs|8,wa||; bump buffer pointer|25411
# getarg WA
# getarg profs
        addq WA,profs
# ||mov|3,prsvc|8,wb||; preserve char counter|25412
# getarg WB
# getarg prsvc
        movq WB,prsvc
# ||mvc||||; move characters to buffer|25413
        rep
        movsb
# ||mov|8,wb|3,prsvc||; recover char counter|25414
# getarg prsvc
# getarg WB
        movq prsvc,WB
# ||mov|7,xr|10,(xs)+||; restore argument pointer|25415
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; restore entry xl|25416
# getarg XL
        pop  XL
# ||brn|6,prst1|||; loop back to test for more|25417
# getarg prst1
        jmp  prst1
# |prst4|mov|8,wb|3,prsvb||; restore entry wb|25421
prst4:
# getarg prsvb
# getarg WB
        movq prsvb,WB
# ||mov|8,wa|3,prsva||; restore entry wa|25422
# getarg prsva
# getarg WA
        movq prsva,WA
# ||exi||||; return to prtst caller|25423
# getarg 
        ret
# ||enp||||; end procedure prtst|25424
# ||ejc|||||25425
# |prttr|prc|25,e|1,0||; entry point|25435
prttr:
# getarg 0
# ||mov|11,-(xs)|7,xr||; save xr|25436
# getarg XR
        push XR
# ||jsr|6,prtic|||; print buffer contents|25437
# getarg prtic
        call prtic
# ||mov|7,xr|3,prbuf||; point to print bfr to clear it|25438
# getarg prbuf
# getarg XR
        movq prbuf,XR
# ||lct|8,wa|3,prlnw||; get buffer length|25439
# getarg WA
# getarg prlnw
        mov  WA,prlnw
# ||add|7,xr|19,*schar||; point past scblk header|25440
# getarg W0
# getarg XR
        movq l_0817,W0
        addq W0,XR
# ||mov|8,wb|4,nullw||; get blanks|25441
# getarg nullw
# getarg WB
        movq nullw,WB
# |prtt1|mov|10,(xr)+|8,wb||; clear a word|25445
prtt1:
# getarg WB
        movq WB,W0
        stosq
# ||bct|8,wa|6,prtt1||; loop|25446
# getarg WA
# getarg prtt1
        decq WA
        jnz  prtt1
# ||zer|3,profs|||; reset profs|25447
# getarg profs
        mov  $0,W0
        mov  W0,profs
# ||mov|7,xr|10,(xs)+||; restore xr|25448
# getarg XR
        pop  XR
# ||exi||||; return|25449
# getarg 
        ret
# ||enp||||; end procedure prttr|25450
# ||ejc|||||25451
# |prtvl|prc|25,r|1,0||; entry point, recursive|25462
prtvl:
# getarg 0
# ||mov|11,-(xs)|7,xl||; save entry xl|25463
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; save argument|25464
# getarg XR
        push XR
# ||chk||||; check for stack overflow|25465
        chk_
        or   W0,W0
        jne  sec06
# |prv01|mov|3,prvsi|13,idval(xr)||; copy idval (if any)|25469
prv01:
# getarg idval(,XR,8)
# getarg W0
# getarg prvsi
        movq idval(,XR,8),W0
        movq W0,prvsi
# ||mov|7,xl|9,(xr)||; load first word of block|25470
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||lei|7,xl|||; load entry point id|25471
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||bsw|7,xl|2,bl__t|6,prv02|; switch on block type|25472
# getarg XL
# getarg bl__t
# getarg prv02
        cmpq XL,bl__t
        jge  prv02
        jmp  *l_0901(,XL,8)
        .data
l_0901:
# ||iff|2,bl_ar|6,prv05||; arblk|25490
# getarg prv05
        .long prv05
# ||iff|1,1|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|1,2|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|2,bl_ic|6,prv08||; icblk|25490
# getarg prv08
        .long prv08
# ||iff|2,bl_nm|6,prv09||; nmblk|25490
# getarg prv09
        .long prv09
# ||iff|1,5|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|1,6|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|1,7|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|2,bl_rc|6,prv08||; rcblk|25490
# getarg prv08
        .long prv08
# ||iff|2,bl_sc|6,prv11||; scblk|25490
# getarg prv11
        .long prv11
# ||iff|2,bl_se|6,prv12||; seblk|25490
# getarg prv12
        .long prv12
# ||iff|2,bl_tb|6,prv13||; tbblk|25490
# getarg prv13
        .long prv13
# ||iff|2,bl_vc|6,prv13||; vcblk|25490
# getarg prv13
        .long prv13
# ||iff|1,13|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|1,14|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|1,15|6,prv02|||25490
# getarg prv02
        .long prv02
# ||iff|2,bl_pd|6,prv10||; pdblk|25490
# getarg prv10
        .long prv10
# ||iff|2,bl_tr|6,prv04||; trblk|25490
# getarg prv04
        .long prv04
# ||esw||||; end of switch on block type|25490
        .text
# |prv02|jsr|6,dtype|||; get datatype name|25494
prv02:
# getarg dtype
        call dtype
# ||jsr|6,prtst|||; print datatype name|25495
# getarg prtst
        call prtst
# |prv03|mov|7,xr|10,(xs)+||; reload argument|25499
prv03:
# getarg XR
        pop  XR
# ||mov|7,xl|10,(xs)+||; restore xl|25500
# getarg XL
        pop  XL
# ||exi||||; return to prtvl caller|25501
# getarg 
        ret
# |prv04|mov|7,xr|13,trval(xr)||; load real value|25505
prv04:
# getarg trval(,XR,8)
# getarg XR
        movq trval(,XR,8),XR
# ||brn|6,prv01|||; and loop back|25506
# getarg prv01
        jmp  prv01
# ||ejc|||||25507
# |prv05|mov|7,xl|7,xr||; preserve argument|25515
prv05:
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|7,xr|21,=scarr||; point to datatype name (array)|25516
# getarg W0
# getarg XR
        .data
l_0902: .long scarr
        .text
        movq l_0902,W0
        movq W0,XR
# ||jsr|6,prtst|||; print it|25517
# getarg prtst
        call prtst
# ||mov|8,wa|18,=ch_pp||; load left paren|25518
# getarg W0
# getarg WA
        movq l_0158,W0
        movq W0,WA
# ||jsr|6,prtch|||; print left paren|25519
# getarg prtch
        call prtch
# ||add|7,xl|13,arofs(xl)||; point to prototype|25520
# getarg arofs(,XL,8)
# getarg XL
        addq arofs(,XL,8),XL
# ||mov|7,xr|9,(xl)||; load prototype|25521
# getarg (XL)
# getarg XR
        movq (XL),XR
# ||jsr|6,prtst|||; print prototype|25522
# getarg prtst
        call prtst
# |prv06|mov|8,wa|18,=ch_rp||; load right paren|25526
prv06:
# getarg W0
# getarg WA
        movq l_0160,W0
        movq W0,WA
# ||jsr|6,prtch|||; print right paren|25527
# getarg prtch
        call prtch
# |prv07|mov|8,wa|18,=ch_bl||; load blank|25531
prv07:
# getarg W0
# getarg WA
        movq l_0572,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|25532
# getarg prtch
        call prtch
# ||mov|8,wa|18,=ch_nm||; load number sign|25533
# getarg W0
# getarg WA
        .data
l_0903: .long ch_nm
        .text
        movq l_0903,W0
        movq W0,WA
# ||jsr|6,prtch|||; print it|25534
# getarg prtch
        call prtch
# ||mti|3,prvsi|||; get idval|25535
# getarg prvsi
        mov  prvsi,IA
# ||jsr|6,prtin|||; print id number|25536
# getarg prtin
        call prtin
# ||brn|6,prv03|||; back to exit|25537
# getarg prv03
        jmp  prv03
# |prv08|mov|11,-(xs)|7,xr||; stack argument for gtstg|25543
prv08:
# getarg XR
        push XR
# ||jsr|6,gtstg|||; convert to string|25544
# getarg gtstg
        call gtstg
        decq rcode
        js   call_264
# ||ppm||||; error return is impossible|25545
# getarg 
        decq rcode
        jns  l_0904
        movq $299,rcode
        jmp  err_
l_0904:
call_264:
# ||jsr|6,prtst|||; print the string|25546
# getarg prtst
        call prtst
# ||mov|3,dnamp|7,xr||; delete garbage string from storage|25547
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||brn|6,prv03|||; back to exit|25548
# getarg prv03
        jmp  prv03
# ||ejc|||||25549
# |prv09|mov|7,xl|13,nmbas(xr)||; load name base|25558
prv09:
# getarg nmbas(,XR,8)
# getarg XL
        movq nmbas(,XR,8),XL
# ||mov|8,wa|9,(xl)||; load first word of block|25559
# getarg (XL)
# getarg WA
        movq (XL),WA
# ||beq|8,wa|22,=b_kvt|6,prv02|; just print name if keyword|25560
# getarg WA
# getarg W0
# getarg prv02
        movq l_0745,W0
        cmpq WA,W0
        je   prv02
# ||beq|8,wa|22,=b_evt|6,prv02|; just print name if expression var|25561
# getarg WA
# getarg W0
# getarg prv02
        movq l_0118,W0
        cmpq WA,W0
        je   prv02
# ||mov|8,wa|18,=ch_dt||; else get dot|25562
# getarg W0
# getarg WA
        movq l_0807,W0
        movq W0,WA
# ||jsr|6,prtch|||; and print it|25563
# getarg prtch
        call prtch
# ||mov|8,wa|13,nmofs(xr)||; load name offset|25564
# getarg nmofs(,XR,8)
# getarg WA
        movq nmofs(,XR,8),WA
# ||jsr|6,prtnm|||; print name|25565
# getarg prtnm
        call prtnm
# ||brn|6,prv03|||; back to exit|25566
# getarg prv03
        jmp  prv03
# |prv10|jsr|6,dtype|||; get datatype name|25572
prv10:
# getarg dtype
        call dtype
# ||jsr|6,prtst|||; print datatype name|25573
# getarg prtst
        call prtst
# ||brn|6,prv07|||; merge back to print id|25574
# getarg prv07
        jmp  prv07
# |prv11|mov|8,wa|18,=ch_sq||; load single quote|25580
prv11:
# getarg W0
# getarg WA
        .data
l_0905: .long ch_sq
        .text
        movq l_0905,W0
        movq W0,WA
# ||jsr|6,prtch|||; print quote|25581
# getarg prtch
        call prtch
# ||jsr|6,prtst|||; print string value|25582
# getarg prtst
        call prtst
# ||jsr|6,prtch|||; print another quote|25583
# getarg prtch
        call prtch
# ||brn|6,prv03|||; back to exit|25584
# getarg prv03
        jmp  prv03
# ||ejc|||||25585
# |prv12|mov|8,wa|18,=ch_as||; load asterisk|25593
prv12:
# getarg W0
# getarg WA
        movq l_0688,W0
        movq W0,WA
# ||jsr|6,prtch|||; print asterisk|25594
# getarg prtch
        call prtch
# ||mov|7,xr|13,sevar(xr)||; load variable pointer|25595
# getarg sevar(,XR,8)
# getarg XR
        movq sevar(,XR,8),XR
# ||jsr|6,prtvn|||; print variable name|25596
# getarg prtvn
        call prtvn
# ||brn|6,prv03|||; jump back to exit|25597
# getarg prv03
        jmp  prv03
# |prv13|mov|7,xl|7,xr||; preserve argument|25603
prv13:
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,dtype|||; get datatype name|25604
# getarg dtype
        call dtype
# ||jsr|6,prtst|||; print datatype name|25605
# getarg prtst
        call prtst
# ||mov|8,wa|18,=ch_pp||; load left paren|25606
# getarg W0
# getarg WA
        movq l_0158,W0
        movq W0,WA
# ||jsr|6,prtch|||; print left paren|25607
# getarg prtch
        call prtch
# ||mov|8,wa|13,tblen(xl)||; load length of block (=vclen)|25608
# getarg tblen(,XL,8)
# getarg WA
        movq tblen(,XL,8),WA
# ||btw|8,wa|||; convert to word count|25609
# getarg WA
        shr  WA,3
# ||sub|8,wa|18,=tbsi_||; allow for standard fields|25610
# getarg W0
# getarg WA
        movq l_0285,W0
        subq W0,WA
# ||beq|9,(xl)|22,=b_tbt|6,prv14|; jump if table|25611
# getarg (XL)
# getarg W0
# getarg prv14
        movq l_0086,W0
        cmpq (XL),W0
        je   prv14
# ||add|8,wa|18,=vctbd||; for vcblk, adjust size|25612
# getarg W0
# getarg WA
        .data
l_0906: .long vctbd
        .text
        movq l_0906,W0
        addq W0,WA
# |prv14|mti|8,wa|||; move as integer|25616
prv14:
# getarg WA
        mov  WA,IA
# ||jsr|6,prtin|||; print integer prototype|25617
# getarg prtin
        call prtin
# ||brn|6,prv06|||; merge back for rest|25618
# getarg prv06
        jmp  prv06
# ||enp||||; end procedure prtvl|25641
# ||ejc|||||25642
# |prtvn|prc|25,e|1,0||; entry point|25651
prtvn:
# getarg 0
# ||mov|11,-(xs)|7,xr||; stack vrblk pointer|25652
# getarg XR
        push XR
# ||add|7,xr|19,*vrsof||; point to possible string name|25653
# getarg W0
# getarg XR
        movq l_0738,W0
        addq W0,XR
# ||bnz|13,sclen(xr)|6,prvn1||; jump if not system variable|25654
# getarg sclen(,XR,8)
# getarg prvn1
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jnz  prvn1
# ||mov|7,xr|13,vrsvo(xr)||; point to svblk with name|25655
# getarg vrsvo(,XR,8)
# getarg XR
        movq vrsvo(,XR,8),XR
# |prvn1|jsr|6,prtst|||; print string name of variable|25659
prvn1:
# getarg prtst
        call prtst
# ||mov|7,xr|10,(xs)+||; restore vrblk pointer|25660
# getarg XR
        pop  XR
# ||exi||||; return to prtvn caller|25661
# getarg 
        ret
# ||enp||||; end procedure prtvn|25662
# ||ejc|||||25665
# |rcbld|prc|25,e|1,0||; entry point|25674
rcbld:
# getarg 0
# ||mov|7,xr|3,dnamp||; load pointer to next available loc|25675
# getarg dnamp
# getarg XR
        movq dnamp,XR
# ||add|7,xr|19,*rcsi_||; point past new rcblk|25676
# getarg W0
# getarg XR
        movq l_0629,W0
        addq W0,XR
# ||blo|7,xr|3,dname|6,rcbl1|; jump if there is room|25677
# getarg XR
# getarg dname
# getarg rcbl1
        cmpq XR,dname
        jb   rcbl1
# ||mov|8,wa|19,*rcsi_||; else load rcblk length|25678
# getarg W0
# getarg WA
        movq l_0629,W0
        movq W0,WA
# ||jsr|6,alloc|||; use standard allocator to get block|25679
# getarg alloc
        call alloc
# ||add|7,xr|8,wa||; point past block to merge|25680
# getarg WA
# getarg XR
        addq WA,XR
# |rcbl1|mov|3,dnamp|7,xr||; set new pointer|25684
rcbl1:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||sub|7,xr|19,*rcsi_||; point back to start of block|25685
# getarg W0
# getarg XR
        movq l_0629,W0
        subq W0,XR
# ||mov|9,(xr)|22,=b_rcl||; store type word|25686
# getarg W0
# getarg (XR)
        movq l_0101,W0
        movq W0,(XR)
# ||str|13,rcval(xr)|||; store real value in rcblk|25687
        mov  XR,W0
        add  8*rcval,W0
        movq l_0103,W0
        call str_
# ||exi||||; return to rcbld caller|25688
# getarg 
        ret
# ||enp||||; end procedure rcbld|25689
# ||ejc|||||25691
# |readr|prc|25,e|1,0||; entry point|25705
readr:
# getarg 0
# ||mov|7,xr|3,r_cni||; get ptr to next image|25706
# getarg r_cni
# getarg XR
        movq r_cni,XR
# ||bnz|7,xr|6,read3||; exit if already read|25707
# getarg XR
# getarg XR
# getarg read3
        or   XR,XR
        jnz  read3
# ||bnz|3,cnind|6,reada||; if within include file|25709
# getarg cnind
# getarg reada
        xor  W0,W0
        cmpq cnind,W0
        jnz  reada
# ||bne|3,stage|18,=stgic|6,read3|; exit if not initial compile|25711
# getarg stage
# getarg W0
# getarg read3
        movq l_0053,W0
        cmpq stage,W0
        jne  read3
# |reada|mov|8,wa|3,cswin||; max read length|25712
reada:
# getarg cswin
# getarg WA
        movq cswin,WA
# ||zer|7,xl|||; clear any dud value in xl|25713
# getarg XL
        xor  XL,XL
# ||jsr|6,alocs|||; allocate buffer|25714
# getarg alocs
        call alocs
# ||jsr|6,sysrd|||; read input image|25715
# getarg sysrd
        call sysrd
        decq rcode
        js   call_265
# ||ppm|6,read4|||; jump if eof or new file name|25716
# getarg read4
# getarg read4
        decq rcode
        jns  l_0907
        jmp  read4
l_0907:
call_265:
# ||icv|3,rdnln|||; increment next line number|25717
# getarg rdnln
        incq rdnln
# ||dcv|3,polct|||; test if time to poll interface|25719
# getarg polct
        decq polct
# ||bnz|3,polct|6,read0||; not yet|25720
# getarg polct
# getarg read0
        xor  W0,W0
        cmpq polct,W0
        jnz  read0
# ||zer|8,wa|||; =0 for poll|25721
# getarg WA
        xor  WA,WA
# ||mov|8,wb|3,rdnln||; line number|25722
# getarg rdnln
# getarg WB
        movq rdnln,WB
# ||jsr|6,syspl|||; allow interactive access|25723
# getarg syspl
        call syspl
        decq rcode
        js   call_266
# ||err|1,320|26,user interrupt|||25724
# getarg 320
        decq rcode
        jns  l_0908
        movq $320,rcode
        jmp  err_
l_0908:
# ||ppm||||; single step|25725
# getarg 
        decq rcode
        jns  l_0909
        movq $299,rcode
        jmp  err_
l_0909:
# ||ppm||||; expression evaluation|25726
# getarg 
        decq rcode
        jns  l_0910
        movq $299,rcode
        jmp  err_
l_0910:
call_266:
# ||mov|3,polcs|8,wa||; new countdown start value|25727
# getarg WA
# getarg polcs
        movq WA,polcs
# ||mov|3,polct|8,wa||; new counter value|25728
# getarg WA
# getarg polct
        movq WA,polct
# |read0|ble|13,sclen(xr)|3,cswin|6,read1|; use smaller of string lnth ...|25730
read0:
# getarg cswin
# getarg sclen(,XR,8)
# getarg W0
# getarg read1
        movq cswin,W0
        cmpq sclen(,XR,8),W0
        jbe  read1
# ||mov|13,sclen(xr)|3,cswin||; ... and xxx of -inxxx|25731
# getarg cswin
# getarg W0
# getarg sclen(,XR,8)
        movq cswin,W0
        movq W0,sclen(,XR,8)
# |read1|mnz|8,wb|||; set trimr to perform trim|25735
read1:
# getarg WB
        mov  XS,WB
# ||jsr|6,trimr|||; trim trailing blanks|25736
# getarg trimr
        call trimr
# |read2|mov|3,r_cni|7,xr||; store copy of pointer|25740
read2:
# getarg XR
# getarg r_cni
        movq XR,r_cni
# |read3|exi||||; return to readr caller|25744
read3:
# getarg 
        ret
# |read4|bze|13,sclen(xr)|6,read5||; jump if true end of file|25753
read4:
# getarg sclen(,XR,8)
# getarg read5
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jz   read5
# ||zer|8,wb|||; new source file name|25754
# getarg WB
        xor  WB,WB
# ||mov|3,rdnln|8,wb||; restart line counter for new file|25755
# getarg WB
# getarg rdnln
        movq WB,rdnln
# ||jsr|6,trimr|||; remove unused space in block|25756
# getarg trimr
        call trimr
# ||jsr|6,newfn|||; record new file name|25757
# getarg newfn
        call newfn
# ||brn|6,reada|||; now reissue read for record data|25758
# getarg reada
        jmp  reada
# |read5|mov|3,dnamp|7,xr||; pop unused scblk|25762
read5:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||bze|3,cnind|6,read6||; jump if not within an include file|25764
# getarg cnind
# getarg read6
        xor  W0,W0
        cmpq cnind,W0
        jz   read6
# ||zer|7,xl|||; eof within include file|25765
# getarg XL
        xor  XL,XL
# ||jsr|6,sysif|||; switch stream back to previous file|25766
# getarg sysif
        call sysif
        decq rcode
        js   call_267
# ||ppm|||||25767
# getarg 
        decq rcode
        jns  l_0911
        movq $299,rcode
        jmp  err_
l_0911:
call_267:
# ||mov|8,wa|3,cnind||; restore prev line number, file name|25768
# getarg cnind
# getarg WA
        movq cnind,WA
# ||add|8,wa|18,=vcvlb||; vector offset in words|25769
# getarg W0
# getarg WA
        movq l_0088,W0
        addq W0,WA
# ||wtb|8,wa|||; convert to bytes|25770
# getarg WA
        sal  WA,3
# ||mov|7,xr|3,r_ifa||; file name array|25771
# getarg r_ifa
# getarg XR
        movq r_ifa,XR
# ||add|7,xr|8,wa||; ptr to element|25772
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|3,r_sfc|9,(xr)||; change source file name|25773
# getarg (XR)
# getarg W0
# getarg r_sfc
        movq (XR),W0
        movq W0,r_sfc
# ||mov|9,(xr)|21,=nulls||; release scblk|25774
# getarg W0
# getarg (XR)
        movq l_0054,W0
        movq W0,(XR)
# ||mov|7,xr|3,r_ifl||; line number array|25775
# getarg r_ifl
# getarg XR
        movq r_ifl,XR
# ||add|7,xr|8,wa||; ptr to element|25776
# getarg WA
# getarg XR
        addq WA,XR
# ||mov|7,xl|9,(xr)||; icblk containing saved line number|25777
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||ldi|13,icval(xl)|||; line number integer|25778
# getarg icval(,XL,8)
        mov  icval(,XL,8),IA
# ||mfi|3,rdnln|||; change source line number|25779
# getarg rdnln
        mov  IA,rdnln
# ||mov|9,(xr)|21,=inton||; release icblk|25780
# getarg W0
# getarg (XR)
        movq l_0063,W0
        movq W0,(XR)
# ||dcv|3,cnind|||; decrement nesting level|25781
# getarg cnind
        decq cnind
# ||mov|8,wb|3,cmpsn||; current statement number|25782
# getarg cmpsn
# getarg WB
        movq cmpsn,WB
# ||icv|8,wb|||; anticipate end of previous stmt|25783
# getarg WB
        incq WB
# ||mti|8,wb|||; convert to integer|25784
# getarg WB
        mov  WB,IA
# ||jsr|6,icbld|||; build icblk for stmt number|25785
# getarg icbld
        call icbld
# ||mov|7,xl|3,r_sfn||; file name table|25786
# getarg r_sfn
# getarg XL
        movq r_sfn,XL
# ||mnz|8,wb|||; lookup statement number by name|25787
# getarg WB
        mov  XS,WB
# ||jsr|6,tfind|||; allocate new teblk|25788
# getarg tfind
        call tfind
        decq rcode
        js   call_268
# ||ppm||||; always possible to allocate block|25789
# getarg 
        decq rcode
        jns  l_0912
        movq $299,rcode
        jmp  err_
l_0912:
call_268:
# ||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|25790
# getarg r_sfc
# getarg W0
# getarg teval(,XL,8)
        movq r_sfc,W0
        movq W0,teval(,XL,8)
# ||beq|3,stage|18,=stgic|6,reada|; if initial compile, reissue read|25791
# getarg stage
# getarg W0
# getarg reada
        movq l_0053,W0
        cmpq stage,W0
        je   reada
# ||bnz|3,cnind|6,reada||; still reading from include file|25792
# getarg cnind
# getarg reada
        xor  W0,W0
        cmpq cnind,W0
        jnz  reada
# ||mov|7,xl|3,r_ici||; restore code argument string|25797
# getarg r_ici
# getarg XL
        movq r_ici,XL
# ||zer|3,r_ici|||; release original string|25798
# getarg r_ici
        mov  $0,W0
        mov  W0,r_ici
# ||mov|8,wa|3,cnsil||; get length of string|25799
# getarg cnsil
# getarg WA
        movq cnsil,WA
# ||mov|8,wb|3,cnspt||; offset of characters left|25800
# getarg cnspt
# getarg WB
        movq cnspt,WB
# ||sub|8,wa|8,wb||; number of characters left|25801
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|3,scnil|8,wa||; set new scan length|25802
# getarg WA
# getarg scnil
        movq WA,scnil
# ||zer|3,scnpt|||; scan from start of substring|25803
# getarg scnpt
        mov  $0,W0
        mov  W0,scnpt
# ||jsr|6,sbstr|||; create substring of remainder|25804
# getarg sbstr
        call sbstr
# ||mov|3,r_cim|7,xr||; set scan image|25805
# getarg XR
# getarg r_cim
        movq XR,r_cim
# ||brn|6,read2|||; return|25806
# getarg read2
        jmp  read2
# |read6|zer|7,xr|||; zero ptr as result|25822
read6:
# getarg XR
        xor  XR,XR
# ||brn|6,read2|||; merge|25823
# getarg read2
        jmp  read2
# ||enp||||; end procedure readr|25824
# ||ejc|||||25825
# |sbstr|prc|25,e|1,0||; entry point|25920
sbstr:
# getarg 0
# ||bze|8,wa|6,sbst2||; jump if null substring|25921
# getarg WA
# getarg sbst2
        or   WA,WA
        jz   sbst2
# ||jsr|6,alocs|||; else allocate scblk|25922
# getarg alocs
        call alocs
# ||mov|8,wa|8,wc||; move number of characters|25923
# getarg WC
# getarg WA
        movq WC,WA
# ||mov|8,wc|7,xr||; save ptr to new scblk|25924
# getarg XR
# getarg WC
        movq XR,WC
# ||plc|7,xl|8,wb||; prepare to load chars from old blk|25925
# getarg XL
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||psc|7,xr|||; prepare to store chars in new blk|25926
# getarg XR
        add  $cfp_f,XR
# ||mvc||||; move characters to new string|25927
        rep
        movsb
# ||mov|7,xr|8,wc||; then restore scblk pointer|25928
# getarg WC
# getarg XR
        movq WC,XR
# |sbst1|zer|7,xl|||; clear garbage pointer in xl|25932
sbst1:
# getarg XL
        xor  XL,XL
# ||exi||||; return to sbstr caller|25933
# getarg 
        ret
# |sbst2|mov|7,xr|21,=nulls||; set null string as result|25937
sbst2:
# getarg W0
# getarg XR
        movq l_0054,W0
        movq W0,XR
# ||brn|6,sbst1|||; return|25938
# getarg sbst1
        jmp  sbst1
# ||enp||||; end procedure sbstr|25939
# ||ejc|||||25940
# |stgcc|prc|25,e|1,0||;|25951
stgcc:
# getarg 0
# ||mov|8,wa|3,polcs||; assume no profiling or stcount tracing|25953
# getarg polcs
# getarg WA
        movq polcs,WA
# ||mov|8,wb|18,=num01||; poll each time polcs expires|25954
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||ldi|3,kvstl|||; get stmt limit|25958
# getarg kvstl
        mov  kvstl,IA
# ||bnz|3,kvpfl|6,stgc1||; jump if profiling enabled|25959
# getarg kvpfl
# getarg stgc1
        xor  W0,W0
        cmpq kvpfl,W0
        jnz  stgc1
# ||ilt|6,stgc3|||; no stcount tracing if negative|25960
# getarg stgc3
        mov  IA,W0
        or   W0,W0
        jl   stgc3
# ||bze|3,r_stc|6,stgc2||; jump if not stcount tracing|25961
# getarg r_stc
# getarg stgc2
        xor  W0,W0
        cmpq r_stc,W0
        jz   stgc2
# |stgc1|mov|8,wb|8,wa||; count polcs times within stmg|25966
stgc1:
# getarg WA
# getarg WB
        movq WA,WB
# ||mov|8,wa|18,=num01||; break out of stmgo on each stmt|25967
# getarg W0
# getarg WA
        movq l_0060,W0
        movq W0,WA
# ||brn|6,stgc3|||;|25971
# getarg stgc3
        jmp  stgc3
# |stgc2|mti|8,wa|||; breakout count start value|25975
stgc2:
# getarg WA
        mov  WA,IA
# ||sbi|3,kvstl|||; proposed stmcs minus stmt limit|25976
# getarg kvstl
        sub  kvstl,IA
        xor  W0,W0
        seto reg_fl
# ||ile|6,stgc3|||; jump if stmt count does not limit|25977
# getarg stgc3
        mov  IA,W0
        or   W0,W0
        jle  stgc3
# ||ldi|3,kvstl|||; stlimit limits breakcount count|25978
# getarg kvstl
        mov  kvstl,IA
# ||mfi|8,wa|||; use it instead|25979
# getarg WA
        mov  IA,WA
# |stgc3|mov|3,stmcs|8,wa||; update breakout count start value|25983
stgc3:
# getarg WA
# getarg stmcs
        movq WA,stmcs
# ||mov|3,stmct|8,wa||; reset breakout counter|25984
# getarg WA
# getarg stmct
        movq WA,stmct
# ||mov|3,polct|8,wb||;|25986
# getarg WB
# getarg polct
        movq WB,polct
# ||exi|||||25988
# getarg 
        ret
# ||ejc|||||25989
# |tfind|prc|25,e|1,1||; entry point|26008
tfind:
# getarg 1
# ||mov|11,-(xs)|8,wb||; save name/value indicator|26009
# getarg WB
        push WB
# ||mov|11,-(xs)|7,xr||; save subscript value|26010
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xl||; save table pointer|26011
# getarg XL
        push XL
# ||mov|8,wa|13,tblen(xl)||; load length of tbblk|26012
# getarg tblen(,XL,8)
# getarg WA
        movq tblen(,XL,8),WA
# ||btw|8,wa|||; convert to word count|26013
# getarg WA
        shr  WA,3
# ||sub|8,wa|18,=tbbuk||; get number of buckets|26014
# getarg W0
# getarg WA
        .data
l_0914: .long tbbuk
        .text
        movq l_0914,W0
        subq W0,WA
# ||mti|8,wa|||; convert to integer value|26015
# getarg WA
        mov  WA,IA
# ||sti|3,tfnsi|||; save for later|26016
# getarg tfnsi
        mov  IA,tfnsi
# ||mov|7,xl|9,(xr)||; load first word of subscript|26017
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||lei|7,xl|||; load block entry id (bl_xx)|26018
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||bsw|7,xl|2,bl__d|6,tfn00|; switch on block type|26019
# getarg XL
# getarg bl__d
# getarg tfn00
        cmpq XL,bl__d
        jge  tfn00
        jmp  *l_0915(,XL,8)
        .data
l_0915:
# ||iff|1,0|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,1|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,2|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|2,bl_ic|6,tfn02||; jump if integer|26030
# getarg tfn02
        .long tfn02
# ||iff|2,bl_nm|6,tfn04||; jump if name|26030
# getarg tfn04
        .long tfn04
# ||iff|2,bl_p0|6,tfn03||; jump if pattern|26030
# getarg tfn03
        .long tfn03
# ||iff|2,bl_p1|6,tfn03||; jump if pattern|26030
# getarg tfn03
        .long tfn03
# ||iff|2,bl_p2|6,tfn03||; jump if pattern|26030
# getarg tfn03
        .long tfn03
# ||iff|2,bl_rc|6,tfn02||; real|26030
# getarg tfn02
        .long tfn02
# ||iff|2,bl_sc|6,tfn05||; jump if string|26030
# getarg tfn05
        .long tfn05
# ||iff|1,10|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,11|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,12|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,13|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,14|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,15|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||iff|1,16|6,tfn00|||26030
# getarg tfn00
        .long tfn00
# ||esw||||; end switch on block type|26030
        .text
# |tfn00|mov|8,wa|12,1(xr)||; load second word|26035
tfn00:
# getarg 1(,XR,8)
# getarg WA
        movq 1(,XR,8),WA
# |tfn01|mti|8,wa|||; convert to integer|26039
tfn01:
# getarg WA
        mov  WA,IA
# ||brn|6,tfn06|||; jump to merge|26040
# getarg tfn06
        jmp  tfn06
# ||ejc|||||26041
# |tfn02|ldi|12,1(xr)|||; load value as hash source|26051
tfn02:
# getarg 1(,XR,8)
        mov  1(,XR,8),IA
# ||ige|6,tfn06|||; ok if positive or zero|26052
# getarg tfn06
        mov  IA,W0
        or   W0,W0
        jge  tfn06
# ||ngi||||; make positive|26053
        neg  IA
        seto reg_fl
# ||iov|6,tfn06|||; clear possible overflow|26054
# getarg tfn06
        iov_ tfn06
# ||brn|6,tfn06|||; merge|26055
# getarg tfn06
        jmp  tfn06
# |tfn03|mov|8,wa|9,(xr)||; load first word as hash source|26059
tfn03:
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||brn|6,tfn01|||; merge back|26060
# getarg tfn01
        jmp  tfn01
# |tfn04|mov|8,wa|13,nmofs(xr)||; load offset as hash source|26064
tfn04:
# getarg nmofs(,XR,8)
# getarg WA
        movq nmofs(,XR,8),WA
# ||brn|6,tfn01|||; merge back|26065
# getarg tfn01
        jmp  tfn01
# |tfn05|jsr|6,hashs|||; call routine to compute hash|26069
tfn05:
# getarg hashs
        call hashs
# |tfn06|rmi|3,tfnsi|||; compute hash index by remaindering|26073
tfn06:
# getarg tfnsi
        mov  tfnsi,W0
        call rmi__
# ||mfi|8,wc|||; get as one word integer|26074
# getarg WC
        mov  IA,WC
# ||wtb|8,wc|||; convert to byte offset|26075
# getarg WC
        sal  WC,3
# ||mov|7,xl|9,(xs)||; get table ptr again|26076
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|7,xl|8,wc||; point to proper bucket|26077
# getarg WC
# getarg XL
        addq WC,XL
# ||mov|7,xr|13,tbbuk(xl)||; load first teblk pointer|26078
# getarg tbbuk(,XL,8)
# getarg XR
        movq tbbuk(,XL,8),XR
# ||beq|7,xr|9,(xs)|6,tfn10|; jump if no teblks on chain|26079
# getarg XR
# getarg (XT)
# getarg tfn10
        cmpq XR,(XT)
        je   tfn10
# |tfn07|mov|8,wb|7,xr||; save teblk pointer|26083
tfn07:
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|7,xr|13,tesub(xr)||; load subscript value|26084
# getarg tesub(,XR,8)
# getarg XR
        movq tesub(,XR,8),XR
# ||mov|7,xl|12,1(xs)||; load input argument subscript val|26085
# getarg 1(,XT,8)
# getarg XL
        movq 1(,XT,8),XL
# ||jsr|6,ident|||; compare them|26086
# getarg ident
        call ident
        decq rcode
        js   call_269
# ||ppm|6,tfn08|||; jump if equal (ident)|26087
# getarg tfn08
# getarg tfn08
        decq rcode
        jns  l_0916
        jmp  tfn08
l_0916:
call_269:
# ||mov|7,xl|8,wb||; restore teblk pointer|26091
# getarg WB
# getarg XL
        movq WB,XL
# ||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|26092
# getarg tenxt(,XL,8)
# getarg XR
        movq tenxt(,XL,8),XR
# ||bne|7,xr|9,(xs)|6,tfn07|; jump if there is one|26093
# getarg XR
# getarg (XT)
# getarg tfn07
        cmpq XR,(XT)
        jne  tfn07
# ||mov|8,wc|19,*tenxt||; set offset to link field (xl base)|26097
# getarg W0
# getarg WC
        movq l_0633,W0
        movq W0,WC
# ||brn|6,tfn11|||; jump to merge|26098
# getarg tfn11
        jmp  tfn11
# ||ejc|||||26099
# |tfn08|mov|7,xl|8,wb||; restore teblk pointer|26105
tfn08:
# getarg WB
# getarg XL
        movq WB,XL
# ||mov|8,wa|19,*teval||; set teblk name offset|26106
# getarg W0
# getarg WA
        movq l_0749,W0
        movq W0,WA
# ||mov|8,wb|12,2(xs)||; restore name/value indicator|26107
# getarg 2(,XT,8)
# getarg WB
        movq 2(,XT,8),WB
# ||bnz|8,wb|6,tfn09||; jump if called by name|26108
# getarg WB
# getarg WB
# getarg tfn09
        or   WB,WB
        jnz  tfn09
# ||jsr|6,acess|||; else get value|26109
# getarg acess
        call acess
        decq rcode
        js   call_270
# ||ppm|6,tfn12|||; jump if reference fails|26110
# getarg tfn12
# getarg tfn12
        decq rcode
        jns  l_0917
        jmp  tfn12
l_0917:
call_270:
# ||zer|8,wb|||; restore name/value indicator|26111
# getarg WB
        xor  WB,WB
# |tfn09|add|7,xs|19,*num03||; pop stack entries|26115
tfn09:
# getarg W0
# getarg XT
        movq l_0589,W0
        addq W0,XT
# ||exi||||; return to tfind caller|26116
# getarg 
        movq $0,rcode
        ret
# |tfn10|add|8,wc|19,*tbbuk||; get offset to bucket ptr|26120
tfn10:
# getarg W0
# getarg WC
        movq l_0632,W0
        addq W0,WC
# ||mov|7,xl|9,(xs)||; set tbblk ptr as base|26121
# getarg (XT)
# getarg XL
        movq (XT),XL
# |tfn11|mov|7,xr|9,(xs)||; tbblk pointer|26125
tfn11:
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|7,xr|13,tbinv(xr)||; load default value in case|26126
# getarg tbinv(,XR,8)
# getarg XR
        movq tbinv(,XR,8),XR
# ||mov|8,wb|12,2(xs)||; load name/value indicator|26127
# getarg 2(,XT,8)
# getarg WB
        movq 2(,XT,8),WB
# ||bze|8,wb|6,tfn09||; exit with default if value call|26128
# getarg WB
# getarg tfn09
        or   WB,WB
        jz   tfn09
# ||mov|8,wb|7,xr||; copy default value|26129
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|8,wa|19,*tesi_||; set size of teblk|26133
# getarg W0
# getarg WA
        movq l_0029,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate teblk|26134
# getarg alloc
        call alloc
# ||add|7,xl|8,wc||; point to hash link|26135
# getarg WC
# getarg XL
        addq WC,XL
# ||mov|9,(xl)|7,xr||; link new teblk at end of chain|26136
# getarg XR
# getarg (XL)
        movq XR,(XL)
# ||mov|9,(xr)|22,=b_tet||; store type word|26137
# getarg W0
# getarg (XR)
        movq l_0894,W0
        movq W0,(XR)
# ||mov|13,teval(xr)|8,wb||; set default as initial value|26138
# getarg WB
# getarg teval(,XR,8)
        movq WB,teval(,XR,8)
# ||mov|13,tenxt(xr)|10,(xs)+||; set tbblk ptr to mark end of chain|26139
# getarg tenxt(,XR,8)
        pop  tenxt(,XR,8)
# ||mov|13,tesub(xr)|10,(xs)+||; store subscript value|26140
# getarg tesub(,XR,8)
        pop  tesub(,XR,8)
# ||mov|8,wb|10,(xs)+||; restore name/value indicator|26141
# getarg WB
        pop  WB
# ||mov|7,xl|7,xr||; copy teblk pointer (name base)|26142
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|19,*teval||; set offset|26143
# getarg W0
# getarg WA
        movq l_0749,W0
        movq W0,WA
# ||exi||||; return to caller with new teblk|26144
# getarg 
        movq $0,rcode
        ret
# |tfn12|exi|1,1|||; alternative return|26148
tfn12:
# getarg 1
        movq $1,rcode
        ret
# ||enp||||; end procedure tfind|26149
# ||ejc|||||26150
# |tmake|prc|25,e|1,0||;|26160
tmake:
# getarg 0
# ||mov|8,wa|8,wc||; copy number of headers|26161
# getarg WC
# getarg WA
        movq WC,WA
# ||add|8,wa|18,=tbsi_||; adjust for standard fields|26162
# getarg W0
# getarg WA
        movq l_0285,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|26163
# getarg WA
        sal  WA,3
# ||jsr|6,alloc|||; allocate space for tbblk|26164
# getarg alloc
        call alloc
# ||mov|8,wb|7,xr||; copy pointer to tbblk|26165
# getarg XR
# getarg WB
        movq XR,WB
# ||mov|10,(xr)+|22,=b_tbt||; store type word|26166
# getarg W0
        movq l_0086,W0
        movq W0,W0
        stosq
# ||zer|10,(xr)+|||; zero id for the moment|26167
        mov  $0,W0
        stosq
# ||mov|10,(xr)+|8,wa||; store length (tblen)|26168
# getarg WA
        movq WA,W0
        stosq
# ||mov|10,(xr)+|7,xl||; store initial lookup value|26169
# getarg XL
        movq XL,W0
        stosq
# ||lct|8,wc|8,wc||; set loop counter (num headers)|26170
# |tma01|mov|10,(xr)+|8,wb||; store tbblk ptr in bucket header|26174
tma01:
# getarg WB
        movq WB,W0
        stosq
# ||bct|8,wc|6,tma01||; loop till all stored|26175
# getarg WC
# getarg tma01
        decq WC
        jnz  tma01
# ||mov|7,xr|8,wb||; recall pointer to tbblk|26176
# getarg WB
# getarg XR
        movq WB,XR
# ||exi|||||26177
# getarg 
        ret
# ||enp|||||26178
# ||ejc|||||26179
# |vmake|prc|25,e|1,1||; entry point|26191
vmake:
# getarg 1
# ||lct|8,wb|8,wa||; copy elements for loop later on|26192
# getarg WB
# getarg WA
        mov  WB,WA
# ||add|8,wa|18,=vcsi_||; add space for standard fields|26193
# getarg W0
# getarg WA
        movq l_0489,W0
        addq W0,WA
# ||wtb|8,wa|||; convert length to bytes|26194
# getarg WA
        sal  WA,3
# ||bgt|8,wa|3,mxlen|6,vmak2|; fail if too large|26195
# getarg WA
# getarg mxlen
# getarg vmak2
        cmpq WA,mxlen
        ja   vmak2
# ||jsr|6,alloc|||; allocate space for vcblk|26196
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_vct||; store type word|26197
# getarg W0
# getarg (XR)
        movq l_0085,W0
        movq W0,(XR)
# ||zer|13,idval(xr)|||; initialize idval|26198
# getarg idval(,XR,8)
        mov  $0,W0
        mov  W0,idval(,XR,8)
# ||mov|13,vclen(xr)|8,wa||; set length|26199
# getarg WA
# getarg vclen(,XR,8)
        movq WA,vclen(,XR,8)
# ||mov|8,wc|7,xl||; copy default value|26200
# getarg XL
# getarg WC
        movq XL,WC
# ||mov|7,xl|7,xr||; copy vcblk pointer|26201
# getarg XR
# getarg XL
        movq XR,XL
# ||add|7,xl|19,*vcvls||; point to first element value|26202
# getarg W0
# getarg XL
        movq l_0748,W0
        addq W0,XL
# |vmak1|mov|10,(xl)+|8,wc||; store one value|26206
vmak1:
# getarg WC
# getarg (XL)
        movq WC,(XL)
        add  $8,XL
# ||bct|8,wb|6,vmak1||; loop till all stored|26207
# getarg WB
# getarg vmak1
        decq WB
        jnz  vmak1
# ||exi||||; success return|26208
# getarg 
        movq $0,rcode
        ret
# |vmak2|exi|1,1|||; fail return|26212
vmak2:
# getarg 1
        movq $1,rcode
        ret
# ||enp|||||26213
# ||ejc|||||26214
# ||ejc|||||26262
# ||ejc|||||26307
# |scane|prc|25,e|1,0||; entry point|26313
scane:
# getarg 0
# ||zer|3,scnbl|||; reset blanks flag|26314
# getarg scnbl
        mov  $0,W0
        mov  W0,scnbl
# ||mov|3,scnsa|8,wa||; save wa|26315
# getarg WA
# getarg scnsa
        movq WA,scnsa
# ||mov|3,scnsb|8,wb||; save wb|26316
# getarg WB
# getarg scnsb
        movq WB,scnsb
# ||mov|3,scnsc|8,wc||; save wc|26317
# getarg WC
# getarg scnsc
        movq WC,scnsc
# ||bze|3,scnrs|6,scn03||; jump if no rescan|26318
# getarg scnrs
# getarg scn03
        xor  W0,W0
        cmpq scnrs,W0
        jz   scn03
# ||mov|7,xl|3,scntp||; set previous returned scan type|26322
# getarg scntp
# getarg XL
        movq scntp,XL
# ||mov|7,xr|3,r_scp||; set previous returned pointer|26323
# getarg r_scp
# getarg XR
        movq r_scp,XR
# ||zer|3,scnrs|||; reset rescan switch|26324
# getarg scnrs
        mov  $0,W0
        mov  W0,scnrs
# ||brn|6,scn13|||; jump to exit|26325
# getarg scn13
        jmp  scn13
# |scn01|jsr|6,readr|||; read next image|26329
scn01:
# getarg readr
        call readr
# ||mov|8,wb|19,*dvubs||; set wb for not reading name|26330
# getarg W0
# getarg WB
        .data
l_0918: .long 8*dvubs
        .text
        movq l_0918,W0
        movq W0,WB
# ||bze|7,xr|6,scn30||; treat as semi-colon if none|26331
# getarg XR
# getarg scn30
        or   XR,XR
        jz   scn30
# ||plc|7,xr|||; else point to first character|26332
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wc|9,(xr)||; load first character|26333
# getarg WC
        xor  W0,W0
        movb (XR),%al
        mov  W0,WC
# ||beq|8,wc|18,=ch_dt|6,scn02|; jump if dot for continuation|26334
# getarg WC
# getarg W0
# getarg scn02
        movq l_0807,W0
        cmpq WC,W0
        je   scn02
# ||bne|8,wc|18,=ch_pl|6,scn30|; else treat as semicolon unless plus|26335
# getarg WC
# getarg W0
# getarg scn30
        movq l_0805,W0
        cmpq WC,W0
        jne  scn30
# |scn02|jsr|6,nexts|||; acquire next source image|26339
scn02:
# getarg nexts
        call nexts
# ||mov|3,scnpt|18,=num01||; set scan pointer past continuation|26340
# getarg W0
# getarg scnpt
        movq l_0060,W0
        movq W0,scnpt
# ||mnz|3,scnbl|||; set blanks flag|26341
# getarg scnbl
        mov  XS,scnbl
# ||ejc|||||26342
# |scn03|mov|8,wa|3,scnpt||; load current offset|26348
scn03:
# getarg scnpt
# getarg WA
        movq scnpt,WA
# ||beq|8,wa|3,scnil|6,scn01|; check continuation if end|26349
# getarg WA
# getarg scnil
# getarg scn01
        cmpq WA,scnil
        je   scn01
# ||mov|7,xl|3,r_cim||; point to current line|26350
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||plc|7,xl|8,wa||; point to current character|26351
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||mov|3,scnse|8,wa||; set start of element location|26352
# getarg WA
# getarg scnse
        movq WA,scnse
# ||mov|8,wc|21,=opdvs||; point to operator dv list|26353
# getarg W0
# getarg WC
        movq l_0777,W0
        movq W0,WC
# ||mov|8,wb|19,*dvubs||; set constant for operator circuit|26354
# getarg W0
# getarg WB
        movq l_0918,W0
        movq W0,WB
# ||brn|6,scn06|||; start scanning|26355
# getarg scn06
        jmp  scn06
# |scn05|bze|8,wb|6,scn10||; jump if trailing|26359
scn05:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||icv|3,scnse|||; increment start of element|26360
# getarg scnse
        incq scnse
# ||beq|8,wa|3,scnil|6,scn01|; jump if end of image|26361
# getarg WA
# getarg scnil
# getarg scn01
        cmpq WA,scnil
        je   scn01
# ||mnz|3,scnbl|||; note blanks seen|26362
# getarg scnbl
        mov  XS,scnbl
# |scn06|lch|7,xr|10,(xl)+||; get next character|26374
scn06:
# getarg XR
        xor  W0,W0
        movb (XL),%al
        mov  W0,XR
        incq XL
# ||icv|8,wa|||; bump scan offset|26375
# getarg WA
        incq WA
# ||mov|3,scnpt|8,wa||; store offset past char scanned|26376
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||bsw|7,xr|2,cfp_u|6,scn07|; switch on scanned character|26378
# getarg XR
# getarg cfp_u
# getarg scn07
        cmpq XR,cfp_u
        jge  scn07
        jmp  *l_0919(,XR,8)
        .data
l_0919:
# ||ejc|||||26405
# ||ejc|||||26461
# ||iff|1,0|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,1|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,2|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,3|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,4|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,5|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,6|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,7|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,8|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_ht|6,scn05||; horizontal tab|26494
# getarg scn05
        .long scn05
# ||iff|1,10|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,11|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,12|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,13|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,14|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,15|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,16|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,17|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,18|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,19|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,20|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,21|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,22|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,23|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,24|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,25|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,26|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,27|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,28|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,29|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,30|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|1,31|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_bl|6,scn05||; blank|26494
# getarg scn05
        .long scn05
# ||iff|2,ch_ex|6,scn37||; exclamation mark|26494
# getarg scn37
        .long scn37
# ||iff|2,ch_dq|6,scn17||; double quote|26494
# getarg scn17
        .long scn17
# ||iff|2,ch_nm|6,scn41||; number sign|26494
# getarg scn41
        .long scn41
# ||iff|2,ch_dl|6,scn36||; dollar|26494
# getarg scn36
        .long scn36
# ||iff|2,ch_pc|6,scn38||; percent|26494
# getarg scn38
        .long scn38
# ||iff|2,ch_am|6,scn44||; ampersand|26494
# getarg scn44
        .long scn44
# ||iff|2,ch_sq|6,scn16||; single quote|26494
# getarg scn16
        .long scn16
# ||iff|2,ch_pp|6,scn25||; left paren|26494
# getarg scn25
        .long scn25
# ||iff|2,ch_rp|6,scn26||; right paren|26494
# getarg scn26
        .long scn26
# ||iff|2,ch_as|6,scn49||; asterisk|26494
# getarg scn49
        .long scn49
# ||iff|2,ch_pl|6,scn33||; plus|26494
# getarg scn33
        .long scn33
# ||iff|2,ch_cm|6,scn31||; comma|26494
# getarg scn31
        .long scn31
# ||iff|2,ch_mn|6,scn34||; minus|26494
# getarg scn34
        .long scn34
# ||iff|2,ch_dt|6,scn32||; dot|26494
# getarg scn32
        .long scn32
# ||iff|2,ch_sl|6,scn40||; slash|26494
# getarg scn40
        .long scn40
# ||iff|2,ch_d0|6,scn08||; digit 0|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d1|6,scn08||; digit 1|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d2|6,scn08||; digit 2|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d3|6,scn08||; digit 3|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d4|6,scn08||; digit 4|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d5|6,scn08||; digit 5|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d6|6,scn08||; digit 6|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d7|6,scn08||; digit 7|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d8|6,scn08||; digit 8|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_d9|6,scn08||; digit 9|26494
# getarg scn08
        .long scn08
# ||iff|2,ch_cl|6,scn29||; colon|26494
# getarg scn29
        .long scn29
# ||iff|2,ch_sm|6,scn30||; semi-colon|26494
# getarg scn30
        .long scn30
# ||iff|2,ch_bb|6,scn28||; left bracket|26494
# getarg scn28
        .long scn28
# ||iff|2,ch_eq|6,scn46||; equal|26494
# getarg scn46
        .long scn46
# ||iff|2,ch_rb|6,scn27||; right bracket|26494
# getarg scn27
        .long scn27
# ||iff|2,ch_qu|6,scn45||; question mark|26494
# getarg scn45
        .long scn45
# ||iff|2,ch_at|6,scn42||; at|26494
# getarg scn42
        .long scn42
# ||iff|2,ch_ua|6,scn09||; shifted a|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ub|6,scn09||; shifted b|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uc|6,scn09||; shifted c|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ud|6,scn09||; shifted d|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ue|6,scn09||; shifted e|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uf|6,scn20||; shifted f|26494
# getarg scn20
        .long scn20
# ||iff|2,ch_ug|6,scn09||; shifted g|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uh|6,scn09||; shifted h|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ui|6,scn09||; shifted i|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uj|6,scn09||; shifted j|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uk|6,scn09||; shifted k|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ul|6,scn09||; shifted l|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_um|6,scn09||; shifted m|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_un|6,scn09||; shifted n|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uo|6,scn09||; shifted o|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_up|6,scn09||; shifted p|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uq|6,scn09||; shifted q|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ur|6,scn09||; shifted r|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_us|6,scn21||; shifted s|26494
# getarg scn21
        .long scn21
# ||iff|2,ch_ut|6,scn09||; shifted t|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uu|6,scn09||; shifted u|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uv|6,scn09||; shifted v|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uw|6,scn09||; shifted w|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ux|6,scn09||; shifted x|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uy|6,scn09||; shifted y|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_uz|6,scn09||; shifted z|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ob|6,scn28||; left bracket|26494
# getarg scn28
        .long scn28
# ||iff|1,92|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_cb|6,scn27||; right bracket|26494
# getarg scn27
        .long scn27
# ||iff|2,ch_ey|6,scn37||; up arrow|26494
# getarg scn37
        .long scn37
# ||iff|2,ch_u_|6,scn24||; underline|26494
# getarg scn24
        .long scn24
# ||iff|1,96|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_la|6,scn09||; letter a|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lb|6,scn09||; letter b|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lc|6,scn09||; letter c|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ld|6,scn09||; letter d|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_le|6,scn09||; letter e|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lf|6,scn20||; letter f|26494
# getarg scn20
        .long scn20
# ||iff|2,ch_lg|6,scn09||; letter g|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lh|6,scn09||; letter h|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_li|6,scn09||; letter i|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lj|6,scn09||; letter j|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lk|6,scn09||; letter k|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ll|6,scn09||; letter l|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lm|6,scn09||; letter m|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ln|6,scn09||; letter n|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lo|6,scn09||; letter o|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lp|6,scn09||; letter p|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lq|6,scn09||; letter q|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lr|6,scn09||; letter r|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ls|6,scn21||; letter s|26494
# getarg scn21
        .long scn21
# ||iff|2,ch_lt|6,scn09||; letter t|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lu|6,scn09||; letter u|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lv|6,scn09||; letter v|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lw|6,scn09||; letter w|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_lx|6,scn09||; letter x|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_ly|6,scn09||; letter y|26494
# getarg scn09
        .long scn09
# ||iff|2,ch_l_|6,scn09||; letter z|26494
# getarg scn09
        .long scn09
# ||iff|1,123|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_br|6,scn43||; vertical bar|26494
# getarg scn43
        .long scn43
# ||iff|1,125|6,scn07|||26494
# getarg scn07
        .long scn07
# ||iff|2,ch_nt|6,scn35||; not|26494
# getarg scn35
        .long scn35
# ||iff|1,127|6,scn07|||26494
# getarg scn07
        .long scn07
# ||esw||||; end switch on character|26494
        .text
# |scn07|bze|8,wb|6,scn10||; jump if scanning name or constant|26498
scn07:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||erb|1,230|26,syntax error: illegal character|||26499
        movq $230,rcode
        jmp  err_
# ||ejc|||||26500
# |scn08|bze|8,wb|6,scn09||; keep scanning if name/constant|26506
scn08:
# getarg WB
# getarg scn09
        or   WB,WB
        jz   scn09
# ||zer|8,wc|||; else set flag for scanning constant|26507
# getarg WC
        xor  WC,WC
# |scn09|beq|8,wa|3,scnil|6,scn11|; jump if end of image|26511
scn09:
# getarg WA
# getarg scnil
# getarg scn11
        cmpq WA,scnil
        je   scn11
# ||zer|8,wb|||; set flag for scanning name/const|26512
# getarg WB
        xor  WB,WB
# ||brn|6,scn06|||; merge back to continue scan|26513
# getarg scn06
        jmp  scn06
# |scn10|dcv|8,wa|||; reset offset to point to delimiter|26517
scn10:
# getarg WA
        decq WA
# |scn11|mov|3,scnpt|8,wa||; store updated scan offset|26521
scn11:
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||mov|8,wb|3,scnse||; point to start of element|26522
# getarg scnse
# getarg WB
        movq scnse,WB
# ||sub|8,wa|8,wb||; get number of characters|26523
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|3,r_cim||; point to line image|26524
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||bnz|8,wc|6,scn15||; jump if name|26525
# getarg WC
# getarg WC
# getarg scn15
        or   WC,WC
        jnz  scn15
# ||jsr|6,sbstr|||; get string for constant|26529
# getarg sbstr
        call sbstr
# ||mov|3,dnamp|7,xr||; delete from storage (not needed)|26530
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||jsr|6,gtnum|||; convert to numeric|26531
# getarg gtnum
        call gtnum
        decq rcode
        js   call_271
# ||ppm|6,scn14|||; jump if conversion failure|26532
# getarg scn14
# getarg scn14
        decq rcode
        jns  l_0920
        jmp  scn14
l_0920:
call_271:
# |scn12|mov|7,xl|18,=t_con||; set result type of constant|26536
scn12:
# getarg W0
# getarg XL
        movq l_0692,W0
        movq W0,XL
# ||ejc|||||26537
# |scn13|mov|8,wa|3,scnsa||; restore wa|26543
scn13:
# getarg scnsa
# getarg WA
        movq scnsa,WA
# ||mov|8,wb|3,scnsb||; restore wb|26544
# getarg scnsb
# getarg WB
        movq scnsb,WB
# ||mov|8,wc|3,scnsc||; restore wc|26545
# getarg scnsc
# getarg WC
        movq scnsc,WC
# ||mov|3,r_scp|7,xr||; save xr in case rescan|26546
# getarg XR
# getarg r_scp
        movq XR,r_scp
# ||mov|3,scntp|7,xl||; save xl in case rescan|26547
# getarg XL
# getarg scntp
        movq XL,scntp
# ||zer|3,scngo|||; reset possible goto flag|26548
# getarg scngo
        mov  $0,W0
        mov  W0,scngo
# ||exi||||; return to scane caller|26549
# getarg 
        ret
# |scn14|erb|1,231|26,syntax error: invalid numeric item|||26553
scn14:
        movq $231,rcode
        jmp  err_
# |scn15|jsr|6,sbstr|||; build string name of variable|26557
scn15:
# getarg sbstr
        call sbstr
# ||bnz|3,scncc|6,scn13||; return if cncrd call|26558
# getarg scncc
# getarg scn13
        xor  W0,W0
        cmpq scncc,W0
        jnz  scn13
# ||jsr|6,gtnvr|||; locate/build vrblk|26559
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_272
# ||ppm||||; dummy (unused) error return|26560
# getarg 
        decq rcode
        jns  l_0921
        movq $299,rcode
        jmp  err_
l_0921:
call_272:
# ||mov|7,xl|18,=t_var||; set type as variable|26561
# getarg W0
# getarg XL
        movq l_0691,W0
        movq W0,XL
# ||brn|6,scn13|||; back to exit|26562
# getarg scn13
        jmp  scn13
# |scn16|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26566
scn16:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||mov|8,wb|18,=ch_sq||; set terminator as single quote|26567
# getarg W0
# getarg WB
        movq l_0905,W0
        movq W0,WB
# ||brn|6,scn18|||; merge|26568
# getarg scn18
        jmp  scn18
# |scn17|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26572
scn17:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||mov|8,wb|18,=ch_dq||; set double quote terminator, merge|26573
# getarg W0
# getarg WB
        .data
l_0922: .long ch_dq
        .text
        movq l_0922,W0
        movq W0,WB
# |scn18|beq|8,wa|3,scnil|6,scn19|; error if end of image|26577
scn18:
# getarg WA
# getarg scnil
# getarg scn19
        cmpq WA,scnil
        je   scn19
# ||lch|8,wc|10,(xl)+||; else load next character|26578
# getarg WC
        xor  W0,W0
        movb (XL),%al
        mov  W0,WC
        incq XL
# ||icv|8,wa|||; bump offset|26579
# getarg WA
        incq WA
# ||bne|8,wc|8,wb|6,scn18|; loop back if not terminator|26580
# getarg WC
# getarg WB
# getarg scn18
        cmpq WC,WB
        jne  scn18
# ||ejc|||||26581
# ||mov|8,wb|3,scnpt||; point to first character|26587
# getarg scnpt
# getarg WB
        movq scnpt,WB
# ||mov|3,scnpt|8,wa||; save offset past final quote|26588
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||dcv|8,wa|||; point back past last character|26589
# getarg WA
        decq WA
# ||sub|8,wa|8,wb||; get number of characters|26590
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|3,r_cim||; point to input image|26591
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||jsr|6,sbstr|||; build substring value|26592
# getarg sbstr
        call sbstr
# ||brn|6,scn12|||; back to exit with constant result|26593
# getarg scn12
        jmp  scn12
# |scn19|mov|3,scnpt|8,wa||; set updated scan pointer|26597
scn19:
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||erb|1,232|26,syntax error: unmatched string quote|||26598
        movq $232,rcode
        jmp  err_
# |scn20|mov|7,xr|18,=t_fgo||; set return code for fail goto|26602
scn20:
# getarg W0
# getarg XR
        movq l_0702,W0
        movq W0,XR
# ||brn|6,scn22|||; jump to merge|26603
# getarg scn22
        jmp  scn22
# |scn21|mov|7,xr|18,=t_sgo||; set success goto as return code|26607
scn21:
# getarg W0
# getarg XR
        movq l_0701,W0
        movq W0,XR
# |scn22|bze|3,scngo|6,scn09||; treat as normal letter if not goto|26611
scn22:
# getarg scngo
# getarg scn09
        xor  W0,W0
        cmpq scngo,W0
        jz   scn09
# |scn23|bze|8,wb|6,scn10||; jump if end of name/constant|26615
scn23:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||mov|7,xl|7,xr||; else copy code|26616
# getarg XR
# getarg XL
        movq XR,XL
# ||brn|6,scn13|||; and jump to exit|26617
# getarg scn13
        jmp  scn13
# |scn24|bze|8,wb|6,scn09||; part of name if scanning name|26621
scn24:
# getarg WB
# getarg scn09
        or   WB,WB
        jz   scn09
# ||brn|6,scn07|||; else illegal|26622
# getarg scn07
        jmp  scn07
# ||ejc|||||26623
# |scn25|mov|7,xr|18,=t_lpr||; set left paren return code|26629
scn25:
# getarg W0
# getarg XR
        .data
l_0923: .long t_lpr
        .text
        movq l_0923,W0
        movq W0,XR
# ||bnz|8,wb|6,scn23||; return left paren unless name|26630
# getarg WB
# getarg WB
# getarg scn23
        or   WB,WB
        jnz  scn23
# ||bze|8,wc|6,scn10||; delimiter if scanning constant|26631
# getarg WC
# getarg scn10
        or   WC,WC
        jz   scn10
# ||mov|8,wb|3,scnse||; point to start of name|26635
# getarg scnse
# getarg WB
        movq scnse,WB
# ||mov|3,scnpt|8,wa||; set pointer past left paren|26636
# getarg WA
# getarg scnpt
        movq WA,scnpt
# ||dcv|8,wa|||; point back past last char of name|26637
# getarg WA
        decq WA
# ||sub|8,wa|8,wb||; get name length|26638
# getarg WB
# getarg WA
        subq WB,WA
# ||mov|7,xl|3,r_cim||; point to input image|26639
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||jsr|6,sbstr|||; get string name for function|26640
# getarg sbstr
        call sbstr
# ||jsr|6,gtnvr|||; locate/build vrblk|26641
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_273
# ||ppm||||; dummy (unused) error return|26642
# getarg 
        decq rcode
        jns  l_0924
        movq $299,rcode
        jmp  err_
l_0924:
call_273:
# ||mov|7,xl|18,=t_fnc||; set code for function call|26643
# getarg W0
# getarg XL
        .data
l_0925: .long t_fnc
        .text
        movq l_0925,W0
        movq W0,XL
# ||brn|6,scn13|||; back to exit|26644
# getarg scn13
        jmp  scn13
# |scn26|mov|7,xr|18,=t_rpr||; right paren, set code|26648
scn26:
# getarg W0
# getarg XR
        .data
l_0926: .long t_rpr
        .text
        movq l_0926,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26649
# getarg scn23
        jmp  scn23
# |scn27|mov|7,xr|18,=t_rbr||; right bracket, set code|26651
scn27:
# getarg W0
# getarg XR
        .data
l_0927: .long t_rbr
        .text
        movq l_0927,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26652
# getarg scn23
        jmp  scn23
# |scn28|mov|7,xr|18,=t_lbr||; left bracket, set code|26654
scn28:
# getarg W0
# getarg XR
        .data
l_0928: .long t_lbr
        .text
        movq l_0928,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26655
# getarg scn23
        jmp  scn23
# |scn29|mov|7,xr|18,=t_col||; colon, set code|26657
scn29:
# getarg W0
# getarg XR
        movq l_0700,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26658
# getarg scn23
        jmp  scn23
# |scn30|mov|7,xr|18,=t_smc||; semi-colon, set code|26660
scn30:
# getarg W0
# getarg XR
        movq l_0697,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26661
# getarg scn23
        jmp  scn23
# |scn31|mov|7,xr|18,=t_cma||; comma, set code|26663
scn31:
# getarg W0
# getarg XR
        movq l_0723,W0
        movq W0,XR
# ||brn|6,scn23|||; take special character exit|26664
# getarg scn23
        jmp  scn23
# ||ejc|||||26665
# |scn32|bze|8,wb|6,scn09||; dot can be part of name or constant|26677
scn32:
# getarg WB
# getarg scn09
        or   WB,WB
        jz   scn09
# ||add|8,wc|8,wb||; else bump pointer|26678
# getarg WB
# getarg WC
        addq WB,WC
# |scn33|bze|8,wc|6,scn09||; plus can be part of constant|26680
scn33:
# getarg WC
# getarg scn09
        or   WC,WC
        jz   scn09
# ||bze|8,wb|6,scn48||; plus cannot be part of name|26681
# getarg WB
# getarg scn48
        or   WB,WB
        jz   scn48
# ||add|8,wc|8,wb||; else bump pointer|26682
# getarg WB
# getarg WC
        addq WB,WC
# |scn34|bze|8,wc|6,scn09||; minus can be part of constant|26684
scn34:
# getarg WC
# getarg scn09
        or   WC,WC
        jz   scn09
# ||bze|8,wb|6,scn48||; minus cannot be part of name|26685
# getarg WB
# getarg scn48
        or   WB,WB
        jz   scn48
# ||add|8,wc|8,wb||; else bump pointer|26686
# getarg WB
# getarg WC
        addq WB,WC
# |scn35|add|8,wc|8,wb||; not|26688
scn35:
# getarg WB
# getarg WC
        addq WB,WC
# |scn36|add|8,wc|8,wb||; dollar|26689
scn36:
# getarg WB
# getarg WC
        addq WB,WC
# |scn37|add|8,wc|8,wb||; exclamation|26690
scn37:
# getarg WB
# getarg WC
        addq WB,WC
# |scn38|add|8,wc|8,wb||; percent|26691
scn38:
# getarg WB
# getarg WC
        addq WB,WC
# |scn39|add|8,wc|8,wb||; asterisk|26692
scn39:
# getarg WB
# getarg WC
        addq WB,WC
# |scn40|add|8,wc|8,wb||; slash|26693
scn40:
# getarg WB
# getarg WC
        addq WB,WC
# |scn41|add|8,wc|8,wb||; number sign|26694
scn41:
# getarg WB
# getarg WC
        addq WB,WC
# |scn42|add|8,wc|8,wb||; at sign|26695
scn42:
# getarg WB
# getarg WC
        addq WB,WC
# |scn43|add|8,wc|8,wb||; vertical bar|26696
scn43:
# getarg WB
# getarg WC
        addq WB,WC
# |scn44|add|8,wc|8,wb||; ampersand|26697
scn44:
# getarg WB
# getarg WC
        addq WB,WC
# |scn45|add|8,wc|8,wb||; question mark|26698
scn45:
# getarg WB
# getarg WC
        addq WB,WC
# |scn46|bze|8,wb|6,scn10||; operator terminates name/constant|26703
scn46:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||mov|7,xr|8,wc||; else copy dv pointer|26704
# getarg WC
# getarg XR
        movq WC,XR
# ||lch|8,wc|9,(xl)||; load next character|26705
# getarg WC
        xor  W0,W0
        movb (XL),%al
        mov  W0,WC
# ||mov|7,xl|18,=t_bop||; set binary op in case|26706
# getarg W0
# getarg XL
        .data
l_0929: .long t_bop
        .text
        movq l_0929,W0
        movq W0,XL
# ||beq|8,wa|3,scnil|6,scn47|; should be binary if image end|26707
# getarg WA
# getarg scnil
# getarg scn47
        cmpq WA,scnil
        je   scn47
# ||beq|8,wc|18,=ch_bl|6,scn47|; should be binary if followed by blk|26708
# getarg WC
# getarg W0
# getarg scn47
        movq l_0572,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_ht|6,scn47|; jump if horizontal tab|26710
# getarg WC
# getarg W0
# getarg scn47
        movq l_0693,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_sm|6,scn47|; semicolon can immediately follow =|26715
# getarg WC
# getarg W0
# getarg scn47
        movq l_0687,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_cl|6,scn47|; colon can immediately follow =|26716
# getarg WC
# getarg W0
# getarg scn47
        movq l_0162,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_rp|6,scn47|; right paren can immediately follow =|26717
# getarg WC
# getarg W0
# getarg scn47
        movq l_0160,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_rb|6,scn47|; right bracket can immediately follow =|26718
# getarg WC
# getarg W0
# getarg scn47
        movq l_0896,W0
        cmpq WC,W0
        je   scn47
# ||beq|8,wc|18,=ch_cb|6,scn47|; right bracket can immediately follow =|26719
# getarg WC
# getarg W0
# getarg scn47
        .data
l_0930: .long ch_cb
        .text
        movq l_0930,W0
        cmpq WC,W0
        je   scn47
# ||add|7,xr|19,*dvbs_||; point to dv for unary op|26723
# getarg W0
# getarg XR
        .data
l_0931: .long 8*dvbs_
        .text
        movq l_0931,W0
        addq W0,XR
# ||mov|7,xl|18,=t_uop||; set type for unary operator|26724
# getarg W0
# getarg XL
        .data
l_0932: .long t_uop
        .text
        movq l_0932,W0
        movq W0,XL
# ||ble|3,scntp|18,=t_uok|6,scn13|; ok unary if ok preceding element|26725
# getarg scntp
# getarg W0
# getarg scn13
        movq l_0802,W0
        cmpq scntp,W0
        jbe  scn13
# ||ejc|||||26726
# |scn47|bnz|3,scnbl|6,scn13||; all ok if preceding blanks, exit|26732
scn47:
# getarg scnbl
# getarg scn13
        xor  W0,W0
        cmpq scnbl,W0
        jnz  scn13
# |scn48|erb|1,233|26,syntax error: invalid use of operator|||26736
scn48:
        movq $233,rcode
        jmp  err_
# |scn49|bze|8,wb|6,scn10||; end of name if scanning name|26740
scn49:
# getarg WB
# getarg scn10
        or   WB,WB
        jz   scn10
# ||beq|8,wa|3,scnil|6,scn39|; not ** if * at image end|26741
# getarg WA
# getarg scnil
# getarg scn39
        cmpq WA,scnil
        je   scn39
# ||mov|7,xr|8,wa||; else save offset past first *|26742
# getarg WA
# getarg XR
        movq WA,XR
# ||mov|3,scnof|8,wa||; save another copy|26743
# getarg WA
# getarg scnof
        movq WA,scnof
# ||lch|8,wa|10,(xl)+||; load next character|26744
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
        incq XL
# ||bne|8,wa|18,=ch_as|6,scn50|; not ** if next char not *|26745
# getarg WA
# getarg W0
# getarg scn50
        movq l_0688,W0
        cmpq WA,W0
        jne  scn50
# ||icv|7,xr|||; else step offset past second *|26746
# getarg XR
        incq XR
# ||beq|7,xr|3,scnil|6,scn51|; ok exclam if end of image|26747
# getarg XR
# getarg scnil
# getarg scn51
        cmpq XR,scnil
        je   scn51
# ||lch|8,wa|9,(xl)||; else load next character|26748
# getarg WA
        xor  W0,W0
        movb (XL),%al
        mov  W0,WA
# ||beq|8,wa|18,=ch_bl|6,scn51|; exclamation if blank|26749
# getarg WA
# getarg W0
# getarg scn51
        movq l_0572,W0
        cmpq WA,W0
        je   scn51
# ||beq|8,wa|18,=ch_ht|6,scn51|; exclamation if horizontal tab|26751
# getarg WA
# getarg W0
# getarg scn51
        movq l_0693,W0
        cmpq WA,W0
        je   scn51
# |scn50|mov|8,wa|3,scnof||; recover stored offset|26759
scn50:
# getarg scnof
# getarg WA
        movq scnof,WA
# ||mov|7,xl|3,r_cim||; point to line again|26760
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||plc|7,xl|8,wa||; point to current char|26761
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||brn|6,scn39|||; merge with unary *|26762
# getarg scn39
        jmp  scn39
# |scn51|mov|3,scnpt|7,xr||; save scan pointer past 2nd *|26766
scn51:
# getarg XR
# getarg scnpt
        movq XR,scnpt
# ||mov|8,wa|7,xr||; copy scan pointer|26767
# getarg XR
# getarg WA
        movq XR,WA
# ||brn|6,scn37|||; merge with exclamation|26768
# getarg scn37
        jmp  scn37
# ||enp||||; end procedure scane|26769
# ||ejc|||||26770
# |scngf|prc|25,e|1,0||; entry point|26787
scngf:
# getarg 0
# ||jsr|6,scane|||; scan initial element|26788
# getarg scane
        call scane
# ||beq|7,xl|18,=t_lpr|6,scng1|; skip if left paren (normal goto)|26789
# getarg XL
# getarg W0
# getarg scng1
        movq l_0923,W0
        cmpq XL,W0
        je   scng1
# ||beq|7,xl|18,=t_lbr|6,scng2|; skip if left bracket (direct goto)|26790
# getarg XL
# getarg W0
# getarg scng2
        movq l_0928,W0
        cmpq XL,W0
        je   scng2
# ||erb|1,234|26,syntax error: goto field incorrect|||26791
        movq $234,rcode
        jmp  err_
# |scng1|mov|8,wb|18,=num01||; set expan flag for normal goto|26795
scng1:
# getarg W0
# getarg WB
        movq l_0060,W0
        movq W0,WB
# ||jsr|6,expan|||; analyze goto field|26796
# getarg expan
        call expan
# ||mov|8,wa|21,=opdvn||; point to opdv for complex goto|26797
# getarg W0
# getarg WA
        .data
l_0933: .long opdvn
        .text
        movq l_0933,W0
        movq W0,WA
# ||ble|7,xr|3,statb|6,scng3|; jump if not in static (sgd15)|26798
# getarg XR
# getarg statb
# getarg scng3
        cmpq XR,statb
        jbe  scng3
# ||blo|7,xr|3,state|6,scng4|; jump to exit if simple label name|26799
# getarg XR
# getarg state
# getarg scng4
        cmpq XR,state
        jb   scng4
# ||brn|6,scng3|||; complex goto - merge|26800
# getarg scng3
        jmp  scng3
# |scng2|mov|8,wb|18,=num02||; set expan flag for direct goto|26804
scng2:
# getarg W0
# getarg WB
        movq l_0130,W0
        movq W0,WB
# ||jsr|6,expan|||; scan goto field|26805
# getarg expan
        call expan
# ||mov|8,wa|21,=opdvd||; set opdv pointer for direct goto|26806
# getarg W0
# getarg WA
        movq l_0636,W0
        movq W0,WA
# ||ejc|||||26807
# |scng3|mov|11,-(xs)|8,wa||; stack operator dv pointer|26813
scng3:
# getarg WA
        push WA
# ||mov|11,-(xs)|7,xr||; stack pointer to expression tree|26814
# getarg XR
        push XR
# ||jsr|6,expop|||; pop operator off|26815
# getarg expop
        call expop
# ||mov|7,xr|10,(xs)+||; reload new expression tree pointer|26816
# getarg XR
        pop  XR
# |scng4|exi||||; return to caller|26820
scng4:
# getarg 
        ret
# ||enp||||; end procedure scngf|26821
# ||ejc|||||26822
# |setvr|prc|25,e|1,0||; entry point|26837
setvr:
# getarg 0
# ||bhi|7,xr|3,state|6,setv1|; exit if not natural variable|26838
# getarg XR
# getarg state
# getarg setv1
        cmpq XR,state
        ja   setv1
# ||mov|7,xl|7,xr||; copy vrblk pointer|26842
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|13,vrget(xr)|22,=b_vrl||; store normal get value|26843
# getarg W0
# getarg vrget(,XR,8)
        .data
l_0934: .long b_vrl
        .text
        movq l_0934,W0
        movq W0,vrget(,XR,8)
# ||beq|13,vrsto(xr)|22,=b_vre|6,setv1|; skip if protected variable|26844
# getarg vrsto(,XR,8)
# getarg W0
# getarg setv1
        movq l_0269,W0
        cmpq vrsto(,XR,8),W0
        je   setv1
# ||mov|13,vrsto(xr)|22,=b_vrs||; store normal store value|26845
# getarg W0
# getarg vrsto(,XR,8)
        .data
l_0935: .long b_vrs
        .text
        movq l_0935,W0
        movq W0,vrsto(,XR,8)
# ||mov|7,xl|13,vrval(xl)||; point to next entry on chain|26846
# getarg vrval(,XL,8)
# getarg XL
        movq vrval(,XL,8),XL
# ||bne|9,(xl)|22,=b_trt|6,setv1|; jump if end of trblk chain|26847
# getarg (XL)
# getarg W0
# getarg setv1
        movq l_0154,W0
        cmpq (XL),W0
        jne  setv1
# ||mov|13,vrget(xr)|22,=b_vra||; store trapped routine address|26848
# getarg W0
# getarg vrget(,XR,8)
        movq l_0653,W0
        movq W0,vrget(,XR,8)
# ||mov|13,vrsto(xr)|22,=b_vrv||; set trapped routine address|26849
# getarg W0
# getarg vrsto(,XR,8)
        movq l_0842,W0
        movq W0,vrsto(,XR,8)
# |setv1|exi||||; return to setvr caller|26853
setv1:
# getarg 
        ret
# ||enp||||; end procedure setvr|26854
# ||ejc|||||26857
# ||ejc|||||26894
# |sorta|prc|25,n|1,1||; entry point|26898
sorta:
# getarg 1
        pop  prc_+8*15
# ||mov|3,srtsr|8,wa||; sort/rsort indicator|26899
# getarg WA
# getarg srtsr
        movq WA,srtsr
# ||mov|3,srtst|19,*num01||; default stride of 1|26900
# getarg W0
# getarg srtst
        .data
l_0936: .long 8*num01
        .text
        movq l_0936,W0
        movq W0,srtst
# ||zer|3,srtof|||; default zero offset to sort key|26901
# getarg srtof
        mov  $0,W0
        mov  W0,srtof
# ||mov|3,srtdf|21,=nulls||; clear datatype field name|26902
# getarg W0
# getarg srtdf
        movq l_0054,W0
        movq W0,srtdf
# ||mov|3,r_sxr|10,(xs)+||; unstack argument 2|26903
# getarg r_sxr
        pop  r_sxr
# ||mov|7,xr|10,(xs)+||; get first argument|26904
# getarg XR
        pop  XR
# ||mnz|8,wa|||; use key/values of table entries|26905
# getarg WA
        mov  XS,WA
# ||jsr|6,gtarr|||; convert to array|26906
# getarg gtarr
        call gtarr
        decq rcode
        js   call_274
# ||ppm|6,srt18|||; signal that table is empty|26907
# getarg srt18
# getarg srt18
        decq rcode
        jns  l_0937
        jmp  srt18
l_0937:
# ||ppm|6,srt16|||; error if non-convertable|26908
# getarg srt16
# getarg srt16
        decq rcode
        jns  l_0938
        jmp  srt16
l_0938:
call_274:
# ||mov|11,-(xs)|7,xr||; stack ptr to resulting key array|26909
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xr||; another copy for copyb|26910
# getarg XR
        push XR
# ||jsr|6,copyb|||; get copy array for sorting into|26911
# getarg copyb
        call copyb
        decq rcode
        js   call_275
# ||ppm||||; cant fail|26912
# getarg 
        decq rcode
        jns  l_0939
        movq $299,rcode
        jmp  err_
l_0939:
call_275:
# ||mov|11,-(xs)|7,xr||; stack pointer to sort array|26913
# getarg XR
        push XR
# ||mov|7,xr|3,r_sxr||; get second arg|26914
# getarg r_sxr
# getarg XR
        movq r_sxr,XR
# ||mov|7,xl|13,num01(xs)||; get ptr to key array|26915
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||bne|9,(xl)|22,=b_vct|6,srt02|; jump if arblk|26916
# getarg (XL)
# getarg W0
# getarg srt02
        movq l_0085,W0
        cmpq (XL),W0
        jne  srt02
# ||beq|7,xr|21,=nulls|6,srt01|; jump if null second arg|26917
# getarg XR
# getarg W0
# getarg srt01
        movq l_0054,W0
        cmpq XR,W0
        je   srt01
# ||jsr|6,gtnvr|||; get vrblk ptr for it|26918
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_276
# ||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||26919
# getarg 257
        decq rcode
        jns  l_0940
        movq $257,rcode
        jmp  err_
l_0940:
call_276:
# ||mov|3,srtdf|7,xr||; store datatype field name vrblk|26920
# getarg XR
# getarg srtdf
        movq XR,srtdf
# |srt01|mov|8,wc|19,*vclen||; offset to a(0)|26924
srt01:
# getarg W0
# getarg WC
        .data
l_0941: .long 8*vclen
        .text
        movq l_0941,W0
        movq W0,WC
# ||mov|8,wb|19,*vcvls||; offset to first item|26925
# getarg W0
# getarg WB
        movq l_0748,W0
        movq W0,WB
# ||mov|8,wa|13,vclen(xl)||; get block length|26926
# getarg vclen(,XL,8)
# getarg WA
        movq vclen(,XL,8),WA
# ||sub|8,wa|19,*vcsi_||; get no. of entries, n (in bytes)|26927
# getarg W0
# getarg WA
        .data
l_0942: .long 8*vcsi_
        .text
        movq l_0942,W0
        subq W0,WA
# ||brn|6,srt04|||; merge|26928
# getarg srt04
        jmp  srt04
# |srt02|ldi|13,ardim(xl)|||; get possible dimension|26932
srt02:
# getarg ardim(,XL,8)
        mov  ardim(,XL,8),IA
# ||mfi|8,wa|||; convert to short integer|26933
# getarg WA
        mov  IA,WA
# ||wtb|8,wa|||; further convert to baus|26934
# getarg WA
        sal  WA,3
# ||mov|8,wb|19,*arvls||; offset to first value if one|26935
# getarg W0
# getarg WB
        .data
l_0943: .long 8*arvls
        .text
        movq l_0943,W0
        movq W0,WB
# ||mov|8,wc|19,*arpro||; offset before values if one dim.|26936
# getarg W0
# getarg WC
        .data
l_0944: .long 8*arpro
        .text
        movq l_0944,W0
        movq W0,WC
# ||beq|13,arndm(xl)|18,=num01|6,srt04|; jump in fact if one dim.|26937
# getarg arndm(,XL,8)
# getarg W0
# getarg srt04
        movq l_0060,W0
        cmpq arndm(,XL,8),W0
        je   srt04
# ||bne|13,arndm(xl)|18,=num02|6,srt16|; fail unless two dimens|26938
# getarg arndm(,XL,8)
# getarg W0
# getarg srt16
        movq l_0130,W0
        cmpq arndm(,XL,8),W0
        jne  srt16
# ||ldi|13,arlb2(xl)|||; get lower bound 2 as default|26939
# getarg arlb2(,XL,8)
        mov  arlb2(,XL,8),IA
# ||beq|7,xr|21,=nulls|6,srt03|; jump if default second arg|26940
# getarg XR
# getarg W0
# getarg srt03
        movq l_0054,W0
        cmpq XR,W0
        je   srt03
# ||jsr|6,gtint|||; convert to integer|26941
# getarg gtint
        call gtint
        decq rcode
        js   call_277
# ||ppm|6,srt17|||; fail|26942
# getarg srt17
# getarg srt17
        decq rcode
        jns  l_0945
        jmp  srt17
l_0945:
call_277:
# ||ldi|13,icval(xr)|||; get actual integer value|26943
# getarg icval(,XR,8)
        mov  icval(,XR,8),IA
# ||ejc|||||26944
# |srt03|sbi|13,arlb2(xl)|||; subtract low bound|26950
srt03:
# getarg arlb2(,XL,8)
        sub  arlb2(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||iov|6,srt17|||; fail if overflow|26951
# getarg srt17
        iov_ srt17
# ||ilt|6,srt17|||; fail if below low bound|26952
# getarg srt17
        mov  IA,W0
        or   W0,W0
        jl   srt17
# ||sbi|13,ardm2(xl)|||; check against dimension|26953
# getarg ardm2(,XL,8)
        sub  ardm2(,XL,8),IA
        xor  W0,W0
        seto reg_fl
# ||ige|6,srt17|||; fail if too large|26954
# getarg srt17
        mov  IA,W0
        or   W0,W0
        jge  srt17
# ||adi|13,ardm2(xl)|||; restore value|26955
# getarg ardm2(,XL,8)
        add  ardm2(,XL,8),IA
        seto reg_fl
# ||mfi|8,wa|||; get as small integer|26956
# getarg WA
        mov  IA,WA
# ||wtb|8,wa|||; offset within row to key|26957
# getarg WA
        sal  WA,3
# ||mov|3,srtof|8,wa||; keep offset|26958
# getarg WA
# getarg srtof
        movq WA,srtof
# ||ldi|13,ardm2(xl)|||; second dimension is row length|26959
# getarg ardm2(,XL,8)
        mov  ardm2(,XL,8),IA
# ||mfi|8,wa|||; convert to short integer|26960
# getarg WA
        mov  IA,WA
# ||mov|7,xr|8,wa||; copy row length|26961
# getarg WA
# getarg XR
        movq WA,XR
# ||wtb|8,wa|||; convert to bytes|26962
# getarg WA
        sal  WA,3
# ||mov|3,srtst|8,wa||; store as stride|26963
# getarg WA
# getarg srtst
        movq WA,srtst
# ||ldi|13,ardim(xl)|||; get number of rows|26964
# getarg ardim(,XL,8)
        mov  ardim(,XL,8),IA
# ||mfi|8,wa|||; as a short integer|26965
# getarg WA
        mov  IA,WA
# ||wtb|8,wa|||; convert n to baus|26966
# getarg WA
        sal  WA,3
# ||mov|8,wc|13,arlen(xl)||; offset past array end|26967
# getarg arlen(,XL,8)
# getarg WC
        movq arlen(,XL,8),WC
# ||sub|8,wc|8,wa||; adjust, giving space for n offsets|26968
# getarg WA
# getarg WC
        subq WA,WC
# ||dca|8,wc|||; point to a(0)|26969
# getarg WC
        subq $8,WC
# ||mov|8,wb|13,arofs(xl)||; offset to word before first item|26970
# getarg arofs(,XL,8)
# getarg WB
        movq arofs(,XL,8),WB
# ||ica|8,wb|||; offset to first item|26971
# getarg WB
        addq $8,WB
# |srt04|ble|8,wa|19,*num01|6,srt15|; return if only a single item|26983
srt04:
# getarg WA
# getarg W0
# getarg srt15
        movq l_0936,W0
        cmpq WA,W0
        jbe  srt15
# ||mov|3,srtsn|8,wa||; store number of items (in baus)|26984
# getarg WA
# getarg srtsn
        movq WA,srtsn
# ||mov|3,srtso|8,wc||; store offset to a(0)|26985
# getarg WC
# getarg srtso
        movq WC,srtso
# ||mov|8,wc|13,arlen(xl)||; length of array or vec (=vclen)|26986
# getarg arlen(,XL,8)
# getarg WC
        movq arlen(,XL,8),WC
# ||add|8,wc|7,xl||; point past end of array or vector|26987
# getarg XL
# getarg WC
        addq XL,WC
# ||mov|3,srtsf|8,wb||; store offset to first row|26988
# getarg WB
# getarg srtsf
        movq WB,srtsf
# ||add|7,xl|8,wb||; point to first item in key array|26989
# getarg WB
# getarg XL
        addq WB,XL
# |srt05|mov|7,xr|9,(xl)||; get an entry|26993
srt05:
# getarg (XL)
# getarg XR
        movq (XL),XR
# |srt06|bne|9,(xr)|22,=b_trt|6,srt07|; jump out if not trblk|26997
srt06:
# getarg (XR)
# getarg W0
# getarg srt07
        movq l_0154,W0
        cmpq (XR),W0
        jne  srt07
# ||mov|7,xr|13,trval(xr)||; get value field|26998
# getarg trval(,XR,8)
# getarg XR
        movq trval(,XR,8),XR
# ||brn|6,srt06|||; loop|26999
# getarg srt06
        jmp  srt06
# ||ejc|||||27000
# |srt07|mov|10,(xl)+|7,xr||; store as array entry|27006
srt07:
# getarg XR
# getarg (XL)
        movq XR,(XL)
        add  $8,XL
# ||blt|7,xl|8,wc|6,srt05|; loop if not done|27007
# getarg XL
# getarg WC
# getarg srt05
        cmpq XL,WC
        jb   srt05
# ||mov|7,xl|9,(xs)||; get adrs of sort array|27008
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||mov|7,xr|3,srtsf||; initial offset to first key|27009
# getarg srtsf
# getarg XR
        movq srtsf,XR
# ||mov|8,wb|3,srtst||; get stride|27010
# getarg srtst
# getarg WB
        movq srtst,WB
# ||add|7,xl|3,srtso||; offset to a(0)|27011
# getarg srtso
# getarg XL
        addq srtso,XL
# ||ica|7,xl|||; point to a(1)|27012
# getarg XL
        addq $8,XL
# ||mov|8,wc|3,srtsn||; get n|27013
# getarg srtsn
# getarg WC
        movq srtsn,WC
# ||btw|8,wc|||; convert from bytes|27014
# getarg WC
        shr  WC,3
# ||mov|3,srtnr|8,wc||; store as row count|27015
# getarg WC
# getarg srtnr
        movq WC,srtnr
# ||lct|8,wc|8,wc||; loop counter|27016
# |srt08|mov|10,(xl)+|7,xr||; store an offset|27020
srt08:
# getarg XR
# getarg (XL)
        movq XR,(XL)
        add  $8,XL
# ||add|7,xr|8,wb||; bump offset by stride|27021
# getarg WB
# getarg XR
        addq WB,XR
# ||bct|8,wc|6,srt08||; loop through rows|27022
# getarg WC
# getarg srt08
        decq WC
        jnz  srt08
# |srt09|mov|8,wa|3,srtsn||; get n|27029
srt09:
# getarg srtsn
# getarg WA
        movq srtsn,WA
# ||mov|8,wc|3,srtnr||; get number of rows|27030
# getarg srtnr
# getarg WC
        movq srtnr,WC
# ||rsh|8,wc|1,1||; i = n / 2 (wc=i, index into array)|27031
# getarg 1
# getarg WC
        shl  1,WC
# ||wtb|8,wc|||; convert back to bytes|27032
# getarg WC
        sal  WC,3
# |srt10|jsr|6,sorth|||; sorth(i,n)|27036
srt10:
# getarg sorth
        call sorth
# ||dca|8,wc|||; i = i - 1|27037
# getarg WC
        subq $8,WC
# ||bnz|8,wc|6,srt10||; loop if i gt 0|27038
# getarg WC
# getarg WC
# getarg srt10
        or   WC,WC
        jnz  srt10
# ||mov|8,wc|8,wa||; i = n|27039
# getarg WA
# getarg WC
        movq WA,WC
# |srt11|dca|8,wc|||; i = i - 1 (n - 1 initially)|27045
srt11:
# getarg WC
        subq $8,WC
# ||bze|8,wc|6,srt12||; jump if done|27046
# getarg WC
# getarg srt12
        or   WC,WC
        jz   srt12
# ||mov|7,xr|9,(xs)||; get sort array address|27047
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,srtso||; point to a(0)|27048
# getarg srtso
# getarg XR
        addq srtso,XR
# ||mov|7,xl|7,xr||; a(0) address|27049
# getarg XR
# getarg XL
        movq XR,XL
# ||add|7,xl|8,wc||; a(i) address|27050
# getarg WC
# getarg XL
        addq WC,XL
# ||mov|8,wb|13,num01(xl)||; copy a(i+1)|27051
# getarg num01(,XL,8)
# getarg WB
        movq num01(,XL,8),WB
# ||mov|13,num01(xl)|13,num01(xr)||; move a(1) to a(i+1)|27052
# getarg num01(,XR,8)
# getarg W0
# getarg num01(,XL,8)
        movq num01(,XR,8),W0
        movq W0,num01(,XL,8)
# ||mov|13,num01(xr)|8,wb||; complete exchange of a(1), a(i+1)|27053
# getarg WB
# getarg num01(,XR,8)
        movq WB,num01(,XR,8)
# ||mov|8,wa|8,wc||; n = i for sorth|27054
# getarg WC
# getarg WA
        movq WC,WA
# ||mov|8,wc|19,*num01||; i = 1 for sorth|27055
# getarg W0
# getarg WC
        movq l_0936,W0
        movq W0,WC
# ||jsr|6,sorth|||; sorth(1,n)|27056
# getarg sorth
        call sorth
# ||mov|8,wc|8,wa||; restore wc|27057
# getarg WA
# getarg WC
        movq WA,WC
# ||brn|6,srt11|||; loop|27058
# getarg srt11
        jmp  srt11
# ||ejc|||||27059
# |srt12|mov|7,xr|9,(xs)||; base adrs of key array|27066
srt12:
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|8,wc|7,xr||; copy it|27067
# getarg XR
# getarg WC
        movq XR,WC
# ||add|8,wc|3,srtso||; offset of a(0)|27068
# getarg srtso
# getarg WC
        addq srtso,WC
# ||add|7,xr|3,srtsf||; adrs of first row of sort array|27069
# getarg srtsf
# getarg XR
        addq srtsf,XR
# ||mov|8,wb|3,srtst||; get stride|27070
# getarg srtst
# getarg WB
        movq srtst,WB
# |srt13|ica|8,wc|||; adrs of next of sorted offsets|27075
srt13:
# getarg WC
        addq $8,WC
# ||mov|7,xl|8,wc||; copy it for access|27076
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|7,xl|9,(xl)||; get offset|27077
# getarg (XL)
# getarg XL
        movq (XL),XL
# ||add|7,xl|13,num01(xs)||; add key array base adrs|27078
# getarg num01(,XT,8)
# getarg XL
        addq num01(,XT,8),XL
# ||mov|8,wa|8,wb||; get count of characters in row|27079
# getarg WB
# getarg WA
        movq WB,WA
# ||mvw||||; copy a complete row|27080
        shr  WA,$3
        shr  WA,$3
        std
        sub  $8,XL
        sub  $8,XR
l_0946:
        or   WA,WA
        jz   l_0947
        movsq
        decq WA
        jmp  l_0946
l_0947:
        cld
# ||dcv|3,srtnr|||; decrement row count|27081
# getarg srtnr
        decq srtnr
# ||bnz|3,srtnr|6,srt13||; repeat till all rows done|27082
# getarg srtnr
# getarg srt13
        xor  W0,W0
        cmpq srtnr,W0
        jnz  srt13
# |srt15|mov|7,xr|10,(xs)+||; pop result array ptr|27086
srt15:
# getarg XR
        pop  XR
# ||ica|7,xs|||; pop key array ptr|27087
# getarg XT
        addq $8,XT
# ||zer|3,r_sxl|||; clear junk|27088
# getarg r_sxl
        mov  $0,W0
        mov  W0,r_sxl
# ||zer|3,r_sxr|||; clear junk|27089
# getarg r_sxr
        mov  $0,W0
        mov  W0,r_sxr
# ||exi||||; return|27090
# getarg 
        movq $0,rcode
        mov  prc_+8*15,W0
        jmp  *W0
# |srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||27094
srt16:
        movq $256,rcode
        jmp  err_
# |srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||27095
srt17:
        movq $258,rcode
        jmp  err_
# |srt18|exi|1,1|||; return indication of null table|27099
srt18:
# getarg 1
        movq $1,rcode
        mov  prc_+8*15,W0
        jmp  *W0
# ||enp||||; end procudure sorta|27100
# ||ejc|||||27101
# |sortc|prc|25,e|1,1||; entry point|27122
sortc:
# getarg 1
# ||mov|3,srts1|8,wa||; save offset 1|27123
# getarg WA
# getarg srts1
        movq WA,srts1
# ||mov|3,srts2|8,wb||; save offset 2|27124
# getarg WB
# getarg srts2
        movq WB,srts2
# ||mov|3,srtsc|8,wc||; save wc|27125
# getarg WC
# getarg srtsc
        movq WC,srtsc
# ||add|7,xl|3,srtof||; add offset to comparand field|27126
# getarg srtof
# getarg XL
        addq srtof,XL
# ||mov|7,xr|7,xl||; copy base + offset|27127
# getarg XL
# getarg XR
        movq XL,XR
# ||add|7,xl|8,wa||; add key1 offset|27128
# getarg WA
# getarg XL
        addq WA,XL
# ||add|7,xr|8,wb||; add key2 offset|27129
# getarg WB
# getarg XR
        addq WB,XR
# ||mov|7,xl|9,(xl)||; get key1|27130
# getarg (XL)
# getarg XL
        movq (XL),XL
# ||mov|7,xr|9,(xr)||; get key2|27131
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||bne|3,srtdf|21,=nulls|6,src12|; jump if datatype field name used|27132
# getarg srtdf
# getarg W0
# getarg src12
        movq l_0054,W0
        cmpq srtdf,W0
        jne  src12
# ||ejc|||||27133
# |src01|mov|8,wc|9,(xl)||; get type code|27139
src01:
# getarg (XL)
# getarg WC
        movq (XL),WC
# ||bne|8,wc|9,(xr)|6,src02|; skip if not same datatype|27140
# getarg WC
# getarg (XR)
# getarg src02
        cmpq WC,(XR)
        jne  src02
# ||beq|8,wc|22,=b_scl|6,src09|; jump if both strings|27141
# getarg WC
# getarg W0
# getarg src09
        movq l_0094,W0
        cmpq WC,W0
        je   src09
# ||beq|8,wc|22,=b_icl|6,src14|; jump if both integers|27142
# getarg WC
# getarg W0
# getarg src14
        movq l_0087,W0
        cmpq WC,W0
        je   src14
# |src02|mov|3,r_sxl|7,xl||; keep arg1|27150
src02:
# getarg XL
# getarg r_sxl
        movq XL,r_sxl
# ||mov|3,r_sxr|7,xr||; keep arg2|27151
# getarg XR
# getarg r_sxr
        movq XR,r_sxr
# ||beq|8,wc|22,=b_scl|6,src11|; do not allow conversion to number|27154
# getarg WC
# getarg W0
# getarg src11
        movq l_0094,W0
        cmpq WC,W0
        je   src11
# ||beq|9,(xr)|22,=b_scl|6,src11|; if either arg is a string|27155
# getarg (XR)
# getarg W0
# getarg src11
        movq l_0094,W0
        cmpq (XR),W0
        je   src11
# |src14|mov|11,-(xs)|7,xl||; stack|27198
src14:
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; args|27199
# getarg XR
        push XR
# ||jsr|6,acomp|||; compare objects|27200
# getarg acomp
        call acomp
        decq rcode
        js   call_278
# ||ppm|6,src10|||; not numeric|27201
# getarg src10
# getarg src10
        decq rcode
        jns  l_0948
        jmp  src10
l_0948:
# ||ppm|6,src10|||; not numeric|27202
# getarg src10
# getarg src10
        decq rcode
        jns  l_0949
        jmp  src10
l_0949:
# ||ppm|6,src03|||; key1 less|27203
# getarg src03
# getarg src03
        decq rcode
        jns  l_0950
        jmp  src03
l_0950:
# ||ppm|6,src08|||; keys equal|27204
# getarg src08
# getarg src08
        decq rcode
        jns  l_0951
        jmp  src08
l_0951:
# ||ppm|6,src05|||; key1 greater|27205
# getarg src05
# getarg src05
        decq rcode
        jns  l_0952
        jmp  src05
l_0952:
call_278:
# |src03|bnz|3,srtsr|6,src06||; jump if rsort|27209
src03:
# getarg srtsr
# getarg src06
        xor  W0,W0
        cmpq srtsr,W0
        jnz  src06
# |src04|mov|8,wc|3,srtsc||; restore wc|27211
src04:
# getarg srtsc
# getarg WC
        movq srtsc,WC
# ||exi|1,1|||; return|27212
# getarg 1
        movq $1,rcode
        ret
# |src05|bnz|3,srtsr|6,src04||; jump if rsort|27216
src05:
# getarg srtsr
# getarg src04
        xor  W0,W0
        cmpq srtsr,W0
        jnz  src04
# |src06|mov|8,wc|3,srtsc||; restore wc|27218
src06:
# getarg srtsc
# getarg WC
        movq srtsc,WC
# ||exi||||; return|27219
# getarg 
        movq $0,rcode
        ret
# |src07|blt|7,xl|7,xr|6,src03|; item first created is less|27223
src07:
# getarg XL
# getarg XR
# getarg src03
        cmpq XL,XR
        jb   src03
# ||bgt|7,xl|7,xr|6,src05|; addresses rise in order of creation|27224
# getarg XL
# getarg XR
# getarg src05
        cmpq XL,XR
        ja   src05
# |src08|blt|3,srts1|3,srts2|6,src04|; test offsets or key addrss instead|27228
src08:
# getarg srts2
# getarg srts1
# getarg W0
# getarg src04
        movq srts2,W0
        cmpq srts1,W0
        jb   src04
# ||brn|6,src06|||; offset 1 greater|27229
# getarg src06
        jmp  src06
# ||ejc|||||27230
# |src09|mov|11,-(xs)|7,xl||; stack|27240
src09:
# getarg XL
        push XL
# ||mov|11,-(xs)|7,xr||; args|27241
# getarg XR
        push XR
# ||jsr|6,lcomp|||; compare objects|27242
# getarg lcomp
        call lcomp
        decq rcode
        js   call_279
# ||ppm||||; cant|27243
# getarg 
        decq rcode
        jns  l_0953
        movq $299,rcode
        jmp  err_
l_0953:
# ||ppm||||; fail|27244
# getarg 
        decq rcode
        jns  l_0954
        movq $299,rcode
        jmp  err_
l_0954:
# ||ppm|6,src03|||; key1 less|27245
# getarg src03
# getarg src03
        decq rcode
        jns  l_0955
        jmp  src03
l_0955:
# ||ppm|6,src08|||; keys equal|27246
# getarg src08
# getarg src08
        decq rcode
        jns  l_0956
        jmp  src08
l_0956:
# ||ppm|6,src05|||; key1 greater|27247
# getarg src05
# getarg src05
        decq rcode
        jns  l_0957
        jmp  src05
l_0957:
call_279:
# |src10|mov|7,xl|3,r_sxl||; get arg1|27251
src10:
# getarg r_sxl
# getarg XL
        movq r_sxl,XL
# ||mov|7,xr|3,r_sxr||; get arg2|27252
# getarg r_sxr
# getarg XR
        movq r_sxr,XR
# ||mov|8,wc|9,(xl)||; get type of key1|27253
# getarg (XL)
# getarg WC
        movq (XL),WC
# ||beq|8,wc|9,(xr)|6,src07|; jump if keys of same type|27254
# getarg WC
# getarg (XR)
# getarg src07
        cmpq WC,(XR)
        je   src07
# |src11|mov|7,xl|8,wc||; get block type word|27258
src11:
# getarg WC
# getarg XL
        movq WC,XL
# ||mov|7,xr|9,(xr)||; get block type word|27259
# getarg (XR)
# getarg XR
        movq (XR),XR
# ||lei|7,xl|||; entry point id for key1|27260
        dec  XL
        mov  (XL),%al
        movzbq %al,XL
# ||lei|7,xr|||; entry point id for key2|27261
        dec  XR
        mov  (XR),%al
        movzbq %al,XR
# ||bgt|7,xl|7,xr|6,src05|; jump if key1 gt key2|27262
# getarg XL
# getarg XR
# getarg src05
        cmpq XL,XR
        ja   src05
# ||brn|6,src03|||; key1 lt key2|27263
# getarg src03
        jmp  src03
# |src12|jsr|6,sortf|||; call routine to find field 1|27267
src12:
# getarg sortf
        call sortf
# ||mov|11,-(xs)|7,xl||; stack item pointer|27268
# getarg XL
        push XL
# ||mov|7,xl|7,xr||; get key2|27269
# getarg XR
# getarg XL
        movq XR,XL
# ||jsr|6,sortf|||; find field 2|27270
# getarg sortf
        call sortf
# ||mov|7,xr|7,xl||; place as key2|27271
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xl|10,(xs)+||; recover key1|27272
# getarg XL
        pop  XL
# ||brn|6,src01|||; merge|27273
# getarg src01
        jmp  src01
# ||enp||||; procedure sortc|27274
# ||ejc|||||27275
# |sortf|prc|25,e|1,0||; entry point|27293
sortf:
# getarg 0
# ||bne|9,(xl)|22,=b_pdt|6,srtf3|; return if not pdblk|27294
# getarg (XL)
# getarg W0
# getarg srtf3
        movq l_0139,W0
        cmpq (XL),W0
        jne  srtf3
# ||mov|11,-(xs)|7,xr||; keep xr|27295
# getarg XR
        push XR
# ||mov|7,xr|3,srtfd||; get possible former dfblk ptr|27296
# getarg srtfd
# getarg XR
        movq srtfd,XR
# ||bze|7,xr|6,srtf4||; jump if not|27297
# getarg XR
# getarg srtf4
        or   XR,XR
        jz   srtf4
# ||bne|7,xr|13,pddfp(xl)|6,srtf4|; jump if not right datatype|27298
# getarg XR
# getarg pddfp(,XL,8)
# getarg srtf4
        cmpq XR,pddfp(,XL,8)
        jne  srtf4
# ||bne|3,srtdf|3,srtff|6,srtf4|; jump if not right field name|27299
# getarg srtff
# getarg srtdf
# getarg W0
# getarg srtf4
        movq srtff,W0
        cmpq srtdf,W0
        jne  srtf4
# ||add|7,xl|3,srtfo||; add offset to required field|27300
# getarg srtfo
# getarg XL
        addq srtfo,XL
# |srtf1|mov|7,xl|9,(xl)||; get item from field|27304
srtf1:
# getarg (XL)
# getarg XL
        movq (XL),XL
# |srtf2|mov|7,xr|10,(xs)+||; restore xr|27308
srtf2:
# getarg XR
        pop  XR
# |srtf3|exi||||; return|27310
srtf3:
# getarg 
        ret
# ||ejc|||||27311
# |srtf4|mov|7,xr|7,xl||; copy original pointer|27317
srtf4:
# getarg XL
# getarg XR
        movq XL,XR
# ||mov|7,xr|13,pddfp(xr)||; point to dfblk|27318
# getarg pddfp(,XR,8)
# getarg XR
        movq pddfp(,XR,8),XR
# ||mov|3,srtfd|7,xr||; keep a copy|27319
# getarg XR
# getarg srtfd
        movq XR,srtfd
# ||mov|8,wc|13,fargs(xr)||; get number of fields|27320
# getarg fargs(,XR,8)
# getarg WC
        movq fargs(,XR,8),WC
# ||wtb|8,wc|||; convert to bytes|27321
# getarg WC
        sal  WC,3
# ||add|7,xr|13,dflen(xr)||; point past last field|27322
# getarg dflen(,XR,8)
# getarg XR
        addq dflen(,XR,8),XR
# |srtf5|dca|8,wc|||; count down|27326
srtf5:
# getarg WC
        subq $8,WC
# ||dca|7,xr|||; point in front|27327
# getarg XR
        subq $8,XR
# ||beq|9,(xr)|3,srtdf|6,srtf6|; skip out if found|27328
# getarg srtdf
# getarg (XR)
# getarg W0
# getarg srtf6
        movq srtdf,W0
        cmpq (XR),W0
        je   srtf6
# ||bnz|8,wc|6,srtf5||; loop|27329
# getarg WC
# getarg WC
# getarg srtf5
        or   WC,WC
        jnz  srtf5
# ||brn|6,srtf2|||; return - not found|27330
# getarg srtf2
        jmp  srtf2
# |srtf6|mov|3,srtff|9,(xr)||; keep field name ptr|27334
srtf6:
# getarg (XR)
# getarg W0
# getarg srtff
        movq (XR),W0
        movq W0,srtff
# ||add|8,wc|19,*pdfld||; add offset to first field|27335
# getarg W0
# getarg WC
        movq l_0019,W0
        addq W0,WC
# ||mov|3,srtfo|8,wc||; store as field offset|27336
# getarg WC
# getarg srtfo
        movq WC,srtfo
# ||add|7,xl|8,wc||; point to field|27337
# getarg WC
# getarg XL
        addq WC,XL
# ||brn|6,srtf1|||; return|27338
# getarg srtf1
        jmp  srtf1
# ||enp||||; procedure sortf|27339
# ||ejc|||||27340
# |sorth|prc|25,n|1,0||; entry point|27355
sorth:
# getarg 0
        pop  prc_+8*16
# ||mov|3,srtsn|8,wa||; save n|27356
# getarg WA
# getarg srtsn
        movq WA,srtsn
# ||mov|3,srtwc|8,wc||; keep wc|27357
# getarg WC
# getarg srtwc
        movq WC,srtwc
# ||mov|7,xl|9,(xs)||; sort array base adrs|27358
# getarg (XT)
# getarg XL
        movq (XT),XL
# ||add|7,xl|3,srtso||; add offset to a(0)|27359
# getarg srtso
# getarg XL
        addq srtso,XL
# ||add|7,xl|8,wc||; point to a(j)|27360
# getarg WC
# getarg XL
        addq WC,XL
# ||mov|3,srtrt|9,(xl)||; get offset to root|27361
# getarg (XL)
# getarg W0
# getarg srtrt
        movq (XL),W0
        movq W0,srtrt
# ||add|8,wc|8,wc||; double j - cant exceed n|27362
# getarg WC
# getarg WC
        addq WC,WC
# |srh01|bgt|8,wc|3,srtsn|6,srh03|; done if j gt n|27366
srh01:
# getarg WC
# getarg srtsn
# getarg srh03
        cmpq WC,srtsn
        ja   srh03
# ||beq|8,wc|3,srtsn|6,srh02|; skip if j equals n|27367
# getarg WC
# getarg srtsn
# getarg srh02
        cmpq WC,srtsn
        je   srh02
# ||mov|7,xr|9,(xs)||; sort array base adrs|27368
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|7,xl|13,num01(xs)||; key array base adrs|27369
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||add|7,xr|3,srtso||; point to a(0)|27370
# getarg srtso
# getarg XR
        addq srtso,XR
# ||add|7,xr|8,wc||; adrs of a(j)|27371
# getarg WC
# getarg XR
        addq WC,XR
# ||mov|8,wa|13,num01(xr)||; get a(j+1)|27372
# getarg num01(,XR,8)
# getarg WA
        movq num01(,XR,8),WA
# ||mov|8,wb|9,(xr)||; get a(j)|27373
# getarg (XR)
# getarg WB
        movq (XR),WB
# ||jsr|6,sortc|||; compare keys - lt(a(j+1),a(j))|27377
# getarg sortc
        call sortc
        decq rcode
        js   call_280
# ||ppm|6,srh02|||; a(j+1) lt a(j)|27378
# getarg srh02
# getarg srh02
        decq rcode
        jns  l_0958
        jmp  srh02
l_0958:
call_280:
# ||ica|8,wc|||; point to greater son, a(j+1)|27379
# getarg WC
        addq $8,WC
# ||ejc|||||27380
# |srh02|mov|7,xl|13,num01(xs)||; key array base adrs|27386
srh02:
# getarg num01(,XT,8)
# getarg XL
        movq num01(,XT,8),XL
# ||mov|7,xr|9,(xs)||; get sort array address|27387
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,srtso||; adrs of a(0)|27388
# getarg srtso
# getarg XR
        addq srtso,XR
# ||mov|8,wb|7,xr||; copy this adrs|27389
# getarg XR
# getarg WB
        movq XR,WB
# ||add|7,xr|8,wc||; adrs of greater son, a(j)|27390
# getarg WC
# getarg XR
        addq WC,XR
# ||mov|8,wa|9,(xr)||; get a(j)|27391
# getarg (XR)
# getarg WA
        movq (XR),WA
# ||mov|7,xr|8,wb||; point back to a(0)|27392
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|8,wb|3,srtrt||; get root|27393
# getarg srtrt
# getarg WB
        movq srtrt,WB
# ||jsr|6,sortc|||; compare them - lt(a(j),root)|27394
# getarg sortc
        call sortc
        decq rcode
        js   call_281
# ||ppm|6,srh03|||; father exceeds sons - done|27395
# getarg srh03
# getarg srh03
        decq rcode
        jns  l_0959
        jmp  srh03
l_0959:
call_281:
# ||mov|7,xr|9,(xs)||; get sort array adrs|27396
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,srtso||; point to a(0)|27397
# getarg srtso
# getarg XR
        addq srtso,XR
# ||mov|7,xl|7,xr||; copy it|27398
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|8,wc||; copy j|27399
# getarg WC
# getarg WA
        movq WC,WA
# ||btw|8,wc|||; convert to words|27400
# getarg WC
        shr  WC,3
# ||rsh|8,wc|1,1||; get j/2|27401
# getarg 1
# getarg WC
        shl  1,WC
# ||wtb|8,wc|||; convert back to bytes|27402
# getarg WC
        sal  WC,3
# ||add|7,xl|8,wa||; point to a(j)|27403
# getarg WA
# getarg XL
        addq WA,XL
# ||add|7,xr|8,wc||; adrs of a(j/2)|27404
# getarg WC
# getarg XR
        addq WC,XR
# ||mov|9,(xr)|9,(xl)||; a(j/2) = a(j)|27405
# getarg (XL)
# getarg W0
# getarg (XR)
        movq (XL),W0
        movq W0,(XR)
# ||mov|8,wc|8,wa||; recover j|27406
# getarg WA
# getarg WC
        movq WA,WC
# ||aov|8,wc|8,wc|6,srh03|; j = j*2. done if too big|27407
# getarg WC
# getarg WC
# getarg srh03
        add  WC,WC
        jc   srh03
# ||brn|6,srh01|||; loop|27408
# getarg srh01
        jmp  srh01
# |srh03|btw|8,wc|||; convert to words|27412
srh03:
# getarg WC
        shr  WC,3
# ||rsh|8,wc|1,1||; j = j/2|27413
# getarg 1
# getarg WC
        shl  1,WC
# ||wtb|8,wc|||; convert back to bytes|27414
# getarg WC
        sal  WC,3
# ||mov|7,xr|9,(xs)||; sort array adrs|27415
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||add|7,xr|3,srtso||; adrs of a(0)|27416
# getarg srtso
# getarg XR
        addq srtso,XR
# ||add|7,xr|8,wc||; adrs of a(j/2)|27417
# getarg WC
# getarg XR
        addq WC,XR
# ||mov|9,(xr)|3,srtrt||; a(j/2) = root|27418
# getarg srtrt
# getarg W0
# getarg (XR)
        movq srtrt,W0
        movq W0,(XR)
# ||mov|8,wa|3,srtsn||; restore wa|27419
# getarg srtsn
# getarg WA
        movq srtsn,WA
# ||mov|8,wc|3,srtwc||; restore wc|27420
# getarg srtwc
# getarg WC
        movq srtwc,WC
# ||exi||||; return|27421
# getarg 
        movq $0,rcode
        mov  prc_+8*16,W0
        jmp  *W0
# ||enp||||; end procedure sorth|27422
# ||ejc|||||27424
# |trace|prc|25,n|1,2||; entry point|27440
trace:
# getarg 2
        pop  prc_+8*17
# ||jsr|6,gtstg|||; get trace type string|27441
# getarg gtstg
        call gtstg
        decq rcode
        js   call_282
# ||ppm|6,trc15|||; jump if not string|27442
# getarg trc15
# getarg trc15
        decq rcode
        jns  l_0960
        jmp  trc15
l_0960:
call_282:
# ||plc|7,xr|||; else point to string|27443
# getarg XR
        add  $cfp_f,XR
# ||lch|8,wa|9,(xr)||; load first character|27444
# getarg WA
        xor  W0,W0
        movb (XR),%al
        mov  W0,WA
# ||flc|8,wa|||; fold to lower case|27446
# getarg WA
        cmpb
        jb   l_0961
        cmpb
        ja   l_0961
        add  $32
l_0961:
# ||mov|7,xr|9,(xs)||; load name argument|27448
# getarg (XT)
# getarg XR
        movq (XT),XR
# ||mov|9,(xs)|7,xl||; stack trblk ptr or zero|27449
# getarg XL
# getarg (XT)
        movq XL,(XT)
# ||mov|8,wc|18,=trtac||; set trtyp for access trace|27450
# getarg W0
# getarg WC
        movq l_0595,W0
        movq W0,WC
# ||beq|8,wa|18,=ch_la|6,trc10|; jump if a (access)|27451
# getarg WA
# getarg W0
# getarg trc10
        .data
l_0962: .long ch_la
        .text
        movq l_0962,W0
        cmpq WA,W0
        je   trc10
# ||mov|8,wc|18,=trtvl||; set trtyp for value trace|27452
# getarg W0
# getarg WC
        movq l_0610,W0
        movq W0,WC
# ||beq|8,wa|18,=ch_lv|6,trc10|; jump if v (value)|27453
# getarg WA
# getarg W0
# getarg trc10
        .data
l_0963: .long ch_lv
        .text
        movq l_0963,W0
        cmpq WA,W0
        je   trc10
# ||beq|8,wa|18,=ch_bl|6,trc10|; jump if blank (value)|27454
# getarg WA
# getarg W0
# getarg trc10
        movq l_0572,W0
        cmpq WA,W0
        je   trc10
# ||beq|8,wa|18,=ch_lf|6,trc01|; jump if f (function)|27458
# getarg WA
# getarg W0
# getarg trc01
        .data
l_0964: .long ch_lf
        .text
        movq l_0964,W0
        cmpq WA,W0
        je   trc01
# ||beq|8,wa|18,=ch_lr|6,trc01|; jump if r (return)|27459
# getarg WA
# getarg W0
# getarg trc01
        .data
l_0965: .long ch_lr
        .text
        movq l_0965,W0
        cmpq WA,W0
        je   trc01
# ||beq|8,wa|18,=ch_ll|6,trc03|; jump if l (label)|27460
# getarg WA
# getarg W0
# getarg trc03
        .data
l_0966: .long ch_ll
        .text
        movq l_0966,W0
        cmpq WA,W0
        je   trc03
# ||beq|8,wa|18,=ch_lk|6,trc06|; jump if k (keyword)|27461
# getarg WA
# getarg W0
# getarg trc06
        .data
l_0967: .long ch_lk
        .text
        movq l_0967,W0
        cmpq WA,W0
        je   trc06
# ||bne|8,wa|18,=ch_lc|6,trc15|; else error if not c (call)|27462
# getarg WA
# getarg W0
# getarg trc15
        .data
l_0968: .long ch_lc
        .text
        movq l_0968,W0
        cmpq WA,W0
        jne  trc15
# |trc01|jsr|6,gtnvr|||; point to vrblk for name|27466
trc01:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_283
# ||ppm|6,trc16|||; jump if bad name|27467
# getarg trc16
# getarg trc16
        decq rcode
        jns  l_0969
        jmp  trc16
l_0969:
call_283:
# ||ica|7,xs|||; pop stack|27468
# getarg XT
        addq $8,XT
# ||mov|7,xr|13,vrfnc(xr)||; point to function block|27469
# getarg vrfnc(,XR,8)
# getarg XR
        movq vrfnc(,XR,8),XR
# ||bne|9,(xr)|22,=b_pfc|6,trc17|; error if not program function|27470
# getarg (XR)
# getarg W0
# getarg trc17
        movq l_0238,W0
        cmpq (XR),W0
        jne  trc17
# ||beq|8,wa|18,=ch_lr|6,trc02|; jump if r (return)|27471
# getarg WA
# getarg W0
# getarg trc02
        movq l_0965,W0
        cmpq WA,W0
        je   trc02
# ||ejc|||||27472
# ||mov|13,pfctr(xr)|7,xl||; set/reset call trace|27478
# getarg XL
# getarg pfctr(,XR,8)
        movq XL,pfctr(,XR,8)
# ||beq|8,wa|18,=ch_lc|6,exnul|; exit with null if c (call)|27479
# getarg WA
# getarg W0
# getarg exnul
        movq l_0968,W0
        cmpq WA,W0
        je   exnul
# |trc02|mov|13,pfrtr(xr)|7,xl||; set/reset return trace|27483
trc02:
# getarg XL
# getarg pfrtr(,XR,8)
        movq XL,pfrtr(,XR,8)
# ||exi||||; return|27484
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc03|jsr|6,gtnvr|||; point to vrblk|27488
trc03:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_284
# ||ppm|6,trc16|||; jump if bad name|27489
# getarg trc16
# getarg trc16
        decq rcode
        jns  l_0970
        jmp  trc16
l_0970:
call_284:
# ||mov|7,xl|13,vrlbl(xr)||; load label pointer|27490
# getarg vrlbl(,XR,8)
# getarg XL
        movq vrlbl(,XR,8),XL
# ||bne|9,(xl)|22,=b_trt|6,trc04|; jump if no old trace|27491
# getarg (XL)
# getarg W0
# getarg trc04
        movq l_0154,W0
        cmpq (XL),W0
        jne  trc04
# ||mov|7,xl|13,trlbl(xl)||; else delete old trace association|27492
# getarg trlbl(,XL,8)
# getarg XL
        movq trlbl(,XL,8),XL
# |trc04|beq|7,xl|21,=stndl|6,trc16|; error if undefined label|27496
trc04:
# getarg XL
# getarg W0
# getarg trc16
        movq l_0157,W0
        cmpq XL,W0
        je   trc16
# ||mov|8,wb|10,(xs)+||; get trblk ptr again|27497
# getarg WB
        pop  WB
# ||bze|8,wb|6,trc05||; jump if stoptr case|27498
# getarg WB
# getarg trc05
        or   WB,WB
        jz   trc05
# ||mov|13,vrlbl(xr)|8,wb||; else set new trblk pointer|27499
# getarg WB
# getarg vrlbl(,XR,8)
        movq WB,vrlbl(,XR,8)
# ||mov|13,vrtra(xr)|22,=b_vrt||; set label trace routine address|27500
# getarg W0
# getarg vrtra(,XR,8)
        .data
l_0971: .long b_vrt
        .text
        movq l_0971,W0
        movq W0,vrtra(,XR,8)
# ||mov|7,xr|8,wb||; copy trblk pointer|27501
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|13,trlbl(xr)|7,xl||; store real label in trblk|27502
# getarg XL
# getarg trlbl(,XR,8)
        movq XL,trlbl(,XR,8)
# ||exi||||; return|27503
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc05|mov|13,vrlbl(xr)|7,xl||; store label ptr back in vrblk|27507
trc05:
# getarg XL
# getarg vrlbl(,XR,8)
        movq XL,vrlbl(,XR,8)
# ||mov|13,vrtra(xr)|22,=b_vrg||; store normal transfer address|27508
# getarg W0
# getarg vrtra(,XR,8)
        .data
l_0972: .long b_vrg
        .text
        movq l_0972,W0
        movq W0,vrtra(,XR,8)
# ||exi||||; return|27509
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# ||ejc|||||27510
# |trc06|jsr|6,gtnvr|||; point to vrblk|27516
trc06:
# getarg gtnvr
        call gtnvr
        decq rcode
        js   call_285
# ||ppm|6,trc16|||; error if not natural var|27517
# getarg trc16
# getarg trc16
        decq rcode
        jns  l_0973
        jmp  trc16
l_0973:
call_285:
# ||bnz|13,vrlen(xr)|6,trc16||; error if not system var|27518
# getarg vrlen(,XR,8)
# getarg trc16
        xor  W0,W0
        cmpq vrlen(,XR,8),W0
        jnz  trc16
# ||ica|7,xs|||; pop stack|27519
# getarg XT
        addq $8,XT
# ||bze|7,xl|6,trc07||; jump if stoptr case|27520
# getarg XL
# getarg trc07
        or   XL,XL
        jz   trc07
# ||mov|13,trkvr(xl)|7,xr||; store vrblk ptr in trblk for ktrex|27521
# getarg XR
# getarg trkvr(,XL,8)
        movq XR,trkvr(,XL,8)
# |trc07|mov|7,xr|13,vrsvp(xr)||; point to svblk|27525
trc07:
# getarg vrsvp(,XR,8)
# getarg XR
        movq vrsvp(,XR,8),XR
# ||beq|7,xr|21,=v_ert|6,trc08|; jump if errtype|27526
# getarg XR
# getarg W0
# getarg trc08
        .data
l_0974: .long v_ert
        .text
        movq l_0974,W0
        cmpq XR,W0
        je   trc08
# ||beq|7,xr|21,=v_stc|6,trc09|; jump if stcount|27527
# getarg XR
# getarg W0
# getarg trc09
        .data
l_0975: .long v_stc
        .text
        movq l_0975,W0
        cmpq XR,W0
        je   trc09
# ||bne|7,xr|21,=v_fnc|6,trc17|; else error if not fnclevel|27528
# getarg XR
# getarg W0
# getarg trc17
        .data
l_0976: .long v_fnc
        .text
        movq l_0976,W0
        cmpq XR,W0
        jne  trc17
# ||mov|3,r_fnc|7,xl||; set/reset fnclevel trace|27532
# getarg XL
# getarg r_fnc
        movq XL,r_fnc
# ||exi||||; return|27533
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc08|mov|3,r_ert|7,xl||; set/reset errtype trace|27537
trc08:
# getarg XL
# getarg r_ert
        movq XL,r_ert
# ||exi||||; return|27538
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc09|mov|3,r_stc|7,xl||; set/reset stcount trace|27542
trc09:
# getarg XL
# getarg r_stc
        movq XL,r_stc
# ||jsr|6,stgcc|||; update countdown counters|27543
# getarg stgcc
        call stgcc
# ||exi||||; return|27544
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# ||ejc|||||27545
# |trc10|jsr|6,gtvar|||; locate variable|27551
trc10:
# getarg gtvar
        call gtvar
        decq rcode
        js   call_286
# ||ppm|6,trc16|||; error if not appropriate name|27552
# getarg trc16
# getarg trc16
        decq rcode
        jns  l_0977
        jmp  trc16
l_0977:
call_286:
# ||mov|8,wb|10,(xs)+||; get new trblk ptr again|27553
# getarg WB
        pop  WB
# ||add|8,wa|7,xl||; point to variable location|27554
# getarg XL
# getarg WA
        addq XL,WA
# ||mov|7,xr|8,wa||; copy variable pointer|27555
# getarg WA
# getarg XR
        movq WA,XR
# |trc11|mov|7,xl|9,(xr)||; point to next entry|27559
trc11:
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bne|9,(xl)|22,=b_trt|6,trc13|; jump if not trblk|27560
# getarg (XL)
# getarg W0
# getarg trc13
        movq l_0154,W0
        cmpq (XL),W0
        jne  trc13
# ||blt|8,wc|13,trtyp(xl)|6,trc13|; jump if too far out on chain|27561
# getarg WC
# getarg trtyp(,XL,8)
# getarg trc13
        cmpq WC,trtyp(,XL,8)
        jb   trc13
# ||beq|8,wc|13,trtyp(xl)|6,trc12|; jump if this matches our type|27562
# getarg WC
# getarg trtyp(,XL,8)
# getarg trc12
        cmpq WC,trtyp(,XL,8)
        je   trc12
# ||add|7,xl|19,*trnxt||; else point to link field|27563
# getarg W0
# getarg XL
        movq l_0736,W0
        addq W0,XL
# ||mov|7,xr|7,xl||; copy pointer|27564
# getarg XL
# getarg XR
        movq XL,XR
# ||brn|6,trc11|||; and loop back|27565
# getarg trc11
        jmp  trc11
# |trc12|mov|7,xl|13,trnxt(xl)||; get ptr to next block or value|27569
trc12:
# getarg trnxt(,XL,8)
# getarg XL
        movq trnxt(,XL,8),XL
# ||mov|9,(xr)|7,xl||; store to delete this trblk|27570
# getarg XL
# getarg (XR)
        movq XL,(XR)
# |trc13|bze|8,wb|6,trc14||; jump if stoptr case|27574
trc13:
# getarg WB
# getarg trc14
        or   WB,WB
        jz   trc14
# ||mov|9,(xr)|8,wb||; else link new trblk in|27575
# getarg WB
# getarg (XR)
        movq WB,(XR)
# ||mov|7,xr|8,wb||; copy trblk pointer|27576
# getarg WB
# getarg XR
        movq WB,XR
# ||mov|13,trnxt(xr)|7,xl||; store forward pointer|27577
# getarg XL
# getarg trnxt(,XR,8)
        movq XL,trnxt(,XR,8)
# ||mov|13,trtyp(xr)|8,wc||; store appropriate trap type code|27578
# getarg WC
# getarg trtyp(,XR,8)
        movq WC,trtyp(,XR,8)
# |trc14|mov|7,xr|8,wa||; recall possible vrblk pointer|27582
trc14:
# getarg WA
# getarg XR
        movq WA,XR
# ||sub|7,xr|19,*vrval||; point back to vrblk|27583
# getarg W0
# getarg XR
        movq l_0121,W0
        subq W0,XR
# ||jsr|6,setvr|||; set fields if vrblk|27584
# getarg setvr
        call setvr
# ||exi||||; return|27585
# getarg 
        movq $0,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc15|exi|1,2|||; take bad trace type error exit|27589
trc15:
# getarg 2
        movq $2,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# |trc16|ica|7,xs|||; pop stack|27593
trc16:
# getarg XT
        addq $8,XT
# |trc17|exi|1,1|||; take bad name error exit|27597
trc17:
# getarg 1
        movq $1,rcode
        mov  prc_+8*17,W0
        jmp  *W0
# ||enp||||; end procedure trace|27598
# ||ejc|||||27599
# |trbld|prc|25,e|1,0||; entry point|27613
trbld:
# getarg 0
# ||mov|11,-(xs)|7,xr||; stack trtag (or trfnm)|27614
# getarg XR
        push XR
# ||mov|8,wa|19,*trsi_||; set size of trblk|27615
# getarg W0
# getarg WA
        movq l_0031,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate trblk|27616
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_trt||; store first word|27617
# getarg W0
# getarg (XR)
        movq l_0154,W0
        movq W0,(XR)
# ||mov|13,trfnc(xr)|7,xl||; store trfnc (or trfpt)|27618
# getarg XL
# getarg trfnc(,XR,8)
        movq XL,trfnc(,XR,8)
# ||mov|13,trtag(xr)|10,(xs)+||; store trtag (or trfnm)|27619
# getarg trtag(,XR,8)
        pop  trtag(,XR,8)
# ||mov|13,trtyp(xr)|8,wb||; store type|27620
# getarg WB
# getarg trtyp(,XR,8)
        movq WB,trtyp(,XR,8)
# ||mov|13,trval(xr)|21,=nulls||; for now, a null value|27621
# getarg W0
# getarg trval(,XR,8)
        movq l_0054,W0
        movq W0,trval(,XR,8)
# ||exi||||; return to caller|27622
# getarg 
        ret
# ||enp||||; end procedure trbld|27623
# ||ejc|||||27624
# |trimr|prc|25,e|1,0||; entry point|27642
trimr:
# getarg 0
# ||mov|7,xl|7,xr||; copy string pointer|27643
# getarg XR
# getarg XL
        movq XR,XL
# ||mov|8,wa|13,sclen(xr)||; load string length|27644
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||bze|8,wa|6,trim2||; jump if null input|27645
# getarg WA
# getarg trim2
        or   WA,WA
        jz   trim2
# ||plc|7,xl|8,wa||; else point past last character|27646
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||bze|8,wb|6,trim3||; jump if no trim|27647
# getarg WB
# getarg trim3
        or   WB,WB
        jz   trim3
# ||mov|8,wc|18,=ch_bl||; load blank character|27648
# getarg W0
# getarg WC
        movq l_0572,W0
        movq W0,WC
# |trim0|lch|8,wb|11,-(xl)||; load next character|27652
trim0:
# getarg WB
        decq XL
        xor  W0,W0
        movb (XL),%al
        mov  W0,WB
# ||beq|8,wb|18,=ch_ht|6,trim1|; jump if horizontal tab|27654
# getarg WB
# getarg W0
# getarg trim1
        movq l_0693,W0
        cmpq WB,W0
        je   trim1
# ||bne|8,wb|8,wc|6,trim3|; jump if non-blank found|27656
# getarg WB
# getarg WC
# getarg trim3
        cmpq WB,WC
        jne  trim3
# |trim1|dcv|8,wa|||; else decrement character count|27657
trim1:
# getarg WA
        decq WA
# ||bnz|8,wa|6,trim0||; loop back if more to check|27658
# getarg WA
# getarg WA
# getarg trim0
        or   WA,WA
        jnz  trim0
# |trim2|mov|3,dnamp|7,xr||; wipe out input string block|27662
trim2:
# getarg XR
# getarg dnamp
        movq XR,dnamp
# ||mov|7,xr|21,=nulls||; load null result|27663
# getarg W0
# getarg XR
        movq l_0054,W0
        movq W0,XR
# ||brn|6,trim5|||; merge to exit|27664
# getarg trim5
        jmp  trim5
# ||ejc|||||27665
# |trim3|mov|13,sclen(xr)|8,wa||; set new length|27671
trim3:
# getarg WA
# getarg sclen(,XR,8)
        movq WA,sclen(,XR,8)
# ||mov|7,xl|7,xr||; copy string pointer|27672
# getarg XR
# getarg XL
        movq XR,XL
# ||psc|7,xl|8,wa||; ready for storing blanks|27673
# getarg XL
# getarg WA
        mov  WA,W0
        add  $cfp_f,W0
        mov  W0,XL
# ||ctb|8,wa|2,schar||; get length of block in bytes|27674
# getarg WA
        add  ($cfp_b-1)+$cfp_b*schar,WA
        and  WA,-$8
# ||add|8,wa|7,xr||; point past new block|27675
# getarg XR
# getarg WA
        addq XR,WA
# ||mov|3,dnamp|8,wa||; set new top of storage pointer|27676
# getarg WA
# getarg dnamp
        movq WA,dnamp
# ||lct|8,wa|18,=cfp_c||; get count of chars in word|27677
# getarg WA
# getarg W0
        .data
l_0978: .long cfp_c
        .text
        movq l_0978,W0
        mov  WA,W0
# ||zer|8,wc|||; set zero char|27678
# getarg WC
        xor  WC,WC
# |trim4|sch|8,wc|10,(xl)+||; store zero character|27682
trim4:
# getarg WC
        movb
        inc  XL
# ||bct|8,wa|6,trim4||; loop back till all stored|27683
# getarg WA
# getarg trim4
        decq WA
        jnz  trim4
# ||csc|7,xl|||; complete store characters|27684
# |trim5|zer|7,xl|||; clear garbage xl pointer|27688
trim5:
# getarg XL
        xor  XL,XL
# ||exi||||; return to caller|27689
# getarg 
        ret
# ||enp||||; end procedure trimr|27690
# ||ejc|||||27691
# |trxeq|prc|25,r|1,0||; entry point (recursive)|27722
trxeq:
# getarg 0
# ||mov|8,wc|3,r_cod||; load code block pointer|27723
# getarg r_cod
# getarg WC
        movq r_cod,WC
# ||scp|8,wb|||; get current code pointer|27724
# getarg WB
        scp_ WB
# ||sub|8,wb|8,wc||; make code pointer into offset|27725
# getarg WC
# getarg WB
        subq WC,WB
# ||mov|11,-(xs)|3,kvtra||; stack trace keyword value|27726
# getarg kvtra
        push kvtra
# ||mov|11,-(xs)|7,xr||; stack trblk pointer|27727
# getarg XR
        push XR
# ||mov|11,-(xs)|7,xl||; stack name base|27728
# getarg XL
        push XL
# ||mov|11,-(xs)|8,wa||; stack name offset|27729
# getarg WA
        push WA
# ||mov|11,-(xs)|8,wc||; stack code block pointer|27730
# getarg WC
        push WC
# ||mov|11,-(xs)|8,wb||; stack code pointer offset|27731
# getarg WB
        push WB
# ||mov|11,-(xs)|3,flptr||; stack old failure pointer|27732
# getarg flptr
        push flptr
# ||zer|11,-(xs)|||; set dummy fail offset|27733
        push $0
# ||mov|3,flptr|7,xs||; set new failure pointer|27734
# getarg XT
# getarg flptr
        movq XT,flptr
# ||zer|3,kvtra|||; reset trace keyword to zero|27735
# getarg kvtra
        mov  $0,W0
        mov  W0,kvtra
# ||mov|8,wc|21,=trxdc||; load new (dummy) code blk pointer|27736
# getarg W0
# getarg WC
        .data
l_0979: .long trxdc
        .text
        movq l_0979,W0
        movq W0,WC
# ||mov|3,r_cod|8,wc||; set as code block pointer|27737
# getarg WC
# getarg r_cod
        movq WC,r_cod
# ||lcp|8,wc|||; and new code pointer|27738
# getarg WC
        lcp_ WC
# ||ejc|||||27739
# ||mov|8,wb|8,wa||; save name offset|27745
# getarg WA
# getarg WB
        movq WA,WB
# ||mov|8,wa|19,*nmsi_||; load nmblk size|27746
# getarg W0
# getarg WA
        movq l_0125,W0
        movq W0,WA
# ||jsr|6,alloc|||; allocate space for nmblk|27747
# getarg alloc
        call alloc
# ||mov|9,(xr)|22,=b_nml||; set type word|27748
# getarg W0
# getarg (XR)
        movq l_0126,W0
        movq W0,(XR)
# ||mov|13,nmbas(xr)|7,xl||; store name base|27749
# getarg XL
# getarg nmbas(,XR,8)
        movq XL,nmbas(,XR,8)
# ||mov|13,nmofs(xr)|8,wb||; store name offset|27750
# getarg WB
# getarg nmofs(,XR,8)
        movq WB,nmofs(,XR,8)
# ||mov|7,xl|12,6(xs)||; reload pointer to trblk|27751
# getarg 6(,XT,8)
# getarg XL
        movq 6(,XT,8),XL
# ||mov|11,-(xs)|7,xr||; stack nmblk pointer (1st argument)|27752
# getarg XR
        push XR
# ||mov|11,-(xs)|13,trtag(xl)||; stack trace tag (2nd argument)|27753
# getarg trtag(,XL,8)
        push trtag(,XL,8)
# ||mov|7,xl|13,trfnc(xl)||; load trace vrblk pointer|27754
# getarg trfnc(,XL,8)
# getarg XL
        movq trfnc(,XL,8),XL
# ||mov|7,xl|13,vrfnc(xl)||; load trace function pointer|27755
# getarg vrfnc(,XL,8)
# getarg XL
        movq vrfnc(,XL,8),XL
# ||beq|7,xl|21,=stndf|6,trxq2|; jump if not a defined function|27756
# getarg XL
# getarg W0
# getarg trxq2
        movq l_0561,W0
        cmpq XL,W0
        je   trxq2
# ||mov|8,wa|18,=num02||; set number of arguments to two|27757
# getarg W0
# getarg WA
        movq l_0130,W0
        movq W0,WA
# ||brn|6,cfunc|||; jump to call function|27758
# getarg cfunc
        jmp  cfunc
# |trxq1|mov|7,xs|3,flptr||; point back to our stack entries|27762
trxq1:
# getarg flptr
# getarg XT
        movq flptr,XT
# ||ica|7,xs|||; pop off garbage fail offset|27763
# getarg XT
        addq $8,XT
# ||mov|3,flptr|10,(xs)+||; restore old failure pointer|27764
# getarg flptr
        pop  flptr
# ||mov|8,wb|10,(xs)+||; reload code offset|27765
# getarg WB
        pop  WB
# ||mov|8,wc|10,(xs)+||; load old code base pointer|27766
# getarg WC
        pop  WC
# ||mov|7,xr|8,wc||; copy cdblk pointer|27767
# getarg WC
# getarg XR
        movq WC,XR
# ||mov|3,kvstn|13,cdstm(xr)||; restore stmnt no|27768
# getarg cdstm(,XR,8)
# getarg W0
# getarg kvstn
        movq cdstm(,XR,8),W0
        movq W0,kvstn
# ||mov|8,wa|10,(xs)+||; reload name offset|27769
# getarg WA
        pop  WA
# ||mov|7,xl|10,(xs)+||; reload name base|27770
# getarg XL
        pop  XL
# ||mov|7,xr|10,(xs)+||; reload trblk pointer|27771
# getarg XR
        pop  XR
# ||mov|3,kvtra|10,(xs)+||; restore trace keyword value|27772
# getarg kvtra
        pop  kvtra
# ||add|8,wb|8,wc||; recompute absolute code pointer|27773
# getarg WC
# getarg WB
        addq WC,WB
# ||lcp|8,wb|||; restore code pointer|27774
# getarg WB
        lcp_ WB
# ||mov|3,r_cod|8,wc||; and code block pointer|27775
# getarg WC
# getarg r_cod
        movq WC,r_cod
# ||exi||||; return to trxeq caller|27776
# getarg 
        ret
# |trxq2|erb|1,197|26,trace fourth arg is not function name or null|||27780
trxq2:
        movq $197,rcode
        jmp  err_
# ||enp||||; end procedure trxeq|27782
# ||ejc|||||27783
# ||ejc|||||27823
# |xscan|prc|25,e|1,0||; entry point|27827
xscan:
# getarg 0
# ||mov|3,xscwb|8,wb||; preserve wb|27828
# getarg WB
# getarg xscwb
        movq WB,xscwb
# ||mov|11,-(xs)|8,wa||; record blank skip flag|27829
# getarg WA
        push WA
# ||mov|11,-(xs)|8,wa||; and second copy|27830
# getarg WA
        push WA
# ||mov|7,xr|3,r_xsc||; point to argument string|27831
# getarg r_xsc
# getarg XR
        movq r_xsc,XR
# ||mov|8,wa|13,sclen(xr)||; load string length|27832
# getarg sclen(,XR,8)
# getarg WA
        movq sclen(,XR,8),WA
# ||mov|8,wb|3,xsofs||; load current offset|27833
# getarg xsofs
# getarg WB
        movq xsofs,WB
# ||sub|8,wa|8,wb||; get number of remaining characters|27834
# getarg WB
# getarg WA
        subq WB,WA
# ||bze|8,wa|6,xscn3||; jump if no characters left|27835
# getarg WA
# getarg xscn3
        or   WA,WA
        jz   xscn3
# ||plc|7,xr|8,wb||; point to current character|27836
# getarg XR
# getarg WB
        mov  WB,W0
        add  $cfp_f,W0
        mov  W0,XR
# |xscn1|lch|8,wb|10,(xr)+||; load next character|27840
xscn1:
# getarg WB
        xor  W0,W0
        movb (XR),%al
        mov  W0,WB
        incq XR
# ||beq|8,wb|8,wc|6,xscn4|; jump if delimiter one found|27841
# getarg WB
# getarg WC
# getarg xscn4
        cmpq WB,WC
        je   xscn4
# ||beq|8,wb|7,xl|6,xscn5|; jump if delimiter two found|27842
# getarg WB
# getarg XL
# getarg xscn5
        cmpq WB,XL
        je   xscn5
# ||bze|9,(xs)|6,xscn2||; jump if not skipping blanks|27843
# getarg (XT)
# getarg xscn2
        xor  W0,W0
        cmpq (XT),W0
        jz   xscn2
# ||icv|3,xsofs|||; assume blank and delete it|27844
# getarg xsofs
        incq xsofs
# ||beq|8,wb|18,=ch_ht|6,xscn2|; jump if horizontal tab|27846
# getarg WB
# getarg W0
# getarg xscn2
        movq l_0693,W0
        cmpq WB,W0
        je   xscn2
# ||beq|8,wb|18,=ch_bl|6,xscn2|; jump if blank|27851
# getarg WB
# getarg W0
# getarg xscn2
        movq l_0572,W0
        cmpq WB,W0
        je   xscn2
# ||dcv|3,xsofs|||; undelete non-blank character|27852
# getarg xsofs
        decq xsofs
# ||zer|9,(xs)|||; and discontinue blank checking|27853
# getarg (XT)
        mov  $0,W0
        mov  W0,(XT)
# |xscn2|dcv|8,wa|||; decrement count of chars left|27857
xscn2:
# getarg WA
        decq WA
# ||bnz|8,wa|6,xscn1||; loop back if more chars to go|27858
# getarg WA
# getarg WA
# getarg xscn1
        or   WA,WA
        jnz  xscn1
# |xscn3|mov|7,xl|3,r_xsc||; point to string block|27862
xscn3:
# getarg r_xsc
# getarg XL
        movq r_xsc,XL
# ||mov|8,wa|13,sclen(xl)||; get string length|27863
# getarg sclen(,XL,8)
# getarg WA
        movq sclen(,XL,8),WA
# ||mov|8,wb|3,xsofs||; load offset|27864
# getarg xsofs
# getarg WB
        movq xsofs,WB
# ||sub|8,wa|8,wb||; get substring length|27865
# getarg WB
# getarg WA
        subq WB,WA
# ||zer|3,r_xsc|||; clear string ptr for collector|27866
# getarg r_xsc
        mov  $0,W0
        mov  W0,r_xsc
# ||zer|3,xscrt|||; set zero (runout) return code|27867
# getarg xscrt
        mov  $0,W0
        mov  W0,xscrt
# ||brn|6,xscn7|||; jump to exit|27868
# getarg xscn7
        jmp  xscn7
# ||ejc|||||27869
# |xscn4|mov|3,xscrt|18,=num01||; set return code|27875
xscn4:
# getarg W0
# getarg xscrt
        movq l_0060,W0
        movq W0,xscrt
# ||brn|6,xscn6|||; jump to merge|27876
# getarg xscn6
        jmp  xscn6
# |xscn5|mov|3,xscrt|18,=num02||; set return code|27880
xscn5:
# getarg W0
# getarg xscrt
        movq l_0130,W0
        movq W0,xscrt
# |xscn6|mov|7,xl|3,r_xsc||; reload pointer to string|27884
xscn6:
# getarg r_xsc
# getarg XL
        movq r_xsc,XL
# ||mov|8,wc|13,sclen(xl)||; get original length of string|27885
# getarg sclen(,XL,8)
# getarg WC
        movq sclen(,XL,8),WC
# ||sub|8,wc|8,wa||; minus chars left = chars scanned|27886
# getarg WA
# getarg WC
        subq WA,WC
# ||mov|8,wa|8,wc||; move to reg for sbstr|27887
# getarg WC
# getarg WA
        movq WC,WA
# ||mov|8,wb|3,xsofs||; set offset|27888
# getarg xsofs
# getarg WB
        movq xsofs,WB
# ||sub|8,wa|8,wb||; compute length for sbstr|27889
# getarg WB
# getarg WA
        subq WB,WA
# ||icv|8,wc|||; adjust new cursor past delimiter|27890
# getarg WC
        incq WC
# ||mov|3,xsofs|8,wc||; store new offset|27891
# getarg WC
# getarg xsofs
        movq WC,xsofs
# |xscn7|zer|7,xr|||; clear garbage character ptr in xr|27895
xscn7:
# getarg XR
        xor  XR,XR
# ||jsr|6,sbstr|||; build sub-string|27896
# getarg sbstr
        call sbstr
# ||ica|7,xs|||; remove copy of blank flag|27897
# getarg XT
        addq $8,XT
# ||mov|8,wb|10,(xs)+||; original blank skip/trim flag|27898
# getarg WB
        pop  WB
# ||bze|13,sclen(xr)|6,xscn8||; cannot trim the null string|27899
# getarg sclen(,XR,8)
# getarg xscn8
        xor  W0,W0
        cmpq sclen(,XR,8),W0
        jz   xscn8
# ||jsr|6,trimr|||; trim trailing blanks if requested|27900
# getarg trimr
        call trimr
# |xscn8|mov|8,wa|3,xscrt||; load return code|27904
xscn8:
# getarg xscrt
# getarg WA
        movq xscrt,WA
# ||mov|8,wb|3,xscwb||; restore wb|27905
# getarg xscwb
# getarg WB
        movq xscwb,WB
# ||exi||||; return to xscan caller|27906
# getarg 
        ret
# ||enp||||; end procedure xscan|27907
# ||ejc|||||27908
# |xscni|prc|25,n|1,2||; entry point|27925
xscni:
# getarg 2
        pop  prc_+8*18
# ||jsr|6,gtstg|||; fetch argument as string|27926
# getarg gtstg
        call gtstg
        decq rcode
        js   call_287
# ||ppm|6,xsci1|||; jump if not convertible|27927
# getarg xsci1
# getarg xsci1
        decq rcode
        jns  l_0980
        jmp  xsci1
l_0980:
call_287:
# ||mov|3,r_xsc|7,xr||; else store scblk ptr for xscan|27928
# getarg XR
# getarg r_xsc
        movq XR,r_xsc
# ||zer|3,xsofs|||; set offset to zero|27929
# getarg xsofs
        mov  $0,W0
        mov  W0,xsofs
# ||bze|8,wa|6,xsci2||; jump if null string|27930
# getarg WA
# getarg xsci2
        or   WA,WA
        jz   xsci2
# ||exi||||; return to xscni caller|27931
# getarg 
        movq $0,rcode
        mov  prc_+8*18,W0
        jmp  *W0
# |xsci1|exi|1,1|||; take not-string error exit|27935
xsci1:
# getarg 1
        movq $1,rcode
        mov  prc_+8*18,W0
        jmp  *W0
# |xsci2|exi|1,2|||; take null-string error exit|27939
xsci2:
# getarg 2
        movq $2,rcode
        mov  prc_+8*18,W0
        jmp  *W0
# ||enp||||; end procedure xscni|27940
# ||ttl|27,s p i t b o l -- stack overflow section||||27941
# ||sec||||; start of stack overflow section|27945
        .global sec06
sec06:  nop
# ||add|3,errft|18,=num04||; force conclusive fatal error|27947
# getarg W0
# getarg errft
        movq l_0729,W0
        addq W0,errft
# ||mov|7,xs|3,flptr||; pop stack to avoid more fails|27948
# getarg flptr
# getarg XT
        movq flptr,XT
# ||bnz|3,gbcfl|6,stak1||; jump if garbage collecting|27949
# getarg gbcfl
# getarg stak1
        xor  W0,W0
        cmpq gbcfl,W0
        jnz  stak1
# ||erb|1,246|26,stack overflow|||27950
        movq $246,rcode
        jmp  err_
# |stak1|mov|7,xr|21,=endso||; point to message|27954
stak1:
# getarg W0
# getarg XR
        .data
l_0981: .long endso
        .text
        movq l_0981,W0
        movq W0,XR
# ||zer|3,kvdmp|||; memory is undumpable|27955
# getarg kvdmp
        mov  $0,W0
        mov  W0,kvdmp
# ||brn|6,stopr|||; give up|27956
# getarg stopr
        jmp  stopr
# ||ttl|27,s p i t b o l -- error section||||27957
# ||sec||||; start of error section|27987
        .global sec07
sec07:
err_:   xchg WA,rcode
# |error|beq|3,r_cim|20,=cmlab|6,cmple|; jump if error in scanning label|27989
error:
# getarg r_cim
# getarg W0
# getarg cmple
        movq l_0690,W0
        cmpq r_cim,W0
        je   cmple
# ||mov|3,kvert|8,wa||; save error code|27990
# getarg WA
# getarg kvert
        movq WA,kvert
# ||zer|3,scnrs|||; reset rescan switch for scane|27991
# getarg scnrs
        mov  $0,W0
        mov  W0,scnrs
# ||zer|3,scngo|||; reset goto switch for scane|27992
# getarg scngo
        mov  $0,W0
        mov  W0,scngo
# ||mov|3,polcs|18,=num01||; reset poll count|27994
# getarg W0
# getarg polcs
        movq l_0060,W0
        movq W0,polcs
# ||mov|3,polct|18,=num01||; reset poll count|27995
# getarg W0
# getarg polct
        movq l_0060,W0
        movq W0,polct
# ||mov|7,xr|3,stage||; load current stage|27997
# getarg stage
# getarg XR
        movq stage,XR
# ||bsw|7,xr|2,stgno||; jump to appropriate error circuit|27998
# getarg XR
        jmp  *l_0982(,XR,8)
        .data
l_0982:
# ||iff|2,stgic|6,err01||; initial compile|28006
# getarg err01
        .long err01
# ||iff|2,stgxc|6,err04||; execute time compile|28006
# getarg err04
        .long err04
# ||iff|2,stgev|6,err04||; eval compiling expr.|28006
# getarg err04
        .long err04
# ||iff|2,stgxt|6,err05||; execute time|28006
# getarg err05
        .long err05
# ||iff|2,stgce|6,err01||; compile - after end|28006
# getarg err01
        .long err01
# ||iff|2,stgxe|6,err04||; xeq compile-past end|28006
# getarg err04
        .long err04
# ||iff|2,stgee|6,err04||; eval evaluating expr|28006
# getarg err04
        .long err04
# ||esw||||; end switch on error type|28006
        .text
# ||ejc|||||28007
# |err01|mov|7,xs|3,cmpxs||; reset stack pointer|28023
err01:
# getarg cmpxs
# getarg XT
        movq cmpxs,XT
# ||ssl|3,cmpss|||; restore s-r stack ptr for cmpil|28024
# ||bnz|3,errsp|6,err03||; jump if error suppress flag set|28025
# getarg errsp
# getarg err03
        xor  W0,W0
        cmpq errsp,W0
        jnz  err03
# ||mov|8,wc|3,cmpsn||; current statement|28028
# getarg cmpsn
# getarg WC
        movq cmpsn,WC
# ||jsr|6,filnm|||; obtain file name for this statement|28029
# getarg filnm
        call filnm
# ||mov|8,wb|3,scnse||; column number|28031
# getarg scnse
# getarg WB
        movq scnse,WB
# ||mov|8,wc|3,rdcln||; line number|28032
# getarg rdcln
# getarg WC
        movq rdcln,WC
# ||mov|7,xr|3,stage||;|28033
# getarg stage
# getarg XR
        movq stage,XR
# ||jsr|6,sysea|||; advise system of error|28034
# getarg sysea
        call sysea
        decq rcode
        js   call_288
# ||ppm|6,erra3|||; if system does not want print|28035
# getarg erra3
# getarg erra3
        decq rcode
        jns  l_0983
        jmp  erra3
l_0983:
call_288:
# ||mov|11,-(xs)|7,xr||; save any provided print message|28036
# getarg XR
        push XR
# ||mov|3,erlst|3,erich||; set flag for listr|28038
# getarg erich
# getarg W0
# getarg erlst
        movq erich,W0
        movq W0,erlst
# ||jsr|6,listr|||; list line|28039
# getarg listr
        call listr
# ||jsr|6,prtis|||; terminate listing|28040
# getarg prtis
        call prtis
# ||zer|3,erlst|||; clear listr flag|28041
# getarg erlst
        mov  $0,W0
        mov  W0,erlst
# ||mov|8,wa|3,scnse||; load scan element offset|28042
# getarg scnse
# getarg WA
        movq scnse,WA
# ||bze|8,wa|6,err02||; skip if not set|28043
# getarg WA
# getarg err02
        or   WA,WA
        jz   err02
# ||lct|8,wb|8,wa||; loop counter|28045
# getarg WB
# getarg WA
        mov  WB,WA
# ||icv|8,wa|||; increase for ch_ex|28046
# getarg WA
        incq WA
# ||mov|7,xl|3,r_cim||; point to bad statement|28047
# getarg r_cim
# getarg XL
        movq r_cim,XL
# ||jsr|6,alocs|||; string block for error flag|28048
# getarg alocs
        call alocs
# ||mov|8,wa|7,xr||; remember string ptr|28049
# getarg XR
# getarg WA
        movq XR,WA
# ||psc|7,xr|||; ready for character storing|28050
# getarg XR
        add  $cfp_f,XR
# ||plc|7,xl|||; ready to get chars|28051
# getarg XL
        add  $cfp_f,XL
# |erra1|lch|8,wc|10,(xl)+||; get next char|28055
erra1:
# getarg WC
        xor  W0,W0
        movb (XL),%al
        mov  W0,WC
        incq XL
# ||beq|8,wc|18,=ch_ht|6,erra2|; skip if tab|28056
# getarg WC
# getarg W0
# getarg erra2
        movq l_0693,W0
        cmpq WC,W0
        je   erra2
# ||mov|8,wc|18,=ch_bl||; get a blank|28057
# getarg W0
# getarg WC
        movq l_0572,W0
        movq W0,WC
# ||ejc|||||28058
# |erra2|sch|8,wc|10,(xr)+||; store char|28062
erra2:
# getarg WC
        movb al
        stosb
# ||bct|8,wb|6,erra1||; loop|28063
# getarg WB
# getarg erra1
        decq WB
        jnz  erra1
# ||mov|7,xl|18,=ch_ex||; exclamation mark|28064
# getarg W0
# getarg XL
        .data
l_0984: .long ch_ex
        .text
        movq l_0984,W0
        movq W0,XL
# ||sch|7,xl|9,(xr)||; store at end of error line|28065
# getarg XL
        mov  W0,XL
        mov  [XR],%al
# ||csc|7,xr|||; end of sch loop|28066
# ||mov|3,profs|18,=stnpd||; allow for statement number|28067
# getarg W0
# getarg profs
        movq l_0863,W0
        movq W0,profs
# ||mov|7,xr|8,wa||; point to error line|28068
# getarg WA
# getarg XR
        movq WA,XR
# ||jsr|6,prtst|||; print error line|28069
# getarg prtst
        call prtst
# |err02|jsr|6,prtis|||; print blank line|28083
err02:
# getarg prtis
        call prtis
# ||mov|7,xr|10,(xs)+||; restore any sysea message|28085
# getarg XR
        pop  XR
# ||bze|7,xr|6,erra0||; did sysea provide message to print|28086
# getarg XR
# getarg erra0
        or   XR,XR
        jz   erra0
# ||jsr|6,prtst|||; print sysea message|28087
# getarg prtst
        call prtst
# |erra0|jsr|6,ermsg|||; generate flag and error message|28089
erra0:
# getarg ermsg
        call ermsg
# ||add|3,lstlc|18,=num03||; bump page ctr for blank, error, blk|28090
# getarg W0
# getarg lstlc
        movq l_0350,W0
        addq W0,lstlc
# |erra3|zer|7,xr|||; in case of fatal error|28091
erra3:
# getarg XR
        xor  XR,XR
# ||bhi|3,errft|18,=num03|6,stopr|; pack up if several fatals|28092
# getarg errft
# getarg W0
# getarg stopr
        movq l_0350,W0
        cmpq errft,W0
        ja   stopr
# ||icv|3,cmerc|||; bump error count|28096
# getarg cmerc
        incq cmerc
# ||add|3,noxeq|3,cswer||; inhibit xeq if -noerrors|28097
# getarg cswer
# getarg W0
# getarg noxeq
        movq cswer,W0
        addq W0,noxeq
# ||bne|3,stage|18,=stgic|6,cmp10|; special return if after end line|28098
# getarg stage
# getarg W0
# getarg cmp10
        movq l_0053,W0
        cmpq stage,W0
        jne  cmp10
# ||ejc|||||28099
# |err03|mov|7,xr|3,r_cim||; point to start of image|28103
err03:
# getarg r_cim
# getarg XR
        movq r_cim,XR
# ||plc|7,xr|||; point to first char|28104
# getarg XR
        add  $cfp_f,XR
# ||lch|7,xr|9,(xr)||; get first char|28105
# getarg XR
        xor  W0,W0
        movb (XR),%al
        mov  W0,XR
# ||beq|7,xr|18,=ch_mn|6,cmpce|; jump if error in control card|28106
# getarg XR
# getarg W0
# getarg cmpce
        movq l_0689,W0
        cmpq XR,W0
        je   cmpce
# ||zer|3,scnrs|||; clear rescan flag|28107
# getarg scnrs
        mov  $0,W0
        mov  W0,scnrs
# ||mnz|3,errsp|||; set error suppress flag|28108
# getarg errsp
        mov  XS,errsp
# ||jsr|6,scane|||; scan next element|28109
# getarg scane
        call scane
# ||bne|7,xl|18,=t_smc|6,err03|; loop back if not statement end|28110
# getarg XL
# getarg W0
# getarg err03
        movq l_0697,W0
        cmpq XL,W0
        jne  err03
# ||zer|3,errsp|||; clear error suppress flag|28111
# getarg errsp
        mov  $0,W0
        mov  W0,errsp
# ||mov|3,cwcof|19,*cdcod||; reset offset in ccblk|28115
# getarg W0
# getarg cwcof
        movq l_0013,W0
        movq W0,cwcof
# ||mov|8,wa|21,=ocer_||; load compile error call|28116
# getarg W0
# getarg WA
        movq l_0686,W0
        movq W0,WA
# ||jsr|6,cdwrd|||; generate it|28117
# getarg cdwrd
        call cdwrd
# ||mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|28118
# getarg cwcof
# getarg W0
# getarg cmsoc(,XT,8)
        movq cwcof,W0
        movq W0,cmsoc(,XT,8)
# ||mnz|13,cmffc(xs)|||; set failure fill in flag|28119
# getarg cmffc(,XT,8)
        mov  XS,cmffc(,XT,8)
# ||jsr|6,cdwrd|||; generate succ. fill in word|28120
# getarg cdwrd
        call cdwrd
# ||brn|6,cmpse|||; merge to generate error as cdfal|28121
# getarg cmpse
        jmp  cmpse
# |err04|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28131
err04:
# getarg errft
# getarg W0
# getarg labo1
        movq l_0350,W0
        cmpq errft,W0
        jae  labo1
# ||beq|3,kvert|18,=nm320|6,err06|; treat user interrupt specially|28133
# getarg kvert
# getarg W0
# getarg err06
        movq l_0225,W0
        cmpq kvert,W0
        je   err06
# ||zer|3,r_ccb|||; forget garbage code block|28135
# getarg r_ccb
        mov  $0,W0
        mov  W0,r_ccb
# ||mov|3,cwcof|19,*cccod||; set initial offset (mbe catspaw)|28136
# getarg W0
# getarg cwcof
        movq l_0681,W0
        movq W0,cwcof
# ||ssl|3,iniss|||; restore main prog s-r stack ptr|28137
# ||jsr|6,ertex|||; get fail message text|28138
# getarg ertex
        call ertex
# ||dca|7,xs|||; ensure stack ok on loop start|28139
# getarg XT
        subq $8,XT
# |erra4|ica|7,xs|||; pop stack|28144
erra4:
# getarg XT
        addq $8,XT
# ||beq|7,xs|3,flprt|6,errc4|; jump if prog defined fn call found|28145
# getarg XT
# getarg flprt
# getarg errc4
        cmpq XT,flprt
        je   errc4
# ||bne|7,xs|3,gtcef|6,erra4|; loop if not eval or code call yet|28146
# getarg XT
# getarg gtcef
# getarg erra4
        cmpq XT,gtcef
        jne  erra4
# ||mov|3,stage|18,=stgxt||; re-set stage for execute|28147
# getarg W0
# getarg stage
        movq l_0075,W0
        movq W0,stage
# ||mov|3,r_cod|3,r_gtc||; recover code ptr|28148
# getarg r_gtc
# getarg W0
# getarg r_cod
        movq r_gtc,W0
        movq W0,r_cod
# ||mov|3,flptr|7,xs||; restore fail pointer|28149
# getarg XT
# getarg flptr
        movq XT,flptr
# ||zer|3,r_cim|||; forget possible image|28150
# getarg r_cim
        mov  $0,W0
        mov  W0,r_cim
# ||zer|3,cnind|||; forget possible include|28152
# getarg cnind
        mov  $0,W0
        mov  W0,cnind
# |errb4|bnz|3,kverl|6,err07||; jump if errlimit non-zero|28157
errb4:
# getarg kverl
# getarg err07
        xor  W0,W0
        cmpq kverl,W0
        jnz  err07
# ||brn|6,exfal|||; fail|28158
# getarg exfal
        jmp  exfal
# |errc4|mov|7,xs|3,flptr||; restore stack from flptr|28162
errc4:
# getarg flptr
# getarg XT
        movq flptr,XT
# ||brn|6,errb4|||; merge|28163
# getarg errb4
        jmp  errb4
# ||ejc|||||28164
# |err05|ssl|3,iniss|||; restore main prog s-r stack ptr|28182
err05:
# ||bnz|3,dmvch|6,err08||; jump if in mid-dump|28183
# getarg dmvch
# getarg err08
        xor  W0,W0
        cmpq dmvch,W0
        jnz  err08
# |err06|bze|3,kverl|6,labo1||; abort if errlimit is zero|28187
err06:
# getarg kverl
# getarg labo1
        xor  W0,W0
        cmpq kverl,W0
        jz   labo1
# ||jsr|6,ertex|||; get fail message text|28188
# getarg ertex
        call ertex
# |err07|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28192
err07:
# getarg errft
# getarg W0
# getarg labo1
        movq l_0350,W0
        cmpq errft,W0
        jae  labo1
# ||dcv|3,kverl|||; decrement errlimit|28193
# getarg kverl
        decq kverl
# ||mov|7,xl|3,r_ert||; load errtype trace pointer|28194
# getarg r_ert
# getarg XL
        movq r_ert,XL
# ||jsr|6,ktrex|||; generate errtype trace if required|28195
# getarg ktrex
        call ktrex
# ||mov|8,wa|3,r_cod||; get current code block|28196
# getarg r_cod
# getarg WA
        movq r_cod,WA
# ||mov|3,r_cnt|8,wa||; set cdblk ptr for continuation|28197
# getarg WA
# getarg r_cnt
        movq WA,r_cnt
# ||scp|8,wb|||; current code pointer|28198
# getarg WB
        scp_ WB
# ||sub|8,wb|8,wa||; offset within code block|28199
# getarg WA
# getarg WB
        subq WA,WB
# ||mov|3,stxoc|8,wb||; save code ptr offset for scontinue|28200
# getarg WB
# getarg stxoc
        movq WB,stxoc
# ||mov|7,xr|3,flptr||; set ptr to failure offset|28201
# getarg flptr
# getarg XR
        movq flptr,XR
# ||mov|3,stxof|9,(xr)||; save failure offset for continue|28202
# getarg (XR)
# getarg W0
# getarg stxof
        movq (XR),W0
        movq W0,stxof
# ||mov|7,xr|3,r_sxc||; load setexit cdblk pointer|28203
# getarg r_sxc
# getarg XR
        movq r_sxc,XR
# ||bze|7,xr|6,lcnt1||; continue if no setexit trap|28204
# getarg XR
# getarg lcnt1
        or   XR,XR
        jz   lcnt1
# ||zer|3,r_sxc|||; else reset trap|28205
# getarg r_sxc
        mov  $0,W0
        mov  W0,r_sxc
# ||mov|3,stxvr|21,=nulls||; reset setexit arg to null|28206
# getarg W0
# getarg stxvr
        movq l_0054,W0
        movq W0,stxvr
# ||mov|7,xl|9,(xr)||; load ptr to code block routine|28207
# getarg (XR)
# getarg XL
        movq (XR),XL
# ||bri|7,xl|||; execute first trap statement|28208
# getarg XL
        jmp  *XL
# |err08|mov|7,xr|3,dmvch||; chain head for affected vrblks|28213
err08:
# getarg dmvch
# getarg XR
        movq dmvch,XR
# ||bze|7,xr|6,err06||; done if zero|28214
# getarg XR
# getarg err06
        or   XR,XR
        jz   err06
# ||mov|3,dmvch|9,(xr)||; set next link as chain head|28215
# getarg (XR)
# getarg W0
# getarg dmvch
        movq (XR),W0
        movq W0,dmvch
# ||jsr|6,setvr|||; restore vrget field|28216
# getarg setvr
        call setvr
# |s_yyy|brn|6,err08|||; loop through chain|28220
s_yyy:
# getarg err08
        jmp  err08
# ||ttl|27,s p i t b o l -- here endeth the code||||28221
# ||end||||; end macro-spitbol assembly|28225
